<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>[C++]シューティングゲーム</title>
    <link rel="stylesheet" href="style.css">
    <style>
      
    </style>
  </head>
  <body>
    <p class="title">[C++]シューティングゲーム 1</p>
    <br>
    <p>シューティングではなくアクションゲームで基礎を練習するなら ↓<br> 
<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/practice.html">https://yonezawashin.github.io/yonezawashin.github.io-2020c/practice.html</a>
    </p>
    <br>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId0001">シューティングC++で目指すところ(意義)</a></li>
      <li><a href="#mozTocId0002">プロジェクトの作成</a></li>
      <li><a href="#mozTocId0003">画像ファイルの追加</a></li>
      <li><a href="#mozTocId0004">Imageクラスの作成</a></li>
      <li><a href="#mozTocId0005">Gameクラスの作成</a></li>
      <li><a href="#mozTocId0006">自機の作成</a><br>
        <a href="#mozTocId00061">- Playerクラスの作成</a> </li>
      <li><a href="#mozTocId0007">自機弾の作成</a><br>
        <a href="#mozTocId00071">- 循環参照・インクルードの罠</a><br>
        <a href="#mozTocId00072">- シングルトン型:唯一物体タイプの追加</a><br>
        <a href="#mozTocId00073">- 仲介マネージャーGameManagerの追加</a><br>
        <a href="#mozTocId00074">- 【※メモリから弾を削除】自機弾PlayerBulletの削除処理</a><br>
        <a href="#mozTocId00075">- 共通削除機能を【テンプレートとして定義】</a><br>
        <a href="#mozTocId00076">- 【実験】メモリ浪費弾の実験</a><br>
        <a href="#mozTocId00077">- 自機弾の角度を変えられるようにする</a><br>
        <a href="#mozTocId00078">- vectorとlistの性能考察</a> </li>
      <li><a href="#mozTocId0008">ベクトル構造体でX,Y,ZをVector3型でまとめて管理する</a><br>
        <a href="#mozTocId00081">- ベクトルの基本</a><br>
        <a href="#mozTocId00082">- ベクトルの計算</a><br> </li>
      <li><a href="#mozTocId0009">敵の作成</a><br>
        <a href="#mozTocId00091">- 共通のベースとなるGameObjectを作成する</a><br>
        <a href="#mozTocId00092">- Zako0クラスの作成</a><br>
      </li>
      <br>
      <p>テキスト2もこのファイル内にまとめた。</p>
      <a href="#mozTocId2000">[C++]シューティングゲーム 2</a><br>
      <br>
      <p>このHTMLのWEBテキストはBlueGriffonという無料のソフトで書いた<br><a href="https://forest.watch.impress.co.jp/library/software/bluegriffon/">https://forest.watch.impress.co.jp/library/software/bluegriffon/</a><br>
      <a href="https://prog-8.com/docs/github-pages">githubで自分のサイトを無料公開できるので自作サイトにも挑戦しては</a></p>
      <br>
    </ol>
    <h1><a id="mozTocId0001" class="mozTocH1"></a>シューティング[C++]で目指すところ(意義)</h1>
    <p>シューティングの制作をC++で行うことで、以下を作業を通じて【体得しよう】</p>
    <ul>
      <li>C++でのクラス定義の仕方を習得</li>
      <li>DXライブラリの公式のサンプルはC言語(関数方式)なので、C++ベースのオブジェクト指向のプログラミングで動かせるようになる</li>
      <li>C++の配列やfor文の使い方を習得</li>
      <li>C++での画像読み込みとそのメモリのお掃除(メモリ開放)</li>
    </ul>
    <p>最終的には、C++で制作したゲームの完成を目標にしましょう。</p>
    <br>
    <br>
    <p>なお、<b>C++は下手にお金出して本を買うくらいなら以下のサイトが教科書代わりになりそう</b>です。<br>
    ・<a href="https://atcoder.jp/contests/apg4b">https://atcoder.jp/contests/apg4b</a><br>
    ・<a href="https://zenn.dev/reputeless/books/standard-cpp-for-competitive-programming/viewer/string">https://zenn.dev/reputeless/books/standard-cpp-for-competitive-programming/viewer/string</a><br>
    ・<a href="https://ezoeryou.github.io/cpp-intro/">https://ezoeryou.github.io/cpp-intro/</a><br>
    <br>
    <h1><a id="mozTocId0002" class="mozTocH1"></a>プロジェクトの作成</h1>
    <h2>まずはDXライブラリ公式のC++のライブラリをダウンロード</h2>
    以下のDXライブラリの公式サイトからC++のDXライブラリをダウンロードしてください。<br>
    <a href="https://dxlib.xsrv.jp/dxdload.html">https://dxlib.xsrv.jp/dxdload.html</a> <br>
    ダウンロードできたらzipファイルを【C:ドライブ直下に展開】してください<br>
    <p> <img src="image/img_dxdownload.png" alt=""></p>
    <br>
    <br>
    <h2>ダウンロードできたらzipファイルを【C:ドライブ直下に展開】</h2>
    <p> <img src="image/img_dxlibextract_c_drive.png" alt=""></p>
    <br>
    <br>
    <h2>プロジェクト作成</h2>
    Visual Studio 2019を起動してください。<br>
    <br>
    起動したら、<code>新しいプロジェクトの作成</code>をクリック<br>
    <br>
    <code>C++ 空のプロジェクト</code>を選択して次へ
    <p> <img src="image/making_cpp_prj.png" alt="" style="width: 1156px; height: 853px;"></p>
    <p>今回のプロジェクト名は【1】「自分の作るゲーム名」か【2】毎回C++のプロジェクトを作るのが面倒な人は今回作るプロジェクトをフォルダごと量産するとして「DXLibGameBase」(ゲームの基礎ベース、コピペで量産用プロジェクト)にしましょう。</p>
    <p></p>
    <p>プロジェクトが作成されたら、まず【main.cpp】作りましょう。</p>
    <br>
    <p>少なくとも一つ【～.cpp】作らないと出てこない次にやる設定↓で【出てこない項目】があります(【C/C++全般】が出てこない！)</p>
    <br>
    <h2>次にプロジェクトのややこしい設定をしっかりやる</h2>
    プロジェクトの【設定を開く前に】最低限一つだけでもcppファイルがプロジェクトにないと【出てこない設定項目がある】ので新しい項目を追加でC++ソースファイル(.cpp)のファイルを一つ作成しておく。<br>
    <br>
    <p> <img src="image/need_one_cpp.png" alt="" style="width: 1152px; height: 713px;"></p>
    <br>
    <br>
    表示モードを切り替えてみて、main.cppができたかを確認する。<br>
    <p> <img src="image/foldermode1.png" alt=""></p>
    <br>
    一つだけcppファイルを作成した後、プロジェクトを右クリックして<code>プロパティ</code>をクリック<br>
    <br>
    <p> <img src="image/open_setting.png" alt="" style="width: 1128px; height: 642px;"></p>
    <br>
    <h2>【設定】マルチバイト文字セットを使用</h2>
    <br>
    設定画面の【構成プロパティ】→【詳細】の【文字セット】を<code>マルチバイト文字セットを使用</code>に変更<br>
    <p> <img src="image/setting_multibyte_moji.png" alt="" style="width: 982px; height: 682px;"></p>
    <br>
    <h2>【設定】C/C++→全般→追加のインクルードディレクトリにDXライブラリのフォルダ位置(PATH)を追加</h2>
    <br>
    設定画面の【C/C++全般】→【全般】の【追加のインクルードディレクトリ】に<code>DXライブラリのフォルダ位置(PATH)</code>を設定<br>
    <p> <img src="image/setting_cpp_add_include_dir.png" alt="" style="width: 1047px; height: 682px;"></p>
    <br>
    フォルダのパス(位置)文字列は以下のgifアニメのようにコピーして貼り付け<br>
    <p> <img src="image/setting_howto_copy_dir.gif" alt="" style="width: 892px; height: 554px;"></p>
    <br>
    <h2>【設定】リンカ→全般→追加のライブラリディレクトリにDXライブラリのフォルダ位置(PATH)を追加</h2>
    <br>
    設定画面の【リンカー】→【全般】の【追加のライブラリディレクトリ】に<code>DXライブラリのフォルダ位置(PATH)</code>を設定<br>
    <p> <img src="image/setting_linker_add_lib_dir.png" alt="" style="width: 1046px; height: 682px;"></p>
    <br>
    フォルダのパス(位置)文字列は以下のgifアニメのようにコピーしたものを貼り付け<br>
    <p> <img src="image/setting_howto_paste_dir.gif" alt="" style="width: 1075px; height: 805px;"></p>
    <br>
    <br>
    <h2>【設定】リンカ→システム→サブシステムをウィンドウに(コンソールのままだと黒画面の文字ベースシステムになる)</h2>
    <br>
    設定画面の【リンカー】→【システム】の【サブシステム】を<code>Windows(SUBSYSTEM:WINDOWS)</code>に設定<br>
    この設定をするとプログラムの開始位置(エントリポイントという)がWinMainというところから始まるようになる。(Consoleの場合はMain)<br>
    <p> <img src="image/setting_entry_point.png" alt="" style="width: 985px; height: 682px;"></p>
    <br>
    <br>
    以上で設定項目は終わり。OKをおして設定を反映しよう<br>
    <br>
    <br>
    <h2>設定を反映させたらサンプルプログラムをmain.cppにコピペして動作を確認</h2>
    <p>以下の【ウィンドウを出すだけの最小限サンプル】を動かして設定を確認しましょう</p>
    <p><code>main.cpp【ウィンドウを出すだけの最小限サンプル】</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode( 960 , 540 , 32 ) ; // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(960, 540);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// この位置にウィンドウの中に画像を描く処理などを書く<br>
      &nbsp;&nbsp;// DXライブラリ公式の色々なサンプルを試してみよう！<br>
      &nbsp;&nbsp;// https://dxlib.xsrv.jp/dxfunc.html<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <h2><a id="mozTocId00021" class="mozTocH1"></a>解像度の定義</h2>
    <p>【C++で】画面解像度を定義するクラスを作ってみましょう。ソリューションエクスプローラーのプロジェクトを右クリックし、追加＞ヘッダファイル(.h)<br>
      Screen.hという名前でヘッダファイルを生成し、そのファイルにクラスを記述します。</p>
    <p><code>Screen.h</code>を編集します：</p>
    <p class="source">#ifndef _SCREEN_H<br>
      #define _SCREEN_H<br>
      // ＃ifndefは「_SCREEN_H」がifもしもn(not) def(定義)されていないなら＃endifに挟まれたコードまでを有効化する(だから2度目以降は無効になる)<br>
      // 二重定義を防止するために＃から始まる【プリプロセッサ】を使っている<br>
      //　【プリプロセッサ】はビルドする段階でコード自体に【前処理】として影響を与える<br>
      // たとえば<br>
      // ・ファイルの読み込み (including) →＃includeがこれ<br>
      // ・マクロの展開（シンボルを、あらかじめ定義された規則に従って置換する）<br>
      // ・コンパイル条件によるソースコードの部分的選択→【＃ifndef　～ ＃endifに囲まれた部分】は一度(＃defineで)定義されると無効化<br>
      // ・コメントの削除 【&nbsp;//&nbsp;】のコメントの削除も【プリプロセス＝前段階で行われる】<br>
      <br>
      // 画面解像度<br>
      class Screen<br>
      {<br>
      public: //publicはC＃と違いpublic:以下にまとめて書かれるスタイル<br>
      &nbsp;&nbsp;static const int Width = 960; // 幅<br>
      &nbsp;&nbsp;static const int Height = 540; // 高さ C＃と違いstaticクラスではなく個々の【すべての変数にstaticをつけて】staticなクラスとする<br>
      };// C＃と違ってクラスの定義も;セミコロンで終わる<br>
      #endif</p>
    <br>
    <br>
    <br>
    <p><code>main.cpp</code>を編集してScreen.hを読み込ませます：</p>
    <p class="source">#include "DxLib.h"<br>
      <em>#include "Screen.h"</em><br>
      // ↑＃includeで別ファイルのヘッダファイル.hをこのコード内に読み込む<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode( <em>Screen::Width, Screen::Height,</em> 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(<em>Screen::Width, Screen::Height</em>);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      <br>
      <br>
      &nbsp;&nbsp;// (中略).....................................<br>
      <br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <h1><a id="mozTocId0003" class="mozTocH1"></a>画像ファイルの追加</h1>
    <p>次は画像ファイルをプロジェクトに追加します。フォルダは【ウィンドウズ上のエクスプローラで作成】します。<br>
      <br>
      <br>
      <img src="image/open_folder_with_explorer1.png" alt=""><br>
      <br>
      <img src="image/gimp6.png" alt=""><br>
      <br>
      <img src="image/new_image_folder.png" alt="" style="width: 362px; height: 180px;"><br>
      <br>
      GIMPをダウンロードして画像をつくってみましょう。<br>
      <a href="https://forest.watch.impress.co.jp/library/software/gimp/">https://forest.watch.impress.co.jp/library/software/gimp/</a><br>
      <br>
      ダウンロードしたら起動して【ファイル】→【新しい画像】<br>
      <img src="image/gimp1.png" alt="" style="width: 1097px; height: 736px;"><br>
      <br>
      キャンバスのサイズはとりあえず64×64でつくってみます(自由につくってもよいがサイズをおぼえておいて、あとで自分のプログラムで読み込むときに合わせないといけないよ)<br>
      <img src="image/gimp2.png" alt="" style="width: 502px; height: 612px;"><br>
      <br>
      透明のレイヤーをつくって背景が透けるようにしておく<br>
      <img src="image/gimp2_1.png" alt="" style="width: 707px; height: 517px;"><br>
      <br>
      消しゴムで消して透明にしておく<br>
      <img src="image/gimp2_2.png" alt="" style="width: 965px; height: 559px;"><br>
      <br>
      新しいレイヤをつくって、そこのレイヤに自分の画像をえがいていく<br>
      <img src="image/gimp2_3.png" alt="" style="width: 635px; height: 743px;"><br>
      <br>
      <img src="image/gimp2_4.png" alt="" style="width: 598px; height: 574px;"><br>
      <br>
      <br>
      マウスで長押しして楕円選択をえらんで円形にえがくエリアをえらぶ<br>
      <img src="image/gimp3.png" alt="" style="width: 793px; height: 594px;"><br>
      <br>
      <br>
      ぬりつぶしの色を決めて、えらんでいるエリアを円形にぬりつぶす<br>
      <img src="image/gimp4.png" alt="" style="width: 653px; height: 614px;"><br>
      <br>
      <br>
      テキストのボタンをおして円のうちがわに自機という文字をうちこむ<br>
      <img src="image/gimp5.png" alt="" style="width: 853px; height: 595px;"><br>
      <br>
      <br>
      画像を保存するフォルダをつくっておく<br>
      <img src="image/gimp6.png" alt="" style="width: 662px; height: 273px;"><br>
      <br>
      <br>
      つくったフォルダにエクスポートする<br>
      <img src="image/gimp7.png" alt="" style="width: 586px; height: 559px;"><br>
      <br>
      <img src="image/gimp8.png" alt="" style="width: 939px; height: 496px;"><br>
      <br>
      <br>
      自分でboss1.png、boss2.png、boss3.pngを180×180など別のサイズでつくってみたり、<br>
      webでゲーム素材、フリーなどのワードで検索して、素材をさがしてみよう(著作権や利用規約をよく読んで注意しないとお金とられて財布が空になっちゃうので注意！！)<br>
      <a href="https://pipoya.net/sozai/">https://pipoya.net/sozai/</a><br>
      <a href="https://qiita.com/TD12734/items/5dc8068732f94452efe2">https://qiita.com/TD12734/items/5dc8068732f94452efe2</a><br>
      
      <img src="image/gimp9.png" alt="" style="width: 668px; height: 160px;"><br>
      <br>
      えがいた画像をべつのフォルダに保存した場合は、下のアニメようにウィンドウズでImageフォルダーにコピーして貼り付けしてください。</p>
    <img src="image/image_copy_paste.gif" alt=""><br>
    <br>
    <img src="image/image_add_project.gif" alt=""><br>
    <p><br>
    </p>
    <h2>試しに表示してみる</h2>
    <p><code>main.cpp</code>にプログラムを追加し、画像が正しく表示できるかテストします。</p>
    <p class="source">#include "DxLib.h"<br>
      <em>#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用</em><br>
      #include "Screen.h"<br>
      // ＃includeで別ファイルのヘッダファイル.hをこのコード内に読み込む<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      <br>
      <br>
      <em> &nbsp;&nbsp;//表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;// これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;SetDrawScreen(DX_SCREEN_BACK);<br>
        <br>
        &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;int bossImage = -1;<br>
        &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
        &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;int x = 100; // Xの初期位置<br>
        &nbsp;&nbsp;int vx = 10;<br>
        <br>
        &nbsp;&nbsp;ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;while (ProcessMessage() == 0) <br>
        &nbsp;&nbsp;{// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 1フレームごとの更新処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (x &lt; 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // X位置の更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理(位置x, y, 拡大率, 回転, 画像ID, TRUEなら透過有効)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, 200, 1.0f, 0, bossImage, TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;}<br>
      </em> <br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <p><br>
    </p>
    <h1><a id="mozTocId0004" class="mozTocH1"></a>Imageクラスの作成</h1>
    <h2>Imageクラスの作成</h2>
    <p>Imageクラスを作成しましょう。Imageクラスの役割は次の2つです。</p>
    <ul>
      <li>画像の読み込み</li>
      <li>読み込んだ画像ハンドルの保持</li>
    </ul>
    <p><br>
    </p>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「Image」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Image.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;static void Load();<br>
      <br>
      &nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <p>次に対となるcppファイルを作成します。<br>
      ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞cppファイル<br>
      「Image.cpp」という名前でcppファイルを作り、クラスを実装します。<br>
      <br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
      <br>
      int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      <br>
      void Image::Load()<br>
      {<br>
      &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      }</p>
    <br>
    <br>
    <h2>試しに【Image.hを使って】表示してみる</h2>
    <p><code>main.cpp</code>のプログラムを変更し、画像が正しく表示できるかテストします。</p>
    <p class="source">#include "DxLib.h"<br>
      #include "Screen.h"<br>
      <em>#include "Image.h"&nbsp;// 画像読み込みクラス</em><br>
      <br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;//表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;// これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;SetDrawScreen(DX_SCREEN_BACK);<br>
      <br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;<em>Image::Load();</em><br>
      &nbsp;&nbsp;<u>int bossImage = -1;<br>
      &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</u><br>
      &nbsp;&nbsp;int x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;int vx = 10;<br>
      <br>
      &nbsp;&nbsp;ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0) <br>
      &nbsp;&nbsp;{// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1フレームごとの更新処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理(位置x, y, 拡大率, 回転, 画像ID, TRUEなら透過有効)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, 200, 1.0f, 0, <em>Image::bossImage</em>, TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <p><br>
    </p>
    <h1><a id="mozTocId0005" class="mozTocH1"></a>Gameクラスの作成</h1>
    <h2>Gameクラスの作成</h2>
    <p>Gameクラスを作成しましょう。Gameクラスの重要な役割は次の3つ。<br></p>
    <ul>
      <li>初期処理Init() : ゲームのwhileループが始まる前に色んな初期化処理をする</li>
      <li>更新処理Update() : ゲームをプレイしている間毎フレームごとに実行される(キャラを1ずつ動かすなど)</li>
      <li>描画処理Draw() : ゲームをプレイしている間毎フレームごとに実行される(キャラをアニメさせながらパラパラ漫画のように描くなど)</li>
    </ul>
    <p><br>
    </p>
    <p>ソリューションエクスプローラーからプロジェクトを[右クリック]し、[追加] → [新しい項目] → Game.hというファイル名を入力<br>
      「Game.h」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Game.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef GAME_H_<br>
      #define GAME_H_<br>
      <br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <br>
      class Game<br>
      {<br>
      public :<br>
      &nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↓{ }を.hに書くことでcppに分けて書くはずの処理ぶぶんを.hに書いてもよい */<br>
      &nbsp;&nbsp;Game() {&nbsp; }; // 初期化コンストラクタ<br>
      &nbsp;&nbsp;~Game() {&nbsp; }; // 破棄処理デストラクタ<br>
      &nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
      &nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
      &nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
      <br>
      &nbsp;&nbsp;int x = 0; //staticじゃないintはここで=0で初期化できる<br>
      &nbsp;&nbsp;int vx = 0;<br>
      <br>
      };<br>
      #endif</p>
    <br>
    <p>次に対となるcppファイルを作成します。<br>
      ソリューションエクスプローラーからプロジェクトを[右クリック]し、[追加] → [新しい項目] → Game.cppというファイル名を入力<br>
      「Game.cpp」という名前でcppファイルを作り、クラスの処理を実装します。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Game.h"<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10; // ボスの初期速度<br>
      }<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10; //画面端で移動方向反転<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // ボス画像のX位置の更新<br>
      <br>
      }<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 1.0f, 0, Image::bossImage, TRUE);<br>
      <br>
      }</p>
    <h2>【Gameクラスを使って】表示してみる</h2>
    <p><code>main.cpp</code>のプログラムを変更し、画像が正しくGameクラスで表示できるかテストします。</p>
    <p class="source">#include "DxLib.h"<br>
      #include "Screen.h"<br>
      <u>#include "Image.h"&nbsp;// 画像読み込みクラス</u><br>
      <em>#include "Game.h"&nbsp;</em><br>
      <br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;//表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;// これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;SetDrawScreen(DX_SCREEN_BACK);<br>
      <br>
      &nbsp;&nbsp;<u>// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;Image::Load();<br>
      &nbsp;&nbsp;int x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;int vx = 10;</u><br>
      &nbsp;&nbsp;<em>// Init初期化処理<br>
      &nbsp;&nbsp;Game game; //Gameの定義(定義と同時に初期化コンストラクタが実行される)<br>
      &nbsp;&nbsp;game.Init(); // gameのInit準備</em><br>
      <br>
      &nbsp;&nbsp;ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0) <br>
      &nbsp;&nbsp;{// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// Update更新処理</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>game.Update(); // gameの更新処理</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// Draw描画処理</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>game.Draw();</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <p><br>
    </p>
    <h1><a id="mozTocId0006" class="mozTocH1">自機の作成</a></h1>
    <h2><a id="mozTocId00061" class="mozTocH1"></a>プレイヤを操作するには便利クラスInputクラスが必須！</h2>
    <p>Inputクラスを作成しましょう。</p>
    <ul>
      <li>static int のstaticタイプの変数は.hだけではシンボリックエラーになるのでこのためだけに最低限.cppファイルを作成する必要がある</li>
    </ul>
    <p> </p>
    <p>ソリューションエクスプローラーからプロジェクトを[右クリック]し、[追加] → [新しい項目] → Game.hというファイル名を入力<br>
      「Input.h」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Input.hを新規作成して</code>以下を実装</p>
    <p class="source">#ifndef INPUT_H_<br>
        #define INPUT_H_<br>
        <br>
        #include "DxLib.h"<br>
      <br>
      <br>
      // 入力クラス<br>
      class Input<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;static int prevState; // 1フレーム前の状態<br>
      &nbsp;&nbsp;static int currentState; // 現在の状態<br>
      <br>
      &nbsp;&nbsp;// 初期化。最初に1回だけ呼んでください。<br>
      &nbsp;&nbsp;static void Init()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;prevState = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;currentState = 0;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 最新の入力状況に更新する処理。<br>
      &nbsp;&nbsp;// 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
      &nbsp;&nbsp;static void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;prevState = currentState;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;currentState = &nbsp;GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// ボタンが押されているか？<br>
      &nbsp;&nbsp;static bool GetButton(int buttonId)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 今ボタンが押されているかどうかを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return (currentState &amp; buttonId) != 0;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// ボタンが押された瞬間か？<br>
      &nbsp;&nbsp;static bool GetButtonDown(int buttonId)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 今は押されていて、かつ1フレーム前は押されていない場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return ((currentState &amp; buttonId) &amp; ~(prevState &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// ボタンが離された瞬間か？<br>
      &nbsp;&nbsp;static bool GetButtonUp(int buttonId)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1フレーム前は押されていて、かつ今は押されていない場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return ((prevState &amp; buttonId) &amp; ~(currentState &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;}<br>
      }<em>;&nbsp;//←【注意】クラス定義の終わりにはコロンが必要だよ！</em><br>
      <br>
      #endif<em>&nbsp;&nbsp;//ここでエラー出た人は↑【注意】の;コロン忘れ</em></p>
    <br>
    <p>次に対となるcppファイルを作成します。<br>
      ソリューションエクスプローラーからプロジェクトを[右クリック]し、[追加] → [新しい項目] → Input.cppというファイル名を入力<br>
      「Input.cpp」という名前でcppファイルを作ります(たった2行の初期化static int変数の初期化のために必須)。<br>
      <br>
      <code>Input.cppを新規作成して</code>、その内容を次のようにします：</p>
    <p class="source">#include "Input.h"<br>
      <br>
      int <em>Input::</em>prevState <em>{ 0 }</em>; // 1フレーム前の状態<br>
      int <em>Input::</em>currentState <em>{ 0 }</em>; // 現在の状態<br>
      <em>// ↑static intのときはこの行書かないとシンボリックエラーになる件(このためだけにcpp書かなきゃならん)</em><br>
      <br>
    </p>
<br>
.cppを作成して.h側のstatic変数を書き連ねていないと↓下のような外部シンボルの未解決エラーが出るので、今後は<b>下記エラーが出たときはcpp忘れを疑って</b>ください<br>
<img src="image/cpp_static_symbolic_error.png" alt=""><br>
<br>
<br>
    <p>Playerクラスを作成する前に、忘れずにプレイヤ画像はDXのプロジェクトのImageフォルダにコピー貼り付けしましょう。<br>
      Imageフォルダにコピーしたらプロジェクトで</p>
    <p>次は画像ファイルをプロジェクトに追加します。画像は【プロジェクトを右クリックで「追加」→「既存の項目」で画像を追加】します。<br>
      <img src="image/player_image_add.gif" alt=""><br>
      <br>
      <code>Image.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;static void Load();<br>
      <br>
      &nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;<em>static int player; //プレイヤ画像のハンドラ</em><br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
      <br>
      int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      <em>int Image::player{-1};</em><br>
      <br>
      void Image::Load()<br>
      {<br>
      &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;<em>player= LoadGraph("Image/player.png");<br>
        &nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      }</p>
    <br>
    <br>
    <h2><a id="mozTocId00061" class="mozTocH1"></a>Playerクラスの作成</h2>
    <p>Playerクラスを作成しましょう。<br>
      Playerクラスをつくるだけで安心すると【落とし穴】があります。Game.cppでInput.Update();を忘れるとプレイヤが動きません。</p>
    <p>Update()やDraw()やInput.Update()を忘れないように注意して進めましょう。<br>
    </p>
    <p>ソリューションエクスプローラーからプロジェクトを[右クリック]し、[追加] → [新しい項目] → Player.hというファイル名を入力<br>
      「Player.h」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Player.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <br>
      class Player<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
      <br>
      &nbsp;&nbsp;float x; // x座標<br>
      &nbsp;&nbsp;float y; // y座標<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;// x : 初期位置x<br>
      &nbsp;&nbsp;// y : 初期位置y<br>
      &nbsp;&nbsp;Player(float x, float y)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 実際に位置を動かす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1.0f, 0, Image::player, TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>Game.h</code>にPlayerを追加します：</p>
    <p class="source">#ifndef GAME_H_<br>
      #define GAME_H_<br>
      <br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <em>#include "Player.h"</em><br>
      <br>
      class Game<br>
      {<br>
      public :<br>
      &nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↓{ }を.hに書くことでcppに分けて書くはずの処理ぶぶんを.hに書いてもよい */<br>
      &nbsp;&nbsp;Game() {&nbsp; }; // 初期化コンストラクタ<br>
      &nbsp;&nbsp;~Game() {&nbsp; }; // 破棄処理デストラクタ<br>
      &nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
      &nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
      &nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
      <br>
      &nbsp;&nbsp;int x = 0; //staticじゃないintはここで=0で初期化できる<br>
      &nbsp;&nbsp;int vx = 0;<br>
      <br>
      &nbsp;&nbsp;<em>Player player{ 100, Screen::Height / 2 }; // 自機の初期化</em><br>
      };<br>
      #endif</p>
    <p>次にGame.cppファイルにUpdateとDraw処理を追加してプレイヤの動作を確認しましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Game.h"<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10; // ボスの初期速度<br>
      }<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;<em>Input::Update();&nbsp;//【注意】これ忘れるとキー入力押してもキャラ動かない</em><br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10; //画面端で移動方向反転<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // ボス画像のX位置の更新<br>
      <br>
      &nbsp;&nbsp;<em>player.Update(); // プレイヤの更新【忘れるとプレイヤが動かない】</em><br>
      }<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 1.0f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;<em>player.Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】</em><br>
      }</p>
    <p>さて、無事にプレイヤをキー入力(↑↓←→)で動かせるようになりましたか？？？。</p>
    <br>
    <ul>
      <li>【プレイヤ画像が出ない】→Game.cppで【player.Draw();しましたか？】</li>
      <li>【プレイヤ画像が動かない1】→Game.cppで【player.Update();しましたか？】</li>
      <li>【プレイヤ画像が動かない2】→Game.cppで【Input.Update();しましたか？】</li>
    </ul>
    <br>
    <h2>√2の定義</h2>
    <p>【C++でも】斜め方向の移動速度を√2で割って補正するために、自分用数学定義クラスを作ってみましょう。ソリューションエクスプローラーのプロジェクトを右クリックし、追加＞ヘッダファイル(.h)<br>
      MyMath.hという名前でヘッダファイルを生成し、そのファイルにクラスを記述します。</p>
    <p><code>MyMath.hを新規作成して</code>その内容を編集します：</p>
    <p class="source">#ifndef _MYMATH_H<br>
      #define _MYMATH_H<br>
      // 数学関連クラス<br>
      class MyMath<br>
      {<br>
      public: <br>
      &nbsp; // C++標準では、静的static定数は【整数型】または【列挙型】のみを.hのクラス内で初期化できます。<br>
      &nbsp; // これが、intやenumの初期化はエラーにならないのに他のstatic floatなどがエラーになる理由です。<br>
      <br>
      &nbsp; // ルート2(変数名の定義だけ)<br>
      &nbsp; static const float Sqrt2;&nbsp;// = 1.41421356237f;(.hではfloat小数型の初期化はできない int型はできるのに)<br>
      <br>
      }; // 【注意】セミコロン抜けで【宣言が必要ですエラー】<br>
      <br>
      #endif // 【宣言が必要ですエラーは上のセミコロン抜け】</p>
    <br>
    <br>
    <br>
    <p><code>MyMath.cppを新規作成して</code>その内容を編集して変数名にSqrt2 = √2 = 1.41421356237f を 割り当てます。</p>
    <p class="source">#include "MyMath.h"<br>
      <br>
      const float MyMath::Sqrt2 = 1.41421356237f;//(floatは有効桁は実質7桁まで正確だがそれ以降は環境によって誤差出る)<br>
      <br>
    <p><br>
      <br>
      定義だけじゃなく、実際にプレイヤを動かしているPlayer.hも編集しなきゃ意味がないよ！お忘れなく！！<br>
      <code>Player.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <em>#include "MyMath.h"</em><br>
      <br>
      class Player<br>
      {<br>
      public:<br>
      &nbsp;const float MoveSpeed = 6; // 移動速度<br>
      <br>
      &nbsp;float x; // x座標<br>
      &nbsp;float y; // y座標<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;// x : 初期位置x<br>
      &nbsp;&nbsp;// y : 初期位置y<br>
      &nbsp;Player(float x, float y)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// 斜め移動も同じ速度になるように調整<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (vx != 0 &amp;&amp; vy != 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx /= MyMath::Sqrt2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 実際に位置を動かす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::player, TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <br>
    <h1><a id="mozTocId0007" class="mozTocH1"></a>自機弾PlayerBulletクラスの作成</h1>
    <h2>PlayerBulletクラスを新規作成しましょう。 </h2>
    <br>
    <p>ソリューションエクスプローラーからプロジェクトを[右クリック]し、[追加] → [新しい項目] → PlayerBullet.hというファイル名を入力<br>
      「PlayerBullet.h」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>PlayerBullet.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      <br>
      // 自機弾クラス<br>
      class PlayerBullet<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      <br>
      &nbsp;&nbsp;float x; // x座標<br>
      &nbsp;&nbsp;float y; // y座標<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;PlayerBullet(float x, float y)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += Speed;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      <br>
      #endif</p>
    <br>
    <code>Image.h</code>に自機弾PlayerBullet画像定義を追加します：
    <p></p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;static void Load();<br>
      <br>
      &nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int player; //プレイヤ画像のハンドラ<br>
      &nbsp;&nbsp;<em>static int playerBullet; //プレイヤの弾画像のハンドラ</em><br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
      <br>
      int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      int Image::player{-1};<br>
      <em>int Image::playerBullet{-1};</em><br>
      <br>
      void Image::Load()<br>
      {<br>
      &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;player= LoadGraph("Image/player.png");<br>
      &nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;<em>playerBullet = LoadGraph("Image/player_bullet.png");<br>
        &nbsp;&nbsp;assert(playerBullet!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      }</p>
    <br>
    <br>
    <br>
    <p><code>Game.h</code>にPlayerBulletを追加します：</p>
    <p class="source">#ifndef GAME_H_<br>
      #define GAME_H_<br>
      <br>
      <em>#include&nbsp;&lt;vector&gt;// 配列std::vectorを使う<br>
        #include&nbsp;&lt;memory&gt;//スマートなポインタを使うのに必要(shared_ptrなど)</em><br>
      <br>
      #include&nbsp;"Image.h"<br>
      #include&nbsp;"Screen.h"<br>
      #include&nbsp;"Player.h"<br>
        <br>
        <br><em>//前方宣言でPlayerBulletという【ポインタの型】があることだけを宣言すれば#includeせずにstd::vectorの中身にPlayerBulletのリンクだけなら入れられる<br>
        class&nbsp;PlayerBullet;</em><br>
      <br>
      class&nbsp;Game<br>
      {<br>
      public&nbsp;:<br>
      &nbsp;&nbsp;Game()&nbsp;{}; // 初期化コンストラクタ<br>
      &nbsp;&nbsp;~Game()&nbsp;{}; // 破棄処理デストラクタ<br>
      &nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
      &nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
      &nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
      <br>
      &nbsp;&nbsp;int x = 0;<br>
      &nbsp;&nbsp;int vx = 0;<br>
      <br>
      &nbsp;&nbsp;<u>Player player{ 100, Screen::Height / 2 }; // 自機の初期化</u><br>
      &nbsp;&nbsp;<em>std::shared_ptr&lt;Player&gt;&nbsp;player{ std::make_shared&lt;Player&gt;(100, Screen::Height / 2, this) }; // 自機の初期化</em><br>
      &nbsp;&nbsp;<em>//↑プレイヤを回し読みポインタ型に。std::make_shared&lt;Player&gt;でメモリ上に実体を生成<br>
      &nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト</em><br>
      &nbsp;&nbsp;//可変長配列vector&nbsp;↑【shared_ptr:共有ポインタ】<br>
      <br>
      &nbsp;&nbsp;//&nbsp;★【shared_ptr:共有ポインタ】とは【データの回し読み(読まれなくなったら廃棄)】<br>
      &nbsp;&nbsp;//&nbsp;「例えば、兄弟で週刊少年ジャンプを【回し読みするときは】<br>
      &nbsp;&nbsp;//&nbsp;おかんに【全員読み終わるまではメモリから捨てられないように】する<br>
      &nbsp;&nbsp;//&nbsp;【読むつもりの人のカウンタ.use_count()】がゼロになると【おかんに捨てられる(リンク切れはメモリから廃棄する)】」<br>
      <br>
      };<br>
      <br>
      #endif</p>
    <p>次にGame.cppファイルにUpdateとDrawに自機弾更新と描画の処理を追加しましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include&nbsp;"Game.h"<br>
      <br>
      <em>#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      };<br>
      <br>
      void&nbsp;Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;player<em>-&gt;</em>Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      &nbsp;&nbsp;<em>//ポインタ↑になると.から-&gt;でのアクセスになる</em><br>
      <br>
      &nbsp;&nbsp;<em>// 自機弾の更新処理<br>
        &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新<br>
        &nbsp;&nbsp;for (const auto&amp; b : playerBullets)<br>
        &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
        &nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>//【放置厳禁！！！このままここに弾の削除処理書かないとメモリがどんどん減ってくよ(気づかないうちにどんどん使用メモリが増える..怖)】</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;player<em>-&gt;</em>Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      &nbsp;&nbsp;<em>//ポインタ↑になると.から-&gt;でのアクセスになる</em><br>
      <br>
      &nbsp;&nbsp;<em>// 自機弾の描画処理<br>
        &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新<br>
        &nbsp;&nbsp;for (const auto&amp; b : playerBullets)<br>
        &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
        &nbsp;&nbsp;}</em><br>
      };<br>
    </p>
    <br>
    <br>
    <br>
    <p><code>Player.h</code>にPlayerBulletへの参照を得るため<em>Gameへのポインタ参照を追加</em>します：</p>
    <p class="source">#ifndef&nbsp;PLAYER_H_<br>
      #define&nbsp;PLAYER_H_<br>
      <br>
      #include&nbsp;"DxLib.h"<br>
      #include&nbsp;"Input.h"<br>
      #include&nbsp;"Image.h"<br>
      #include&nbsp;"MyMath.h"<br>
      <br>
      <em>class&nbsp;Game;&nbsp;//←【エラー地獄に注意！】ここにGameクラスがあるものとして書くことで【循環相互インクルード問題】を回避<br>
        <br>
        //↑Gameクラス内にPlayer変数を持っているからPlayerの定義が終わらないとGameの定義が完了しない(未定義エラー)<br>
        //【なのに】Playerクラス内にGame変数を持っているからPlayerの定義も終わらない！！(未定義エラー)<br>
        //【つまりPlayerとGameが互いに定義が終わるのを待つ】【循環相互インクルードどうぞどうぞ状態】になる<br>
        //【解決するために】とりあえずclass Game;とだけここに書いてGameは定義完了済と見せかけているわけです！<br>
        //[エラー:Playerは未定義です]とか[エラー:Gameは未定義です]とか定義してるはずのものが未定義の場合は大体これ！！</em><br>
      <br>
      class&nbsp;Player<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
      <br>
      &nbsp;&nbsp;float x; // x座標<br>
      &nbsp;&nbsp;float y; // y座標<br>
      <br>
      &nbsp;&nbsp;<em>Game* game { nullptr }; // Gameのインスタンスの参照<br>
        &nbsp;&nbsp;//↑ * ポインタ型です！プレイヤの【内部に】ゲームの情報を【メモリ実体として持つ】と<br>
        &nbsp;&nbsp;//そのプレイヤを親のゲームがもつと【延々とループで終わりなきメモリ爆発ループ】になるから<br>
        &nbsp;&nbsp;//メモリに対しての参照=【レコードの針をGameに指して】【Gameの住所アドレスだけをプレイヤ内部に持つ】</em><br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;// x : 初期位置x<br>
      &nbsp;&nbsp;// y : 初期位置y<br>
      &nbsp;&nbsp;Player(float x, float y<em>, Game* game</em>)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;game = game;</em><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;<em>void Update();//【★←Player.cppを新規作成してそちらに処理を書き移す】</em><br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;<em>void Draw();//【★←Player.cppを新規作成してそちらに処理を書き移す】</em><br>
      <br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>↑Player.hにあった上記処理部分を↓Player.cppを新規作成して書き移します</code></p>
    <p><code>Player.cpp</code>にPlayerBulletの発射処理を追加します：</p>
    <p class="source"> #include&nbsp;"Player.h"<br>
      <br>
      <em>#include&nbsp;"Game.h"&nbsp;//&nbsp;★game-&gt;playerBulletsなどClass Game;でカバーできない【定義の内部のplayerBulletsにアクセスするのでインクルード必要】<br>
        #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★弾を生成して【使う処理があるのでインクルード必要】</em><br>
      <br>
      <br>
      <br>
      // 更新処理【書き移す際にはPlayer::という形で::所属が必要になります】<br>
      void&nbsp;<em>Player::</em>Update()<br>
      {<br>
      &nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
      &nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
      <br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
      &nbsp;&nbsp;if (vx != 0 &amp;&amp; vy != 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 実際に位置を動かす<br>
      &nbsp;&nbsp;x += vx;<br>
      &nbsp;&nbsp;y += vy;<br>
      <br>
      &nbsp;&nbsp;<em>// ボタン押下で自機弾を発射<br>
        &nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;emplace_backで配列に追加。make_shared↓でプレイヤ弾を新しく生成<br>
        &nbsp;&nbsp;&nbsp;&nbsp;game-&gt;playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(x, y));<br>
        &nbsp;&nbsp;}</em><br>
      }<br>
      <br>
      // 描画処理<br>
      void&nbsp;<em>Player::</em>Draw()<br>
      {<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::player, TRUE);<br>
      }<br>
      <br>
    </p>
    <br>
    <br>
    <br>
    <p>【確認してみましょう】ここまでで一旦弾が打てるかチェックしてみましょう！【メモリは削除されないバージョンなので要注意！！】</p>
    <br>
    <br>
    <br>
    <br>
    <h2><a id="mozTocId00071" class="mozTocH1"></a>循環参照・インクルードの罠</h2>
    <p>【さてここで大量のエラーで詰んだ人も多いのでは】おそらくは【Player.hに弾を弾を撃つ処理を書いたのでは】</p>
    <p>それにしても【なぜヘッダh.ファイルとcppファイルに書く違いだけで大量のエラー】が出てしまうのでしょう？</p>
    <br>
    <p> <img src="image/include_loop_error.png" alt="" style="width: 700px; height: 538px;"></p>
    <br>
    <p>原因である【循環参照・循環インクルード】について説明します。<br>
      実はインクルードしたPlayer.hやGame.hは【⇒ビルド】した際に【Player.hの中身が#include "Player.h"へとコピペ】されるのです<br>
      そして問題は相互に【Player.hで#include "Game.h"】⇔【Game.hで#include "Player.h"】すると<br>
      互いへの【コピペがループする】ため【延々とGameかPlayerの定義が完成せず】<br>
      結果、邪悪なことに【全然関係ないPlayerBulletが未定義などと、とばっちりエラーが起こる】のです</p>
    <p> <img src="image/include_loop.png" alt="" style="width: 672px; height: 382px;"></p>
    <br>
    <p>さてこの【循環参照・循環インクルード】への対策をどうするかが問題です。<br>
      <br>
      【1】 ヘッダ.hでのインクルードを避け.cppファイルでインクルードするのが基本的には有効です(ヘッダ.h同士が相互にコピペしあわないから)<br>
      【2】 しかし根本的には【★相互に参照しあう構造の設計自体すっきりさせたい】です。<br>
      <br>
      今はPlayer⇔Gameの1対1の関係でまだ把握可能ですが、ザコや敵の弾などが他に増えてくると<br>
      恐怖の三角関係や四角関係など【どこかで一周回ると無限インクルード発生】が起こってきます。<br>
      まだ【1対1の循環なら見抜ける】けど【★三角ループや四角ループは発見が難しすぎ】です。</p>
    <p> <img src="image/include_loop_meditator.png" alt="" style="width: 801px; height: 852px;"></p>
    <p>そう、相互に行き来する【★矢印を一つへ集中させる】のです。<br>
      こういったパターンを<a href="https://refactoring.guru/ja/design-patterns/mediator">【★仲介者(Meditator:メディエーター)パターン】</a>あるいは<a href="https://www.techscore.com/tech/DesignPattern/Facade">【★窓口(Facade:ファサード)パターン】</a>と呼びます。<br>
      このパターンは【循環参照問題以外にも色んな利点】があり多用されます。<br>
      一点に集中させれば【メモリの状況もここに集中します】し<br>
      ここを経由すれば【どこからでもどこへでも連絡でき指令が出せます】<br>
      そしていちいち初期化の時に【参照の連絡先の交換が必要なくなります】</p>
    <p>ついでにもう一つ【★唯一物(シングルトン)パターン】も取り入れておきます。</p>
    <p> <img src="image/include_loop_singleton.png" alt="" style="width: 565px; height: 946px;"></p>
    <p>こういった先人の生み出したパターンを【デザインパターン】といいます。</p>
    <p>有用なデザインパターンは23ほどあり、状況に合わせてうまく取り入れることが上級者への道で<br>
      変な構造で作っていると起こる面倒な時間のロスが減り【残業時間が減ります】<br>
      案外【ブラックな現場は構造のデザインそのものが悪かった】ことも多いです(なんかいちいちやりづらい環境)<br>
      こういう【構造自体に疑問を持てる人が開発のリーダーシップを取れる】と心地よく制作が進むので<br>
      時間とスキルに余裕ができたら将来のリーダーに向けて【デザイン構造パターン】を勉強するとよいかもしれません。</p>
    <br>
    <br>
    <p>さて、ではまず<code>Singleton.h</code>を追加しましょう。<br>
      コード中身は難しい文法が多いですが、<br>
      基本の要点は<br>
      <br>
      【1】「代入」「コピー」「実体ポインタへの直接アクセス」を★private:として【外部から禁止】<br>
      【2】「実体へは★GetInstance()関数経由でしかアクセスできない」よう窓口を絞り<br>
      【3】「テンプレ化」★template&lt;class T&gt;して何でも唯一化できるようになっています</p>
    <br>
    <h2><a id="mozTocId00072" class="mozTocH1"></a>シングルトン型:唯一物体タイプの追加</h2>
    <p>難しいコードなので導入するだけでも良いですが、<br>
      C++の「代入」「コピー」「テンプレ化」は基礎として大事なので頑張って6割ほどは理解できるようになりたいですね。<br>
      2,3年後上級者となって読み返して9割ほど理解できるようになるよう成長してゆきましょう。</p>
    <p><code>Singleton.h</code></p>
    <p class="source"> #ifndef SINGLETON_H_<br>
      #define SINGLETON_H_<br>
      <br>
      // テンプレートT型シングルトンSingleton&lt;～&gt; ～になんでも指定して唯一物にできる<br>
      // ★Singleton&lt;T&gt;型は【必ず唯一で複製不可】(使い方:どこからでもアクセスし変数を共有するクラス向き)<br>
      // ★ゲーム内の【どこからアクセスしても統一性が保たれる】(唯一だから)「クラス名と実体が一致」<br>
      template&lt;class T&gt;<br>
      class Singleton<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;// GetInstanceを通して【しか】T型クラスをつくれないうえに、<br>
      &nbsp;&nbsp;// ★作ったものは【かならず唯一で複製不可】<br>
      &nbsp;&nbsp;// それが【シングルトン型】！<br>
      &nbsp;&nbsp;// ゲーム中で唯一で複製不可にしたい【ゲームを一律管理するクラス】などに最適！<br>
      &nbsp;&nbsp;// https://teratail.com/questions/17416<br>
      &nbsp;&nbsp;// http://rudora7.blog81.fc2.com/blog-entry-393.html<br>
      &nbsp;&nbsp;// ②↓同じ関数の定義はプログラム全体で１つだけしか許されません。(static関数名は被らない)<br>
      &nbsp;&nbsp;static inline T&amp; GetInstance()<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;//①↓関数の中で定義されたstatic変数は、関数の定義毎に１つ領域が確保されます。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;static T instance; //メモリ上にstatic変数確保(静かに常に待機するinstance)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return instance; //①=(常駐)②=(唯一) ①と②両方満たすinstanceは【メモリ上に唯一】<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;//★【{}内のローカルstaticの特性:ラベル(上の例ではinstance)がリセットされずに常駐】https://monozukuri-c.com/langc-static-memory/<br>
      &nbsp;&nbsp;//つまり、ゲームマネージャなどを★リセットされず常駐状態にできるわけです<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;Singleton() {} // 外部でのインスタンス作成は禁止(protected:内部公開、外部禁止)<br>
      &nbsp;&nbsp;virtual ~Singleton() {} // 仮想デストラクタ(シングルトンを【継承するためには忘れちゃダメ】)<br>
      <br>
      private:&nbsp;&nbsp;//代入やコピーをprivateにして外部クラスからアクセスできないように【縛る】<br>
      &nbsp;&nbsp;void operator=(const Singleton&amp; obj) {} // 代入演算子禁止<br>
      &nbsp;&nbsp;Singleton(const Singleton&amp; obj) {} // コピーコンストラクタ禁止(コピーできない【唯一】)<br>
      &nbsp;&nbsp;static T* instance; // private:だから外部アクセスできない【GetInstance()経由しかアクセスできないように縛る】<br>
      };<br>
      <br>
      // いつもcppで書いたstatic変数初期化も★【Tテンプレートクラスだからすべて.hヘッダにまとめて書いた】<br>
      template&lt; class T &gt;<br>
      T* Singleton&lt; T &gt;::instance = 0; //cppでの定義を.h内に書いた(static変数はclass内で初期化できないから)<br>
      <br>
      #endif<br>
    </p>
    <br>
    <h2><a id="mozTocId00073" class="mozTocH1"></a>仲介マネージャーGameManagerの追加</h2>
    <p>続いて仲介の役割を担当する<code>GameManager.h</code>を作成します。</p>
    <p class="source"> #ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      <br>
      #include&nbsp;"Singleton.h"<br>
      <br>
      class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      class&nbsp;PlayerBullet;<br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機の初期化<br>
      <br>
      &nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;// 複数リスト↑vector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Game.h</code>からGameManager.hに移行した処理を消して代わりにGameMangerへの連絡先gmを確保します。</p>
    <p class="source">#ifndef GAME_H_<br>
      #define GAME_H_<br>
      <br>
      #include&nbsp;&lt;vector&gt;//配列 std::vectorを使う<br>
      #include&nbsp;&lt;memory&gt;//スマートなポインタを使うのに必要(shared_ptrなど)<br>
      <br>
      #include&nbsp;"Image.h"<br>
      #include&nbsp;"Screen.h"<br>
      <u>#include&nbsp;"Player.h"</u><br>
      <br>
      <u>//前方宣言でPlayerBulletという【ポインタの型】があることだけを宣言すれば#includeせずにstd::vectorの中身にPlayerBulletのリンクだけなら入れられる<br>
        class&nbsp;PlayerBullet;</u><br>
      <br>
      <em>#include&nbsp;"GameManager.h"</em><br>
      <br>
      class&nbsp;Game<br>
      {<br>
      public&nbsp;:<br>
      &nbsp;&nbsp;Game()&nbsp;{}; // 初期化コンストラクタ<br>
      &nbsp;&nbsp;~Game()&nbsp;{}; // 破棄処理デストラクタ<br>
      <br>
      &nbsp;&nbsp;<em>//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
        &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る</em><br>
      <br>
      &nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
      &nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
      &nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
      <br>
      &nbsp;&nbsp;int x = 0;<br>
      &nbsp;&nbsp;int vx = 0;<br>
      <br>
      &nbsp;&nbsp;<u>std::shared_ptr&lt;Player&gt;&nbsp;player{ std::make_shared&lt;Player&gt;(100, Screen::Height / 2, this) }; // 自機の初期化<br>
        &nbsp;&nbsp;//↑プレイヤを回し読みポインタ型に。std::make_shared&lt;Player&gt;でメモリ上に実体を生成<br>
        &nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト</u><br>
      <br>
      };<br>
      <br>
      #endif</p>
    <p>次にGame.cppファイルのPlayerやPlayerBulletのアクセスをGamaManagerのgm経由に書き換えましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のように変更します：</p>
    <p class="source">#include "Game.h"<br>
      <br>
      <em>#include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理の関数を呼出すのでインクルード必要】</em><br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理の関数を呼出すのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      <br>
      &nbsp;&nbsp;<em>gm.player = std::make_shared&lt;Player&gt;((float)100, (float)(Screen::Height / 2)); // 自機の初期化</em><br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;<em>gm.</em>player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      &nbsp;&nbsp;//ポインタ↑になると.から-&gt;でのアクセスになる<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : <em>gm.</em>playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//【放置厳禁！！！このままここに弾削除処理書かないとメモリがどんどん減ってくよ(気づかないうちにね..怖)】<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;<em>gm.</em>player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      &nbsp;&nbsp;//ポインタ↑になると.から-&gt;でのアクセスになる<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : <em>gm.</em>playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      };<br>
    </p>
    <br>
    <p><code>Player.h</code>もGameManagerのgm経由でのアクセスにするので#include "Game.h"やGame*のポインタはなくなります。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      <br>
      <u>class Game;//←【エラー地獄に注意！】ここにGameクラスがあるものとして書くことで【循環相互インクルード問題】を回避</u><br>
      <br>
      <em>#include&nbsp;"GameManager.h"</em><br>
      <br>
      class Player<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
      <br>
      &nbsp;&nbsp;float x; // x座標<br>
      &nbsp;&nbsp;float y; // y座標<br>
      <br>
      &nbsp;&nbsp;<em>//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
        &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る</em><br>
      <br>
      &nbsp;&nbsp;<u>Game* game { nullptr }; // Gameのインスタンスの参照<br>
        &nbsp;&nbsp;//↑ * ポインタ型です！プレイヤの【内部に】ゲームの情報を【メモリ実体として持つ】と<br>
        &nbsp;&nbsp;//そのプレイヤを親のゲームがもつと【延々とループで終わりなきメモリ爆発ループ】になるから<br>
        &nbsp;&nbsp;//メモリに対しての参照=【レコードの針をGameに指して】【Gameの住所アドレスだけをプレイヤ内部に持つ】</u><br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;// x : 初期位置x<br>
      &nbsp;&nbsp;// y : 初期位置y<br>
      &nbsp;&nbsp;Player(float x, float y<u>, Game* game</u>)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>this-&gt;game = game;</u><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理の関数定義<br>
      &nbsp;&nbsp;void Update();<br>
      <br>
      &nbsp;&nbsp;// 描画処理の関数定義<br>
      &nbsp;&nbsp;void Draw();<br>
      <br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>Player.cpp</code>もGameManagerのgm経由でのアクセスに書き換えます</p>
    <p class="source"> #include&nbsp;"Player.h"<br>
      <br>
      <u>#include "Game.h"</u><br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★弾を生成して【使う処理があるのでインクルード必要】<br>
      <br>
      // 更新処理【書き移す際にはPlayer::という形で::所属が必要になります】<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
      &nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
      <br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
      &nbsp;&nbsp;if (vx != 0 &amp;&amp; vy != 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 実際に位置を動かす<br>
      &nbsp;&nbsp;x += vx;<br>
      &nbsp;&nbsp;y += vy;<br>
      <br>
      &nbsp;&nbsp;// ボタン押下で自機弾を発射<br>
      &nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;emplace_backで配列に追加。make_shared↓でプレイヤ弾を新しく生成<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>gm.</em>playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(x, y));<br>
      &nbsp;&nbsp;}<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::player, TRUE);<br>
      }<br>
      <br>
    </p>
    <h2><a id="mozTocId00074" class="mozTocH1"></a>【※メモリから弾を削除】自機弾PlayerBulletの削除処理</h2>
    <p>PlayerBulletクラスを改造しましょう。<br>
    </p>
    <p><code>PlayerBullet.h</code>の内容を次のように【改造】します：</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      <em>#include "Screen.h"</em><br>
      <br>
      // 自機弾クラス<br>
      class PlayerBullet<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      &nbsp;&nbsp;<em>const int VisibleRadius = 16; // 見た目の半径</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
      &nbsp;&nbsp;//【使用注意】int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ<br>
      <br>
      &nbsp;&nbsp;float x; // x座標<br>
      &nbsp;&nbsp;float y; // y座標<br>
      &nbsp;&nbsp;<em>bool isDead = false; // 死亡フラグ</em><br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;PlayerBullet(float x, float y)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += Speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// 画面外に出たら、死亡フラグを立てる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (x - VisibleRadius &gt; Screen::Width)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      </em> &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      <br>
      #endif</p>
    <br>
    <p>次にGame.cppファイルに自機弾PlayerBulletの【削除処理】を追加しましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      <br>
      &nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;((float)100, (float)Screen::Height / 2); // 自機の初期化<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
        &nbsp;&nbsp;<br>
        &nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
        &nbsp;&nbsp;// 非常に複雑な式に見えるがこれでisDeadのものを削除<br>
        &nbsp;&nbsp;// https://stackoverflow.com/questions/42723205/remove-if-from-a-stdvector-of-shared-pointers-with-a-member-function<br>
        &nbsp;&nbsp;gm.playerBullets.erase(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;std::remove_if(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int usingCount = -1;//テスト用コード(以下のコメントアウト部分は省略可)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if (ptr-&gt;isDead) usingCount = ptr.use_count();//おかんのコレ捨てるよカウンタ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//弾を捨てるまでの残り↑カウント(1だとisDeadがtrueなら0になり削除へ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.end()<br>
        &nbsp;&nbsp;);</em><br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      };<br>
    </p>
    <br>
    <p>さて、削除部分の処理が非常に複雑ですね。C#と比較してみましょう。<br>
      【C#】<br>
      playerBullets.RemoveAll(pb =&gt; pb.isDead);<br>
      【C++】<br>
    </p>
    <p class="source"> gm.playerBullets.erase(<br>
      &nbsp;&nbsp;std::remove_if(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int usingCount = -1;//テスト用コード(以下のコメントアウト部分は省略可)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if (ptr-&gt;isDead) usingCount = ptr.use_count();//おかんのコレ捨てるよカウンタ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//弾を捨てるまでの残り↑カウント(1だとisDeadがtrueなら0になり削除へ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}),<br>
      &nbsp;&nbsp;gm.playerBullets.end()<br>
      );<br>
    </p>
    <br>
    テスト用のコードを消して読みやすくしてみましょう。<br>
    【C++】<br>
    <p class="source"> gm.playerBullets.<em>erase</em>(<br>
      &nbsp;&nbsp;std::<em>remove_if</em>(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}),<br>
      &nbsp;&nbsp;gm.playerBullets.end()<br>
      );<br>
    </p>
    <br>
    これでもまだ複雑ですが、なぜ複雑に見えるか？<br>
    【実は二つの処理が同時に行われている】ためです。<br>
    <br>
    【1】erase処理&nbsp;:&nbsp;<a href="https://cpprefjp.github.io/reference/vector/vector/erase.html">指定した配列の要素を削除する処理です。</a><br>
    基本構文は<br>
    &nbsp;&nbsp;v.erase(【削除開始位置】, 【終了位置】);<br>
    で、プレイヤ弾の削除処理では<br>
    <p class="source"> gm.playerBullets.erase(<br>
      &nbsp;&nbsp;……<br>
      &nbsp;&nbsp;&nbsp;&nbsp;……<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;……<br>
      &nbsp;&nbsp;&nbsp;&nbsp;……,<br>
      &nbsp;&nbsp;gm.playerBullets.end()<br>
      );<br>
    </p>
    よく見ると実は<br>
    gm.playerBullets.erase(【複雑な何か】,&nbsp;gm.playerBullets.end()&nbsp;);<br>
    となっているだけで実は【複雑な何か】 ～ 【end()終了位置】までの削除処理を行っているだけだとわかります。<br>
    こういう風にカンマ,や(かっこ)で区切られた構造を読み解く力が身に付けば複雑なコードでも<br>
    <br>
    【分解ステップを踏んでゆけば読み解けるようになります】<br>
    <br>
    そして次の「複雑な何か↓」も分解して読み解いてみましょう。<br>
    【2】remove_if処理&nbsp;:&nbsp;<a href="https://cpprefjp.github.io/reference/algorithm/remove_if.html">ある条件を①満たすものを【配列の後ろ】に、②満たさないものを【前に】集め①の始まりの位置を返す</a><br>
    基本構文はvを配列とすると<br>
    &nbsp;&nbsp;std::remove_if(v.begin(), v.end(), 条件);//配列v開始位置から終了位置まで「条件」に従い分離並べ替えし条件を満たす後ろに並べ替えられたものの分離された先頭位置を返す<br>
    つまりremove_ifは配列の後ろに条件を満たすものを分離する処理の担当で削除すべきものの先頭の位置をeraseに渡す担当だとわかります。<br>
    <br>
    要するに【1】と【2】で協力して「削除」と「分離並べ替え」を【分担していただけ】だったわけです。<br>
    <br>
    そしてその条件式が<br>
    <p class="source"> [](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {&nbsp;<em>return ptr-&gt;isDead;</em>&nbsp;}<br>
    </p>
    というスタイルでisDeadがtrueかfalseかreturnするという【ちょっとクセの強い条件式の書き方】で書かれていたということです。<br>
    <br>
    ここは【慣れてゆくしかないです】何度も見て【見慣れる】ことです。<br>
    <p></p>
    <p>しかし、なぜ【わざわざeraseとremove_ifを組合わせる必要があるのか】<br>
      それは【erase単体だけだと削除処理が遅い】からです。<br>
      vectorはメモリ上にデータが【隙間なく詰まってます】ゆえに【通常性能は速いです】<br>
      ただ引き換えに【あいだのデータを1個消す】だけで【隙間を埋める座席移動が発生】します。<br>
      100万のデータが座ってる中、中央付近のデータを1個消すだけで【50万回ぶん一つずつ隙間を埋める座席移動が発生】します。<br>
      これがeraseだけ異様に遅い理由です。<br>
      逆に映画館の座席で通路付近に座ってる人を思い浮かべてください。<br>
      映画が終わると通路付近の座席の人はすぐに立って横に出れば最初に通路への出られますよね。<br>
      ゆえに配列の【後ろから】一つ削除する【pop_back処理は速い】です。<br>
      したがって【後ろに消したいものを先に集めてしまえばよいのです】<br>
      これが【remove_if】処理です。remove_ifは条件を指定して【削除候補を後ろに並べ替えます】<br>
      ゆえに【2】remove_ifで先に後ろに並べ替えて【1】eraseでまとめて削除の【1】【2】のハイブリッドが必要なのです。<br>
    </p>
    <p> <img src="image/erase_remove_if_fast.png" alt="" style="width: 620px; height: 701px;"></p>
    <p>ただ、毎回この複雑なコードを書くと【コードが見にくくなる】ので【テンプレート化】に挑戦してみましょう。</p>
    <h2><a id="mozTocId00075" class="mozTocH1"></a>共通削除機能を【テンプレートとして定義】</h2>
    <p><code>GameManager.h</code>に共通の削除機能として【テンプレート機能】として追加してみましょう。</p>
    <p class="source"> #ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      <br>
      #include&nbsp;"Singleton.h"<br>
      <br>
      class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      class&nbsp;PlayerBullet;<br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機の初期化<br>
      <br>
      &nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;// 複数リスト↑vector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      <br>
      <br>
      &nbsp;&nbsp;<em>//&nbsp;★削除処理を共通テンプレート関数にする<br>
        &nbsp;&nbsp;//&nbsp;[共通テンプレート関数]https://programming-place.net/ppp/contents/cpp/language/009.html#function_template<br>
        &nbsp;&nbsp;template&nbsp;&lt;typename&nbsp;T,&nbsp;class&nbsp;T_if&gt;<br>
        &nbsp;&nbsp;void&nbsp;EraseRemoveIf(std::vector&lt;T&gt;&nbsp;&amp;v,&nbsp;T_if&nbsp;if_condition)<br>
        &nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特定のタイプT↑&nbsp;&nbsp;↑配列v&nbsp;&nbsp;&nbsp;↑条件式if_condition<br>
        &nbsp;&nbsp;&nbsp;&nbsp;v.erase(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::remove_if(v.begin(),&nbsp;v.end(),if_condition),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.end()&nbsp;//&nbsp;&nbsp;↓remove_ifの位置<br>
        &nbsp;&nbsp;&nbsp;&nbsp;);//例.[生][生][死][死][死]←&nbsp;v.end()の位置<br>
        &nbsp;&nbsp;};</em><br>
      <br>
      protected:<br>
      &nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p>そして<code>Game.cpp</code>の削除処理をシンプルに書き直します</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      <br>
      &nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;((float)100, (float)Screen::Height / 2); // 自機の初期化<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 自機弾の削除処理<br>
        &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<u>// 自機弾のリストから死んでるものを除去する<br>
        &nbsp;&nbsp;// 非常に複雑な式に見えるがこれでisDeadのものを削除<br>
        &nbsp;&nbsp;// https://stackoverflow.com/questions/42723205/remove-if-from-a-stdvector-of-shared-pointers-with-a-member-function<br>
        &nbsp;&nbsp;gm.playerBullets.erase(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;std::remove_if(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int usingCount = -1;//テスト用コード(以下のコメントアウト部分は省略可)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if (ptr-&gt;isDead) usingCount = ptr.use_count();//おかんのコレ捨てるよカウンタ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//弾を捨てるまでの残り↑カウント(1だとisDeadがtrueなら0になり削除へ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.end()<br>
        &nbsp;&nbsp;);</u><br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      };<br>
    </p>
    <p>さて、使う側はすっきり2行にまとまりました。<br>
      これなら削除するリストがenemiesやenemyBulletsなど増えてきても書きやすいです。</p>
    <p>テンプレート化template&nbsp;&lt;typename&nbsp;T&gt;を習得することは上級者への第一歩です。<br>
      C++だけでなく【C#でもテンプレート化ができます】ぜひ練習して習得してゆきましょう。<br>
      逆の目線で言うと【実は今まではテンプレート化された使いやすい機能を使わせてもらっていた】のです。意識せずに。<br>
      使う側が意識しなくていいほど【使いやすいテンプレート】を自力で作れることが理想形です。トライしてゆきましょう。<br>
    </p>
    <br>
    <h2><a id="mozTocId00076" class="mozTocH1"></a>【実験】メモリ浪費弾の実験</h2>
    <p> ここまでで一応弾の削除処理は書けました。しかし本当に弾が削除されているか実感がありません。<br>
      弾1個は現状では【かなり微小なメモリしか】使用しません。<br>
      実行して【メモリのグラフを見ても増えているか減っているか見えないほど微小です】<br>
      そこで【人為的に弾1個のメモリを大きくする】実験をしてみましょう。<br>
      注意が必要です【危険な実験】です(ほったらかすと)。【実験コードは必ず元に戻してください！！】<br>
      では実験を始めてみましょう。<br>
    </p>
    <p><code>PlayerBullet.h</code>の内容を次のように【改造】します：</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <br>
      // 自機弾クラス<br>
      class PlayerBullet<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      &nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
      &nbsp;&nbsp;<em>int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ</em><br>
      <br>
      &nbsp;&nbsp;float x; // x座標<br>
      &nbsp;&nbsp;float y; // y座標<br>
      &nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;PlayerBullet(float x, float y)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += Speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 画面外に出たら、死亡フラグを立てる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (x - VisibleRadius &gt; Screen::Width)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      <br>
      #endif</p>
    <br>
    <p>無駄メモリをあえて人為的に定義して弾を撃ってみましょう。<br>
      メモリの【グラフがうなぎ上りに上昇しなければ】プレイヤの弾に関してはメモリの削除と開放が成功している証拠です。<br>
      <br>
    </p>
    <p> <img src="image/memory_valance_and.png" alt="" style="width: 773px; height: 467px;"></p>
    <p>試しに<code>Game.cpp</code>で削除処理をわすれた場合の実験をしてみましょう。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      <br>
      &nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;((float)100, (float)Screen::Height / 2); // 自機の初期化<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 自機弾の削除処理<br>
        &nbsp;&nbsp;//gm.EraseRemoveIf(gm.playerBullets,<br>
        &nbsp;&nbsp;//&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      };<br>
    </p>
    <p> <img src="image/memory_leak.png" alt="" style="width: 728px; height: 433px;"></p>
    <p>実験が終わったら実験コードをもとに戻しましょう<code>PlayerBullet.h</code>の内容を次のようにします</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <br>
      // 自機弾クラス<br>
      class PlayerBullet<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      &nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
      &nbsp;&nbsp;<em>//【実験コード】int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ</em><br>
      <br>
      &nbsp;&nbsp;float x; // x座標<br>
      &nbsp;&nbsp;float y; // y座標<br>
      &nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;PlayerBullet(float x, float y)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += Speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 画面外に出たら、死亡フラグを立てる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (x - VisibleRadius &gt; Screen::Width)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      <br>
      #endif</p>
    <br>
    <p><code>Game.cpp</code>の削除処理ももとに戻しましょう。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      <br>
      &nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;((float)100, (float)Screen::Height / 2); // 自機の初期化<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 自機弾の削除処理<br>
        &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      };<br>
    </p>
    <br>
    <h2><a id="mozTocId00077" class="mozTocH1"></a>自機弾の角度を変えられるようにする</h2>
    数学の基礎のおさらい【cosθとsinθはx,yに対応する】【たて×よこの比率(範囲:min:-1.0～1.0:max)】<br>
    <img src="image/cos_sin1.png" alt=""><br>
    <img src="image/cos_sin2.png" alt=""><br>
    <br>
    <p><code>PlayerBullet.h</code>に角度をつけられるようにします</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      <em>#include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要</em><br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <br>
      // 自機弾クラス<br>
      class PlayerBullet<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      &nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
      &nbsp;&nbsp;//【実験コード】int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ<br>
      <br>
      &nbsp;&nbsp;float x; // x座標<br>
      &nbsp;&nbsp;float y; // y座標<br>
      &nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
      <br>
      &nbsp;&nbsp;<em>float vx; // x方向移動速度</em><br>
      &nbsp;&nbsp;<em>float vy; // y方向移動速度</em><br>
      &nbsp;&nbsp;<em>float angle; // 移動角度</em><br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;PlayerBullet(float x, float y<em>, float angle</em>)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;angle = angle;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>vx = (float)std::cos(angle) * Speed;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>vy = (float)std::sin(angle) * Speed;</em><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>x += vx;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>y += vy;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 画面外に出たら、死亡フラグを立てる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (<em>x + VisibleRadius &lt; 0 || x - VisibleRadius &gt; Screen::Width || <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y + VisibleRadius &lt; 0 || y - VisibleRadius &gt; Screen::Height</em>)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, <em>angle</em>, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      <br>
      #endif</p>
    <br>
    <p><code>MyMath.h</code>を編集します：</p>
    <p class="source">#ifndef _MYMATH_H<br>
      #define _MYMATH_H<br>
      // 数学関連クラス<br>
      class MyMath<br>
      {<br>
      public: <br>
      &nbsp;&nbsp;static const float Sqrt2;&nbsp;&nbsp;// = 1.41421356237f;(.hではfloat小数型の初期化はできない int型はできるのに)<br>
      &nbsp;&nbsp;<em>static const float PI; // 円周率 3.14159265359f;</em><br>
      &nbsp;&nbsp;<em>static const float Deg2Rad; // 度からラジアンに変換する定数 PI / 180f;</em><br>
      <br>
      }; // 【注意】セミコロン抜けで【宣言が必要ですエラー】<br>
      <br>
      #endif //【宣言が必要ですエラーは上のセミコロン抜け】</p>
    <br>
    <p><code>MyMath.cpp</code>を編集して変数に数値を割り当て。</p>
    <p class="source">#include "MyMath.h"<br>
      <br>
      const float MyMath::Sqrt2 = 1.41421356237f;//(floatは有効桁は実質7桁まで正確だがそれ以降は環境によって誤差出る)<br>
      <em>const float MyMath::PI = 3.14159265359f; // 円周率<br>
        const float MyMath::Deg2Rad = MyMath::PI / 180; // 度からラジアンに変換する定数</em><br>
      <br>
    </p>
    <p><code>Player.cpp</code>のプレイヤの弾の生成を改修します。</p>
    <p class="source">#include "Player.h"<br>
      <em>#include "MyMath.h"<br>
      </em> <br>
      (前略)...................................<br>
      <br>
      &nbsp;&nbsp;// ボタン押下で自機弾を発射<br>
      &nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;C++ではAddがemplace_backに↓&nbsp;newがmake_shared↓に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(x, y<em>, 0</em>));<em>//右</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(x, y, -15 * MyMath::Deg2Rad));//右上</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(x, y, +15 * MyMath::Deg2Rad));//右下</em><br>
      &nbsp;&nbsp;}<br>
      }<br>
      <br>
      (以下略) </p>

    <br>
    
    <h2><a id="mozTocId00078" class="mozTocH1"></a>vectorとlistの性能考察</h2>
    データのリスト(今回は弾のリスト)をどうデータ管理するかにはstd::vectorとstd::listの2パターンの格納方法が考えられます。
    <img src="image/vector_vs_list.png" alt="" style="width: 799px; height: 439px;"><br>
    <br>
    ※vectorは大量の弾が増えてきたときにまとまったメモリの領域を割り当てる必要が出てくるので、ランダムアクセスしたいなどの用途がない場合は、<br>
    list構造にしておくほうが、メモリの再確保などで遅くなる可能性を回避できるので、listに書き換えてみましょう。<br>
    <br>
    <p><code>GameManager.h</code>で管理しているPlayerBulletのvector配列をlist構造に変更してみましょう。</p>
    <p class="source"> #ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      <u>#include &lt;vector&gt;</u><br>
      <em>#include &lt;list&gt;</em><br>
      <br>
      #include&nbsp;"Singleton.h"<br>
      <br>
      class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      class&nbsp;PlayerBullet;<br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機の初期化<br>
      <br>
      &nbsp;&nbsp;std::<em>list</em>&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;// 複数リスト↑<em>list</em> ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      <br>
      <br>
      &nbsp;&nbsp;//&nbsp;★削除処理を共通テンプレート関数にする<br>
        &nbsp;&nbsp;//&nbsp;[共通テンプレート関数]https://programming-place.net/ppp/contents/cpp/language/009.html#function_template<br>
        &nbsp;&nbsp;template&nbsp;&lt;typename&nbsp;T,&nbsp;class&nbsp;T_if&gt;<br>
        &nbsp;&nbsp;void&nbsp;EraseRemoveIf(std::<em>list</em>&lt;T&gt;&nbsp;&amp;v,&nbsp;T_if&nbsp;if_condition)<br>
        &nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特定のタイプT↑&nbsp;&nbsp;↑配列v&nbsp;&nbsp;&nbsp;↑条件式if_condition<br>
        &nbsp;&nbsp;&nbsp;&nbsp;v.erase(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::remove_if(v.begin(),&nbsp;v.end(),if_condition),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.end()&nbsp;<em>&nbsp;&nbsp;</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;);<em>&nbsp;</em><br>
        &nbsp;&nbsp;};<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>

    <h1><a id="mozTocId0008" class="mozTocH1"></a>ベクトル構造体でX,Y,ZをVector3型でまとめて管理する</h1>
    <h2><a id="mozTocId00081" class="mozTocH1">ベクトルの基本</h2>
    <p>現状ではX,Yは別々の変数として定義していますが、これを数学のベクトルを扱うVector3型を定義してそちらに置き換えましょう(std::vectorとはつづりが同じだけどまったく別のもの)<br>

    <p><code>Vector3.h</code>を作成します(拡張も見越して3DのZ座標も導入しておきます)</p>
    <p class="source">#ifndef VECTOR3_H_<br>
      #define VECTOR3_H_<br>
      <br>
      #include &lt;array&gt; //vector配列と基本同じだが【有限】の個数である違いがあるxyzなど3つ固定の個数ならstd::vectorよりstd::array型がよい<br>
      #include &lt;cmath&gt;<br>
      #include &lt;limits&gt; // 無限大などをstd::numeric_limits&lt;float&gt;::infinity()で取得<br>
      <br>
      //★【UnityのVector演算コード】<br>
      // https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
      <br>
      // 3変数x,y,zを持つ構造体。3つの数字をまとめて扱うならXYZ座標以外にも使えるよ。x,y,z別々に足したり引いたり面倒でしょう。<br>
      struct Vector3<br>
      {<br>
      // struct型はpublic:がなくてもデフォルトがpublic:&nbsp;&nbsp;private:を書けばプライベートにもできる<br>
      &nbsp;&nbsp;float x = 0; // x座標<br>
      &nbsp;&nbsp;float y = 0; // y座標<br>
      &nbsp;&nbsp;float z = 0; //【3D】z座標<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ 初期化 z = 0.fでzのデフォルト値があるので2Dとしても使える<br>
      &nbsp;&nbsp;Vector3(float x = 0.f, float y = 0.f, float z = 0.f)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z = z;<br>
      &nbsp;&nbsp;} <br>
      &nbsp;&nbsp;//仮想デストラクタ<br>
      &nbsp;&nbsp;virtual ~Vector3()<br>
      &nbsp;&nbsp;{<br>
      <br>
      &nbsp;&nbsp;}<br>
      <br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p><br>
    基本的にはX,Y,Zを上記コードでVector3型で一つの定義にまとめることができます。<br>
    <br>
    次に少し便利にすべく少しトリッキーですが、共用体を使ってx,y,zをstd::array型でxyzとしてまとめて扱えるようにしてみましょう<br>
    <p><code>Vector3.h</code>を書き換えます。</p>
    <p class="source">#ifndef VECTOR3_H_<br>
      #define VECTOR3_H_<br>
      <br>
      #include &lt;array&gt; //vector配列と基本同じだが【有限】の個数である違いがあるxyzなど3つ固定の個数ならstd::vectorよりstd::array型がよい<br>
      #include &lt;cmath&gt;<br>
      #include &lt;limits&gt; // 無限大などをstd::numeric_limits&lt;float&gt;::infinity()で取得<br>
      <br>
      //★【UnityのVector演算コード】<br>
      // https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
      <br>
      // 3変数x,y,zを持つ構造体。3つの数字をまとめて扱うならXYZ座標以外にも使えるよ。x,y,z別々に足したり引いたり面倒でしょう。<br>
      struct Vector3<br>
      {<br>
      // struct型はpublic:がなくてもデフォルトがpublic:&nbsp;&nbsp;private:を書けばプライベートにもできる<br>
      &nbsp;&nbsp;<em>//float x = 0; // x座標<br>
      &nbsp;&nbsp;//float y = 0; // y座標<br>
      &nbsp;&nbsp;//float z = 0; // z座標&nbsp;3つの定義をunionで配列xyzと共用することでxyz[1]=5.5f;とすると yも5.5となる【運命共用体】(メモリ上は同じ位置になる)<br>
      <br>
      &nbsp;&nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
		  &nbsp;&nbsp;&nbsp;&nbsp;struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float x;// x座標<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float y;// y座標<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float z;// z座標<br>
		  &nbsp;&nbsp;&nbsp;&nbsp;}; //[匿名共用体とは] https://zenn.dev/block/articles/beda29f11f05afc147ef<br>
		  &nbsp;&nbsp;&nbsp;&nbsp;std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
	    &nbsp;&nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる</em><br>
	<br>
      &nbsp;&nbsp;// コンストラクタ 初期化 z = 0.fでzのデフォルト値があるので2Dとしても使える<br>
      &nbsp;&nbsp;Vector3(float x = 0.f, float y = 0.f, float z = 0.f)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;xyz = { x,y,z };// たった1行で書ける</em><br>
      &nbsp;&nbsp;} <br>
      &nbsp;&nbsp;//仮想デストラクタ<br>
      &nbsp;&nbsp;virtual ~Vector3()<br>
      &nbsp;&nbsp;{<br>
      <br>
      &nbsp;&nbsp;}<br>
      <br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p><br>
	  
    <h2><a id="mozTocId00082" class="mozTocH1">ベクトルの計算</h2>
    次にベクトル同士を足したり引いたり割ったりできるように、ベクトルの計算関数を追加しましょう。<br>
    <p><code>Vector3.h</code>を書き換えます。</p>
    <p class="source">#ifndef VECTOR3_H_<br>
      #define VECTOR3_H_<br>
      <br>
      #include &lt;array&gt; //vector配列と基本同じだが【有限】の個数である違いがあるxyzなど3つ固定の個数ならstd::vectorよりstd::array型がよい<br>
      #include &lt;cmath&gt;<br>
      #include &lt;limits&gt; // 無限大などをstd::numeric_limits&lt;float&gt;::infinity()で取得<br>
      <br>
      //★【UnityのVector演算コード】<br>
      // https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
      <br>
      // 3変数x,y,zを持つ構造体。3つの数字をまとめて扱うならXYZ座標以外にも使えるよ。x,y,z別々に足したり引いたり面倒でしょう。<br>
      struct Vector3<br>
      {<br>
      // struct型はpublic:がなくてもデフォルトがpublic:&nbsp;&nbsp;private:を書けばプライベートにもできる<br>
      &nbsp;&nbsp;//float x = 0; // x座標<br>
      &nbsp;&nbsp;//float y = 0; // y座標<br>
      &nbsp;&nbsp;//float z = 0; // z座標&nbsp;3つの定義をunionで配列xyzと共用することでxyz[1]=5.5f;とすると yも5.5となる【運命共用体】(メモリ上は同じ位置になる)<br>
      <br>
      &nbsp;&nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
		  &nbsp;&nbsp;&nbsp;&nbsp;struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float x;// x座標<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float y;// y座標<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float z;// z座標<br>
		  &nbsp;&nbsp;&nbsp;&nbsp;}; //[匿名共用体とは] https://zenn.dev/block/articles/beda29f11f05afc147ef<br>
		  &nbsp;&nbsp;&nbsp;&nbsp;std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
	    &nbsp;&nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ 初期化 z = 0.fでzのデフォルト値があるので2Dとしても使える<br>
      &nbsp;&nbsp;Vector3(float x = 0.f, float y = 0.f, float z = 0.f)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;xyz = { x,y,z };// たった1行で書ける<br>
      &nbsp;&nbsp;} <br>
      &nbsp;&nbsp;//仮想デストラクタ<br>
      &nbsp;&nbsp;virtual ~Vector3()<br>
      &nbsp;&nbsp;{<br>
      <br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;<em>// Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
      &nbsp;&nbsp;static const Vector3 zero;// = { 0.f,  0.f,  0.f };<br>
      &nbsp;&nbsp;static const Vector3 one; // = { 1.f,  1.f,  1.f };<br>
      &nbsp;&nbsp;static const Vector3 forward;// = { 0.f,  0.f,  1.f };<br>
      &nbsp;&nbsp;static const Vector3 back;   // = { 0.f,  0.f, -1.f };<br>
      &nbsp;&nbsp;static const Vector3 up;  // = { 0.f,  1.f,  0.f };<br>
      &nbsp;&nbsp;static const Vector3 down;// = { 0.f, -1.f,  0.f };<br>
      &nbsp;&nbsp;static const Vector3 left; // = {-1.f, 0.f,  0.f };<br>
      &nbsp;&nbsp;static const Vector3 right;// = { 1.f, 0.f,  0.f };<br>
      &nbsp;&nbsp;//[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
      &nbsp;&nbsp;static const Vector3 negativeInfinity;<br>
      &nbsp;&nbsp;//[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
      &nbsp;&nbsp;static const Vector3 positiveInfinity;<br>
<br>
<br>
      &nbsp;&nbsp;// 2つのベクトルの内積<br>
      &nbsp;&nbsp;static float dot(const Vector3& leftVec, const Vector3& rightVec)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return leftVec.x * rightVec.x + leftVec.y * rightVec.y + leftVec.z * rightVec.z; //普通にx同士,y同士,z同士掛けるだけ<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// 2つのベクトルの外積<br>
      &nbsp;&nbsp;static Vector3 cross(const Vector3& leftVec, const Vector3& rightVec)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return Vector3{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftVec.y * rightVec.z - leftVec.z * rightVec.y,  // x = 左y * 右z - 左z * 右y<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftVec.z * rightVec.x - leftVec.x * rightVec.z,  // y = 左z * 右x - 左x * 右z<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftVec.x * rightVec.y - leftVec.y * rightVec.x };// z = 左x * 右y - 左y * 右x //行列独特の特殊な掛け方<br>
      &nbsp;&nbsp;}<br>
<br>
<br>
      &nbsp;&nbsp;// ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)(スタティック版)<br>
      &nbsp;&nbsp;static float _sqrMagnitude(const Vector3& _vec)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return _vec.x * _vec.x + _vec.y * _vec.y + _vec.z * _vec.z; // x*x + y*y + z*z<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// ベクトルの長さ(0から点(x,y,z)までの距離)(スタティック版)<br>
      &nbsp;&nbsp;static float _magnitude(const Vector3& _vec)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return std::sqrt(_sqrMagnitude(_vec)); // √x*x + y*y + z*z<br>
      &nbsp;&nbsp;}<br>
<br>
<br>
      &nbsp;&nbsp;// destArrayにデータを保管しておく<br>
      &nbsp;&nbsp;Vector3& copyToArray(std::array&lt;float, 3&gt;& destArray)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;destArray = this-&gt;xyz;//配列としてコピー<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;// sourceArray配列からVector3データを生成<br>
      &nbsp;&nbsp;Vector3 fromArray(std::array&lt;float, 3&gt;& sourceArray)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return Vector3{ sourceArray[0], sourceArray[1], sourceArray[2] }; //配列から初期化 <br>
      &nbsp;&nbsp;}<br>
<br>
<br>
      &nbsp;&nbsp;// ベクトルの長さ(0から点(x,y,z)までの距離)<br>
      &nbsp;&nbsp;float magnitude()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return std::sqrt(x * x + y * y + z * z); // √(x*x + y*y + z*z)<br>
      &nbsp;&nbsp;};<br>
<br>
      &nbsp;&nbsp;// ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)<br>
      &nbsp;&nbsp;float sqrMagnitude()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return x * x + y * y + z * z; // x*x + y*y + z*z <br>
      &nbsp;&nbsp;};<br>
<br>
<br>
      &nbsp;&nbsp;// 正規化したベクトルを返す<br>
      &nbsp;&nbsp;Vector3 normalized()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float mag = magnitude();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (mag &lt; 0.00001f) // ほぼ0ベクトルか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Vector3{ x / mag, y / mag, z / mag }; // x / |x|, y / |y|, z / |z|<br>
      &nbsp;&nbsp;}<br>
<br>
<br>
<br>
      &nbsp;&nbsp;/*-----　演算子オーバーロード　-----*/<br>
<br>
      &nbsp;&nbsp;// 逆ベクトル<br>
      &nbsp;&nbsp;inline Vector3 operator - () const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this*-1;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// Vectorをそのまま足し合わせる<br>
      &nbsp;&nbsp;inline Vector3 operator + () const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// Vector同士の足し算 x,y,z個別に足し合わせる<br>
      &nbsp;&nbsp;Vector3 operator + (const Vector3 add_v3) const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Vector3 v3; //★*thisじゃダメな理由 a = vec1 + vec2のとき vec1の数値が書き変わったらあかんから<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.x = this-&gt;x + add_v3.x; //[コレはダメ] this->x = this->x + add_v3.x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.y = this-&gt;y + add_v3.y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.z = this-&gt;z + add_v3.z;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return v3;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// Vector同士の引き算 x,y,z個別に引き合わせる<br>
      &nbsp;&nbsp;Vector3 operator - (const Vector3 minus_v3) const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Vector3 v3;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.x = this-&gt;x - minus_v3.x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.y = this-&gt;y - minus_v3.y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.z = this-&gt;z - minus_v3.z;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return v3;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// Vector同士の掛け算 x,y,z個別に掛け合わせる<br>
      &nbsp;&nbsp;Vector3 operator * (float multiply_num) const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Vector3 v3;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.x = this-&gt;x * multiply_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.y = this-&gt;y * multiply_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.z = this-&gt;z * multiply_num;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return v3;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// Vector同士の割り算 x,y,z個別に割り合わせる<br>
      &nbsp;&nbsp;// 0.fでは割れないようにしてある<br>
      &nbsp;&nbsp;Vector3 operator / (float divide_num) const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (divide_num == 0.0f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Vector3 v3;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.x = this-&gt;x / divide_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.y = this-&gt;y / divide_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.z = this-&gt;z / divide_num;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return v3;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;Vector3& operator += (const Vector3 add_v3)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x += add_v3.x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y += add_v3.y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z += add_v3.z;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this; //*thisを返すことで v1 + v2 + v3見たく数珠繋ぎできる<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;Vector3& operator -= (const Vector3 minus_v3)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x -= minus_v3.x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y -= minus_v3.y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z -= minus_v3.z;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;Vector3& operator *= (float multiply_num)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x *= multiply_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y *= multiply_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z *= multiply_num;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// 0.fでは割れないようにしてある<br>
      &nbsp;&nbsp;Vector3& operator /= (float divide_num)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (divide_num == 0.0f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x /= divide_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y /= divide_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z /= divide_num;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// 代入演算子 x,y,zを全部 change_numに変える<br>
      &nbsp;&nbsp;Vector3& operator = (float change_num)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = change_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = change_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z = change_num;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// 一致演算子 x,y,zを全部一致するか 一つでも違えばfalse<br>
      &nbsp;&nbsp;bool operator == (const Vector3& v3_other)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (this-&gt;x != v3_other.x) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (this-&gt;y != v3_other.y) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (this-&gt;z != v3_other.z) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return true;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// 不一致演算子 x,y,zを全部不一致か 一つでも同じならfalse<br>
      &nbsp;&nbsp;bool operator != (const Vector3& v3_other)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (this-&gt;x == v3_other.x) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (this-&gt;y == v3_other.y) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (this-&gt;z == v3_other.z) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return true;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;/*---- 以下 DXライブラリ向けにVector3とDX版Vectorの変換方法を用意  ---------------*/<br>
<br>
// DXlibを#includeしていればDX_LIB_Hも定義済みなので下記関数も定義される VECTORの定義はDXライブラリ版のVector3<br>
#ifdef DX_LIB_H<br>
      &nbsp;&nbsp;// Vector3からDxLibのVECTORへの変換<br>
      &nbsp;&nbsp;VECTOR Vec3ToVec()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;VECTOR Result;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Result.x = this-&gt;x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Result.y = this-&gt;y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Result.z = this-&gt;z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return Result;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// 左辺値がDXのVECTOR型のときの=代入対応<br>
      &nbsp;&nbsp;inline operator VECTOR() const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;VECTOR Result;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Result.x = this-&gt;x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Result.y = this-&gt;y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Result.z = this-&gt;z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return Result;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// 右辺値がDXのVECTOR型のときの=代入対応<br>
      &nbsp;&nbsp;Vector3 operator=(const VECTOR& other)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = other.x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = other.y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z = other.z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
#endif</em><br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p><br>
<br>
	  
      <code>Vector3.cppを新規作成して</code>その内容を次のようにします：<br>
<p class="source">#include "Vector3.h"<br>
      <br>
// Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
Vector3 const Vector3::zero = Vector3(0.f,  0.f,  0.f );<br>
Vector3 const Vector3::one  = Vector3(1.f,  1.f,  1.f );<br>
Vector3 const Vector3::forward = Vector3(0.f,  0.f,  1.f );<br>
Vector3 const Vector3::back    = Vector3(0.f,  0.f, -1.f );<br>
Vector3 const Vector3::up   = Vector3(0.f,  1.f,  0.f );<br>
Vector3 const Vector3::down = Vector3(0.f, -1.f,  0.f );<br>
Vector3 const Vector3::left  = Vector3(-1.f,  0.f, 0.f );<br>
Vector3 const Vector3::right = Vector3(1.f,  0.f,  0.f );<br>
//[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
Vector3 const Vector3::negativeInfinity = Vector3(-std::numeric_limits&lt;float&gt;::infinity(), -std::numeric_limits&lt;float&gt;::infinity(), -std::numeric_limits&lt;float&gt;::infinity() );<br>
//[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
Vector3 const Vector3::positiveInfinity = Vector3(std::numeric_limits&lt;float&gt;::infinity(), std::numeric_limits&lt;float&gt;::infinity(), std::numeric_limits&lt;float&gt;::infinity() );<br>
</p>
<br>
	プレイヤや弾のクラスのx,yをVector3型に置きかえてみます<br>
	  <p><code>PlayerBullet.h</code>のx,yをVector3型におきかえます。</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      #include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <em>#include "Vector3.h"</em><br>
      <br>
      // 自機弾クラス<br>
      class PlayerBullet<br>
      {<br>
      public:<br>
	    <br>
      &nbsp;&nbsp;<em>Vector3 position; // xyz座標</em><br>
      &nbsp;&nbsp;<em>Vector3 v; // xyz方向移動速度</em><br>
	    <br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      &nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
      &nbsp;&nbsp;<br>
      <br>
      <br> 
      &nbsp;<u>float x; // x座標<br>
      &nbsp;float y; // y座標</u><br>
      <br>
      &nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
      <br>
      &nbsp;&nbsp;<u>float vx; // x方向移動速度<br>
      &nbsp;&nbsp;float vy; // y方向移動速度</u><br>
      &nbsp;&nbsp;float angle; // 移動角度<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;PlayerBullet(<em>Vector3 pos</em>, float angle)<em> : position { pos }</em><br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;</u><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angle = angle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;v = Vector3((float)std::cos(angle) * Speed,(float)std::sin(angle) * Speed, 0);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>vx = (float)std::cos(angle) * Speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy = (float)std::sin(angle) * Speed;</u><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>position += v;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>x += vx;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 画面外に出たら、死亡フラグを立てる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (<em>position.x + VisibleRadius &lt; 0 || position.x - VisibleRadius &gt; Screen::Width || <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.y + VisibleRadius &lt; 0 || position.y - VisibleRadius &gt; Screen::Height</em>)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(<em>position.x, position.y</em>, 1, angle, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      <br>
      #endif</p>
    <br>
      <code>Player.h</code>の内容を次のようにします：<br>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      <em>#include "Vector3.h"</em><br>
<br>
      #include "GameManager.h"<br>
      <br>
      class Player<br>
      {<br>
      public:<br>
      <br>
      &nbsp;&nbsp;<em>Vector3 position; // xyz座標</em><br>
      <br>
      &nbsp;const float MoveSpeed = 6; // 移動速度<br>
      <br> 
      &nbsp;<u>float x; // x座標<br>
      &nbsp;float y; // y座標</u><br>
      <br>
      &nbsp;&nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
        &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;<em>// pos : 初期位置</em><br>
      &nbsp;Player(<em>Vector3 pos</em>) <em>: position { pos }</em><br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;</u><br>
      &nbsp;&nbsp;}<br>
	    <br>
      &nbsp;&nbsp;<em>virtual ~Player() {}; // 仮想デストラクタ ※無いと【削除された関数を参照しようとしてますエラー】が出るかも</em><br>

      <br>
      &nbsp;&nbsp;// 更新処理の関数定義<br>
      &nbsp;&nbsp;void Update();<br>
      <br>
      &nbsp;&nbsp;// 描画処理の関数定義<br>
      &nbsp;&nbsp;void Draw();<br>
      <br>
      };<br>
      <br>
      #endif</p>
    <p><code>Player.cpp</code>もVector3での処理に書き換えます</p>
    <p class="source"> #include&nbsp;"Player.h"<br>
      <br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★弾を生成して【使う処理があるのでインクルード必要】<br>
      <br>
      // 更新処理【書き移す際にはPlayer::という形で::所属が必要になります】<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;<u>float vx = 0; // x方向移動速度<br>
      &nbsp;&nbsp;float vy = 0; // y方向移動速度</u><br>
      &nbsp;&nbsp;<em>Vector3 v{0,0,0}; // xyz方向移動速度</em><br>
      <br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>v.x</em> = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>v.x</em> = MoveSpeed; // 右<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>v.y</em> = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>v.y</em> = MoveSpeed; // 下<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
      &nbsp;&nbsp;if (<em>v.magnitude() > 0</em>)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>v /= MyMath::Sqrt2;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>vx /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;</u><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 実際に位置を動かす<br>
      &nbsp;&nbsp;<em>position += v;</em><br>
      &nbsp;&nbsp;<u>x += vx;<br>
      &nbsp;&nbsp;y += vy;</u><br>
      <br>
      &nbsp;&nbsp;// ボタン押下で自機弾を発射<br>
      &nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// C++ではAddがpush_backに↓ newがmake_shared↓に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(<em>position</em>, 0));//右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(<em>position</em>, -15 * MyMath::Deg2Rad));//右上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(<em>position</em>, +15 * MyMath::Deg2Rad));//右下<br>
      &nbsp;&nbsp;}
	    <br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;DrawRotaGraphF(<em>position.x, position.y</em>, 1, 0, Image::player, TRUE);<br>
      }<br>
      <br>
    </p>
	<p>次にGame.cppファイルのPlayerの生成処理をVector3に対応する形に書き換えましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のように変更します：</p>
    <p class="source">#include "Game.h"<br>
      <br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      <br>
      &nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;(<em>Vector3((float)100, (float)(Screen::Height / 2))</em>); // 自機の初期化<br>
      };<br>
      <br>
      <br>
      (中略)...<br>
      <br>
      };<br>
    </p>
	  
    <h1><a id="mozTocId0009" class="mozTocH1"></a>敵の作成【共通のGameObjectを継承する】</h1>
    <h2>Enemyクラスを作成するにあたって共通の基底(ベース)クラスとなるGameObjectを導入する</h2>
    <p>Enemyクラスを定義してそれを継承する形でZako0をつくることもできますが<br>
      その構造で作り進めると循環参照インクルードが起こってしまいがちです。<br>
      なぜなら、衝突判定で【PlayerBullet⇔Enemy⇔Playerの相互の矢印の参照ループが生まれやすくなります】<br>
      そこで共通の基底(ベース)クラスとなるGameObject、すなわち全てのものが継承する【ベースとなる継承元】を導入します。<br>
      これで矢印はGameObjectにまとまりオブジェクト同士の参照をせずに済みます。<br>
    </p>
    <p> <img src="image/include_base_gameobject.png" alt="" style="width: 702px; height: 758px;"></p>
    <h2><a id="mozTocId00091" class="mozTocH1">共通のベースとなるGameObjectを作成する</h2>
    <p><code>GameObject.h</code>を作成します(拡張も見越して3DのZ座標も導入しておきます)。</p>
    <p class="source">#ifndef GAMEOBJECT_H_<br>
      #define GAMEOBJECT_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Vector3.h"<br>
      #include &lt;string&gt; //文字タグのため<br>
      #include &lt;memory&gt; //回し読みポインタの定義のため<br>
      <br>
      // ゲーム上に表示される物体の基底クラス。<br>
      // プレイヤーや敵、アイテムなどはこのクラスを継承して作る。<br>
      class GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Vector3 position {0,0,0}; // xyz座標<br>
      &nbsp;&nbsp;Vector3 v{0,0,0}; //xyz方向の速度<br>
	    <br>
      &nbsp;&nbsp;bool isDead = false; // 死んだ（削除対象）フラグ<br>
	    <br>
      &nbsp;&nbsp;std::string tag = ""; // Zako0やBossやPlayerなど小カテゴリ<br>
      &nbsp;&nbsp;std::string typeTag = ""; // EnemyやPlayerなど大カテゴリ<br>
      &nbsp;&nbsp;std::string statusTag = ""; // 爆発状態やアイテムゲット状態など自由に使えばよい<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;GameObject(Vector3 pos) : position{ pos }<br>
      &nbsp;&nbsp;{<br>
      <br>
      &nbsp;&nbsp;} <br>
      &nbsp;&nbsp;//★仮想デストラクタ【忘れるとメモリがヤバいダメ絶対】<br>
      &nbsp;&nbsp;//【注意！】ベースの基底では必ず定義しないとstringなどが浪費され極悪なメモリ被害に発展<br>
      &nbsp;&nbsp;virtual ~GameObject()<br>
      &nbsp;&nbsp;{<br>
      <br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;//★純粋仮想関数=0は継承したZakoやPlayerなどの必須機能(継承したら絶対override必須縛り)<br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;virtual void Update() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;virtual void Draw() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      <br>
      &nbsp;&nbsp;//★virtual仮想関数は共通カスタマイズ機能(継承してもoverride必須ではないご自由にカスタマイズ)<br>
      &nbsp;&nbsp;// 衝突したときの関数(仮のvirtual関数←純粋仮想関数と違い継承してもoverride必須ではない)<br>
      &nbsp;&nbsp;virtual void OnCollision(std::shared_ptr&lt;GameObject&gt; other)<br>
      &nbsp;&nbsp;{<br>
      <br>
      &nbsp;&nbsp;}<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Enemy.h</code>を作成します。</p>
    <p class="source">#ifndef ENEMY_H_<br>
      #define ENEMY_H_<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      #include "GameManager.h"<br>
      <br>
      // 敵の基底クラス。<br>
      // 全ての敵は、このクラスを継承して作る。<br>
      // ★【勉強】abstract型はC++にない!!【純粋仮想関数】を使って作る<br>
      class Enemy : public GameObject<br>
      {<br>
      public:<br>
      <br>
      &nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Enemy(Vector3 pos) :  GameObject( pos ) // GameObjectをベースとして初期化処理を継承する<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;typeTag = "Enemy";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;virtual void Update() = 0;//virtual ～ = 0;で【純粋仮想関数に】これで【C#のabstract型に】<br>
      <br>
      &nbsp;&nbsp;// 描画処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;virtual void Draw() = 0; //virtual ～ = 0;で【純粋仮想関数に】【関数 = 0で未定義状態を表現】<br>
      <br>
      &nbsp;&nbsp;//【勉強】関数 = 0って何?と思った人は【関数もメモリ上では住所アドレスに過ぎない】ことを知ろう<br>
      &nbsp;&nbsp;// ★関数 = 0はつまり関数の住所ポインタの針が【メモリ上の何かを針で参照してない(住所不定無処理)】<br>
      &nbsp;&nbsp;// つまり【関数が未定義ってこと】＝【あいまい部分があるabstractクラスってこと】<br>
      &nbsp;&nbsp;//http://etc2myday.jugem.jp/?eid=204<br>
      &nbsp;&nbsp;//http://wisdom.sakura.ne.jp/programming/c/c54.html<br>
      &nbsp;&nbsp;//逆にいうと【関数を配列】にするっていうトリッキーなこともできる!<br>
      &nbsp;&nbsp;//http://www.ced.is.utsunomiya-u.ac.jp/lecture/2012/prog/p3/kadai3/virtualfunc2.php<br>
      <br>
      &nbsp;&nbsp;// 自機弾に当たったときの処理<br>
      &nbsp;&nbsp;virtual void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Player.h</code>も共通のベースとなるGameObjectを継承するように書き換えます。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      #include "Vector3.h"<br>
      <br>
      <em>#include&nbsp;"GameObject.h"</em><br>
      <br>
      #include&nbsp;"GameManager.h"<br>
      <br>
      class Player <em>: public GameObject</em><br>
      {<em> // 継承は↑: public ～にする。publicをつけ忘れるとGameObjectの変数がすべてprivateとして継承されちゃう</em><br>
      public:<br>
	    <br>
      &nbsp;&nbsp;<em>//【★注意！】ここに【positionの定義が残ってるとGameObjectと被る】ので<br>
        &nbsp;&nbsp;// 名前の同じ変数が2つ【パラレルワールドに存在してしまう！】<br>
        &nbsp;&nbsp;// Playerからx=13,y=5に変えたつもりでも【ベースのGameObjectはx=0,y=0のままの不思議バグで混乱！】</em><br>
      &nbsp;&nbsp;<u>Vector3 position; // xyz座標</u><br>
	          <br>
      &nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
      <br>
      <br>
      &nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;// pos : 初期位置<br>
      &nbsp;&nbsp;Player(Vector3 pos) : <em>GameObject( pos ) //【忘れると】GameObjectの初期化処理が飛ばされて大混乱！</em><br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;virtual ~Player() {}; // 仮想デストラクタ<br>
	    <br>
      &nbsp;&nbsp;// 更新処理の関数定義<br>
      &nbsp;&nbsp;void Update();<br>
      <br>
      &nbsp;&nbsp;// 描画処理の関数定義<br>
      &nbsp;&nbsp;void Draw();<br>
      <br>
      };<br>
      <br>
      #endif</p>
    <p><code>PlayerBullet.h</code>もGameObjectを継承する形に書き換えます。</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      #include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include "Vector3.h"<br>
      <br>
      <em>#include "GameObject.h"</em><br>
      <br>
      // 自機弾クラス<br>
      class PlayerBullet<em>: public GameObject</em><br>
      {<em> // 継承は↑: public ～にする。publicをつけ忘れるとGameObjectの変数がすべてprivateとして継承されちゃう</em><br>
      public:<br>
	    &nbsp;&nbsp;<em>//【★注意！GameObjectと被る変数は全部消す】</em><br>
      &nbsp;&nbsp;<u>Vector3 position; // xyz座標<br>
        &nbsp;&nbsp;Vector3 v; // xyz方向移動速度</u><br>
        <br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      &nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
      &nbsp;&nbsp;<br>
      <br>
	    &nbsp;&nbsp;<u>bool isDead = false; // 死亡フラグ</u><br>
      <br>
      &nbsp;&nbsp;float angle; // 移動角度<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;PlayerBullet(Vector3 pos, float angle) <em>: GameObject( pos )</em><br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;tag = "PlayerBullet";</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angle = angle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;v = Vector3((float)std::cos(angle) * Speed, (float)std::sin(angle) * Speed, 0);<br>
      &nbsp;&nbsp;}<br>
      <br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;(中略)....................<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, angle, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      <br>
      #endif</p>
    <h2><a id="mozTocId00092" class="mozTocH1"></a>Zako0クラスの作成</h2>
    <p><code>Zako0.h</code>を作成します。</p>
    <p class="source">#ifndef ZAKO_0_H_<br>
      #define ZAKO_0_H_<br>
      <br>
      #include "Enemy.h"<br>
      #include "Image.h"<br>
      <br>
      // ザコ0クラス<br>
      class Zako0 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Zako0(Vector3 pos)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;: Enemy( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako0";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;position.x -= 1; // とりあえず左へ移動<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako0, TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Image.h</code>にザコ0,1,2,3と敵弾の画像定義を追加します：</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;static void Load();<br>
      <br>
      &nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int player; //プレイヤ画像のハンドラ<br>
      &nbsp;&nbsp;static int playerBullet; //プレイヤの弾画像のハンドラ<br>
      &nbsp;&nbsp;<em>static int enemyBullet16; //敵弾 画像のハンドラ(読込画像番号)</em><br>
      &nbsp;&nbsp;<em>static int zako0; //ザコ0 画像のハンドラ(読込画像番号)</em><br>
      &nbsp;&nbsp;<em>static int zako1; //ザコ1 画像のハンドラ(読込画像番号)</em><br>
      &nbsp;&nbsp;<em>static int zako2; //ザコ2 画像のハンドラ(読込画像番号)</em><br>
      &nbsp;&nbsp;<em>static int zako3; //ザコ3 画像のハンドラ(読込画像番号)</em><br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
      <br>
      int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      int Image::player{-1};<br>
      int Image::playerBullet{-1};<br>
      <em>int Image::enemyBullet16{-1};</em><br>
      <em>int Image::zako0{-1};</em><br>
      <em>int Image::zako1{-1};</em><br>
      <em>int Image::zako2{-1};</em><br>
      <em>int Image::zako3{-1};</em><br>
      <br>
      void Image::Load()<br>
      {<br>
      &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;player= LoadGraph("Image/player.png");<br>
      &nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;playerBullet = LoadGraph("Image/player_bullet.png");<br>
      &nbsp;&nbsp;assert(playerBullet!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;<em>enemyBullet16 = LoadGraph("Image/enemy_bullet_16.png");<br>
        &nbsp;&nbsp;assert(enemyBullet16!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      &nbsp;&nbsp;<em>zako0 = LoadGraph("Image/zako0.png");<br>
        &nbsp;&nbsp;assert(zako0!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      &nbsp;&nbsp;<em>zako1 = LoadGraph("Image/zako1.png");<br>
        &nbsp;&nbsp;assert(zako1!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      &nbsp;&nbsp;<em>zako2 = LoadGraph("Image/zako2.png");<br>
        &nbsp;&nbsp;assert(zako2!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      &nbsp;&nbsp;<em>zako3 = LoadGraph("Image/zako3.png");<br>
        &nbsp;&nbsp;assert(zako3!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      }<br>
    </p>
    <h2>敵を管理する仕組みの作成</h2>
    <p><code>GameManager.h</code>に敵のリストを追加しましょう。</p>
    <p class="source"> #ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      <br>
      #include&nbsp;"Singleton.h"<br>
      <br>
      class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      class&nbsp;PlayerBullet;<br>
      <em>class&nbsp;Enemy;</em><br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機のポインタ<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;<em>std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト</em><br>
      &nbsp;&nbsp;// 複数リスト↑list ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      <br>
      (中略).............. <br>
      protected:<br>
      &nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Game.cpp</code>に敵の生成と更新と描画処理を追加しましょう。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <em>#include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      <br>
      &nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)Screen::Height / 2)); // 自機の初期化<br>
      &nbsp;&nbsp;<em>// とりあえず適当に敵を生成</em><br>
      &nbsp;&nbsp;<em>gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)600, (float)100)));</em><br>
      &nbsp;&nbsp;<em>gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)1000, (float)500)));</em><br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 敵の更新処理<br>
        &nbsp;&nbsp;for (const auto&amp; b : gm.enemies)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
        &nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;<em>// 敵の描画処理<br>
        &nbsp;&nbsp;for (const auto&amp; b : gm.enemies)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
        &nbsp;&nbsp;}</em><br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      };<br>
    </p>
    <br>
    <br>
    <br>
    <a id="mozTocId2000" class="mozTocH1"></a>
    <p class="title">[C++]シューティングゲーム 2</p>
    <br>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId2001">敵と自機弾の当たり判定の作成</a></li>
      <li><a href="#mozTocId2002">敵に耐久力を持たせる(おまけでSinの波運動のコード例も)</a></li>
      <li><a href="#mozTocId2003">自機と敵の当たり判定</a></li>
      <li><a href="#mozTocId2004">自機のライフの作成</a></li>
      <li><a href="#mozTocId2005">敵弾の作成</a><br>
        <a href="#mozTocId20052">- 練習問題(MyRandomで±15度に散乱弾を撃つ敵キャラ)</a><br>
        <a href="#mozTocId20053">- 練習問題(やられると点滅後自爆する敵キャラ)</a> </li>
      <br>
      <p>次のテキスト3はこちら。</p>
      <br>
      <a href="#mozTocId3000">[C++]シューティングゲーム 3</a><br>
    </ol>
    <h1><a id="mozTocId2001" class="mozTocH1"></a>敵と自機弾の当たり判定の作成</h1>
    <p>当たり判定の式をMyMathクラスに定義します。</p>
    <img src="image/circle_circle_intersection.png">
    <p><code>MyMath.h</code>を編集します：</p>
    <p class="source">#ifndef _MYMATH_H<br>
      #define _MYMATH_H<br>
	    <br>
<em>#include "Vector3.h"</em><br>
	    <br>
      // 数学関連クラス<br>
      class MyMath<br>
      {<br>
      public: <br>
      &nbsp;&nbsp;static const float Sqrt2;&nbsp;&nbsp;// = 1.41421356237f;(.hではfloat小数型の初期化はできない int型はできるのに)<br>
      &nbsp;&nbsp;static const float PI; // 円周率 3.14159265359f;<br>
      &nbsp;&nbsp;static const float Deg2Rad; // 度からラジアンに変換する定数 PI / 180f;<br>
      <br>
      &nbsp;&nbsp;<em>/// &lt;summary&gt;<br>
        &nbsp;&nbsp;/// 円と円が重なっているかを調べる<br>
        &nbsp;&nbsp;/// &lt;/summary&gt;<br>
        &nbsp;&nbsp;/// &lt;param name="pos1"&gt;円1の中心&lt;/param&gt;<br>
        &nbsp;&nbsp;/// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;/// &lt;param name="pos2"&gt;円2の中心&lt;/param&gt;<br>
        &nbsp;&nbsp;/// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;/// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;static bool CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Vector3 pos1, float radius1,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Vector3 pos2, float radius2)<br>
        &nbsp;&nbsp;{ //[2乗のまま &lt; 比較すると高速] https://www.stmn.tech/entry/2016/06/15/033835<br>
        &nbsp;&nbsp;&nbsp;&nbsp;return ((pos1 - pos2).sqrMagnitude()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt; (radius1 + radius2) * (radius1 + radius2));<br>
        &nbsp;&nbsp;}</em><br>
      }; // 【注意】セミコロン抜けで【宣言が必要ですエラー】<br>
      <br>
      #endif //【宣言が必要ですエラーは上のセミコロン抜け】</p>
    <br>
    <p><code>Enemy.h</code>を改修します。当たり判定の半径を表す変数と、死亡フラグ、被弾時の処理を追加します。</p>
    <p class="source">#ifndef ENEMY_H_<br>
      #define ENEMY_H_<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      #include "GameManager.h"<br>
      <br>
      // 敵の基底クラス。<br>
      // 全ての敵は、このクラスを継承して作る。<br>
      // ★【勉強】abstract型はC++にない!!【純粋仮想関数】を使って作る<br>
      class Enemy : public GameObject<br>
      {<br>
      public:<br>
      <br>
      &nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;<em>float collisionRadius = 32; // 当たり判定の半径</em><br>
      &nbsp;&nbsp;<em>float life = 1; // 耐久力</em><br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Enemy(Vector3 pos) : GameObject( pos ) // GameObjectをベースとして初期化処理を継承する<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;typeTag = "Enemy";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;virtual void Update() = 0;//virtual ～ = 0;で【純粋仮想関数に】これで【C#のabstract型に】<br>
      <br>
      &nbsp;&nbsp;// 描画処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;virtual void Draw() = 0; //virtual ～ = 0;で【純粋仮想関数に】【関数 = 0で未定義状態を表現】<br>
      <br>
      &nbsp;&nbsp;//【勉強】関数 = 0って何?と思った人は【関数もメモリ上では住所アドレスに過ぎない】ことを知ろう<br>
      &nbsp;&nbsp;// ★関数 = 0はつまり関数の住所ポインタの針が【メモリ上の何かを針で参照してない(住所不定無処理)】<br>
      &nbsp;&nbsp;// つまり【関数が未定義ってこと】＝【あいまい部分があるabstractクラスってこと】<br>
      &nbsp;&nbsp;//http://etc2myday.jugem.jp/?eid=204<br>
      &nbsp;&nbsp;//http://wisdom.sakura.ne.jp/programming/c/c54.html<br>
      &nbsp;&nbsp;//逆にいうと【関数を配列】にするっていうトリッキーなこともできる!<br>
      &nbsp;&nbsp;//http://www.ced.is.utsunomiya-u.ac.jp/lecture/2012/prog/p3/kadai3/virtualfunc2.php<br>
      <br>
      &nbsp;&nbsp;// 自機弾に当たったときの処理 関数の【★引数をGameObject型↓にすることで循環インクルード抑止】<br>
        &nbsp;&nbsp;virtual void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<em>life -= 1; // ライフを減らす<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;// ライフが無くなったら、死亡<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (life &lt;= 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
        &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>PlayerBullet.h</code>を改修します。当たり判定を表す変数を追加します。</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      #include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      // 自機弾クラス<br>
      class PlayerBullet: public GameObject<br>
      { // 継承は↑: public ～にする。publicをつけ忘れるとGameObjectの変数がすべてprivateとして継承されちゃう<br>
      public:<br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      &nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
      &nbsp;&nbsp;<br>
      <br>
      &nbsp;&nbsp;<em>float collisionRadius = 16; // 当たり判定の半径</em><br>
      &nbsp;&nbsp;float angle; // 移動角度<br>
      <br>
      <br>
      &nbsp;&nbsp;(中略)....................<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;(中略)....................<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, angle, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;<em>// 敵にぶつかった時の処理<br>
        &nbsp;&nbsp;void OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
        &nbsp;&nbsp;}</em><br>
      };<br>
      <br>
      #endif</p>
    <p><code>Game.cpp</code>を改修します。自機弾と敵が当たっているか調べる処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 敵の更新処理<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 自機弾と敵の衝突判定<br>
        &nbsp;&nbsp;for(const auto&amp; playerBullet : gm.playerBullets)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 自機弾が死んでたらスキップする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾と敵が重なっているか？<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;position, playerBullet-&gt;collisionRadius,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;OnCollisionEnemy(enemy);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      <br>
      &nbsp;&nbsp;<em>// 敵のリストから死んでるものを除去する<br>
        &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      (以下略)............<br>
    </p>
    <h1><a id="mozTocId2002" class="mozTocH1"></a>敵に耐久力を持たせる(おまけでSinの波運動のコード例も)</h1>
    <p><code>Zako1.h</code>のlifeを5にすることでZako1を硬くしてみましょう。<br>
      ついでにsinの波運動も試してみましょう。</p>
<p><code>Zako1.hを新規作成</code>します。黄色の部分がZako0との違いです。</p>
    <p class="source">#ifndef ZAKO_1_H_<br>
      #define ZAKO_1_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      <em>#include &lt;cmath&gt; // Sinの計算に使う<br>
        #include "MyMath.h"</em><br>
      #include "Image.h"<br>
      <br>
      // ザコ1クラス<br>
      class Zako1 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;<em>float sinMove = 0; // Sinの動きをする際の0～360度</em><br>
      &nbsp;&nbsp;<em>float sinRadius = 70; // Sinの動きをするときの半径</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Zako1(Vector3 pos) : Enemy ( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako1";//オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>life = 5;</em><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;position.x -= 1; // 左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>float prevSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>sinMove += 2.5f; // Sinの波運動の角度を進める</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>float currentSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// (前の角度でのY) - (今の角度でのY)の差を足すことで【ベースのyの位置 ± sinの動き】になる</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>position.y += currentSinY - prevSinY; // 上下方向のSinの波運動</em><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako1, TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Game.cpp</code>にZako1の生成処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <em>#include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;// とりあえず適当に敵を生成<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)600, (float)100)));<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)1000, (float)500)));<br>
      &nbsp;&nbsp;<em>gm.enemies.emplace_back(std::make_shared&lt;Zako1&gt;(Vector3((float)1000, (float)150)));</em><br>
      };<br>
      <br>
    </p>
    <h1><a id="mozTocId2003" class="mozTocH1"></a>自機と敵の当たり判定</h1>
    <p><code>Player.h</code>に当たり判定半径を定義します。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      #include "Vector3.h"<br>
      <br>
      #include&nbsp;"GameObject.h"<br>
      <br>
      #include&nbsp;"GameManager.h"<br>
      <br>
      class Player : public GameObject<br>
      { // 継承は↑: public ～にする。publicをつけ忘れるとGameObjectの変数がすべてprivateとして継承されちゃう<br>
      public:<br>
      &nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
      <br>
      &nbsp;&nbsp;<em>float collisionRadius = 32; // 当たり判定半径</em><br>
      <br>
      &nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;// pos : 初期位置<br>
      &nbsp;&nbsp;Player(Vector3 pos) : GameObject( pos ) //【忘れると】GameObjectの初期化処理が飛ばされて大混乱！<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;}<br>
	    <br>
      &nbsp;&nbsp;virtual ~Player() {}; // 仮想デストラクタ ※無いと【削除された関数を参照しようとしてますエラー】が出るかも
      <br>
      &nbsp;&nbsp;// 更新処理の関数定義<br>
      &nbsp;&nbsp;void Update();<br>
      <br>
      &nbsp;&nbsp;// 描画処理の関数定義<br>
      &nbsp;&nbsp;void Draw();<br>
      <br>
      &nbsp;&nbsp;<em>// 敵にぶつかった時の処理<br>
        &nbsp;&nbsp;void OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other);</em><br>
      };<br>
      <br>
      #endif</p>
    <p><code>Player.cpp</code>に敵との当たり判定処理を追加します。</p>
    <p class="source"> #include&nbsp;"Player.h"<br>
      <br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;弾を生成して【使う処理があるのでインクルード必要】<br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;// 継承したGameObjectにvがあるのでvをfloatで定義し直さないように注意<br>
      &nbsp;&nbsp;v = Vector3(0,0,0); // xyz方向移動速度<br>
      <br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.x = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.x = MoveSpeed; // 右<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.y = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.y = MoveSpeed; // 下<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
      &nbsp;&nbsp;if (v.magnitude() > 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 実際に位置を動かす<br>
      &nbsp;&nbsp;position += v;<br>
      <br>
      &nbsp;&nbsp;// ボタン押下で自機弾を発射<br>
      &nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// C++ではAddがpush_backに↓ newがmake_shared↓に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(position, 0));//右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(position, -15 * MyMath::Deg2Rad));//右上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(position, +15 * MyMath::Deg2Rad));//右下<br>
      &nbsp;&nbsp;}
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::player, TRUE);<br>
      }<br>
      <br>
      <em>// 敵にぶつかった時の処理<br>
        void Player::OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other)<br>
        {<br>
        &nbsp;&nbsp;isDead = true;<br>
        }</em><br>
    </p>
    <p><code>Game.cpp</code>を改修します。自機が死んだとき消す処理と自機と敵の衝突判定を追加します。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;<em>if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;</em>gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 敵の更新処理<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾と敵の衝突判定<br>
      &nbsp;&nbsp;for(const auto&amp; playerBullet : gm.playerBullets)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 自機弾が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾と敵が重なっているか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;position, playerBullet-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;OnCollisionEnemy(enemy);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 自機と敵の衝突判定<br>
        &nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gtposition, gm.player-&gt;collisionRadius,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;OnCollisionEnemy(enemy);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      <br>
      &nbsp;&nbsp;// 敵のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;// 敵の描画処理<br>
      &nbsp;&nbsp;for (const auto&amp; e : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;<em>if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;</em>gm.player-&gt;Draw(); // プレイヤの描画【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      };<br>
    </p>
    <h1><a id="mozTocId2004" class="mozTocH1"></a>自機のライフの作成</h1>
    <p><code>Player.h</code>にライフと無敵時間を定義します。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      <br>
      #include&nbsp;"GameObject.h"<br>
      <br>
      #include&nbsp;"GameManager.h"<br>
      <br>
      class Player : public GameObject<br>
      { // 継承は↑: public ～にする。publicをつけ忘れるとGameObjectの変数がすべてprivateとして継承されちゃう<br>
      public:<br>
      &nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
      &nbsp;&nbsp;<em>int MutekiJikan = 120; // 無敵時間</em><br>
      <br>
      &nbsp;&nbsp;float collisionRadius = 32; // 当たり判定半径<br>
      <br>
      &nbsp;&nbsp;<em>int life = 3; // ライフ</em><br>
      &nbsp;&nbsp;<em>int mutekiTimer = 0; // 残り無敵時間。0以下なら無敵じゃないってこと</em><br>
      <br>
      &nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;// pos : 初期位置<br>
      &nbsp;&nbsp;Player(Vector3 pos) : GameObject( pos ) //【忘れると】GameObjectの初期化処理が飛ばされて大混乱！<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;virtual ~Player() {}; // 仮想デストラクタ ※無いと【削除された関数を参照しようとしてますエラー】が出るかも
	    <br>
      &nbsp;&nbsp;// 更新処理の関数定義<br>
      &nbsp;&nbsp;void Update();<br>
      <br>
      &nbsp;&nbsp;// 描画処理の関数定義<br>
      &nbsp;&nbsp;void Draw();<br>
      <br>
      &nbsp;&nbsp;// 敵にぶつかった時の処理<br>
      &nbsp;&nbsp;void OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other);<br>
      <br>
      &nbsp;&nbsp;<em>// ダメージを受ける処理<br>
        &nbsp;&nbsp;void TakeDamage();</em><br>
      };<br>
      <br>
      #endif</p>
    <p><code>Player.cpp</code>に敵との当たり判定処理を追加します。</p>
    <p class="source"> #include&nbsp;"Player.h"<br>
      <br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;弾を生成して【使う処理があるのでインクルード必要】<br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;// 継承したGameObjectにvがあるのでvをfloatで定義し直さないように修正<br>
      &nbsp;&nbsp;v = Vector3(0,0,0); // xyz方向移動速度<br>
      <br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.x = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.x = MoveSpeed; // 右<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.y = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.y = MoveSpeed; // 下<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
      &nbsp;&nbsp;if (v.magnitude() > 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 実際に位置を動かす<br>
      &nbsp;&nbsp;position += v;<br>
      <br>
      &nbsp;&nbsp;// ボタン押下で自機弾を発射<br>
      &nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// C++ではAddがpush_backに↓ newがmake_shared↓に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(position, 0));//右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(position, -15 * MyMath::Deg2Rad));//右上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(position, +15 * MyMath::Deg2Rad));//右下<br>
      &nbsp;&nbsp;}
      <br>
      &nbsp;&nbsp;<em>mutekiTimer--; // 無敵タイマーは無条件で毎フレームカウントダウン</em><br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;<em>// 無敵ではない場合は描画<br>
        &nbsp;&nbsp;// 無敵中は2フレームに1回描画（点滅）<br>
        &nbsp;&nbsp;if (mutekiTimer &lt;= 0 || mutekiTimer % 2 == 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;</em>DrawRotaGraphF(position.x, position.y, 1, 0, Image::player, TRUE);<br>
      }<br>
      <br>
      // 敵にぶつかった時の処理<br>
      void Player::OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other)<br>
      {<br>
      &nbsp;&nbsp;<em>// 無敵じゃなければダメージを受ける<br>
        &nbsp;&nbsp;if (mutekiTimer &lt;= 0)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;TakeDamage();<br>
        &nbsp;&nbsp;}</em><br>
      }<br>
      <br>
      <em>// ダメージを受ける処理<br>
        void Player::TakeDamage()<br>
        {<br>
        &nbsp;&nbsp;life -= 1; // ライフ減少<br>
        <br>
        &nbsp;&nbsp;if (life &lt;= 0)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// ライフが無くなったら死亡<br>
        &nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;else<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 無敵時間発動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;mutekiTimer = MutekiJikan;<br>
        &nbsp;&nbsp;}<br>
        }</em><br>
    </p>
    <h1><a id="mozTocId2005" class="mozTocH1"></a>敵弾の作成</h1>
    <h2><a id="mozTocId20051" class="mozTocH1"></a>敵弾の作成(発射間隔を空けて撃つ方法を学ぶ)</h2>
    <p><code>EnemyBullet.h</code>を新規作成します。</p>
    <p class="source">#ifndef ENEMYBULLET_H_<br>
      #define ENEMYBULLET_H_<br>
      <br>
      #include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include "Vector3.h"<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      // 敵弾クラス<br>
      class EnemyBullet: public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const int VisibleRadius = 8; // 見た目の半径<br>
      &nbsp;&nbsp;<br>
      <br>
      &nbsp;&nbsp;float angle; // 移動角度(垂直Vertical)<br>
      &nbsp;&nbsp;float angleH=0; // 移動角度(水平Horizontal)<br>
      <br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;EnemyBullet(Vector3 pos, float angle, float speed) : GameObject( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angle = angle;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 角度からx方向の移動速度を算出<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.x = (float)std::cos(angle) * speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 角度からy方向の移動速度を算出<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.y = (float)std::sin(angle) * speed;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;EnemyBullet(Vector3 pos, float angleV, float angleH, float speed) : GameObject( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angle = angleV;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angleH = angleH;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [3Dの角度は水平・垂直に分割]https://teratail.com/questions/126004<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float cosAngleV = (float)std::cos(angle);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 角度からx方向の移動速度を算出<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.x = cosAngleV * (float)std::sin(angleH) * speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 角度からy方向の移動速度を算出<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.y = (float)std::sin(angle) * speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 角度からz方向の移動速度を算出<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.z = cosAngleV * (float)std::cos(angleH) * speed;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度の分だけ移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;position += v;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 画面外に出たら死亡フラグを立てる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (position.y + VisibleRadius &lt; 0 || position.y - VisibleRadius &gt; Screen::Height ||<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.x + VisibleRadius &lt; 0 || position.x - VisibleRadius &gt; Screen::Width)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, angle, Image::enemyBullet16,TRUE);<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// プレイヤにぶつかった時の処理<br>
      &nbsp;&nbsp;virtual void OnCollisionPlayer(std::shared_ptr&lt;GameObject&gt; other)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <p><code>GameManager.h</code>にEnemyBulletを管理するリストの定義を追加します。</p>
    <p class="source"> #ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      <br>
      #include&nbsp;"Singleton.h"<br>
      <br>
      class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      class&nbsp;PlayerBullet;<br>
      class&nbsp;Enemy;<br>
      <em>class&nbsp;EnemyBullet;</em><br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機のポインタ<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
      &nbsp;&nbsp;<em>std::list&lt;std::shared_ptr&lt;EnemyBullet&gt;&gt; enemyBullets; // 敵弾のリスト</em><br>
      &nbsp;&nbsp;// 複数リスト↑list ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      <br>
      (中略).............. <br>
      protected:<br>
      &nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Game.cpp</code>にEnemyBulletの更新Updateと削除Remove、描画Drawの処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <em>#include&nbsp;"EnemyBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      #include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;<em>// 敵弾の更新処理<br>
        &nbsp;&nbsp;for (const auto&amp; b : gm.enemyBullets)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
        &nbsp;&nbsp;}</em><br>
      <br>
      &nbsp;&nbsp;// 敵の更新処理<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾と敵の衝突判定<br>
      &nbsp;&nbsp;for(const auto&amp; playerBullet : gm.playerBullets)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 自機弾が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾と敵が重なっているか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;position, playerBullet-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;OnCollisionEnemy(enemy);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機と敵の衝突判定<br>
      &nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;OnCollisionEnemy(enemy);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;// 敵のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;<em>// 敵弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemyBullets,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;EnemyBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;// 敵の描画処理<br>
      &nbsp;&nbsp;for (const auto&amp; e : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;Draw(); // プレイヤの描画【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;<em>// 敵弾の描画処理<br>
        &nbsp;&nbsp;for (const auto&amp; b : gm.enemyBullets)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
        &nbsp;&nbsp;}</em><br>
      };<br>
    </p>
    <p><code>Zako0.h</code>に弾を発射間隔を開けながら撃たせます。</p>
    <p class="source">#ifndef ZAKO_0_H_<br>
      #define ZAKO_0_H_<br>
      <br>
      #include "Enemy.h"<br>
      #include "Image.h"<br>
      <em>#include "MyMath.h"</em><br>
      <em>#include&nbsp;"EnemyBullet.h"&nbsp;// make_sharedなど【実際の弾を撃ち生成処理を行うのでインクルード必要】</em><br>
      <br>
      // ザコ0クラス<br>
      class Zako0 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;<em>int counter = 0;</em><br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Zako0(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako0";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;position.x -= 1; // とりあえず左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>counter++;</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (counter % 10 == 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, 180 * MyMath::Deg2Rad, 8));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako0, TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Zako0.h</code>の弾の発射間隔を開ける方法は別のやり方もあります。</p>
    <p class="source">#ifndef ZAKO_0_H_<br>
      #define ZAKO_0_H_<br>
      <br>
      #include "Enemy.h"<br>
      #include "Image.h"<br>
      <em>#include "MyMath.h"</em><br>
      <em>#include&nbsp;"EnemyBullet.h"&nbsp;// make_sharedなど【実際の弾を撃ち生成処理を行うのでインクルード必要】</em><br>
      <br>
      // ザコ0クラス<br>
      class Zako0 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;<em>int coolTime = 0; // クールタイム（冷却時間。0になるまで次の弾が撃てない）</em><br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Zako0(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako0";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;position.x -= 1; // とりあえず左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>coolTime--;</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (coolTime &lt;= 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, 180 * MyMath::Deg2Rad, 8));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coolTime += 10;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako0, TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <h2><a id="mozTocId20052" class="mozTocH1"></a>練習問題(色んな弾の撃ち方を試す)</h2>
    <p>弾の発射角度の方向を180度 + (-15度～+15度)にすることで散乱弾を実現します。</p>
    <p>まず、乱数生成に必要な乱数クラス<code>MyRandom.h</code>を作成します。</p>
    <p class="source">#ifndef MYRANDOM_H_<br>
      #define MYRANDOM_H_<br>
      <br>
      #include &lt;random&gt;<br>
      <br>
      class MyRandom<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;// ゲーム中で唯一のインスタンス<br>
      &nbsp;&nbsp;static std::random_device rnd;// 非決定的な乱数生成器<br>
      &nbsp;&nbsp;static std::mt19937 random; // メルセンヌ・ツイスタの32ビット版<br>
      <br>
      &nbsp;&nbsp;// 初期化（シード指定無し）<br>
      &nbsp;&nbsp;static void Init()<br>
      &nbsp;&nbsp;{ // https://cpprefjp.github.io/reference/random/random_device.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;random.seed(rnd()); // 乱数をシードにすることで毎回ランダムにする<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 初期化（シードを指定）<br>
      &nbsp;&nbsp;static void Init(int seed)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;random.seed(seed);<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 指定した範囲の整数の乱数を取得する<br>
      &nbsp;&nbsp;static int Range(int min, int max)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::uniform_int_distribution&lt;&gt; randRange(min, max); // [min, max] 範囲の一様乱数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return randRange(random);<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 指定した範囲の小数の乱数を取得する<br>
      &nbsp;&nbsp;static float Range(float min, float max)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::uniform_real_distribution&lt;&gt; randRange(min, max); // [min&lt;= x &lt;=max] 範囲の一様乱数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return (float)randRange(random);<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 指定した確率（％）でtrueになる<br>
      &nbsp;&nbsp;static bool Percent(float probability)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return Range(0.0f, 1.0f) * 100 &lt;= probability;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 指定した範囲で乱数を返却する。<br>
      &nbsp;&nbsp;// 例えば1.5fを指定すると、-1.5～+1.5の範囲の値を返却する。<br>
      &nbsp;&nbsp;static float PlusMinus(float value)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return Range(-value, value);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <p>staticなクラスなので<code>MyRandom.cpp</code>を作成して変数をcppで定義初期化します。</p>
    <p class="source">#include "MyRandom.h"<br>
      <br>
      std::random_device MyRandom::rnd;// 非決定的な乱数生成器<br>
      std::mt19937 MyRandom::random; // メルセンヌ・ツイスタの32ビット版 https://qiita.com/angel_p_57/items/971d0208186f81d5d044<br>
    </p>
    <p><code>Zako2.h</code>を作成して弾の発射方向を-15度～+15度までランダムに散らすようにしてみます。</p>
    <p class="source">#ifndef ZAKO_2_H_<br>
      #define ZAKO_2_H_<br>
      <br>
      #include "Enemy.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include &lt;cmath&gt; // Sin Cosの計算に使う<br>
      #include "MyMath.h"<br>
      #include "MyRandom.h"<em></em><br>
      #include&nbsp;"EnemyBullet.h"&nbsp;// make_sharedなど【実際の弾を撃ち生成処理を行うのでインクルード必要】<br>
      <br>
      // ザコ2クラス<br>
      class Zako2 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;int coolTime = 0; // クールタイム（冷却時間。0になるまで次の弾が撃てない）<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Zako2(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako2";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(position.x &gt; Screen::Width - 200)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ // スクリーンの端から200の位置で止まる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.x -= 1; // とりあえず左へ移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;coolTime--;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (coolTime &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float bulletAngle = MyRandom::Range(-15.0f,15.0f); // ±15度の乱数の角度を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, (180 + bulletAngle) * MyMath::Deg2Rad, 8));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coolTime += 10;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako2, TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Game.cpp</code>にMyRandom乱数とザコ2の初期化を追加します。</p>
    <p class="source">#include "Game.h"<br>
      <em>#include&nbsp;"MyRandom.h"&nbsp;</em><br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"EnemyBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <em>#include&nbsp;"Zako2.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;<em>MyRandom::Init(); // 乱数シードの初期化</em><br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;// とりあえず適当に敵を生成<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)600, (float)100)));<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)1000, (float)500)));<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako1&gt;(Vector3((float)1000, (float)150)));<br>
      &nbsp;&nbsp;<em>gm.enemies.emplace_back(std::make_shared&lt;Zako2&gt;(Vector3((float)1200, (float)250)));</em><br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
    </p>
    <br>
    <p>どうでしょうか(-15度～+15度)の散乱弾を撃つ敵キャラを作れましたか？</p>
    <p>まずはザコ2を試してみましょう。うまくいったら次のザコ3を試してみましょう。</p>
    <p> <img src="image/gif01.gif" alt=""></p>
    <br>
    <p><a id="mozTocId20053" class="mozTocH1"></a>こんどは<code>Zako3.h</code>を作成して10ダメージ受けると点滅状態(5秒=5×60=300フレーム)になり、isDeadと同時に弾を全方向に0度～360度に散らすようにしてみます。</p>
    <p>勉強になるテクニックとして【共通処理の上書きオーバーライド】や【点滅処理の条件式】や【ド・モルガンの定理】を使っているので上級者も1度は試してみましょう。</p>
    <p class="source">#ifndef ZAKO_3_H_<br>
      #define ZAKO_3_H_<br>
      <br>
      #include "Enemy.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include &lt;cmath&gt; // Sin Cosの計算に使う<br>
      #include "MyMath.h"<br>
      #include "Vector3.h"<br>
      #include "MyRandom.h"<em></em><br>
      #include&nbsp;"EnemyBullet.h"&nbsp;// make_sharedなど【実際の弾を撃ち生成処理を行うのでインクルード必要】<br>
      <br>
      // ザコ3クラス(自爆型機雷タイプの敵キャラ)<br>
      class Zako3 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;int bombCounter = -1; // やられたときのisDeadまでのカウントダウン<br>
      &nbsp;&nbsp;int BombTime = 300; // 爆発までのカウント時間<br>
      &nbsp;&nbsp;int life = 10; // 敵ライフ<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Zako3(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako3";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(position.x &gt; Screen::Width - 350)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ // スクリーンの端から350の位置で止まる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.x -= 1; // とりあえず左へ移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ // スクリーン端から350の位置で自爆モードに入る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;life = 0; // 画面中央付近で勝手にlife=0で自爆モードに入る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;bombCounter--; // 爆発カウンタは常にカウントダウン(-1から始まるときは0を通過しないので爆発しない)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(life &lt;= 0 &amp;&amp; bombCounter &lt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bombCounter = BombTime; // 爆発モードに入る(bombCounterがプラス値になり0になると爆発)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (bombCounter == 0) // 初期状態は-1からカウントダウン-1,-2,-3..するからここには入らずに済む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i=0; i &lt; 360; i = i+10) //【勉強】for文は1ずつプラスじゃなくてもよい<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, (180 + i) * MyMath::Deg2Rad, 6));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // 爆発カウンタ==0で初めてisDead状態に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 【勉強】共通処理を上書きオーバーライドで上塗りして共通処理を無効化・乗っ取るテクニック<br>
      &nbsp;&nbsp;// 自機弾との衝突処理を★【上書きオーバーライド】して死亡フラグが立たないように<br>
      &nbsp;&nbsp;virtual void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet) override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;life -= 1; // ライフを減らす<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 死亡フラグはこのザコ3だけ特別に衝突ではONにしない<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;//【ド・モルガンの定理を学ぼう】||と&amp;&amp;の逆の関係性の法則<br>
      &nbsp;&nbsp;&nbsp;&nbsp;//【勉強】条件【または||】は条件【かつ&amp;&amp;】の(life &lt;= 0 &amp;&amp; bombCounter &gt; 0)のちょうど逆条件！<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(life &gt; 0 || bombCounter &lt;= 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp; || (bombCounter % 8 &lt; 4) ) //[点滅]パラパラ8枚の周期で余り4以下の時だけ描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako3, TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Game.cpp</code>にザコ3の生成処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"EnemyBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako2.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <em>#include&nbsp;"Zako3.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;// とりあえず適当に敵を生成<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)600, (float)100)));<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)1000, (float)500)));<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako1&gt;(Vector3((float)1000, (float)150)));<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako2&gt;(Vector3((float)1200, (float)250)));<br>
      &nbsp;&nbsp;<em>gm.enemies.emplace_back(std::make_shared&lt;Zako3&gt;(Vector3((float)1300, (float)400)));</em><br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
    </p>
    <br>
    <p>どうでしょうか爆弾っぽい自爆タイプの敵キャラが作れましたか？</p>
    <p> <img src="image/zako3_selfbomb.gif" alt=""></p>
    <br>
    <a id="mozTocId3000" class="mozTocH1"></a>
    <p class="title">[C++]シューティングゲーム 3</p>
    <br>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId3001">自機と敵弾の当たり判定</a></li>
      <li><a href="#mozTocId3002">爆発エフェクトの作成(分割画像DivImage型の定義)</a><br>
        <a href="#mozTocId30022">爆発クラスの作成</a><br>
        <a href="#mozTocId30023">管理する仕組みの作成</a><br>
        <a href="#mozTocId30024">爆発を出す処理(Enemyで敵の共通の爆発を生成)</a><br>
      </li>
      <li><a href="#mozTocId3003">ボスの作成</a></li>
      <li><a href="#mozTocId3004">【練習問題】ボスの状態ごとの行動パターンのプログラミング</a></li>
      <li><a href="#mozTocId3005">プレイヤのライフをバーで表示させる</a></li>
      <li><a href="#mozTocId3006">アイテムクラスとザコからのドロップ処理の作成</a></li>
      <li><a href="#mozTocId3007">Item0を画面のはしっこで光らせてバウンドさせる処理の作成</a></li>
      <li><a href="#mozTocId3008">Item1クラスでボスへクリティカルヒットしたらバリアーとなる星のアイテムをドロップする処理の作成</a></li>
      <br>
      <p>次のテキスト4はこちら。</p>
      <br>
      <a href="#mozTocId4000">[C++]シューティングゲーム 4</a><br>
    </ol>
    <h1><a id="mozTocId3001" class="mozTocH1"></a>自機と敵弾の当たり判定</h1>
    <p>自機と敵弾がぶつかったら、自機がダメージを受けるようにしましょう。</p>
    <p><code>EnemyBullet.h</code>に当たり判定の大きさを表す変数を追加します。</p>
    <p class="source">#ifndef ENEMYBULLET_H_<br>
      #define ENEMYBULLET_H_<br>
      <br>
      #include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      // 敵弾クラス<br>
      class EnemyBullet: public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const int VisibleRadius = 8; // 見た目の半径<br>
      &nbsp;&nbsp;<em>float collisionRadius = 8; // 当たり判定半径</em><br>
      <br>
      &nbsp;&nbsp;(以下略)........................<br>
    </p>
    <p><code>Player.h</code>に敵弾とぶつかったときの処理の定義を追加します。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      <br>
      #include&nbsp;"GameObject.h"<br>
      <br>
      #include&nbsp;"GameManager.h"<br>
      <br>
      class Player : public GameObject<br>
      { // 継承は↑: public ～にする。publicをつけ忘れるとGameObjectの変数がすべてprivateとして継承されちゃう<br>
      public:<br>
      <br>
      &nbsp;&nbsp;(中略)...........<br>
      <br>
      &nbsp;&nbsp;// 敵にぶつかった時の処理<br>
      &nbsp;&nbsp;void OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other);<br>
      <br>
      &nbsp;&nbsp;<em>// 敵弾とぶつかった時の処理<br>
        &nbsp;&nbsp;void OnCollisionEnemyBullet(std::shared_ptr&lt;GameObject&gt; other);</em><br>
      <br>
      &nbsp;&nbsp;// ダメージを受ける処理<br>
      &nbsp;&nbsp;void TakeDamage();<br>
      };<br>
      <br>
      #endif</p>
    <p><code>Player.cpp</code>に敵弾とぶつかったときの処理を追加します。</p>
    <p class="source"> #include&nbsp;"Player.h"<br>
      <br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;弾を生成して【使う処理があるのでインクルード必要】<br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;(中略).........<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;(中略).........<br>
      }<br>
      <br>
      // 敵にぶつかった時の処理<br>
      void Player::OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other)<br>
      {<br>
      &nbsp;&nbsp;// 無敵じゃなければダメージを受ける<br>
      &nbsp;&nbsp;if (mutekiTimer &lt;= 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;TakeDamage();<br>
      &nbsp;&nbsp;}<br>
      }<br>
      <br>
      <em>// 敵弾とぶつかった時の処理<br>
        void Player::OnCollisionEnemyBullet(std::shared_ptr&lt;GameObject&gt; other)<br>
        {<br>
        &nbsp;&nbsp;// 無敵じゃなければダメージを受ける<br>
        &nbsp;&nbsp;if (mutekiTimer &lt;= 0)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;TakeDamage();<br>
        &nbsp;&nbsp;}<br>
        }</em><br>
      <br>
      // ダメージを受ける処理<br>
      void Player::TakeDamage()<br>
      {<br>
      &nbsp;&nbsp;life -= 1; // ライフ減少<br>
      <br>
      &nbsp;&nbsp;if (life &lt;= 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ライフが無くなったら死亡<br>
      &nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 無敵時間発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;mutekiTimer = MutekiJikan;<br>
      &nbsp;&nbsp;}<br>
      }<br>
    </p>
    <p><code>Game.cpp</code>に当たり判定の処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"MyRandom.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"EnemyBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako2.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako3.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 敵弾の更新処理<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.enemyBullets)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 自機と敵弾の衝突判定<br>
        &nbsp;&nbsp;for (const auto&amp; enemyBullet : gm.enemyBullets)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 敵弾が死んでたらスキップ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (enemyBullet-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemyBullet-&gt;position, enemyBullet-&gt;collisionRadius))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;OnCollisionEnemyBullet(enemyBullet);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;}</em><br>
      <br>
      &nbsp;&nbsp;// 敵の更新処理<br>
      &nbsp;&nbsp;for (const auto&amp; e : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾と敵の衝突判定<br>
      &nbsp;&nbsp;for(const auto&amp; playerBullet : gm.playerBullets)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 自機弾が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾と敵が重なっているか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;position, playerBullet-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;OnCollisionEnemy(enemy);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機と敵の衝突判定<br>
      &nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;OnCollisionEnemy(enemy);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      <br>
      &nbsp;&nbsp;// 敵のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;(中略)......<br>
      };<br>
    </p>
    <h1><a id="mozTocId3002" class="mozTocH1"></a>爆発エフェクトの作成(分割画像DivImage型の定義)</h1>
    <h2>分割画像DivImage型でデータ内部に分割画像の分割XY数や画像サイズ、画像数も覚えておく</h2>
    <p><code>DivImage.h</code>を新規作成して、カスタムしたデータタイプ【DivImage型】を定義して縦2×横8の分割された爆発画像を読込みましょう。</p>
    爆発画像は <a href="https://twitter.com/jetyam/status/887664013936541696">https://twitter.com/jetyam/status/887664013936541696</a>の縦2×横8の64pixの画像を想定<br>
    <p class="source">#ifndef DIVIMAGE_H_<br>
      #define DIVIMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 画像の2のべき乗チェックに使う<br>
      <br>
      // 分割画像を読込むためのデータ構造(画像数や画像ハンドル配列、3Dに使う場合の2のべき乗チェック機能をもつ)<br>
      class DivImage<br>
      {&nbsp;&nbsp;// 2Dの分割画像や3Dに分割Div画像を使うと画像全体が使われてしまうのを回避するための情報<br>
      public:<br>
      &nbsp;&nbsp;int XNum = 0;<br>
      &nbsp;&nbsp;int YNum = 0;<br>
      &nbsp;&nbsp;int XSize = 0;<br>
      &nbsp;&nbsp;int YSize = 0;<br>
      &nbsp;&nbsp;int* HandleArray = nullptr;<br>
      &nbsp;&nbsp;int AllNum = 0;<br>
      &nbsp;&nbsp;bool is3DTexture = false;<br>
      <br>
      // 初期化 : X方向分割画像数 XNum, Y方向分割画像数 YNum, 画像 横 幅XSizeピクセル, 画像 縦 高さYSizeピクセル<br>
      &nbsp;&nbsp;DivImage(int XNum, int YNum, int XSize, int YSize, bool is3DTexture=false)<br>
      &nbsp;&nbsp;{ // 初期化コンストラクタ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;XNum = XNum; // X方向分割画像数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;YNum = YNum; // Y方向分割画像数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;XSize = XSize; // 画像 横 幅XSize(ピクセルドット数)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;YSize = YSize; // 画像 縦 高さYSize(ピクセルドット数)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;AllNum = XNum * YNum; // トータルの分割画像数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;is3DTexture = is3DTexture; // 3Dテクスチャ分割画像かtrueだと2のべき乗チェックが入る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ★div分割画像読込ハンドラ保存用のint配列メモリを確保し-1で初期化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;HandleArray = new int[AllNum]; // 配列を確保し-1で初期化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; AllNum; i++) HandleArray[i] = -1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;//↑【演習★】初期化後の動的配列をデバッガで見てみよう[ary,256として再評価ボタン]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// http://visualstudiostudy.blog.fc2.com/blog-entry-17.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int* ary = HandleArray;<br>
      #ifdef _DEBUG // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(is3DTexture==true) ImagePowCheck((*this)); // *(this)でthisポインタの示す変数内容を表す<br>
      #endif<br>
      &nbsp;&nbsp;};<br>
      <br>
      &nbsp;&nbsp;~DivImage()<br>
      &nbsp;&nbsp;{ // デストラクタでメモリを解放<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (this-&gt;HandleArray != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete[] this-&gt;HandleArray;<br>
      &nbsp;&nbsp;};<br>
      <br>
      &nbsp;&nbsp;//【勉強 []添え字演算子を独自に定義】https://programming.pc-note.net/cpp/operator.html<br>
      &nbsp;&nbsp;// 内部のHandleArrayへ今までの様にImage::explosion[5]とかで簡単アクセスできるように【あいだに噛ます】<br>
      &nbsp;&nbsp;int const&amp; operator [](int index) const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(index&lt;0 || AllNum&lt;=index) assert("画像データのアクセス番号がおかしい！" == "");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return HandleArray[index];<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;int&amp; operator [](int index)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(index&lt;0 || AllNum&lt;=index) assert("画像データのアクセス番号がおかしい！" == "");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return HandleArray[index];<br>
      &nbsp;&nbsp;}<br>
      <br>
      #ifdef _DEBUG // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;bool is_pow2(unsigned int x) // 2のべき乗か計算<br>
      &nbsp;&nbsp;{ // https://programming-place.net/ppp/contents/c/rev_res/math012.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return (x != 0) &amp;&amp; (x &amp; (x - 1)) == 0;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;void ImagePowCheck(DivImage&amp; divImage)<br>
      &nbsp;&nbsp;{ // ★3Dに使う画像は2のべき乗でなければ受け付けないようにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// https://yttm-work.jp/gmpg/gmpg_0031.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// https://yappy-t.hatenadiary.org/entry/20100110/1263138881<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (divImage.XSize &gt; 0 &amp;&amp; divImage.YSize &gt; 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; is_pow2(divImage.XSize) &amp;&amp; is_pow2(divImage.YSize)) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else assert("3Dに使うなら2のべき乗の画像サイズにしなきゃ" == "");<br>
      &nbsp;&nbsp;}<br>
      #endif<br>
      <br>
      private: // コピーと代入をプライベートにして禁止する<br>
      &nbsp;&nbsp;&nbsp; // コピーコンストラクタの禁止privateオーバーロード<br>
      &nbsp;&nbsp;&nbsp; DivImage(const DivImage&amp; divImage) {};<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 代入演算子の禁止privateオーバーロード<br>
      &nbsp;&nbsp;&nbsp; void operator=(const DivImage&amp; divImage) {};<br>
      };<br>
      <br>
      #endif</p>
    <p><code>Image.h</code>でカスタムしたデータタイプ【DivImage型】で縦2×横8の分割された爆発画像を読込みましょう。</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      <em>#include "DivImage.h" // 分割画像の読込みに使う</em><br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;static void Load();<br>
      &nbsp;&nbsp;<em>static int LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage);</em><br>
      <br>
      &nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int player; //プレイヤ画像のハンドラ<br>
      &nbsp;&nbsp;static int playerBullet; //プレイヤの弾画像のハンドラ<br>
      &nbsp;&nbsp;static int enemyBullet16; //敵弾 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako0; //ザコ0 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako1; //ザコ1 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako2; //ザコ2 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako3; //ザコ3 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;<em>static DivImage explosion; // [分割画像]爆発エフェクト</em><br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
      <br>
      int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      int Image::player{-1};<br>
      int Image::playerBullet{-1};<br>
      int Image::enemyBullet16{-1};<br>
      int Image::zako0{-1};<br>
      int Image::zako1{-1};<br>
      int Image::zako2{-1};<br>
      int Image::zako3{-1};<br>
      <em>// ★分割画像は初期化のときに{X方向画像数, Y方向画像数, 画像横幅XSize,画像縦幅YSize}を指定</em><br>
      <em>DivImage Image::explosion{ 8, 2, 64, 64 };<br>
      //↑どのような画像を使うかで変わる<br>
      // 例えば https://pipoya.net/sozai/assets/effects/effect-event-1/ のイベントエフェクト.zipの<br>
      // 1800×180の縦一列のみなら DivImage Image::explosion{ 10, 1, 180, 180 };となる</em><br>
      <br>
      void Image::Load()<br>
      {<br>
      &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;player= LoadGraph("Image/player.png");<br>
      &nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;playerBullet = LoadGraph("Image/player_bullet.png");<br>
      &nbsp;&nbsp;assert(playerBullet!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;enemyBullet16 = LoadGraph("Image/enemy_bullet_16.png");<br>
      &nbsp;&nbsp;assert(enemyBullet16!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako0 = LoadGraph("Image/zako0.png");<br>
      &nbsp;&nbsp;assert(zako0!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako1 = LoadGraph("Image/zako1.png");<br>
      &nbsp;&nbsp;assert(zako1!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako2 = LoadGraph("Image/zako2.png");<br>
      &nbsp;&nbsp;assert(zako2!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako3 = LoadGraph("Image/zako3.png");<br>
      &nbsp;&nbsp;assert(zako3!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
	&nbsp;&nbsp;<em>// div分割画像をロード<br>
      &nbsp;&nbsp;Image::LoadDivGraph("Image/explosion.png", explosion);<br>
        &nbsp;&nbsp;for (int i = 0; i &lt; explosion.AllNum; i++)<br>
        &nbsp;&nbsp;{ // 画像読込失敗<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (explosion.HandleArray[i] == -1) assert("爆発分割画像読込失敗" == "");<br>
        &nbsp;&nbsp;}</em><br>
      }<br>
      <br>
      <em>// DXライブラリのLoadDivGraphを使いやすくラッピング<br>
        // ★関数に参照渡しを行う<br>
        // 関数の引数に参照渡しを行うことでdivImageの中身を書き換えることができる(値渡しでは書換不可)<br>
        //　https://qiita.com/agate-pris/items/05948b7d33f3e88b8967<br>
        // https://qiita.com/RuthTaro/items/f35c3a26779c0ca1a41a<br>
        int Image::LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage)<br>
        {<br>
        &nbsp;&nbsp;return DxLib::LoadDivGraph(FileName, divImage.XNum * divImage.YNum,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;divImage.XNum, divImage.YNum, divImage.XSize, divImage.YSize, divImage.HandleArray);<br>
        };</em><br>
    </p>
    <h2><a id="mozTocId30022" class="mozTocH1"></a>爆発クラスの作成</h2>
    <p><code>Explosion.h</code>を新規作成して爆発エフェクトを表示するクラスを作ります。</p>
    <p class="source">#ifndef EXPLOSION_H_<br>
      #define EXPLOSION_H_<br>
      <br>
      #include "Image.h"<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      // 爆発エフェクトクラス<br>
      class Explosion : public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;int counter = 0; // 時間を計るための変数<br>
      &nbsp;&nbsp;int imageIndex = 0; // 表示すべき画像の番号<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Explosion(Vector3 pos) : GameObject( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Explosion";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;counter++;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;imageIndex = counter / 3; // そのままだと速すぎるので、3で割る<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 絵は16枚しかない（0～15）ので、<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 16番目を表示しようとしたら終了。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (imageIndex &gt;= 16)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;// 分割して読み込んだ絵のハンドルが各要素に格納されているので、<br>
      &nbsp;&nbsp;// 要素番号を指定してハンドルを取り出して使う。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::explosion[imageIndex], TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <h2><a id="mozTocId30023" class="mozTocH1"></a>管理する仕組みの作成</h2>
    <p><code>GameManager.h</code>にExplosionを管理するリストの定義を追加します。</p>
    <p class="source"> #ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      <br>
      #include&nbsp;"Singleton.h"<br>
      <br>
      class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      class&nbsp;PlayerBullet;<br>
      class&nbsp;Enemy;<br>
      class&nbsp;EnemyBullet;<br>
      <em>class&nbsp;Explosion;</em><br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機のポインタ<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;EnemyBullet&gt;&gt; enemyBullets; // 敵弾のリスト<br>
      &nbsp;&nbsp;<em>std::list&lt;std::shared_ptr&lt;Explosion&gt;&gt; explosions; // 爆発エフェクトのリスト</em><br>
      &nbsp;&nbsp;// 複数リスト↑list ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      <br>
      (中略).............. <br>
      protected:<br>
      &nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Game.cpp</code>に当たり判定の処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
	    <br>
      #include&nbsp;"MyRandom.h"<br>
	    <br>
      #include "Player.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include "PlayerBullet.h" // Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include "EnemyBullet.h" // Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <em>#include "Explosion.h" // Update(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      #include "Zako0.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include "Zako1.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include "Zako2.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include "Zako3.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;// 自機と敵の衝突判定<br>
      &nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;OnCollisionEnemy(enemy);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 爆発エフェクトの更新処理<br>
        &nbsp;&nbsp;for (const auto&amp; e : gm.explosions)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Update();<br>
        &nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;<br>
      <br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;// 敵のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;// 敵弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemyBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;EnemyBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;<em>//爆発エフェクトのリストから死んでるものを除去する<br>
        &nbsp;&nbsp;gm.EraseRemoveIf(gm.explosions,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Explosion&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;(中略)......<br>
      <br>
      &nbsp;&nbsp;// 敵の描画処理<br>
      &nbsp;&nbsp;for (const auto&amp; e : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 爆発エフェクトの描画処理<br>
        &nbsp;&nbsp;for (const auto&amp; e : gm.explosions)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Draw();<br>
        &nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;(中略)......<br>
      <br>
      };<br>
    </p>
    <h2><a id="mozTocId30024" class="mozTocH1"></a>爆発を出す処理(Enemyで敵の共通の爆発を生成)</h2>
    <p><code>Enemy.h</code>を改修して、敵が死んだときに爆発エフェクトを出すようにしましょう。</p>
    <p class="source">#ifndef ENEMY_H_<br>
      #define ENEMY_H_<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      #include "GameManager.h"<br>
      <br>
      <em>#include "Explosion.h"</em><br>
      <br>
      // 敵の基底クラス。<br>
      // 全ての敵は、このクラスを継承して作る。<br>
      // ★【勉強】abstract型はC++にない!!【純粋仮想関数】を使って作る<br>
      class Enemy : public GameObject<br>
      {<br>
      public:<br>
      <br>
      &nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;float collisionRadius = 32; // 当たり判定の半径<br>
      &nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
      &nbsp;&nbsp;float life = 1; // 耐久力<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Enemy(Vector3 pos) : GameObject( pos ) // GameObjectをベースとして初期化処理を継承する<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;typeTag = "Enemy";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;virtual void Update() = 0;//virtual ～ = 0;で【純粋仮想関数に】これで【C#のabstract型に】<br>
      <br>
      &nbsp;&nbsp;// 描画処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;virtual void Draw() = 0; //virtual ～ = 0;で【純粋仮想関数に】【関数 = 0で未定義状態を表現】<br>
      <br>
      <br>
      &nbsp;&nbsp;// 自機弾に当たったときの処理<br>
      &nbsp;&nbsp;virtual void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;life -= 1; // ライフを減らす<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ライフが無くなったら、死亡<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (life &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>// 爆発を出す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.explosions.emplace_back(std::make_shared&lt;Explosion&gt;(Vector3(position.x, position.y)));</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p><br>
	  ここまでで、実行して爆発が出るか試してみましょう！<br>
    <h1><a id="mozTocId3003" class="mozTocH1"></a>ボスの作成</h1>
    <p>まずはボスの3状態の画像をImageフォルダに用意しておきましょう。</p>
    <ul>
      <li>boss1.png</li>
      <li>boss2.png</li>
      <li>boss3.png</li>
    </ul>
    <p><code>Image.h</code>にboss1.png、boss2.png、boss3.pngの読込み処理を追加します。</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "DivImage.h" // 分割画像の読込みに使う<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;static void Load();<br>
      &nbsp;&nbsp;static int LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage);<br>
      <br>
      &nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int player; //プレイヤ画像のハンドラ<br>
      &nbsp;&nbsp;static int playerBullet; //プレイヤの弾画像のハンドラ<br>
      &nbsp;&nbsp;static int enemyBullet16; //敵弾 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako0; //ザコ0 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako1; //ザコ1 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako2; //ザコ2 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako3; //ザコ3 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;<em>static int boss1; //ボス通常 画像のハンドラ(読込画像番号)</em><br>
      &nbsp;&nbsp;<em>static int boss2; //ボス2気絶 画像のハンドラ(読込画像番号)</em><br>
      &nbsp;&nbsp;<em>static int boss3; //ボス3発狂 画像のハンドラ(読込画像番号)</em><br>
      &nbsp;&nbsp;static DivImage explosion; // [分割画像]爆発エフェクト<br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
      <br>
      int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      int Image::player{-1};<br>
      int Image::playerBullet{-1};<br>
      int Image::enemyBullet16{-1};<br>
      int Image::zako0{-1};<br>
      int Image::zako1{-1};<br>
      int Image::zako2{-1};<br>
      int Image::zako3{-1};<br>
      <em>int Image::boss1{-1};</em><br>
      <em>int Image::boss2{-1};</em><br>
      <em>int Image::boss3{-1};</em><br>
      // ★分割画像は初期化のときに{X方向画像数, Y方向画像数, 画像横幅XSize,画像縦幅YSize}を指定<br>
      DivImage Image::explosion{ 8, 2, 64, 64 };<br>
      <br>
      void Image::Load()<br>
      {<br>
      &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;player= LoadGraph("Image/player.png");<br>
      &nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;playerBullet = LoadGraph("Image/player_bullet.png");<br>
      &nbsp;&nbsp;assert(playerBullet!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;enemyBullet16 = LoadGraph("Image/enemy_bullet_16.png");<br>
      &nbsp;&nbsp;assert(enemyBullet16!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako0 = LoadGraph("Image/zako0.png");<br>
      &nbsp;&nbsp;assert(zako0!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako1 = LoadGraph("Image/zako1.png");<br>
      &nbsp;&nbsp;assert(zako1!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako2 = LoadGraph("Image/zako2.png");<br>
      &nbsp;&nbsp;assert(zako2!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako3 = LoadGraph("Image/zako3.png");<br>
      &nbsp;&nbsp;assert(zako3!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;<em>boss1 = LoadGraph("Image/boss1.png");<br>
        &nbsp;&nbsp;assert(boss1!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      &nbsp;&nbsp;<em>boss2 = LoadGraph("Image/boss2.png");<br>
        &nbsp;&nbsp;assert(boss2!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      &nbsp;&nbsp;<em>boss3 = LoadGraph("Image/boss3.png");<br>
        &nbsp;&nbsp;assert(boss3!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      &nbsp;&nbsp;// div分割画像をロード<br>
      &nbsp;&nbsp;Image::LoadDivGraph("Image/explosion.png", explosion);<br>
      &nbsp;&nbsp;for (int i = 0; i &lt; explosion.AllNum; i++)<br>
      &nbsp;&nbsp;{ // 画像読込失敗<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (explosion.HandleArray[i] == -1) assert("爆発分割画像読込失敗" == "");<br>
      &nbsp;&nbsp;}<br>
      }<br>
      <br>
      // DXライブラリのLoadDivGraphを使いやすくラッピング<br>
      // ★関数に参照渡しを行う<br>
      // 関数の引数に参照渡しを行うことでdivImageの中身を書き換えることができる(値渡しでは書換不可)<br>
      //　https://qiita.com/agate-pris/items/05948b7d33f3e88b8967<br>
      // https://qiita.com/RuthTaro/items/f35c3a26779c0ca1a41a<br>
      int Image::LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage)<br>
      {<br>
      &nbsp;&nbsp;return DxLib::LoadDivGraph(FileName, divImage.XNum * divImage.YNum,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;divImage.XNum, divImage.YNum, divImage.XSize, divImage.YSize, divImage.HandleArray);<br>
      };<br>
    </p>
    <br>
    <p><code>Boss.h</code>を新規作成してif else でStateに応じて行動を遷移させてみましょう。</p>
    <p>「<b>登場</b>」画面右から出てくる<br>
      　↓<br>
      「<b>通常</b>」通常の状態。通常の攻撃を行う<br>
      　↓<br>
      「<b>気絶</b>」気絶状態の絵になる<br>
      　↓<br>
      「<b>発狂</b>」怒った絵になる。激しい攻撃を繰り広げてくる<br>
      　↓<br>
      「<b>死亡</b>」少し時間をかけて死亡の演出を行う<br>
      　↓<br>
      完全に消滅</p>
    <p><br>
    </p>
<code>Boss.hを新規作成</code>します。<br>
    <p class="source">#ifndef BOSS_H_<br>
      #define BOSS_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      #include "Image.h"<br>
      <br>
      // ボスクラス。Enemyを継承して作る<br>
      class Boss : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // ボスの状態種別<br>
      &nbsp;&nbsp;&nbsp; enum class State<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Appear, // 登場<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Normal, // 通常時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Swoon, // 気絶時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Angry, // 発狂モード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dying, // 死亡<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; State state = State::Appear; // 現在の状態<br>
      &nbsp;&nbsp;&nbsp; int swoonTime = 120; // 残り気絶時間<br>
      &nbsp;&nbsp;&nbsp; int dyingTime = 180; // 死亡時のアニメーション時間<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Boss(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Boss"; // オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life = 100; // ライフ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collisionRadius = 70; // 当たり判定半径<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state == State::Appear) // 登場状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x -= 1; // 左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (position.x &lt;= 750) // x座標が750以下になったら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = State::Normal; // 通常状態へ移行<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Normal) // 通常状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Swoon) // 気絶状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; swoonTime--; // タイマー減少<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (swoonTime &lt;= 0) // タイマーが0になったら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = State::Angry; // 発狂モードへ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Angry) // 発狂モード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Dying) // 死亡中<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dyingTime--; // タイマー減少<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dyingTime &lt;= 0) // タイマーが0になったら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isDead = true; // 完全に消滅<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state == State::Appear || state == State::Normal) // 登場時と通常時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss1, TRUE); // 普通の画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Swoon) // 気絶時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss2, TRUE); // 気絶時の画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Angry) // 発狂モード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss3, TRUE); // 怒ってる画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Dying) // 死亡中<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss2, TRUE); // 気絶時の画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 自機弾に当たったときの処理をoverride（上書き）する<br>
      &nbsp;&nbsp; &nbsp;virtual void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet) override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 登場時、気絶時、死亡時は被弾しても何もしない<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (state == State::Appear || state == State::Swoon || state == State::Dying)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;life -= 1; // ライフを減らす<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (life &lt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ライフが無くなったら、すぐ消滅するのではなく、死亡状態へ移行<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;state = State::Dying;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (state == State::Normal &amp;&amp; life &lt;= 50)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 通常状態でライフが50以下になったら、気絶する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;state = State::Swoon;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <p><code>Game.cpp</code>にボスの生成処理を追加してボスが期待通りに状態遷移することを確認しましょう。</p>
    <p class="source">#include "Game.h"<br>
	    <br>
      #include "MyRandom.h"<br>
      <br>
      #include "Player.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include "PlayerBullet.h"<br>
      #include "EnemyBullet.h"<br>
      #include "Explosion.h"<br>
      #include "Zako0.h"<br>
      #include "Zako1.h"<br>
      #include "Zako2.h"<br>
      #include "Zako3.h"<br>
      <em>#include "Boss.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;&nbsp; Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数シードの初期化<br>
      <br>
      &nbsp;&nbsp;&nbsp; (中略).................<br>
      <br>
      &nbsp;&nbsp;&nbsp; gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化<br>
      &nbsp;&nbsp;&nbsp; // とりあえず適当に敵を生成<br>
      &nbsp;&nbsp;&nbsp; <em>gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));</em><br>
      }<br>
      <br>
      (以下略).................</p>
    <br>
	
    <h1><a id="mozTocId3004" class="mozTocH1"></a>【練習問題】ボスの状態ごとの行動パターンのプログラミング</h1>
    <p>さきほどのボスは登場してもじっとしたままです。<br>
	    Zako0～Zako3の動きを応用して自分オリジナルのボスの行動パターンを自作してみてください。<br>
	    例として下記に実装例を置いてはおきますがあくまで参考として、自分で考えて組んでみることが大事です。<br>
	    ここまでの復習と集大成として、Zako0～Zako3のコードを移植しながら、プログラミングすることが肝要です。</p>
	<p><code>Boss.hの行動パターンのプログラム例</code>(lifeとenumの状態をAngry以外にも増やせばもっと長期戦も演出できる)</p>
	  <p class="source">#ifndef BOSS_H_<br>
      #define BOSS_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      #include "Image.h"<br>
      <br>
      <em>#include &lt;cmath&gt; // Sin Cosの計算に使う<br>
      #include "MyMath.h"<br>
      #include "MyRandom.h" // 乱数方向弾に使う</em><br>
      <br>
      // ボスクラス。Enemyを継承して作る<br>
      class Boss : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // ボスの状態種別<br>
      &nbsp;&nbsp;&nbsp; enum class State<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Appear, // 登場<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Normal, // 通常時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Swoon, // 気絶時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Angry, // 発狂モード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dying, // 死亡<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; State state = State::Appear; // 現在の状態<br>
      &nbsp;&nbsp;&nbsp; int swoonTime = 120; // 残り気絶時間<br>
      &nbsp;&nbsp;&nbsp; int dyingTime = 180; // 死亡時のアニメーション時間<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>int coolTime = 0; // クールタイム(冷却時間。0になるまで次の弾が撃てない)<br>
      &nbsp;&nbsp;&nbsp; float sinMove = 0; // Sinの動きをする際の0～360度<br>
      &nbsp;&nbsp;&nbsp; float sinRadius = 120; // Sinの動きをするときの半径</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Boss(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Boss"; // オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life = 100; // ライフ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collisionRadius = 70; // 当たり判定半径<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state == State::Appear) // 登場状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x -= 1; // 左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (position.x &lt;= 750) // x座標が750以下になったら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = State::Normal; // 通常状態へ移行<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Normal) // 通常状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>coolTime--;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (coolTime &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp; // ボスの弾はスピード16で2倍の速度で撃ち出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, 180 * MyMath::Deg2Rad, 16));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime += 200; // そのかわり発射間隔は長め<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float prevSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sinMove += 2.5f; // Sinの波運動の角度を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float currentSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (前の角度でのY) - (今の角度でのY)の差を足すことで【ベースのyの位置 ± sinの動き】になる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y += currentSinY - prevSinY; // 上下方向のSinの波運動</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Swoon) // 気絶状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; swoonTime--; // タイマー減少<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (swoonTime &lt;= 0) // タイマーが0になったら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>coolTime = 0; // クールタイムを0にリセットしてから</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = State::Angry; // 発狂モードへ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Angry) // 発狂モード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>coolTime--;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (coolTime &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, 180 * MyMath::Deg2Rad, 16));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime += 20;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float prevSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sinMove += 10.5f; // Sinの波運動の角度を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float currentSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (前の角度でのY) - (今の角度でのY)の差を足すことで【ベースのyの位置 ± sinの動き】になる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y += currentSinY - prevSinY; // 上下方向のSinの波運動</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Dying) // 死亡中<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dyingTime--; // タイマー減少<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dyingTime &lt;= 0) // タイマーが0になったら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isDead = true; // 完全に消滅<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state == State::Appear || state == State::Normal) // 登場時と通常時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss1, TRUE); // 普通の画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Swoon) // 気絶時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss2, TRUE); // 気絶時の画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Angry) // 発狂モード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss3, TRUE); // 怒ってる画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Dying) // 死亡中<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss2, TRUE); // 気絶時の画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 自機弾に当たったときの処理をoverride（上書き）する<br>
      &nbsp;&nbsp; &nbsp;virtual void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet) override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 登場時、気絶時、死亡時は被弾しても何もしない<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (state == State::Appear || state == State::Swoon || state == State::Dying)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;life -= 1; // ライフを減らす<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (life &lt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ライフが無くなったら、すぐ消滅するのではなく、死亡状態へ移行<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;state = State::Dying;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (state == State::Normal &amp;&amp; life &lt;= 50)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 通常状態でライフが50以下になったら、気絶する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;state = State::Swoon;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
	  <br>
	  enumを使った状態の遷移はボスだけでなくZakoにも応用できます。<br>
	  プログラマの腕の見せ所(醍醐味)は、さまざまな敵の行動パターンを組むことにあります。<br>
	  (これを発展させると、プレイヤの状態に合わせて知的に行動するAIにつながっていきます)<br>
	  <br>
	  <br>
<h1><a id="mozTocId3005" class="mozTocH1"></a>プレイヤのライフをバーで表示させる</h1>
<p><code>Player.h</code>に現在のライフをバーで表示する処理の定義を追加します。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      <br>
      #include&nbsp;"GameObject.h"<br>
      <br>
      #include&nbsp;"GameManager.h"<br>
      <br>
      class Player : public GameObject<br>
      { // 継承は↑: public ～にする。publicをつけ忘れるとGameObjectの変数がすべてprivateとして継承されちゃう<br>
      public:<br>
      <br>
      &nbsp;&nbsp;(中略)...........<br>
      <br>
      &nbsp;&nbsp;<em>int lifeMax = 20; // 最大ライフ</em><br>
      &nbsp;&nbsp;int life = 3; // ライフ<br>
      &nbsp;&nbsp;int mutekiTimer = 0; // 残り無敵時間。0以下なら無敵じゃないってこと<br>
      <br>
      &nbsp;&nbsp;(中略)...........<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw();//【★←Player.cppを新規作成してそちらに処理を書き移す】<br>
      <br>
      <em>&nbsp;&nbsp;// ライフをバーで表示する処理<br>
      &nbsp;&nbsp;void DrawLifeBar();</em><br>
      <br>
      &nbsp;&nbsp;// 敵にぶつかった時の処理<br>
      &nbsp;&nbsp;void OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other);<br>
      <br>
      &nbsp;&nbsp;// 敵弾とぶつかった時の処理<br>
        &nbsp;&nbsp;void OnCollisionEnemyBullet(std::shared_ptr&lt;GameObject&gt; other);<br>
      <br>
      &nbsp;&nbsp;// ダメージを受ける処理<br>
      &nbsp;&nbsp;void TakeDamage();<br>
      };<br>
      <br>
      #endif</p>
    <p><code>Player.cpp</code>に現在のライフをバーで表示する処理の定義を追加します。</p>
    <p class="source"> #include&nbsp;"Player.h"<br>
      <br>
      &nbsp;&nbsp;(中略).........<br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;(中略).........<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;(中略).........<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// ライフをバーで表示する処理<br>
      &nbsp;&nbsp;DrawLifeBar();</em><br>
      }<br>
      <br>
      <em>// ライフをバーで表示する処理<br>
      void Player::DrawLifeBar()<br>
      {<br>
      &nbsp;&nbsp;// ライフをバー表示する際の色設定<br>
      &nbsp;&nbsp;unsigned int frameColor = GetColor(255, 255, 255); // バーの枠の色<br>
      &nbsp;&nbsp;unsigned int backColor = GetColor(0, 0, 0); // バーの背景の色<br>
      &nbsp;&nbsp;unsigned int lineColor = GetColor(0, 0, 0); // バーの区切り目盛りの色<br>
      &nbsp;&nbsp;unsigned int red = GetColor(255, 0, 0), orange = GetColor(255, 100, 0); // ピンチ時の赤、オレンジ<br>
      &nbsp;&nbsp;unsigned int green = GetColor(0, 255, 0), blue = GetColor(0, 255, 255); // 10までは緑、11以上は水色<br>
      &nbsp;&nbsp;int barMax = (lifeMax &gt; 10) ? 10 : lifeMax; // バーの目盛りの数<br>
      &nbsp;&nbsp;int barWidth = 40, barPart = barWidth / barMax, rectWidth = (barPart + 1) * barMax;<br>
      &nbsp;&nbsp;int barHeight = 4; // バーの表示する高さ(4+1+1) 枠は上+1, 下+1, 目盛ぶん↑+1して×10し直すとバーの四角形幅になる<br>
      &nbsp;&nbsp;Vector3 barPos{ position.x - rectWidth / 2, position.y + collisionRadius }; // バーの表示位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// バーの背景を描画<br>
      &nbsp;&nbsp;DrawBox(barPos.x - 1, barPos.y - 1, barPos.x + 1 + rectWidth, barPos.y + 1 + barHeight, backColor, TRUE);<br>
      &nbsp;&nbsp;// バーの枠を描画<br>
      &nbsp;&nbsp;DrawBox(barPos.x - 1, barPos.y - 1, barPos.x + 1 + rectWidth, barPos.y + 1 + barHeight, frameColor, FALSE);<br>
      &nbsp;&nbsp;auto barColor = (life &lt;= 1) ? red : (life &lt;= 2) ? orange : green; // lifeが 残り1:赤,残り2:橙 10以下:緑<br>
      &nbsp;&nbsp;// バーの中身を10まで描画<br>
      &nbsp;&nbsp;int barNum = (life &lt; 10) ? life : 10;<br>
      &nbsp;&nbsp;for (int i = 0; i &lt; barNum; ++i)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawBox(barPos.x + i * (barPart + 1), barPos.y,<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;barPos.x + (i + 1) * (barPart + 1), barPos.y + barHeight, barColor, TRUE);<br>
      &nbsp;&nbsp;// バーの中身(水色)を20まで描画<br>
      &nbsp;&nbsp;int blueNum = (life &gt; 20) ? 10 : (life &gt; 10) ? life - 10 : 0; // lifeが残り10以上のときは水色<br>
      &nbsp;&nbsp;for (int i = 0; i &lt; blueNum; ++i)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawBox(barPos.x + i * (barPart + 1), barPos.y,<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;barPos.x + (i + 1) * (barPart + 1), barPos.y + barHeight, blue, TRUE);<br>
      &nbsp;&nbsp;// バーの目盛りを描画<br>
      &nbsp;&nbsp;for (int i = 0; i &lt; 9; ++i)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawLine(barPos.x + (i + 1) * (barPart + 1), barPos.y,<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; barPos.x + (i + 1) * (barPart + 1), barPos.y + barHeight, (i + 1 == life) ? barColor : lineColor, TRUE);<br>
      }</em><br>
      <br>
      &nbsp;&nbsp;(以下略).........<br>
    </p>
<br>
いかがでしょうか、プレイヤの下にライフのバーが表示されるようになりましたか？<br>
現状では、ライフを回復するすべがないので、ライフが10を超えることはないですが、<br>
ライフが10を超えると、10までの緑色のバーの上のレイヤに、0から折り返して水色で20までライフが表示される機能もプログラミングしておきました。<br>
<br>	  
次はザコがライフを回復するアイテムをドロップする処理をプログラミングしてみましょう。<br>	  
<br>	  
<h1><a id="mozTocId3006" class="mozTocH1"></a>アイテムクラスとザコからのドロップ処理の作成</h1>
<p>ザコからプレイヤのライフを回復するアイテムをドロップさせてみましょう。<br>
      GIMPで16×16のハートのドット絵画像を自作して<code>heart.pngという名前でpng画像としてDXプロジェクトのImageフォルダにエクスポート</code>しておきましょう。</p>
・<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/image/heart.xcf">heart.xcf(GIMPの編集ファイル)</a>←右クリック[名前をつけてリンク先を保存]でダウンロードすればGIMPで編集できる<br>
・<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/image/heart.png">heart.png(↑GIMPから名前をつけてエクスポートしたpng画像ファイル)</a>←右クリック[名前をつけてリンク先を保存]でダウンロード<br>    
<img src="image/gimp_heart_dot.png">
    <p><code>Image.h</code>にheart.pngの読込み処理を追加します。</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "DivImage.h" // 分割画像の読込みに使う<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;static void Load();<br>
      &nbsp;&nbsp;static int LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage);<br>
      <br>
      &nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int player; //プレイヤ画像のハンドラ<br>
      &nbsp;&nbsp;static int playerBullet; //プレイヤの弾画像のハンドラ<br>
      &nbsp;&nbsp;static int enemyBullet16; //敵弾 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako0; //ザコ0 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako1; //ザコ1 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako2; //ザコ2 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako3; //ザコ3 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int boss1; //ボス通常 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int boss2; //ボス2気絶 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int boss3; //ボス3発狂 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static DivImage explosion; // [分割画像]爆発エフェクト<br>
      &nbsp;&nbsp;<em>static int item0; //アイテム0 画像のハンドラ(読込画像番号)</em><br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
      <br>
      int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      int Image::player{-1};<br>
      int Image::playerBullet{-1};<br>
      int Image::enemyBullet16{-1};<br>
      int Image::zako0{-1};<br>
      int Image::zako1{-1};<br>
      int Image::zako2{-1};<br>
      int Image::zako3{-1};<br>
      int Image::boss1{-1};<br>
      int Image::boss2{-1};<br>
      int Image::boss3{-1};<br>
      // ★分割画像は初期化のときに{X方向画像数, Y方向画像数, 画像横幅XSize,画像縦幅YSize}を指定<br>
      DivImage Image::explosion{ 8, 2, 64, 64 };<br>
      <em>int Image::item0{-1};</em><br>
      <br>
      void Image::Load()<br>
      {<br>
      &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;player= LoadGraph("Image/player.png");<br>
      &nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;playerBullet = LoadGraph("Image/player_bullet.png");<br>
      &nbsp;&nbsp;assert(playerBullet!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;enemyBullet16 = LoadGraph("Image/enemy_bullet_16.png");<br>
      &nbsp;&nbsp;assert(enemyBullet16!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako0 = LoadGraph("Image/zako0.png");<br>
      &nbsp;&nbsp;assert(zako0!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako1 = LoadGraph("Image/zako1.png");<br>
      &nbsp;&nbsp;assert(zako1!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako2 = LoadGraph("Image/zako2.png");<br>
      &nbsp;&nbsp;assert(zako2!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako3 = LoadGraph("Image/zako3.png");<br>
      &nbsp;&nbsp;assert(zako3!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;boss1 = LoadGraph("Image/boss1.png");<br>
        &nbsp;&nbsp;assert(boss1!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;boss2 = LoadGraph("Image/boss2.png");<br>
        &nbsp;&nbsp;assert(boss2!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;boss3 = LoadGraph("Image/boss3.png");<br>
        &nbsp;&nbsp;assert(boss3!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;// div分割画像をロード<br>
      &nbsp;&nbsp;Image::LoadDivGraph("Image/explosion.png", explosion);<br>
      &nbsp;&nbsp;for (int i = 0; i &lt; explosion.AllNum; i++)<br>
      &nbsp;&nbsp;{ // 画像読込失敗<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (explosion.HandleArray[i] == -1) assert("爆発分割画像読込失敗" == "");<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;<em>item0 = LoadGraph("Image/heart.png");<br>
      &nbsp;&nbsp;assert(item0!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      }<br>
      <br>
      // DXライブラリのLoadDivGraphを使いやすくラッピング<br>
      // ★関数に参照渡しを行う<br>
      // 関数の引数に参照渡しを行うことでdivImageの中身を書き換えることができる(値渡しでは書換不可)<br>
      //　https://qiita.com/agate-pris/items/05948b7d33f3e88b8967<br>
      // https://qiita.com/RuthTaro/items/f35c3a26779c0ca1a41a<br>
      int Image::LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage)<br>
      {<br>
      &nbsp;&nbsp;return DxLib::LoadDivGraph(FileName, divImage.XNum * divImage.YNum,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;divImage.XNum, divImage.YNum, divImage.XSize, divImage.YSize, divImage.HandleArray);<br>
      };<br>
    </p>
<p><code>Player.h</code>にライフを回復する処理を追加します。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      <br>
      #include&nbsp;"GameObject.h"<br>
      <br>
      #include&nbsp;"GameManager.h"<br>
      <br>
      class Player : public GameObject<br>
      { // 継承は↑: public ～にする。publicをつけ忘れるとGameObjectの変数がすべてprivateとして継承されちゃう<br>
      public:<br>
      <br>
      &nbsp;&nbsp;(中略)...........<br>
      <br>
      <br>
      &nbsp;&nbsp;// ダメージを受ける処理<br>
      &nbsp;&nbsp;void TakeDamage();<br>
      <br>
      &nbsp;&nbsp;<em>// ライフが回復する処理<br>
      &nbsp;&nbsp;void RecoverLife(int amount);</em><br>
      };<br>
      <br>
      #endif</p>
    <p><code>Player.cpp</code>にライフを回復する処理を追加します。</p>
    <p class="source"> #include&nbsp;"Player.h"<br>
      <br>
      &nbsp;&nbsp;(中略).........<br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;(中略).........<br>
      }<br>
      <br>
      <br>
      &nbsp;&nbsp;(中略).........<br>
      <br>
      // ダメージを受ける処理<br>
      void Player::TakeDamage()<br>
      {<br>
      &nbsp;&nbsp;life -= 1; // ライフ減少<br>
      <br>
      &nbsp;&nbsp;if (life &lt;= 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ライフが無くなったら死亡<br>
      &nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 無敵時間発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;mutekiTimer = MutekiJikan;<br>
      &nbsp;&nbsp;}<br>
      }<br>
      <br>
      <em>// ライフが回復する処理<br>
      void Player::RecoverLife(int amount)<br>
      {<br>
      &nbsp;&nbsp;life += amount; // ライフ回復<br>
      }</em><br>
    </p>
    <br>
<code>Item.hを新規作成</code>します。<br>
    <p class="source">#ifndef ITEM_H_<br>
      #define ITEM_H_<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      #include "GameManager.h"<br>
      <br>
      // アイテムのベース基底クラス<br>
      class Item : public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; //【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; GameManager& gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&)を得る<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; float collisionRadius; // 当たり判定の半径<br>
      &nbsp;&nbsp;&nbsp; <br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ v:移動速度(方向) radius:当たり判定の半径<br>
      &nbsp;&nbsp;&nbsp; Item(Vector3 pos, Vector3 v, float radius = 8)<br>
      &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; : collisionRadius{ radius }, GameObject( pos ) // GameObjectをベースとして初期化処理を継承する<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "Item"; // オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;v = v; // GameObjectの速度vを利用する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() = 0;//virtual ～ = 0;で【純粋仮想関数に】これで【C#のabstract型に】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() = 0; //virtual ～ = 0;で【純粋仮想関数に】【関数 = 0で未定義状態を表現】<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 自機に当たったときの処理 派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp; &nbsp;virtual void OnCollisionPlayer(std::shared_ptr&lt;GameObject&gt; object)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// アイテムごとに継承でoverrideして個別処理を書く<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
      <br>
      このベース基底となるItem.hを継承してItem0やItem1などを作成します。<br>
      <br>
<code>Item0.hを新規作成</code>します。<br>
    <p class="source">#ifndef ITEM_0_H_<br>
      #define ITEM_0_H_<br>
      <br>
      #include "Item.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <br>
      // アイテム0クラス ライフを回復するアイテム<br>
      class Item0 : public Item<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int amount; // 回復量など<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Item0(Vector3 pos,<br>
      &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Vector3 v = Vector3{ -0.5f,0.0f }, // デフォルトは-0.5fで遅めのスクロール量<br>
      &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; int amount = 1)<br>
      &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; : amount{ amount }, Item(pos, v, 8)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Item0"; // オブジェクトの判別タグ<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;this-&gt;position += this-&gt;v; // vのx,y量ぶん移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;// スクリーンの画面外になったらisDeadにして消す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;if (position.x + collisionRadius &lt; 0 || Screen::Width &lt; position.x - collisionRadius<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; || position.y + collisionRadius &lt; 0 || Screen::Height &lt; position.y - collisionRadius )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::item0, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 自機に当たったときの処理 上書きoverrideする<br>
      &nbsp;&nbsp; &nbsp;virtual void OnCollisionPlayer(std::shared_ptr&lt;GameObject&gt; object)  override;<br>
      };<br>
      <br>
      #endif</p>
      <br>
<br>
<code>Item0.cppを新規作成</code>します。<br>
    <p class="source">#include "Item0.h"<br>
      <br>
      #include "Player.h" // アイテムとプレイヤは相互にインクルードしそうなのでcppで#include<br>
      <br>
      // 自機に当たったときの処理 上書きoverrideする<br>
      void Item0::OnCollisionPlayer(std::shared_ptr&lt;GameObject&gt; object)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; //[共有ポインタをダウンキャスト(親GameObject → 子Playerに)]<br>
      &nbsp;&nbsp;&nbsp; // https://cpprefjp.github.io/reference/memory/shared_ptr/dynamic_pointer_cast.html<br>
      &nbsp;&nbsp;&nbsp; if (std::shared_ptr&lt;Player&gt; pPlayer = std::dynamic_pointer_cast&lt;Player&gt;(object))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer->RecoverLife(amount); // ライフを回復する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; isDead = true; // 取ったら消される<br>
      }<br>
      </p>
      <br>
      さらに、このItem0をザコがやられる直前にドロップさせる処理を追加します。<br>
      <br>
<p>まずはベースとなる<code>Enemy.hにアイテムをドロップするvirtual仮想関数を追加</code>して継承overrideできるように準備します。</p>
    <p class="source">#ifndef ENEMY_H_<br>
      #define ENEMY_H_<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      #include "GameManager.h"<br>
      <br>
      // 敵の基底クラス。<br>
      // 全ての敵は、このクラスを継承して作る。<br>
      // ★【勉強】abstract型はC++にない!!【純粋仮想関数】を使って作る<br>
      class Enemy : public GameObject<br>
      {<br>
      public:<br>
      <br>
      &nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;float collisionRadius = 32; // 当たり判定の半径<br>
      &nbsp;&nbsp;float life = 1; // 耐久力<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Enemy(Vector3 pos) : GameObject( pos ) // GameObjectをベースとして初期化処理を継承する<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;typeTag = "Enemy";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;virtual void Update() = 0;//virtual ～ = 0;で【純粋仮想関数に】これで【C#のabstract型に】<br>
      <br>
      &nbsp;&nbsp;// 描画処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;virtual void Draw() = 0; //virtual ～ = 0;で【純粋仮想関数に】【関数 = 0で未定義状態を表現】<br>
      <br>
      <br>
      &nbsp;&nbsp;// 自機弾に当たったときの処理 関数の【★引数をGameObject型↓にすることで循環インクルード抑止】<br>
      &nbsp;&nbsp;virtual void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;life -= 1; // ライフを減らす<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ライフが無くなったら、死亡<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (life &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>DropItem(); // アイテムを落とす処理(落とすかどうかはoverrideされた関数次第)</em><br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// アイテムを落とす処理 継承overrideして各ザコごとに違うドロップを実装できる<br>
      &nbsp;&nbsp;virtual void DropItem()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 継承overrideして各ザコごとに違う処理を実装する<br>
      &nbsp;&nbsp;}</em><br>
      };<br>
      <br>
      #endif<br>
    </p>
<br>
<p>例として、<code>Zako1.hにアイテム0をドロップさせる処理を追加</code>します。</p>
    <p class="source">#ifndef ZAKO_1_H_<br>
      #define ZAKO_1_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      #include &lt;cmath&gt; // Sinの計算に使う<br>
      #include "MyMath.h"<br>
      #include "Image.h"<br>
      <br>
      <em>#include "MyRandom.h" // 乱数でアイテムのドロップを抽選する<br>
      #include "Item0.h"</em><br>
      <br>
      // ザコ1クラス<br>
      class Zako1 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;float sinMove = 0; // Sinの動きをする際の0～360度<br>
      &nbsp;&nbsp;float sinRadius = 70; // Sinの動きをするときの半径<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Zako1(Vector3 pos) : Enemy ( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako1";//オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;life = 5;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;position.x -= 1; // 左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;float prevSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;sinMove += 2.5f; // Sinの波運動の角度を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float currentSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// (前の角度でのY) - (今の角度でのY)の差を足すことで【ベースのyの位置 ± sinの動き】になる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;position.y += currentSinY - prevSinY; // 上下方向のSinの波運動<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako1, TRUE);<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;<em>// アイテムを落とす処理<br>
      &nbsp;&nbsp;void DropItem() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isDead) // 消えるまえに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (MyRandom::Percent(50.0f)) // 50%の確率でアイテムをドロップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.items.emplace_back(std::make_shared&lt;Item0&gt;(position));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}</em><br>
      };<br>
      <br>
      #endif<br>
    </p>
<br>
さて、これでザコ1からアイテムがドロップはしますが、まだプレイヤとアイテムの当たり判定がありません。<br>
プレイヤとアイテムの当たり判定処理を追加しましょう。<br>
<br>
<p><code>GameManager.h</code>にItemを管理するリストの定義を追加します。</p>
    <p class="source"> #ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      <br>
      #include&nbsp;"Singleton.h"<br>
      <br>
      class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      class&nbsp;PlayerBullet;<br>
      class&nbsp;Enemy;<br>
      class&nbsp;EnemyBullet;<br>
      class&nbsp;Explosion;<br>
      <em>class&nbsp;Item;</em><br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機のポインタ<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;EnemyBullet&gt;&gt; enemyBullets; // 敵弾のリスト<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;Explosion&gt;&gt; explosions; // 爆発エフェクトのリスト<br>
      &nbsp;&nbsp;<em>std::list&lt;std::shared_ptr&lt;Item&gt;&gt; items; // アイテムのリスト</em><br>
      &nbsp;&nbsp;// 複数リスト↑list ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      <br>
      (中略).............. <br>
      protected:<br>
      &nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
<p><code>Game.cpp</code>にアイテムの当たり判定の処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
	    <br>
      #include&nbsp;"MyRandom.h"<br>
	    <br>
      #include&nbsp;"Player.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h // Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"EnemyBullet.h" // Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Explosion.h" // Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako0.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako1.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako2.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako3.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako3.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <em>#include&nbsp;"Item.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 爆発エフェクトの更新処理<br>
      &nbsp;&nbsp;for (const auto&amp; e : gm.explosions)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// アイテムの更新処理<br>
      &nbsp;&nbsp;for (const auto&amp; itm : gm.items)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;itm-&gt;Update();<br>
      &nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 自機とアイテムの衝突判定<br>
      &nbsp;&nbsp;for (const auto&amp; itm : gm.items)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;break;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// アイテムが死んでたらスキップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (itm-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;continue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;itm-&gt;position, itm-&gt;collisionRadius) )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;itm-&gt;OnCollisionPlayer(gm.player);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;<br>
      <br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;// 敵のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;// 敵弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemyBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;EnemyBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;//爆発エフェクトのリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.explosions,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Explosion&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;<em>//アイテムのリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.items,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Item&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;(中略)......<br>
      <br>
      &nbsp;&nbsp;// 敵弾の描画処理<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.enemyBullets)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// アイテムの描画処理<br>
      &nbsp;&nbsp;for (const auto&amp; itm : gm.items)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;itm-&gt;Draw();<br>
      &nbsp;&nbsp;}</em><br>
      }<br>
    </p>
	  <br>
	  さて、ザコ1を倒すと回復アイテムを50%の確率でドロップし、プレイヤがそれを取るとライフが1回復するようになりましたか？<br>
	  <br>
	  <br>
<h1><a id="mozTocId3007" class="mozTocH1"></a>Item0を画面のはしっこで光らせてバウンドさせる処理の作成</h1>
<code>Item0.hに画面のはしっこの反射処理とisFlashフラグで一瞬光らせる処理を追加</code>します。<br>
    <p class="source">#ifndef ITEM_0_H_<br>
      #define ITEM_0_H_<br>
      <br>
      #include "Item.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <br>
      // アイテム0クラス ライフを回復するアイテム<br>
      class Item0 : public Item<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int amount; // 回復量など<br>
      &nbsp;&nbsp;&nbsp; <em>int bounceNum; // 跳ね返る回数<br>
      &nbsp;&nbsp;&nbsp; bool isFlash; // 画面が一瞬真っ白になる(跳ね返る瞬間)</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Item0(Vector3 pos,<br>
      &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Vector3 v = Vector3{ -0.5f,0.0f }, // デフォルトは-0.5fで遅めのスクロール量<br>
      &nbsp;&nbsp;&nbsp; <em>&nbsp; &nbsp; &nbsp; bool isFlash = false, int bounceNum = 0,</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; int amount = 1)<br>
      &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; : <em>isFlash{ isFlash }, bounceNum{ bounceNum }, </em>amount{ amount }, Item(pos, v, 8)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Item0"; // オブジェクトの判別タグ<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;this-&gt;position += this-&gt;v; // vのx,y量ぶん移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<em>if (bounceNum &gt; 0) // 反射可能回数が 0 以上なら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;bool isBounce = false; // 反射するか<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (position.x &lt; collisionRadius)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;v.x = -v.x; // x逆方向に反射(マイナスをつけて方向反転)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position.x = collisionRadius; // めりこんだぶんをスクリーンの境界線に沿わす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isBounce = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (Screen::Width - collisionRadius &lt; position.x)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;v.x = -v.x; // x逆方向に反射(マイナスをつけて方向反転)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position.x = Screen::Width - collisionRadius; // めりこんだぶんを境界線に沿わす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isBounce = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (position.y &lt; collisionRadius)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;v.y = -v.y; // y逆方向に反射(マイナスをつけて方向反転)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position.y = collisionRadius; // めりこんだぶんをスクリーンの境界線に沿わす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isBounce = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (Screen::Height - collisionRadius &lt; position.y)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;v.y = -v.y; // y逆方向に反射(マイナスをつけて方向反転)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position.y = Screen::Height - collisionRadius; // めりこんだぶんを境界線に沿わす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isBounce = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (isBounce) // 反射判定がtrueならば<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;--bounceNum; // 跳ね返り可能回数を -1 する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;v *= 0.94f; // 反射時のスピード減衰率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isFlash = true; // 画面を一瞬フラッシュする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;// スクリーンの画面外になったらisDeadにして消す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;if (position.x + collisionRadius &lt; 0 || Screen::Width &lt; position.x - collisionRadius<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; || position.y + collisionRadius &lt; 0 || Screen::Height &lt; position.y - collisionRadius )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if (isFlash) // 画面を一瞬真っ白にする(跳ね返る瞬間)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// 画面のスクリーンと同じサイズの大きな白い四角を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DrawBox(0, 0, Screen::Width, Screen::Height, GetColor(200, 200, 200), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// 白画面の上に黒丸を描くとバウンド位置が目立つ(衝撃波っぽい)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DrawCircle(position.x, position.y, collisionRadius * 5, GetColor(0, 0, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, <em>(isFlash)? 2.0f : </em>1, 0, Image::item0, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>isFlash = false; // すぐにfalseに戻せば一瞬だけしか光らない</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 自機に当たったときの処理 上書きoverrideする<br>
      &nbsp;&nbsp; &nbsp;void OnCollisionPlayer(std::shared_ptr&lt;GameObject&gt; object)  override;<br>
      };<br>
      <br>
      #endif</p>
      <br>
<p>例として、<code>Zako1.hにアイテム0の初速度と反射する回数と乱数で飛ぶ角度を決めて初期化する処理を追加</code>します。</p>
    <p class="source">#ifndef ZAKO_1_H_<br>
      #define ZAKO_1_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      #include &lt;cmath&gt; // Sinの計算に使う<br>
      #include "MyMath.h"<br>
      #include "Image.h"<br>
      <br>
      #include "MyRandom.h" // 乱数でアイテムのドロップ<em>と飛ぶ角度</em>を抽選する<br>
      #include "Item0.h"<br>
      <br>
      // ザコ1クラス<br>
      class Zako1 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;float sinMove = 0; // Sinの動きをする際の0～360度<br>
      &nbsp;&nbsp;float sinRadius = 70; // Sinの動きをするときの半径<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Zako1(Vector3 pos) : Enemy ( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako1";//オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;life = 5;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;position.x -= 1; // 左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;float prevSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;sinMove += 2.5f; // Sinの波運動の角度を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float currentSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// (前の角度でのY) - (今の角度でのY)の差を足すことで【ベースのyの位置 ± sinの動き】になる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;position.y += currentSinY - prevSinY; // 上下方向のSinの波運動<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako1, TRUE);<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// アイテムを落とす処理<br>
      &nbsp;&nbsp;void DropItem() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isDead) // 消えるまえに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (MyRandom::Percent(50.0f)) // 50%の確率でアイテムをドロップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>float itemSpeed = 25.0f; // アイテムの飛び出すスピード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float angle = MyRandom::Range(0.0f, 360.0f) * MyMath::Deg2Rad; // 飛び出す角度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 v_Item{ std::cos(angle) * itemSpeed, std::sin(angle) * itemSpeed }; // 飛ぶ方向ベクトル<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int bounceNum = 10; // バウンド回数</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.items.emplace_back(std::make_shared&lt;Item0&gt;(position<em>, v_Item, true, bounceNum</em>));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
<br>
いかがでしょう、アイテムが画面のはしっこでバウンドして、一瞬画面がフラッシュするようになりましたか？<br>
現状シューティングの構成要素は「プレイヤ」「敵」「弾」「アイテム」ですが、そのうち自由にアレンジできるのは「敵、弾、アイテム」です。<br>
「敵、弾」が増えたとしてもゲームが難しくなるだけなので工夫したところで、プレイヤが苦戦するだけで面白さのアレンジの限界が来るはずです。<br>
一方、3つのうち<b>「アイテム」だけがプレイヤ側のメリットとなる変化をゲームに起こす</b>ことができます。<br>
敵の弾がバウンドしたとしても、画面に弾があふれかえっている状況だと何が何だかわからなくなるでしょう。<br>
なので、効果的にバウンドさせて見せるなら「アイテム」のほうがよいかな、と思いました。<br>
また、アイテムは取れなくてもそれはそれでゲームは進むので、ゆったり単調に動くよりは、高速で動くほうが、ゲームにメリハリがつくかと思います。<br>
<br>
ただのバウンドではありますが、モンストもただのバウンドをひたすら発展させてヒットに向かったわけなので<b>「シンプルなものこそあなどることなかれ」</b>ですね。<br>
<br>
	  
<h1><a id="mozTocId3008" class="mozTocH1"></a>Item1クラスでボスへクリティカルヒットしたらバリアーとなる星のアイテムをドロップする処理の作成</h1>
<p>ボスから「プレイヤの周りをまわって、敵の弾からプレイヤを守る星バリアのアイテム」をドロップさせてみましょう。<br>
      GIMPで16×16のスターのドット絵画像を自作して<code>star.pngという名前でpng画像としてDXプロジェクトのImageフォルダにエクスポート</code>しておきましょう。</p>
・<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/image/star.xcf">star.xcf(GIMPの編集ファイル)</a>←右クリック[名前をつけてリンク先を保存]でダウンロードすればGIMPで編集できる<br>
・<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/image/star.png">star.png(↑GIMPから名前をつけてエクスポートしたpng画像ファイル)</a>←右クリック[名前をつけてリンク先を保存]でダウンロード<br>    
<img src="image/gimp_star_dot.png">
    <p><code>Image.h</code>にstar.pngの読込み処理を追加します。</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "DivImage.h" // 分割画像の読込みに使う<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;static void Load();<br>
      &nbsp;&nbsp;static int LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage);<br>
      <br>
      &nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int player; //プレイヤ画像のハンドラ<br>
      &nbsp;&nbsp;static int playerBullet; //プレイヤの弾画像のハンドラ<br>
      &nbsp;&nbsp;static int enemyBullet16; //敵弾 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako0; //ザコ0 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako1; //ザコ1 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako2; //ザコ2 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako3; //ザコ3 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int boss1; //ボス通常 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int boss2; //ボス2気絶 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int boss3; //ボス3発狂 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static DivImage explosion; // [分割画像]爆発エフェクト<br>
      &nbsp;&nbsp;static int item0; //アイテム0 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;<em>static int item1; //アイテム1 画像のハンドラ(読込画像番号)</em><br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
      <br>
      int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      int Image::player{-1};<br>
      int Image::playerBullet{-1};<br>
      int Image::enemyBullet16{-1};<br>
      int Image::zako0{-1};<br>
      int Image::zako1{-1};<br>
      int Image::zako2{-1};<br>
      int Image::zako3{-1};<br>
      int Image::boss1{-1};<br>
      int Image::boss2{-1};<br>
      int Image::boss3{-1};<br>
      // ★分割画像は初期化のときに{X方向画像数, Y方向画像数, 画像横幅XSize,画像縦幅YSize}を指定<br>
      DivImage Image::explosion{ 8, 2, 64, 64 };<br>
      int Image::item0{-1};<br>
      <em>int Image::item1{-1};</em><br>
      <br>
      void Image::Load()<br>
      {<br>
      &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;player= LoadGraph("Image/player.png");<br>
      &nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;playerBullet = LoadGraph("Image/player_bullet.png");<br>
      &nbsp;&nbsp;assert(playerBullet!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;enemyBullet16 = LoadGraph("Image/enemy_bullet_16.png");<br>
      &nbsp;&nbsp;assert(enemyBullet16!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako0 = LoadGraph("Image/zako0.png");<br>
      &nbsp;&nbsp;assert(zako0!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako1 = LoadGraph("Image/zako1.png");<br>
      &nbsp;&nbsp;assert(zako1!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako2 = LoadGraph("Image/zako2.png");<br>
      &nbsp;&nbsp;assert(zako2!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako3 = LoadGraph("Image/zako3.png");<br>
      &nbsp;&nbsp;assert(zako3!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;boss1 = LoadGraph("Image/boss1.png");<br>
        &nbsp;&nbsp;assert(boss1!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;boss2 = LoadGraph("Image/boss2.png");<br>
        &nbsp;&nbsp;assert(boss2!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;boss3 = LoadGraph("Image/boss3.png");<br>
        &nbsp;&nbsp;assert(boss3!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;// div分割画像をロード<br>
      &nbsp;&nbsp;Image::LoadDivGraph("Image/explosion.png", explosion);<br>
      &nbsp;&nbsp;for (int i = 0; i &lt; explosion.AllNum; i++)<br>
      &nbsp;&nbsp;{ // 画像読込失敗<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (explosion.HandleArray[i] == -1) assert("爆発分割画像読込失敗" == "");<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;item0 = LoadGraph("Image/heart.png");<br>
      &nbsp;&nbsp;assert(item0!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;<em>item1 = LoadGraph("Image/star.png");<br>
      &nbsp;&nbsp;assert(item1!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      }<br>
      <br>
      // DXライブラリのLoadDivGraphを使いやすくラッピング<br>
      // ★関数に参照渡しを行う<br>
      // 関数の引数に参照渡しを行うことでdivImageの中身を書き換えることができる(値渡しでは書換不可)<br>
      //　https://qiita.com/agate-pris/items/05948b7d33f3e88b8967<br>
      // https://qiita.com/RuthTaro/items/f35c3a26779c0ca1a41a<br>
      int Image::LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage)<br>
      {<br>
      &nbsp;&nbsp;return DxLib::LoadDivGraph(FileName, divImage.XNum * divImage.YNum,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;divImage.XNum, divImage.YNum, divImage.XSize, divImage.YSize, divImage.HandleArray);<br>
      };<br>
    </p>
<br>
<code>Item.hに敵弾と衝突した際に呼び出されるベースとなるコールバック関数を定義</code>します。<br>
    <p class="source">#ifndef ITEM_H_<br>
      #define ITEM_H_<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      #include "GameManager.h"<br>
      <br>
      // アイテムのベース基底クラス<br>
      class Item : public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; //【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; GameManager& gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&)を得る<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; float collisionRadius; // 当たり判定の半径<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <em>enum class CollisionTo // 当たり判定の対象(ビット32桁に1を立てて表現)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; None = 0,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Player &nbsp; &nbsp; &nbsp;= 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; EnemyBullet = 0b0000'0000'0000'0000'0000'0000'0000'0010,<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; CollisionTo collisionTo = CollisionTo::Player; // デフォルトはプレイヤとの当たりを判定する</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ v:移動速度(方向) radius:当たり判定の半径<br>
      &nbsp;&nbsp;&nbsp; Item(Vector3 pos, Vector3 v, float radius = 8)<br>
      &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; : collisionRadius{ radius }, GameObject( pos ) // GameObjectをベースとして初期化処理を継承する<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "Item"; // オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;v = v; // GameObjectの速度vを利用する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() = 0;//virtual ～ = 0;で【純粋仮想関数に】これで【C#のabstract型に】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() = 0; //virtual ～ = 0;で【純粋仮想関数に】【関数 = 0で未定義状態を表現】<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 自機に当たったときの処理 派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp; &nbsp;virtual void OnCollisionPlayer(std::shared_ptr&lt;GameObject&gt; object)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// アイテムごとに継承でoverrideして個別処理を書く<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;<em>// 敵弾とぶつかった時の処理<br>
      &nbsp;&nbsp; &nbsp;virtual void OnCollisionEnemyBullet(std::shared_ptr&lt;GameObject&gt; object)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// アイテムごとに継承でoverrideして個別処理を書く<br>
      &nbsp;&nbsp; &nbsp;}</em><br>
      };<br>
      <br>
      #endif</p>
<br>
<code>Item1.hを新規作成</code>します。<br>
    <p class="source">#ifndef ITEM_1_H_<br>
      #define ITEM_1_H_<br>
      <br>
      #include "Item.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include "MyMath.h"<br>
      #include &lt;cmath&gt;<br>
      <br>
      // アイテム1クラス プレイヤを敵弾から守り身代わりになるバリアアイテム<br>
      class Item1 : public Item<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int life; // バリアー(星)の耐える回数<br>
      &nbsp;&nbsp;&nbsp; float xForce = 0.1f; // 加速の力(流れ星の加速)<br>
      &nbsp;&nbsp;&nbsp; enum class State<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Popping, // ポップ(飛び出した勢いのあるあいだ)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Shooting,// 流れ星(加速して流れていく)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Barrier, // バリアモードのとき<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; State state = State::Popping; // 動作状態<br>
      &nbsp;&nbsp;&nbsp; GameObject* pParent{ nullptr }; // 親となっているプレイヤなどへのリンク(バリアの中心点)<br>
      &nbsp;&nbsp;&nbsp; float barrierRadius; // バリアの円回転の半径<br>
      &nbsp;&nbsp;&nbsp; float barrierAngle = 0.0f; // バリアの回転角度<br>
      &nbsp;&nbsp;&nbsp; bool isHiting = false; // 敵弾にヒットした時に一瞬拡大して表示<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Item1(Vector3 pos,<br>
      &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Vector3 v = Vector3{ -0.5f,0.0f }, // デフォルトは-0.5fで遅めのスクロール量<br>
      &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; int life = 3, float xForce = 0.8f, float barrierRadius = 40.0f)<br>
      &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; : life{ life }, xForce{ xForce }, barrierRadius{ barrierRadius },<br>
      &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Item(pos, v, 8)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Item1"; // オブジェクトの判別タグ<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;if (state == State::Popping) // 飛び出した勢いは段々減る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position += v; // vのx,y量ぶん移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;v *= 0.85f; // 速度が減衰<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (v.magnitude() &lt; 0.01f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;state = State::Shooting; // 流れ星モードに移行<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;else if (state == State::Shooting)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position += v; // vのx,y量ぶん移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;v.x -= xForce; // 流れ星が少しずつ加速する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;else if (state == State::Barrier &amp;&amp; pParent != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;barrierAngle += 5.5f; // 毎フレーム5.5度ずつ回転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position.x = pParent-&gt;position.x + barrierRadius * std::cos(barrierAngle * MyMath::Deg2Rad);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position.y = pParent-&gt;position.y + barrierRadius * std::sin(barrierAngle * MyMath::Deg2Rad);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (pParent-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isDead = true; // 親のプレイヤリンク先がisDeadなら連動して消す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;if (state != State::Barrier) // バリア状態でないときに画面外に出たら消す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクリーンの画面外になったらisDeadにして消す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (position.x + collisionRadius &lt; 0 || Screen::Width &lt; position.x - collisionRadius<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; || position.y + collisionRadius &lt; 0 || Screen::Height &lt; position.y - collisionRadius )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, (isHiting)? 2.0f : 1, 0, Image::item1, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 自機に当たったときの処理 上書きoverrideする<br>
      &nbsp;&nbsp; &nbsp;virtual void OnCollisionPlayer(std::shared_ptr&lt;GameObject&gt; object)  override;<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 敵弾とぶつかった時の処理<br>
      &nbsp;&nbsp; &nbsp;virtual void OnCollisionEnemyBullet(std::shared_ptr&lt;GameObject&gt; object)  override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!((int)collisionTo &amp; (int)CollisionTo::EnemyBullet))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return; // 敵弾と当たり判定しない設定のときは何もせずreturn<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (life &lt;= 0) // ライフ(バリアの耐久回数)が0以下になったら<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isDead = true; // 当たった直後に消える<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isHiting = true; // 一瞬拡大して表示<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;--life; // ライフ(バリアの耐久回数)を減らす<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
      <br>
<br>
<code>Item1.cppを新規作成</code>します。<br>
    <p class="source">#include "Item1.h"<br>
      <br>
      #include "Player.h" // アイテムとプレイヤは相互にインクルードしそうなのでcppで#include<br>
      <br>
      // 自機に当たったときの処理 上書きoverrideする<br>
      void Item1::OnCollisionPlayer(std::shared_ptr&lt;GameObject&gt; object)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (!((int)collisionTo &amp; (int)CollisionTo::Player))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return; // プレイヤと当たり判定しないenumビット設定のときは何もせずreturn<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; //[共有ポインタをダウンキャスト(親GameObject → 子Playerに)]<br>
      &nbsp;&nbsp;&nbsp; // https://cpprefjp.github.io/reference/memory/shared_ptr/dynamic_pointer_cast.html<br>
      &nbsp;&nbsp;&nbsp; if (std::shared_ptr&lt;Player&gt; pPlayer = std::dynamic_pointer_cast&lt;Player&gt;(object))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pParent = pPlayer.get(); // プレイヤへのリンクを親リンクとしてリンクされた(x,y)を中心に回転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = State::Barrier; // バリアモードへ移行<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collisionTo = CollisionTo::EnemyBullet; // 敵弾との当たり判定モードに移行<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      </p>
      <br>
<br>
<code>Item0.cppにも当たり判定の種類の判定(PlayerかEnemyBulletかの判定)を追加</code>します。<br>
    <p class="source">#include "Item0.h"<br>
      <br>
      #include "Player.h" // アイテムとプレイヤは相互にインクルードしそうなのでcppで#include<br>
      <br>
      // 自機に当たったときの処理 上書きoverrideする<br>
      void Item0::OnCollisionPlayer(std::shared_ptr&lt;GameObject&gt; object)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; <em>if (!((int)collisionTo &amp; (int)CollisionTo::Player))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return; // プレイヤと当たり判定しないenumビット設定のときは何もせずreturn</em><br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; //[共有ポインタをダウンキャスト(親GameObject → 子Playerに)]<br>
      &nbsp;&nbsp;&nbsp; // https://cpprefjp.github.io/reference/memory/shared_ptr/dynamic_pointer_cast.html<br>
      &nbsp;&nbsp;&nbsp; if (std::shared_ptr&lt;Player&gt; pPlayer = std::dynamic_pointer_cast&lt;Player&gt;(object))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer->RecoverLife(amount); // ライフを回復する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; isDead = true; // 取ったら消される<br>
      }<br>
      </p>
      <br>
<p>例として<code>Boss.hで弾が当たったy位置が ±5 以内のときクリティカルと判定してバリアーの星を出す処理</code>を追加します。</p>
<p class="source">#ifndef BOSS_H_<br>
      #define BOSS_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      #include "Image.h"<br>
      <br>
      #include &lt;cmath&gt; // Sin Cosの計算に使う<br>
      #include "MyMath.h"<br>
      #include "MyRandom.h" // 乱数方向弾<em>とバリアーの星の飛び出す方向の抽選</em>に使う<br>
      <em>#include "Item1.h"<br>
      #include "PlayerBullet.h"</em><br>
      <br>
      // ボスクラス。Enemyを継承して作る<br>
      class Boss : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // ボスの状態種別<br>
      &nbsp;&nbsp;&nbsp; enum class State<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Appear, // 登場<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Normal, // 通常時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Swoon, // 気絶時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Angry, // 発狂モード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dying, // 死亡<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; State state = State::Appear; // 現在の状態<br>
      &nbsp;&nbsp;&nbsp; int swoonTime = 120; // 残り気絶時間<br>
      &nbsp;&nbsp;&nbsp; int dyingTime = 180; // 死亡時のアニメーション時間<br>
      <br>
      &nbsp;&nbsp;&nbsp; int coolTime = 0; // クールタイム(冷却時間。0になるまで次の弾が撃てない)<br>
      &nbsp;&nbsp;&nbsp; float sinMove = 0; // Sinの動きをする際の0～360度<br>
      &nbsp;&nbsp;&nbsp; float sinRadius = 120; // Sinの動きをするときの半径<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>bool isCritical = false; // 弾に当たった瞬間の yが ±2 以内のときクリティカルと判定<br>
      &nbsp;&nbsp;&nbsp; Vector3 criticalPos{0,0,0}; // クリティカルヒットした位置</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Boss(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Boss"; // オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life = 100; // ライフ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collisionRadius = 70; // 当たり判定半径<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state == State::Appear) // 登場状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x -= 1; // 左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (position.x &lt;= 750) // x座標が750以下になったら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = State::Normal; // 通常状態へ移行<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Normal) // 通常状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime--;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (coolTime &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp; // ボスの弾はスピード16で2倍の速度で撃ち出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, 180 * MyMath::Deg2Rad, 16));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime += 200; // そのかわり発射間隔は長め<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float prevSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sinMove += 2.5f; // Sinの波運動の角度を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float currentSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (前の角度でのY) - (今の角度でのY)の差を足すことで【ベースのyの位置 ± sinの動き】になる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y += currentSinY - prevSinY; // 上下方向のSinの波運動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Swoon) // 気絶状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; swoonTime--; // タイマー減少<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (swoonTime &lt;= 0) // タイマーが0になったら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime = 0; // クールタイムを0にリセットしてから<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = State::Angry; // 発狂モードへ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Angry) // 発狂モード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime--;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (coolTime &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, 180 * MyMath::Deg2Rad, 16));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime += 20;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float prevSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sinMove += 10.5f; // Sinの波運動の角度を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float currentSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (前の角度でのY) - (今の角度でのY)の差を足すことで【ベースのyの位置 ± sinの動き】になる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.y += currentSinY - prevSinY; // 上下方向のSinの波運動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Dying) // 死亡中<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dyingTime--; // タイマー減少<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dyingTime &lt;= 0) // タイマーが0になったら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isDead = true; // 完全に消滅<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state == State::Appear || state == State::Normal) // 登場時と通常時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss1, TRUE); // 普通の画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Swoon) // 気絶時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss2, TRUE); // 気絶時の画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Angry) // 発狂モード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss3, TRUE); // 怒ってる画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Dying) // 死亡中<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss2, TRUE); // 気絶時の画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if (isCritical)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 画面のスクリーンと同じサイズの大きな白い四角(フラッシュ)を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawBox(0, 0, Screen::Width, Screen::Height, GetColor(200, 200, 200), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 白フラッシュの上に黒丸を描くとクリティカルヒットした位置が目立つ(衝撃波っぽい)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawCircle(position.x, position.y, 10, GetColor(0, 0, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isCritical = false; // クリティカルフラグをfalseにすぐ戻す(フラッシュ点滅)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 自機弾に当たったときの処理をoverride（上書き）する<br>
      &nbsp;&nbsp; &nbsp;void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet) override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 登場時、気絶時、死亡時は被弾しても何もしない<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (state == State::Appear || state == State::Swoon || state == State::Dying)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;life -= 1; // ライフを減らす<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>float posY = position.y; // [ボス中心y]と[当たった瞬間の弾のy]が ±5 ならクリティカル<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (posY - 5 &lt;= playerBullet-&gt;position.y &amp;&amp; playerBullet-&gt;position.y &lt;= posY + 5)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isCritical = true; // クリティカルフラグをtrueに<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;criticalPos = playerBullet->position; // クリティカルヒットした位置を記録する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DropItem(); // バリアの星アイテムを落とす<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (life &lt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ライフが無くなったら、すぐ消滅するのではなく、死亡状態へ移行<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;state = State::Dying;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (state == State::Normal &amp;&amp; life &lt;= 50)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 通常状態でライフが50以下になったら、気絶する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;state = State::Swoon;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;<em>// アイテムを落とす処理<br>
      &nbsp;&nbsp; &nbsp;void DropItem() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (MyRandom::Percent(100.0f)) // 100%の確率でバリアになる星をドロップ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float itemSpeed = 25.0f; // アイテムの飛び出すスピード<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float angle = MyRandom::Range(0.0f, 360.0f) * MyMath::Deg2Rad; // 飛び出す角度<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Vector3 v_Item{ std::cos(angle) * itemSpeed, std::sin(angle) * itemSpeed }; // 飛ぶ方向ベクトル<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int barrierLife = 3; // バリアは敵弾に3回当たるまでガードしてくれる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.items.emplace_back(std::make_shared&lt;Item1&gt;(position, v_Item, barrierLife));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}</em><br>
      };<br>
      <br>
      #endif</p>
<br>
<p><code>EnemyBullet.hにアイテムと衝突したさいの関数</code>を追加します。</p>
    <p class="source">#ifndef ENEMYBULLET_H_<br>
      #define ENEMYBULLET_H_<br>
      <br>
      #include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include "Vector3.h"<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      // 敵弾クラス<br>
      class EnemyBullet: public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const int VisibleRadius = 8; // 見た目の半径<br>
      &nbsp;&nbsp;<br>
      <br>
      &nbsp;&nbsp;float angle; // 移動角度(垂直Vertical)<br>
      &nbsp;&nbsp;float angleH=0; // 移動角度(水平Horizontal)<br>
      <br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;EnemyBullet(Vector3 pos, float angle, float speed) : GameObject( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angle = angle;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 角度からx方向の移動速度を算出<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.x = (float)std::cos(angle) * speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 角度からy方向の移動速度を算出<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.y = (float)std::sin(angle) * speed;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;EnemyBullet(Vector3 pos, float angleV, float angleH, float speed) : GameObject( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angle = angleV;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angleH = angleH;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [3Dの角度は水平・垂直に分割]https://teratail.com/questions/126004<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float cosAngleV = (float)std::cos(angle);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 角度からx方向の移動速度を算出<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.x = cosAngleV * (float)std::sin(angleH) * speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 角度からy方向の移動速度を算出<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.y = (float)std::sin(angle) * speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 角度からz方向の移動速度を算出<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.z = cosAngleV * (float)std::cos(angleH) * speed;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度の分だけ移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;position += v;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 画面外に出たら死亡フラグを立てる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (position.y + VisibleRadius &lt; 0 || position.y - VisibleRadius &gt; Screen::Height ||<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.x + VisibleRadius &lt; 0 || position.x - VisibleRadius &gt; Screen::Width)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, angle, Image::enemyBullet16,TRUE);<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// プレイヤにぶつかった時の処理<br>
      &nbsp;&nbsp;void OnCollisionPlayer(std::shared_ptr&lt;GameObject&gt; other)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;<em>// アイテム(プレイヤの回りをまわるバリア)にぶつかった時の処理<br>
      &nbsp;&nbsp;void OnCollisionItem(std::shared_ptr&lt;GameObject&gt; other)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;}</em><br>
      };<br>
      <br>
      #endif</p>
<p><code>Game.cpp</code>にアイテムの当たり判定の処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
	    <br>
      #include&nbsp;"MyRandom.h"<br>
	    <br>
      #include&nbsp;"Player.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h // Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"EnemyBullet.h" // Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Explosion.h" // Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako0.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako1.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako2.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako3.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako3.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Item.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 爆発エフェクトの更新処理<br>
      &nbsp;&nbsp;for (const auto&amp; e : gm.explosions)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アイテムの更新処理<br>
      &nbsp;&nbsp;for (const auto&amp; itm : gm.items)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;itm-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機とアイテム<em>、敵弾とアイテム</em>の衝突判定<br>
      &nbsp;&nbsp;for (const auto&amp; itm : gm.items)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;break;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// アイテムが死んでたらスキップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (itm-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;continue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;itm-&gt;position, itm-&gt;collisionRadius) )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;itm-&gt;OnCollisionPlayer(gm.player);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>for (const auto&amp; enemyBullet : gm.enemyBullets)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 敵弾が死んでたらスキップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (enemyBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;itm-&gt;position, itm-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;enemyBullet-&gt;position, enemyBullet-&gt;collisionRadius) )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemyBullet-&gt;OnCollisionItem(itm);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;itm-&gt;OnCollisionEnemyBullet(enemyBullet);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      <br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;// 敵のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;// 敵弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemyBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;EnemyBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;//爆発エフェクトのリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.explosions,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Explosion&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;//アイテムのリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.items,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Item&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;(中略)......<br>
      }<br>
    </p>
<br>
<br>
いかがですか、ボスに弾を打ち込むとときどきクリティカルヒットして、星が飛び出し、<br>
左方向に加速しながら流れ星して、取るとプレイヤの周りをまわるバリアとなり、敵の弾から身代わりとなってガードしてくれれば成功です。<br>
<br>
流れ星の動き方は、今回はアイテムとして作りましたが、<br>
敵から秘密兵器のミサイルとして「EnemyBullet2」クラスとして自作すれば、敵のミサイル攻撃としても使える動きになると思います。<br>
<br>
また、星もバリアじゃなく<a href="https://youtu.be/37oQA2Vaz1M?t=87">カービーのようなエフェクト</a>としての使い方や、取るとスコアアップなど色んな使い方が企画できます。<br>
<br>
<br>
    <a id="mozTocId4000" class="mozTocH1"></a>
    <p class="title">[C++]シューティングゲーム 4</p>
    <br>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId4001">シーンを分ける(循環インクルードを避けメモリも管理するには?)</a><br>
        <a href="#mozTocId40012">【高難度】画面やステージごとにImageのメモリを開放する</a><br>
        <a href="#mozTocId40013">サウンドの読込みと再生機能</a><br>
        <a href="#mozTocId40014">【高難度】画面やステージごとにサウンドをメモリ読込み・解放(音量調整機能も追加)</a><br>
      </li>
      <li><a href="#mozTocId4002">CSVを読み込んで敵を生成するプログラム</a><br>
        <a href="#mozTocId40022">カスタムしたデータ構造DataCsv.hでデータ自身にLoadと幅高さ管理を任せる</a><br>
        <a href="#mozTocId40023">【高難度】敵データの全方位読出しアルゴリズム</a><br>
      </li>
      <li><a href="#mozTocId4003">自機狙い弾</a></li>
      <li><a href="#mozTocId4004">自機に向かってくる敵</a></li>
      <br>
      <p>次のテキスト5はこちら。</p>
      <br>
      <a href="#mozTocId5000">[C++]シューティングゲーム 5【応用1】</a><br>
    </ol>
    <h1><a id="mozTocId4001" class="mozTocH1"></a>シーンを分ける(循環インクルードを避けメモリも管理するには?)</h1>
    <p>タイトルやプレイ画面やゲームオーバーのシーンを分けましょう。<br>
      シーンは構造的に<code>タイトル⇒プレイ画面⇒ゲームオーバー⇒タイトル...とループする</code>ので<br>
      普通に考えれば循環インクルードしやすいですね。<br>
      ということで基本方針としては</p>
    <ol>
      <li>マネージャの.hヘッダに現在のシーンと一つ前のシーンを保持</li>
      <li>マネージャの.cppで各シーンをインクルードして画面チェンジ機能の処理を作成する</li>
      <li>各シーンではマネージャの.hをインクルードして画面チェンジ機能を呼び出す</li>
    </ol>
    <p>上記の構造であれば、マネージャの.hヘッダで循環は止まります、なぜか?<br>
      マネージャの.hヘッダには【画面チェンジ機能の定義だけ】があり、各シーンをインクルード必要としません。<br>
      実際の<b>【画面チェンジ機能の処理はcppに書き】【cppで各シーンの.hヘッダをインクルードします】</b><br>
    </p>
    <p>さて、実際のプログラムをしてみましょう。<br>
      <b>【シーン専門のマネージャーSceneManagerを作ることにしましょう】</b>(GameManagerでやっても良いですが)。 <br>
      管理方針は人によりますが、現状のマネージャーの役割は一度ここで整理しておいた方がよいですね</p>
    <ol>
      <li>【ゲームのマネージャ役】敵リストなど<b>メモリへのリンクを保持</b>する</li>
      <li>【ゲームのマネージャ役2】メモリから<b>isDeadの要素などを高速削除</b>する機能</li>
      <li>【ゲームのマネージャ役3】メモリの<b>要素同士の連絡の【参照を集約】</b>して隠れた参照をしないように整理する</li>
      <li>【シーンのマネージャ役】現在と前の画面の<b>メモリへのリンクを保持</b>する</li>
      <li>【シーンのマネージャ役2】次の画面へ<b>シーンをチェンジ</b>する(チェンジするだけでなく前画面の<b>弾などのメモリ参照を外さないとメモリに残り続ける</b>)</li>
      <li>【シーンのマネージャ役3】<b>前の画面の弾など【終了時のメモリ参照の掃除】</b>を<b>【各シーンに号令をかける】</b></li>
    </ol>
    <p>シーンの遷移こそがある意味【一番のメモリの管理の「要所」】。</p>
    <p>なぜなら<b>【画面チェンジは実質≒前の画面のメモリへの参照リンクお掃除】</b>に近いですから。</p>
    <p>気をつけてくださいね<b>【メモリの回し読みポインタの参照リンクお掃除しないと】</b>前の画面の<b>メモリはフリーになりません</b></p>
    <h2>シーンマネージャで画面遷移を作成する(Game.cppからコードを画面に分けて移植)</h2>
    <p>Scene.hを新規作成してベースとなるシーンの基底クラスを定義しましょう。<br>
      <b>ポイント要点は【開始Initialize()】と【終了Finalize()】を区別していることです。</b><br>
      いままでもInit()や初期化コンストラクタはありましたが<br>
      <b>【終了の Finalize() 】を分けることでシーンの切替えのタイミングで弾のメモリなどのリセットの処理を書けます。</b><br>
      <b>【Initialize()には生成や初期化】【Finalize()にはメモリなどのリセット処理】</b>を書き分けましょう。<br>
      つまり<b>【シーンの移り変わりが出てきたからこそ】【終了のFinalize()の概念も必要になってきた】</b>ということですね。<br>
      逆に今までは1つの画面しかなかったので初期化のInit()だけでよかったわけですね。</p>
    <p><code>Scene.hを新規作成</code>してベースとなるシーンの基底クラスを定義します。</p>
    <p class="source">#ifndef SCENE_H_<br>
      #define SCENE_H_<br>
      <br>
      #include &lt;string&gt; // シーンの判別文字列tagに使う<br>
      <br>
      // シーンの基底クラス あいまいなabstract型タイプ<br>
      class Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;std::string tag = ""; // シーンの種類の判別に使う<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;//★仮想デストラクタ【忘れるとメモリがヤバいダメ絶対】<br>
      &nbsp;&nbsp; &nbsp;//【注意！】ベースの基底では必ず定義しないとstringなどが浪費され極悪なメモリ被害に発展<br>
      &nbsp;&nbsp; &nbsp;virtual ~Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 特に配列とかなくても★string文字列も内部では実質配列だから！5文字分のメモリとかがすり減ってく..<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 仮想デストラクタはstringなど暗黙に内部に配列を持つ要素のデストラクタを暗黙に呼んでくれている！<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;//★純粋仮想関数=0は継承したPlaySceneなどの必須機能(継承したら絶対override必須縛り)<br>
      &nbsp;&nbsp; &nbsp;// 必須縛りによってSceneを継承したものは【Update,Drawが実装されてるはずの確証があるので】<br>
      &nbsp;&nbsp; &nbsp;// for文であいまいなSceneのまま【まとめてUpdate,Drawできる】のだ。<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;virtual void Initialize() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じくリセット処理を行うがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp; &nbsp;virtual void Finalize() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;virtual void Update() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;virtual void Draw() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>SceneManager.hを新規作成</code>してシーンを管理するクラスを定義しましょう。</p>
    <p class="source">#ifndef SCNENEMANAGER_H_<br>
      #define SCNENEMANAGER_H_<br>
      <br>
      #include &lt;vector&gt;<br>
      #include &lt;memory&gt;<br>
      #include &lt;string&gt;<br>
      #include &lt;assert.h&gt; // シーン読み込みの失敗表示用<br>
      <br>
      #include "Singleton.h"<br>
      <br>
      class Scene; //クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      <br>
      class SceneManager : public Singleton&lt;SceneManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;friend class Singleton&lt;SceneManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <b>// マネージャを【どこからでもアクセスしやすい「変数の掲示板」として使えばシーンをまたぐ変数も定義できる】</b><br>
      &nbsp;&nbsp;&nbsp; std::string selectStage = "stage1"; // 選択中のステージ名など<br>
      &nbsp;&nbsp; &nbsp;int scoreMax = -1; // 【シーンをまたぐスコアなど】はマネージャに定義すれば【シーンをまたいだあとも】消えず残る<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp; &nbsp;std::shared_ptr&lt;Scene&gt; prevScene{ nullptr }; // 一つ前のシーン<br>
      &nbsp;&nbsp; &nbsp;std::shared_ptr&lt;Scene&gt; currentScene{ nullptr }; // 現在のシーン<br>
	    <br>
      &nbsp;&nbsp; &nbsp;std::string currentSceneName = ""; // 現在のシーン名を保管しておく<br>
      &nbsp;&nbsp; &nbsp;std::string changingSceneName = ""; // 予約された次のシーンのクラス名(次に移動予定のシーン名を保管しておく)<br>
	    <br>
      &nbsp;&nbsp; &nbsp;// シーン名を比較、何の変化もなければfalseでシーン移動不必要の判定<br>
      &nbsp;&nbsp; &nbsp;bool isChanging(const std::string&amp; nextSceneName);<br>
	    <br>
      &nbsp;&nbsp; &nbsp;// 次のシーンの予約だけしてLoadScene()を引数なしで呼び出したタイミングで遷移する(ループの途中じゃないキリのいいタイミングを狙って遷移させる)<br>
      &nbsp;&nbsp; &nbsp;void NextScene(const std::string&amp; nextSceneName);<br>
	    <br>
      &nbsp;&nbsp; &nbsp;// シーンをチェンジし遷移する(前のシーンのリセット処理もする)<br>
      &nbsp;&nbsp; &nbsp;void LoadScene(const std::string&amp; sceneName = "");<br>
      <br>
      protected:<br>
      &nbsp;&nbsp; &nbsp;SceneManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp; &nbsp;virtual ~SceneManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>TitleScene.hを新規作成</code>してタイトル画面のひな型を作成しましょう。</p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;TitleScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "TitleScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sm.LoadScene("PlayScene"); //シーン遷移<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 0, "TitleSceneです。ボタン押下でPlaySceneへ。", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 200, "MAXスコア: " + sm.scoreMax, GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>GameOverScene.hを新規作成</code>してゲームオーバー画面のひな型を作成しましょう。</p>
    <p class="source">#ifndef GAMEOVERSCENE_H_<br>
      #define GAMEOVERSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class GameOverScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;GameOverScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "GameOverScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sm.LoadScene("TitleScene"); //シーン遷移<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 0, "GameOver....ボタン押下でPlaySceneへ", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>PlayScene.hを新規作成</code>してプレイ画面のひな型を作成しましょう。<br>
      なお、<b>実際のプレイに関するコードはGame.cppから頑張って移植</b>してみましょう。<br>
      ここに全部書くと逆にシーン遷移に関するコードがわかりづらくなりますから。<br>
      個々人で作成中の<code>Game.cppのゲームのコードをUpdate(),Draw(),Init()はInitialize()へ移植</code>してみましょう。</p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      #include "Player.h"<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp; &nbsp;int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;PlayScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "PlayScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;</em>// ここでプレイヤの初期化などのプレイ開始時の処理<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;</em>// ここにプレイ終了時のメモリのリセット処理(ゲームクリアやゲームオーバーなど)<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ゲーム終了時のスコアがMAXなら記録して終了<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(score &gt; sm.scoreMax) sm.scoreMax = score;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;</em>// ここにプレイ中の更新処理を持ってくる<br>
      <br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ゲームオーバー判定と画面チェンジ処理<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;bool isGameover = (gm.player == nullptr);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!isGameover &amp;&amp; gm.player-&gt;isDead) isGameover = true;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (isGameover)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sm.LoadScene("GameOverScene"); //シーン遷移<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;</em>// ここにプレイ画面の描画処理を持ってくる<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>SceneManager.cppを新規作成</code>してシーンを遷移する機能を作成しましょう。</p>
    <p class="source">#include "SceneManager.h"<br>
      <br>
      #include "Scene.h"<br>
      #include "TitleScene.h"<br>
      #include "PlayScene.h"<br>
      #include "GameOverScene.h"<br>
      <br>
      bool SceneManager::isChanging(const std::string&amp; nextSceneName)<br>
      {<br>
      &nbsp;&nbsp; &nbsp;if (currentSceneName != nextSceneName) //シーン名不一致<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return true; // シーン名が変更<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;return false; // シーン名に変更無し<br>
      }<br>
<br>
      void SceneManager::NextScene(const std::string&amp; nextSceneName)<br>
      {<br>
      &nbsp;&nbsp; &nbsp;// 遷移予定nextシーン名と現在のシーン名を比較、何の変化もなければfalseでシーン移動不必要の判定<br>
      &nbsp;&nbsp; &nbsp;if (isChanging(nextSceneName) == false) return; //特に変更なしでシーン移動の必要なし<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;changingSceneName = nextSceneName; // 次に移動予定のシーン名を保管しておく<br>
      }<br>
<br>
      void SceneManager::LoadScene(const std::string&amp; sceneName)<br>
      {<br>
      &nbsp;&nbsp; &nbsp;std::string loadSceneName = sceneName;
      &nbsp;&nbsp; &nbsp;// sceneNameの指定が空の場合にはNextScene()での事前のシーン変更予約があるかチェック<br>
      &nbsp;&nbsp; &nbsp;if (sceneName == "" &amp;&amp; changingSceneName != "")<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;loadSceneName = changingSceneName;<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;if (loadSceneName == "") return; // シーン指定がないときは終了<br>
      &nbsp;&nbsp; &nbsp;// 現在のシーンの終了処理<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;if(currentScene !=nullptr)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentScene-&gt;Finalize(); // 終了処理を呼び出す<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;if (loadSceneName == "TitleScene")<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 次のシーンの生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentScene = std::make_shared&lt;TitleScene&gt;();<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;else if (loadSceneName == "PlayScene")<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 次のシーンの生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentScene = std::make_shared&lt;PlayScene&gt;();<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;else if (loadSceneName == "GameOverScene")<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 次のシーンの生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentScene = std::make_shared&lt;GameOverScene&gt;();<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;else<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;assert("指定されたシーン名の生成処理が見つからなかった→SceneManager.cppを見直しましょう" == "");<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;currentSceneName = loadSceneName; // 現在のシーン名の更新<br>
      &nbsp;&nbsp; &nbsp;changingSceneName = ""; // NextScenceのシーン予約名をリセット<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 次のシーンの初期化<br>
      &nbsp;&nbsp; &nbsp;currentScene-&gt;Initialize(); // 初期化を呼び出す<br>
      }</p>
    <br>
    <br>
    <br>
    <p><code>Game.cppからPlayScene.h、TitleScene.hにプレイに関するコードを移植してみます</code><br>
      ですが、<b>あくまでも移植【例】です。</b><br>
      皆さん独自の敵などいますからあくまで移植の【例】です。</p>
    <br>
    <br>
    <p><code>Game.cppからTitleScene.hにテスト用のボス表示のコードを移植してみます。</code></p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      <em>#include "Screen.h"</em><br>
      <em>#include "Input.h"</em><br>
      #include "Image.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;<em>// テスト用のボス画像をタイトル画面で左右移動させる<br>
        &nbsp;&nbsp; &nbsp;int x = 0; //staticじゃないintはここで=0で初期化できる<br>
        &nbsp;&nbsp; &nbsp;int vx = 0;</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;TitleScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "TitleScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// テスト用のボス画像をタイトル画面で左右移動させる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x = 100; // Xの初期位置<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = 10; // ボスの初期速度</em><br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sm.LoadScene("PlayScene"); //シーン遷移<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// テスト用のボス画像をタイトル画面で左右移動させる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (x &lt; 0)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = 10; //速度の変更<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (x &gt; Screen::Width)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = -10; //画面端で移動方向反転<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x += vx; // ボス画像のX位置の更新</em><br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// テスト用のボス画像をタイトル画面で左右移動させる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawRotaGraphF((float)x, 200, 0.9f, 0, Image::bossImage, TRUE);</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 0, "TitleSceneです。ボタン押下でPlaySceneへ。", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 200, "MAXスコア: " + sm.scoreMax, GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>Game.hから移植したコードを削除します。</code></p>
    <p class="source">#ifndef GAME_H_<br>
      #define GAME_H_<br>
      <br>
      #include &lt;vector&gt;//配列std::vectorを使う<br>
      #include &lt;memory&gt;//スマートなポインタを使うのに必要(shared_ptrなど)<br>
      <br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      #include "GameManager.h"<br>
      <br>
      class Game<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↓{ }を.hに書くことでcppに分けて書くはずの処理ぶぶんを.hに書いてもよい */<br>
      &nbsp;&nbsp;&nbsp; Game() {&nbsp; }; // 初期化コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; ~Game() {&nbsp; }; // 破棄処理デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; void Init(); // Init処理(定義だけ)<br>
      &nbsp;&nbsp;&nbsp; void Update(); // 更新処理(定義だけ)<br>
      &nbsp;&nbsp;&nbsp; void Draw();// 描画処理(定義だけ)<br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>int x = 0; //staticじゃないintはここで=0で初期化できる<br>
        &nbsp;&nbsp;&nbsp; int vx = 0;</u><br>
      <br>
      };<br>
      #endif</p>
    <p><code>Game.cppから移植したコードを削除し、ImageやRandomなどの共通機能の初期化だけに絞ります。</code></p>
    <p class="source">#include "Game.h"<br>
      <br>
      <em>#include "MyRandom.h"</em><br>
      #include "Player.h" // ★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      ....<br>
      (中略)... その他いろいろなヘッダ............<br>
      ....<br>
      #include "Zako2.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include "Zako3.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include "Boss.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;&nbsp; Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数シードの初期化<br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;&nbsp; vx = 10; // ボスの初期速度</u><br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化<br>
      &nbsp;&nbsp;&nbsp; // とりあえず適当に敵を生成<br>
      &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)600, (float)100)));<br>
      &nbsp;&nbsp;&nbsp; (中略).....<br>
      &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));<br>
      }<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>if (x &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vx = 10; //速度の変更<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (x &gt; Screen::Width)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vx = -10; //画面端で移動方向反転<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; x += vx; // ボス画像のX位置の更新</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;&nbsp; (中略)......................<br>
      }<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;&nbsp; <u>DrawRotaGraphF((float)x, 200, 0.9f, 0, Image::bossImage, TRUE);</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; (中略)..................<br>
      }</p>
    <br>
    <p><code>PlayScene.hにGame.cppからプレイ中に関するコードを移植してみます。</code></p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      <em>#include "Screen.h"</em><br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      <em>#include "Player.h"<br>
        #include "Boss.h"<br>
        #include "PlayerBullet.h"<br>
        #include "EnemyBullet.h"<br>
        #include "Explosion.h"<br>
        #include "Item.h"</em><br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp; &nbsp;int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;PlayScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "PlayScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// ここでプレイヤの初期化などのプレイ開始時の処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵の仮生成<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));</em><br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ここにプレイ終了時のメモリのリセット処理(ゲームクリアやゲームオーバーなど)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>gm.player = nullptr; // プレイヤのメモリからの解放<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.enemies.clear(); // 敵のメモリからの解放<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.playerBullets.clear(); // プレイヤの弾のメモリからの解放<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.enemyBullets.clear(); // 敵弾のメモリからの解放<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.explosions.clear(); // 爆発エフェクトのメモリからの解放<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.items.clear(); // アイテムのメモリからの解放</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ゲーム終了時のスコアがMAXなら記録して終了<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(score &gt; sm.scoreMax) sm.scoreMax = score;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ここにプレイ中の更新処理を持ってくる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機弾の更新処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; b : gm.playerBullets)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp; // autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b-&gt;Update();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵弾の更新処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; b : gm.enemyBullets)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b-&gt;Update();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機と敵弾の衝突判定<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; enemyBullet : gm.enemyBullets)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機が死んでたらこれ以上判定しない<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (gm.player-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵弾が死んでたらスキップ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (enemyBullet-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 円同士の衝突判定で調べる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enemyBullet-&gt;position, enemyBullet-&gt;collisionRadius))<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player-&gt;OnCollisionEnemyBullet(enemyBullet);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵の更新処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; b : gm.enemies)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b-&gt;Update();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機弾と敵の衝突判定<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; playerBullet : gm.playerBullets)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機弾が死んでたらスキップする<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (playerBullet-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; enemy : gm.enemies)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵が死んでたらスキップする<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (enemy-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機弾と敵が重なっているか？<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;playerBullet-&gt;position, playerBullet-&gt;collisionRadius,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;playerBullet-&gt;OnCollisionEnemy(enemy);<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (playerBullet-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機と敵の衝突判定<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; enemy : gm.enemies)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機が死んでたらこれ以上判定しない<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (gm.player-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵が死んでたらスキップ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (enemy-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 円同士の衝突判定で調べる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player-&gt;OnCollisionEnemy(enemy);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 爆発エフェクトの更新処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; e : gm.explosions)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;e-&gt;Update();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// アイテムの更新処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; itm : gm.items)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;itm-&gt;Update();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機とアイテム、敵弾とアイテムの衝突判定<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; itm : gm.items)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機が死んでたらこれ以上判定しない<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (gm.player-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// アイテムが死んでたらスキップ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (itm-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 円同士の衝突判定で調べる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;itm-&gt;position, itm-&gt;collisionRadius) )<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;itm-&gt;OnCollisionPlayer(gm.player);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; enemyBullet : gm.enemyBullets)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵弾が死んでたらスキップ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (enemyBullet-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 円同士の衝突判定で調べる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;itm-&gt;position, itm-&gt;collisionRadius,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;enemyBullet-&gt;position, enemyBullet-&gt;collisionRadius) )<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enemyBullet-&gt;OnCollisionItem(itm);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;itm-&gt;OnCollisionEnemyBullet(enemyBullet);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機弾の削除処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵のリストから死んでるものを除去する<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.EraseRemoveIf(gm.enemies,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵弾のリストから死んでるものを除去する<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.EraseRemoveIf(gm.enemyBullets,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[](std::shared_ptr&lt;EnemyBullet&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//爆発エフェクトのリストから死んでるものを除去する<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.EraseRemoveIf(gm.explosions,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[](std::shared_ptr&lt;Explosion&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//アイテムのリストから死んでるものを除去する<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.EraseRemoveIf(gm.items,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[](std::shared_ptr&lt;Item&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除</em><br>
      <br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ゲームオーバー判定と画面チェンジ処理<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;bool isGameover = (gm.player == nullptr);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!isGameover &amp;&amp; gm.player-&gt;isDead) isGameover = true;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (isGameover)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sm.LoadScene("GameOverScene"); //シーン遷移<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ここにプレイ画面の描画処理を持ってくる<br>
      <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// 敵の描画処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; b : gm.enemies)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b-&gt;Draw();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 爆発エフェクトの描画処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; e : gm.explosions)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;e-&gt;Draw();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機弾の描画処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// for文で全自機弾をループで回してUpdateで更新する<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; b : gm.playerBullets)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp; // autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b-&gt;Draw();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵弾の描画処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; b : gm.enemyBullets)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b-&gt;Draw();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// アイテムの描画処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; itm : gm.items)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;itm-&gt;Draw();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</em><br>
        &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>Game.cppから移植したコードを削除します。</code></p>
    <p class="source">#include "Game.h"<br>
      <br>
      #include "MyRandom.h"<br>
      <u>#include "Player.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
        #include "PlayerBullet.h"<br>
        #include "EnemyBullet.h"<br>
        #include "Explosion.h"<br>
        #include "Zako0.h"<br>
        #include "Zako1.h"<br>
        #include "Zako2.h"<br>
        #include "Zako3.h"<br>
        #include "Item.h"<br>
        #include "Boss.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</u><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;&nbsp; Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数シードの初期化<br>
	    <br>
      &nbsp;&nbsp;&nbsp; <u>gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化<br>
      &nbsp;&nbsp;&nbsp; // とりあえず適当に敵を生成<br>
      &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)600, (float)100)));<br>
      &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)1000, (float)500)));<br>
      &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Zako1&gt;(Vector3((float)1000, (float)150)));<br>
      &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Zako2&gt;(Vector3((float)1200, (float)250)));<br>
      &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Zako3&gt;(Vector3((float)1300, (float)400)));<br>
<br>
      &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));</u><br>
	    <br>
      }<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 自機弾の更新処理<br>
        &nbsp;&nbsp;&nbsp; // for文で全自機弾をループで回してUpdateで更新する<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.playerBullets)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp; // autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b-&gt;Update();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 敵弾の更新処理<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.enemyBullets)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b-&gt;Update();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; (中略)................<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 自機と敵の衝突判定<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; enemy : gm.enemies)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 自機が死んでたらこれ以上判定しない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (gm.player-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 敵が死んでたらスキップ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (enemy-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円同士の衝突判定で調べる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enemy-&gt;position, enemy-&gt;collisionRadius))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.player-&gt;OnCollisionEnemy(enemy);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 爆発エフェクトの更新処理<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; e : gm.explosions)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e-&gt;Update();<br>
        &nbsp;&nbsp;&nbsp; }<br>
	<br>
	&nbsp;&nbsp;&nbsp; (中略)................<br>
        <br>
        &nbsp;&nbsp;&nbsp; //return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 自機弾の削除処理<br>
        &nbsp;&nbsp;&nbsp; gm.EraseRemoveIf(gm.playerBullets,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;PlayerBullet&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
        <br>
        &nbsp;&nbsp;&nbsp; (中略)..............<br>
        <br>
        &nbsp;&nbsp;&nbsp; //爆発エフェクトのリストから死んでるものを除去する<br>
        &nbsp;&nbsp;&nbsp; gm.EraseRemoveIf(gm.explosions,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;Explosion&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
        <br>
        &nbsp;&nbsp;&nbsp; //アイテムのリストから死んでるものを除去する<br>
        &nbsp;&nbsp;&nbsp; gm.EraseRemoveIf(gm.items,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;Item&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除</u><br>
      <br>
      <br>
      <br>
      <br>
      }<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;<u>// 敵の描画処理<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.enemies)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b-&gt;Draw();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 爆発エフェクトの描画処理<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; e : gm.explosions)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e-&gt;Draw();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 自機弾の描画処理<br>
        &nbsp;&nbsp;&nbsp; // for文で全自機弾をループで回してUpdateで更新する<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.playerBullets)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp; // autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b-&gt;Draw();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 敵弾の描画処理<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.enemyBullets)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b-&gt;Draw();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; // アイテムの描画処理<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; itm : gm.items)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itm-&gt;Draw();<br>
        &nbsp;&nbsp;&nbsp; }</u><br>
      }</p>
    <br>
    <br>
    <br>
    <p>さて、移植しただけではゲームは動きません。<br>
      <code>Game.hとGame.cppにシーンの初期遷移、更新、描画の処理</code>を追加しましょう。</p>
    <br>
    <br>
    <p><code>Game.hにシーンのマネージャへの連絡先sm</code>を追加しましょう。</p>
    <p class="source">#ifndef GAME_H_<br>
      #define GAME_H_<br>
      <br>
      #include &lt;vector&gt;//配列std::vectorを使う<br>
      #include &lt;memory&gt;//スマートなポインタを使うのに必要(shared_ptrなど)<br>
      <br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      #include "GameManager.h"<br>
      <em>#include "SceneManager.h"<br>
        #include "Scene.h"</em><br>
      <br>
      class Game<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↓{ }を.hに書くことでcppに分けて書くはずの処理ぶぶんを.hに書いてもよい */<br>
      &nbsp;&nbsp;&nbsp; Game() {&nbsp; }; // 初期化コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; ~Game() {&nbsp; }; // 破棄処理デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;<em>SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る</em><br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; void Init(); // Init処理(定義だけ)<br>
      &nbsp;&nbsp;&nbsp; void Update(); // 更新処理(定義だけ)<br>
      &nbsp;&nbsp;&nbsp; void Draw();// 描画処理(定義だけ)<br>
      };<br>
      #endif</p>
    <p><code>Game.cppにシーンの初期遷移、更新、描画の処理</code>を追加しましょう。</p>
    <p class="source">#include "Game.h"<br>
      <br>
      #include "MyRandom.h"<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;&nbsp; Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数シードの初期化<br>
      <br>
      &nbsp;&nbsp; &nbsp;<em>// ゲーム開始して最初はタイトルシーンに遷移<br>
        &nbsp;&nbsp; &nbsp;sm.LoadScene("TitleScene");</em><br>
      }<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Input::Update(); //【注意】これ忘れると<em>全シーン反応しない</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;<em>// シーンの更新処理<br>
        &nbsp;&nbsp; &nbsp;sm.currentScene-&gt;Update();</em><br>
      }<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;<em>// シーンの描画処理<br>
        &nbsp;&nbsp; &nbsp;sm.currentScene-&gt;Draw();</em><br>
      }</p>
    <br>
    <br>
    <br>
    <br>
    <p>さて、ここまでで画面遷移できるようになりました。<br>
      <b>一度実行して画面遷移できるか確認</b>してみてください。<br>
    </p>
    <br>
    <br>
    <br>
    <h2><a id="mozTocId40012" class="mozTocH1"></a>【高難度】画面やステージごとにImageのメモリを開放する</h2>
    <p>さて、画面遷移は実現しましたが、<b>現状ではメモリの節約効果は薄いです</b>。<br>
      なぜか？ 答えはImageクラスではゲーム<b>開始時に全画像データを読み込んだままずっと持ち続け</b>てます。<br>
      ゆえにゲームが壮大になれば<b>【冒険で使う全画像データがメモリにのり続けてしまい】</b>ます。<br>
      よって<b>【画面やステージマップごと】</b>に<b>【使用する画像以外をメモリから解放する】</b>処理を取り入れましょう。<br>
      <br>
      【補足と考察】<br>
      (実はプレイ中の<b>敵や弾[1個=数byte]の削除処理はメモリより【当たり判定のCPU計算を軽くする】効果の方が強かった</b>)<br>
      (<b>敵や弾[1個=数byte]×1000個でも1000バイト=1KBキロバイト</b>、一方で<b>【大きめの背景画像ファイルは1個で1～1000KBキロバイト=1MBメガバイト】</b>)<br>
      (<b>つまり画像1つ分で弾数万発ぶんのメモリ節約</b>、まあでも<b>【数万発の当たり判定したらCPU重くて画面フリーズしますが】</b>)<br>
    </p>
    <br>
    <br>
    <p><code>Image.hにロード済み画像の辞書に関する定義</code>を追加しましょう(mapタイプ型 = 辞書配列型)。</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
      <em>#include &lt;unordered_map&gt; // ロード済の画像辞書に使う</em><br>
      <em>#include &lt;string&gt; // 文字列string</em><em><br>
        #include &lt;memory&gt; // 辞書の指す先を回し読みポインタにする<br>
        #include &lt;vector&gt; // シーンのリストに使う<br>
        #include &lt;algorithm&gt; // シーンのリストからのfindに使う</em><br>
      #include "DivImage.h" // 分割画像の読込みに使う<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; Image() {}; // 初期化コンストラクタの定義だけ<br>
      &nbsp;&nbsp;&nbsp; ~Image() {}; // 破棄する処理デストラクタの定義だけ<br>
      &nbsp;&nbsp;&nbsp; static void Load(<em>std::string scene=""</em>); <em>// シーンを指定して使う画像だけロードすればメモリを節約できる</em><br>
      &nbsp;&nbsp;&nbsp; static int LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage<em>, std::string scene="", std::vector&lt;std::string&gt; useScenes={""}</em>);<br>
      &nbsp;&nbsp;&nbsp; <em>static int LoadGraph(const TCHAR* FileName, std::string scene = "", std::vector&lt;std::string&gt; useScenes = { "" }</em>);<br>
      &nbsp;&nbsp;&nbsp; <em>static std::unordered_map&lt;std::string, DivImage*&gt; loadDic; // ロード済の画像辞書</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;&nbsp; static int player; //プレイヤ画像のハンドラ<br>
      &nbsp;&nbsp;&nbsp; static int playerBullet; //プレイヤの弾画像のハンドラ<br>
      &nbsp;&nbsp;&nbsp; static int enemyBullet16; //敵弾 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;&nbsp; static int zako0; //ザコ0 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;&nbsp; static int zako1; //ザコ1 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;&nbsp; static int zako2; //ザコ2 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;&nbsp; static int zako3; //ザコ3 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;&nbsp; static int boss1; // ボス通常時<br>
      &nbsp;&nbsp;&nbsp; static int boss2; // ボス気絶<br>
      &nbsp;&nbsp;&nbsp; static int boss3; // ボス発狂<br>
      &nbsp;&nbsp;&nbsp; static DivImage explosion; // [分割画像]爆発エフェクト<br>
      &nbsp;&nbsp;&nbsp; static int item0; // アイテム0 画像のハンドラ(読込画像番号)<br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif</p>
    <br>
    <p><code>Image.cppにロード済み画像を辞書に登録しシーンで使わない画像を開放する処理</code>を追加しましょう。</p>
    <p class="source">#include "Image.h"<br>
      <br>
      <em>std::unordered_map&lt;std::string, DivImage*&gt; Image::loadDic;</em><br>
      <br>
      int Image::bossImage{ -1 }; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      int Image::player{ -1 };<br>
      int Image::playerBullet{ -1 };<br>
      int Image::enemyBullet16{ -1 };<br>
      int Image::zako0{ -1 };<br>
      int Image::zako1{ -1 };<br>
      int Image::zako2{ -1 };<br>
      int Image::zako3{ -1 };<br>
      int Image::boss1{ -1 };<br>
      int Image::boss2{ -1 };<br>
      int Image::boss3{ -1 };<br>
      // ★分割画像は初期化のときに{X方向画像数, Y方向画像数, 画像横幅XSize,画像縦幅YSize}を指定<br>
      DivImage Image::explosion{ 8, 2, 64, 64 };<br>
      int Image::item0{ -1 };<br>
      <br>
      void Image::Load(<em>std::string scene</em>)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; bossImage = LoadGraph("Image/boss1.png"<em>, scene, { "TitleScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; player = LoadGraph("Image/player.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(player != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; playerBullet = LoadGraph("Image/player_bullet.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(playerBullet != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; enemyBullet16 = LoadGraph("Image/enemy_bullet_16.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(enemyBullet16 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; zako0 = LoadGraph("Image/zako0.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(zako0 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; zako1 = LoadGraph("Image/zako1.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(zako1 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; zako2 = LoadGraph("Image/zako2.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(zako2 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; zako3 = LoadGraph("Image/zako3.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(zako3 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; boss1 = LoadGraph("Image/boss1.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(boss1 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; boss2 = LoadGraph("Image/boss2.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(boss2 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; boss3 = LoadGraph("Image/boss3.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(boss3 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // div分割画像をロード<em> or メモリ開放</em><br>
      &nbsp;&nbsp;&nbsp; if( Image::LoadDivGraph("Image/explosion.png", explosion<em>, scene, { "PlayScene" }</em>) != -2 )<u>;</u><br>
      &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>for (int i = 0; i &lt; explosion.AllNum; i++)<br>
        &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>{&nbsp;&nbsp;&nbsp; // 画像読込失敗<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;&nbsp;&nbsp; </em>&nbsp;&nbsp;&nbsp; if (explosion.HandleArray[i] == -1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;&nbsp;&nbsp; </em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert("画像読込失敗(画像ファイル名やフォルダが正しい?)" == "");<br>
        &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>}<br>
      <br>
      &nbsp;&nbsp;&nbsp; item0 = LoadGraph("Image/heart.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(item0 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; item1 = LoadGraph("Image/star.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(item1 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      }<br>
      <br>
      <em>// DXライブラリのLoadGraphを同じ関数名でラッピング(既存コードの書換えを最小限にする工夫)<br>
        // シーンごとにすでにメモリにロードしてある画像でシーンに使わないものはメモリから解放する<br>
        int Image::LoadGraph(const TCHAR* FileName, std::string scene, std::vector&lt;std::string&gt; useScenes)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; DivImage divImage{ 1,1,1,1 }; // 1×1の1分割画像として分割画像とロードを共通化<br>
        &nbsp;&nbsp;&nbsp; return Image::LoadDivGraph(FileName, divImage, scene, useScenes);<br>
        }</em><br>
      <br>
      // DXライブラリのLoadDivGraphを使いやすくラッピング<br>
      // ★関数に参照渡しを行う<br>
      // 関数の引数に参照渡しを行うことでdivImageの中身を書き換えることができる(値渡しでは書換不可)<br>
      // https://qiita.com/agate-pris/items/05948b7d33f3e88b8967<br>
      // https://qiita.com/RuthTaro/items/f35c3a26779c0ca1a41a<br>
      int Image::LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage<em>, std::string scene, std::vector&lt;std::string&gt; useScenes</em>)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; <em>int result = -1;<br>
        &nbsp;&nbsp;&nbsp; // 次のシーンで使う画像かの判別、useScenesリストにあれば使う判定<br>
        &nbsp;&nbsp;&nbsp; bool use = std::find(useScenes.begin(), useScenes.end(), scene) != useScenes.end();<br>
        &nbsp;&nbsp;&nbsp; if (use)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; &nbsp;// ロード済み辞書に指定したファイルがある(count=1)のとき<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (loadDic.count(FileName) == 1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; loadDic[FileName] != nullptr &amp;&amp; loadDic[FileName]-&gt;HandleArray != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 画像ハンドルをfor文で書き写す(単一:AllNum=1,分割画像:AllNum&gt;1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; loadDic[FileName]-&gt;AllNum; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; divImage.HandleArray[i] = loadDic[FileName]-&gt;HandleArray[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ロード済みなら画像ハンドルを返す(ロード時間短縮)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (loadDic[FileName]-&gt;AllNum == 1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return loadDic[FileName]-&gt;HandleArray[0];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else return 0; // 分割画像なら成功:0を返す(本家LoadDivGraphに合わせて)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXライブラリで画像をロードし辞書に登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (divImage.AllNum == 1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 単一画像のロードと画像サイズ取得<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = divImage.HandleArray[0] = DxLib::LoadGraph(FileName);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetGraphSize(result, &amp;(divImage.XSize), &amp;(divImage.YSize)); // 画像サイズ取得<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (divImage.AllNum &gt; 1) // 複数分割画像の読込み<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = </em>DxLib::LoadDivGraph(FileName, divImage.XNum * divImage.YNum,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; divImage.XNum, divImage.YNum, divImage.XSize, divImage.YSize, divImage.HandleArray);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>for (int i = 0; i &lt; divImage.AllNum; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { // 画像読込失敗<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (divImage.HandleArray[i] == -1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert("画像読込失敗(画像ファイル名やフォルダが正しい?)" == "");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 辞書用にdivImageの【★コピーを取ってポインタ】として保管<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result != -1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (loadDic.count(FileName) == 1 &amp;&amp; loadDic[FileName] != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 上書き登録のために既存の情報を消す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DivImage* oldHandle = loadDic[FileName];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; delete oldHandle;// 辞書に保管している情報削除<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; loadDic.erase(FileName);// 辞書から索引も削除<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 新たに辞書登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; loadDic[FileName] = new DivImage(divImage);//←★コピーコンストラクタ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result; // ロードした結果を返す<br>
        &nbsp;&nbsp;&nbsp; } // ↓ここまでの↑returnに引っかからずif抜けてきたら【シーン利用しない画像】<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 今回のシーンでは利用しない画像の時はメモリから画像を開放して節約<br>
        &nbsp;&nbsp;&nbsp; if (loadDic.count(FileName) == 1 &amp;&amp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loadDic[FileName] != nullptr &amp;&amp; loadDic[FileName]-&gt;HandleArray != nullptr)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; &nbsp;// メモリから画像開放 https://dxlib.xsrv.jp/function/dxfunc_graph1.html#R3N15<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; loadDic[FileName]-&gt;AllNum; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DeleteGraph(loadDic[FileName]-&gt;HandleArray[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DivImage* oldHandle = loadDic[FileName];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete oldHandle;// 辞書に保管している情報削除<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loadDic.erase(FileName); // 辞書からも索引削除<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; // 今回のシーンでは利用しない画像の時は-2を返す<br>
        &nbsp;&nbsp;&nbsp; return -2; // 画像読込み失敗の-1と区別するため-2を返します</em><br>
      };</p>
    <br>
    <p><code>DivImage.hにコピーコンストラクタをpublic定義にして</code>画像辞書に分割画像のコピーへのポインタを保存できるようにする。<br>
      下記スライドで変更理由に目を通しておきましょう(C++でクラス内でnewやdeleteのした際の根の深いコピー時の*ポインタとデータ分離問題)。</p>
      <img src="image/copy_new_delete.png" alt="" style="width: 766px; height: 421px;"><br>
    <p class="source">#ifndef DIVIMAGE_H_<br>
      #define DIVIMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 画像の2のべき乗チェックに使う<br>
      <br>
      // 分割画像を読込むためのデータ構造(画像数や画像ハンドル配列、3Dに使う場合の2のべき乗チェック機能をもつ)<br>
      class DivImage<br>
      {&nbsp; // 2Dの分割画像や3Dに分割Div画像を使うと画像全体が使われてしまうのを回避するための情報<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int XNum = 0;<br>
      &nbsp;&nbsp;&nbsp; int YNum = 0;<br>
      &nbsp;&nbsp;&nbsp; int XSize = 0;<br>
      &nbsp;&nbsp;&nbsp; int YSize = 0;<br>
      &nbsp;&nbsp;&nbsp; int* HandleArray = nullptr;<br>
      &nbsp;&nbsp;&nbsp; int AllNum = 0;<br>
      &nbsp;&nbsp;&nbsp; bool is3DTexture = false;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化 : X方向分割画像数 XNum, Y方向分割画像数 YNum, 画像 横 幅XSizeピクセル, 画像 縦 高さYSizeピクセル<br>
      &nbsp;&nbsp;&nbsp; DivImage(int XNum, int YNum, int XSize, int YSize, bool is3DTexture = false)<br>
      &nbsp;&nbsp;&nbsp; { // 初期化コンストラクタ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;XNum = XNum; // X方向分割画像数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;YNum = YNum; // Y方向分割画像数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;XSize = XSize; // 画像 横 幅XSize(ピクセルドット数)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;YSize = YSize; // 画像 縦 高さYSize(ピクセルドット数)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllNum = XNum * YNum; // トータルの分割画像数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;is3DTexture = is3DTexture; // 3Dテクスチャ分割画像かtrueだと2のべき乗チェックが入る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★div分割画像読込ハンドラ保存用のint配列メモリを確保し-1で初期化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;HandleArray = new int[AllNum]; // 配列を確保し-1で初期化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; AllNum; i++) HandleArray[i] = -1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //↑【演習★】初期化後の動的配列をデバッガで見てみよう[ary,256として再評価ボタン]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // http://visualstudiostudy.blog.fc2.com/blog-entry-17.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int* ary = HandleArray;<br>
      #ifdef _DEBUG // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is3DTexture == true) ImagePowCheck((*this)); // *(this)でthisポインタの示す変数内容を表す<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; ~DivImage()<br>
      &nbsp;&nbsp;&nbsp; { // デストラクタでメモリを解放<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;HandleArray != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] this-&gt;HandleArray;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// コピーコンストラクタ(動的new配列をクラス内に持つ場合にはカスタムが必要)<br>
        &nbsp;&nbsp;&nbsp; DivImage(const DivImage&amp; divImage)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 基本はただのコピー書き移し<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XNum = divImage.XNum; YNum = divImage.YNum;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XSize = divImage.XSize; YSize = divImage.YSize;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllNum = XNum * YNum;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is3DTexture = divImage.is3DTexture;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↓★この配列だけはデフォルトのコピーコンストラクタではコピーされない！<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HandleArray = new int[AllNum]; //★[勉強]こちらでもnew確保<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; AllNum; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; HandleArray[i] = divImage.HandleArray[i];<br>
        &nbsp;&nbsp;&nbsp; };</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; //【勉強 []添え字演算子を独自に定義】https://programming.pc-note.net/cpp/operator.html<br>
      &nbsp;&nbsp;&nbsp; // 内部のHandleArrayに今までの様にImage::explosion[5]とかで簡単アクセスできるように【あいだに噛ます】<br>
      &nbsp;&nbsp;&nbsp; int const&amp; operator [](int index) const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (index &lt; 0 || AllNum &lt;= index) assert("画像データのアクセス番号がおかしい！" == "");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HandleArray[index];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; int&amp; operator [](int index)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (index &lt; 0 || AllNum &lt;= index) assert("画像データのアクセス番号がおかしい！" == "");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HandleArray[index];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      #ifdef _DEBUG // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;&nbsp; bool is_pow2(unsigned int x) // 2のべき乗か計算<br>
      &nbsp;&nbsp;&nbsp; { // https://programming-place.net/ppp/contents/c/rev_res/math012.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (x != 0) &amp;&amp; (x &amp; (x - 1)) == 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; void ImagePowCheck(DivImage&amp; divImage)<br>
      &nbsp;&nbsp;&nbsp; { // ★3Dに使う画像は2のべき乗でなければ受け付けないようにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://yttm-work.jp/gmpg/gmpg_0031.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://yappy-t.hatenadiary.org/entry/20100110/1263138881<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (divImage.XSize &gt; 0 &amp;&amp; divImage.YSize &gt; 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; is_pow2(divImage.XSize) &amp;&amp; is_pow2(divImage.YSize)) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else assert("3Dに使うなら2のべき乗の画像サイズにしなきゃ" == "");<br>
      &nbsp;&nbsp;&nbsp; }<br>
      #endif<br>
      <br>
      private: // <u>コピーと</u>代入をプライベートにして禁止する<br>
      &nbsp;&nbsp;&nbsp; <u>// コピーコンストラクタの禁止privateオーバーロード<br>
        &nbsp;&nbsp;&nbsp; DivImage(const DivImage&amp; divImage) {};</u><br>
      &nbsp;&nbsp;&nbsp; <em>// いままでコピー禁止してたのはnew,deleteの面倒なデータと*ポインタ分離問題を察知するため</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 代入演算子の禁止privateオーバーロード<br>
      &nbsp;&nbsp;&nbsp; void operator=(const DivImage&amp; divImage) {};<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>TitleScene.hにシーンごとの画像読込みとメモリ開放する処理</code>を追加しましょう。</p>
    <p class="source">(中略)........<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Image::Load("TitleScene"); //画像の読込みとメモリ開放</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vx = 10; // ボスの初期速度<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (中略)........</p>
    <br>
    <p><code>PlayScene.hにシーンごとの画像読込みとメモリ開放する処理</code>を追加しましょう。</p>
    <p class="source">(中略)........<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Image::Load("PlayScene"); //画像の読込みとメモリ開放</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ここでプレイヤの初期化などのプレイ開始時の処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 敵の仮生成<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (中略)........</p>
    <br>
    <p><code>GameOverScene.hにシーンごとの画像読込みとメモリ開放する処理</code>を追加します。<br>
      (現状シーンで画像使ってないけどプレイ中画面のメモリを解放する効果が出る)。</p>
    <p class="source">(中略)........<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Image::Load("GameOverScene"); //画像の読込みとメモリ開放</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (中略)........</p>
    <br>
    <p><code>Game.cppでやっていたImageのLoadを削除</code>します。</p>
    <p class="source">#include "Game.h"<br>
      <br>
      #include "MyRandom.h"<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;&nbsp; <u>Image::Load(); //画像の読込み</u><br>
      &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数シードの初期化<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ゲーム開始して最初はタイトルシーンに遷移<br>
      &nbsp;&nbsp;&nbsp; sm.LoadScene("TitleScene");<br>
      }<br>
      <br>
      (以下略)............</p>
    <br>
    <br>
    <p>これで一応画面ごとにメモリから画像データが開放される構造になりました。<br>
      でも、ほとんどメモリのグラフには変化がないかもしれません(<b>タイトル動画など重いデータあれば威力発揮</b>) </p>
    <br>
    <br>
    <h2><a id="mozTocId40013" class="mozTocH1"></a>サウンドの読込みと再生機能</h2>
    <p>実は画像より音声のほうがメモリ消費が大きかったりします。<br>
      なぜか?画像はアニメしなければ1枚ですよね。<br>
      一方<b>【音声には時間の長さがあります】</b>再生時間が10分など長くなれば数MBになります。<br>
      <b>特に.mp3など圧縮された音声ファイルはメモリ上では非圧縮の.wavになります！</b><br>
      ゲーム開始前は小さいmp3の音声ファイルがゲーム開始すると<b>【メモリ上で数十倍に膨れ上がります】</b><br>
      しかも最悪なことに<b>【圧縮をもとの音声に戻すためロードにめちゃくちゃ時間がかかります】</b><br>
      ゆえにロードが重くなるのを防ぐためLoadSoundMemする<b>音声ファイルは【あらかじめ.wav変換したほうがLoadが早い】</b>です。<br>
      以下リンクの変換ツールで<b>mp3などを.wavの非圧縮の音声ファイルに変換</b>して使いましょう。<br>
      <a href="https://forest.watch.impress.co.jp/library/software/flicaudiocon/">https://forest.watch.impress.co.jp/library/software/flicaudiocon/</a> <br>
      <br>
      今回はまず<b>「webでさがしたBGM素材サイト」</b>から音声ファイルを取ってきてSoundクラスを作成してみましょう。<br>
	    素材サイト例)<br>
	    <a href="https://maou.audio/category/bgm/">https://maou.audio/category/bgm/</a> <br>
	    <a href="https://maou.audio/category/se/">https://maou.audio/category/se/</a> <br>
	<br>
	    自分でシンセをダウンロードして効果音やBGMを自分で作っちゃうことだってできる。<br>
	    (<a href="https://www.eiga-square.jp/title/2001_a_space_odyssey/scene/1">人は真にクリエイティブになればなるほど借り物に飽き足らずそれを作る道具の方に興味が行くものです</a>)<br>
	    <ul>
	    <li><a href="https://www.bespokesynth.com/docs/index.html">あるいはC++で書かれたシンセサイザー(Bespoke)でループするパターンBGMを作曲してしまえば著作権すら気にする必要もなくなります。</a></li>
	    <li><a href="https://www.bespokesynth.com/#contact">こちらのリンクのDownload for Windowsからダウンロードできる</a> </li>
	    <li><a href="https://github.com/BespokeSynth/BespokeSynth/">C++のコードもこちらから見て勉強できるぞ!?</a> </li>
	    <li><a href="https://apps.apple.com/jp/app/audiokit-synth-one-synthesizer/id1371050497">スマホならSynth1で寝る前に横になりながら気軽に効果音自作も</a> </li>
	    </ul>
		     <br>
      以下のファイルを作成中のC++のプロジェクト下にImageフォルダの時のように「SEフォルダ」や「BGMフォルダ」を作成してコピーしておきましょう。</p>
    <ul>
      <li>start.ogg&nbsp; スタート時に鳴らす&nbsp;&nbsp; ⇒ SE/start.oggに移動</li>
      <li>bomb.wav&nbsp; 爆発時に鳴らす&nbsp;&nbsp; ⇒ SE/bomb.wavに移動</li>
      <li>title.ogg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; タイトル画面で流れる&nbsp;&nbsp; ⇒ BGM/title.mp3に移動</li>
      <li>gameplay.ogg プレイ画面で流れる&nbsp;&nbsp; ⇒ BGM/gameplay.mp3に移動</li>
      <li>ending.ogg &nbsp;&nbsp;&nbsp; ゲームオーバ画面で流れる&nbsp;&nbsp; ⇒ BGM/ending.mp3に移動</li>
    </ul>
    <p>まずは簡易版のSoundクラスを作ってみましょう。基本はImage.hと似ています。</p>
    <p><code>Sound.hを新規作成</code>します。</p>
    <p class="source">#ifndef SOUND_H_<br>
      #define SOUND_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 音声読み込みの読込み失敗表示用<br>
      #include &lt;string&gt;<br>
      <br>
      class Sound<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;Sound() {}; // 初期化コンストラクタの定義<br>
      &nbsp;&nbsp; &nbsp;~Sound() {}; // 破棄処理デストラクタの定義<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// メモリ再生音源管理番号<br>
      &nbsp;&nbsp; &nbsp;static int start; // ピロピロリン<br>
      &nbsp;&nbsp; &nbsp;static int bomb; // ボン！<br>
      <br>
      &nbsp;&nbsp; &nbsp;static std::string playingMusic; // 再生中のBGM(同一BGMをPlayMusic指定しても再生し直さない)<br>
      <br>
      &nbsp;&nbsp; &nbsp;static void Load();<br>
      &nbsp;&nbsp; &nbsp;// メモリから音声を再生(個別の音量設定も効かせられる)<br>
      &nbsp;&nbsp; &nbsp;static void Play(int handle, int PlayType = DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp; &nbsp;// ディスク上の音楽を直接再生する(メモリ上に展開しない)<br>
      &nbsp;&nbsp; &nbsp;static void PlayMusic(std::string file, int PlayType = DX_PLAYTYPE_LOOP);<br>
      &nbsp;&nbsp; &nbsp;<br>
      private:<br>
      <br>
      };<br>
      #endif</p>
    <br>
    <br>
    <p><code>Sound.cppを新規作成</code>します。<br>
      <b>すでにプレイ中のBGMは同じBGMをPlayMusicしようとしても再生し直さない工夫をしています。<br>
        これで再生ボタンUpdate連打状態で重くなるストッパーになります</b>。</p>
    <p class="source">#include "Sound.h"<br>
      <br>
      // メモリ再生音源管理番号<br>
      int Sound::start; // ピロピロリン<br>
      int Sound::bomb; // ボン！<br>
      <br>
      std::string Sound::playingMusic; // 再生中のBGM(同一BGMをプレイ指定しても初めから再生しない)<br>
      <br>
      void Sound::Load()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; start = LoadSoundMem("SE/start.ogg");<br>
      &nbsp;&nbsp;&nbsp; assert(start != -1); // 読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; bomb = LoadSoundMem("SE/bomb.wav");<br>
      &nbsp;&nbsp;&nbsp; assert(bomb != -1); // 読込失敗、ファイル名かフォルダ名が間違ってる<br>
      }<br>
      <br>
      // メモリ上の音声を再生する。<br>
      void Sound::Play(int handle, int PlayType)<br>
      {&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // メモリ上から音声再生<br>
      &nbsp;&nbsp;&nbsp; PlaySoundMem(handle, PlayType);<br>
      }<br>
      <br>
      // ディスク上の音楽を直接再生する(メモリ上に展開しない)<br>
      void Sound::PlayMusic(std::string file, int PlayType)<br>
      {&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <b>// プレイ中のBGMを再指定しても再生し直さず即時return<br>
        &nbsp;&nbsp;&nbsp; if (file == playingMusic) return;<br>
        <br>
        &nbsp;&nbsp;&nbsp; playingMusic = file; // プレイ中のBGM名を記録</b><br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::PlayMusic(file.c_str(), PlayType); //ディスクから直接再生(メモリにのせない)<br>
      }<br>
    </p>
    <br>
    <br>
    <p><code>Game.cppにSoundのロード処理を追加</code>します。<br>
    </p>
    <p class="source">#include "Game.h"<br>
      <br>
      #include "MyRandom.h"<br>
      <em>#include "Sound.h"</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
	    (中略)......<br>
      &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数シードの初期化<br>
      &nbsp;&nbsp;&nbsp; <em>Sound::Load(); //音声の読込み</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // ゲーム開始して最初はタイトルシーンに遷移<br>
      &nbsp;&nbsp;&nbsp; sm.LoadScene("TitleScene");<br>
      }<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;&nbsp; // シーンの更新処理<br>
      &nbsp;&nbsp;&nbsp; sm.currentScene-&gt;Update();<br>
      }<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // シーンの描画処理<br>
      &nbsp;&nbsp;&nbsp; sm.currentScene-&gt;Draw();<br>
      }<br>
    </p>
    <br>
    <p><code>TitleScene.hにサウンドの読込みとBGM再生、ゲームスタート時の再生処理と再生終わり待ちで画面遷移する処理</code>を追加します。</p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <em>#include "Sound.h"</em><br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;<em>// スタートボタンを押したら音声再生完了を待って画面移動<br>
        &nbsp;&nbsp; &nbsp;bool isStartPushed = false;</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;int x = 0; //staticじゃないintはここで=0で初期化できる<br>
      &nbsp;&nbsp; &nbsp;int vx = 0;<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;TitleScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "TitleScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
	    (中略).....<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>Sound::PlayMusic("BGM/title.mp3"); //タイトルBGMを再生<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isStartPushed = false; // ボタンのフラグをリセット</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = 10; // ボスの初期速度<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだが終了時だけやりたいリセットの仕方もあるかも)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;<em>// ボタン入力に応じた処理<br>
        &nbsp;&nbsp; &nbsp;void HandleInput()<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// ボタンを押したらスタート音声を再生<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Sound::Play(Sound::start);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isStartPushed = true; // 画面遷移トリガーON<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;}</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// スタートの効果音の再生が終わるまで画面遷移を待つ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (isStartPushed &amp;&amp; CheckSoundMem(Sound::start) == 0)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// スタート音声再生終了をトリガーとして画面遷移<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sm.LoadScene("PlayScene"); //シーン遷移<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;HandleInput(); // キー入力処理</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = -10; //画面端で移動方向反転<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x += vx; // ボス画像のX位置の更新<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 0, "TitleSceneです。ボタン押下でPlaySceneへ。", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 200, "MAXスコア: " + sm.scoreMax, GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawRotaGraphF((float)x, 200, 1.0f, 0, Image::bossImage, TRUE);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>PlayScene.hにプレイBGM再生と敵の被弾の効果音の処理</code>を追加します。<br>
      音声のハンドルを<b>辞書管理してメモリから解放したり個別音量調整できるように</b>します。</p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <em>#include "Sound.h"</em><br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Boss.h"<br>
      #include "PlayerBullet.h"<br>
      #include "EnemyBullet.h"<br>
      #include "Explosion.h"<br>
      #include "Item.h"<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp;&nbsp; GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; PlayScene() : Scene()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;tag = "PlayScene";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
     (中略).....<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>Sound::PlayMusic("BGM/gameplay.mp3"); //プレイ画面BGMを再生</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ここでプレイヤの初期化などのプレイ開始時の処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵の仮生成<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (中略)...................<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (中略)...................<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾と敵の衝突判定<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; playerBullet : gm.playerBullets)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾と敵が重なっているか？<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; playerBullet-&gt;position, playerBullet-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; playerBullet-&gt;OnCollisionEnemy(enemy);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>Sound::Play(Sound::bomb); // 効果音の再生</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; break;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (中略)...................<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ゲームオーバー判定と画面チェンジ処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bool isGameover = (gm.player == nullptr);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isGameover &amp;&amp; gm.player-&gt;isDead) isGameover = true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isGameover)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>Sound::PlayMusic("BGM/ending.mp3");</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.LoadScene("GameOverScene"); //シーン遷移<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (中略)...................<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p>ここまでで簡易的なサウンドの再生できるようになります。<br>
      実行してみてうまく音声が再生できるか試してみましょう。<br>
      次は高度なサウンドの機能を作成しますが、難易度が上がりますので<br>
      <b>簡単に再生できるだけでよい人は高度なサウンド機能は一旦後回しでもよいかも</b>しれません。</p>
    <br>
    <br>
    <br>
    <h2><a id="mozTocId40014" class="mozTocH1"></a>【高難度】画面やステージごとにサウンドをメモリ読込み・解放(音量調整機能も追加)</h2>
    <p>さて、一応基本的なサウンド再生機能は実現しました。<br>
      この項では<b>少し高度なサウンドの音量管理とメモリ管理を辞書配列で実現します。</b><br>
      とりあえず再生できればよいや、という人は<b>あとから取り入れる形でもよいかも</b>しれません。</p>
    <p>辞書配列には<b>辞書配列mapの【高速版unordered_map】を使用</b>しました。<br>
      普通の辞書は【あいうえお順に毎度並べ替えに時間かけてる】ですが、<br>
      <b>高速版辞書は【いちいち、あいうえお並び替えしないから高速】</b>と覚えておきましょう。<br>
      <b>並べ替え順のない高速辞書を【ハッシュ】と呼びます。</b><br>
      <b>ハッシュは【辞書のキー⇒順番の必要ないデータへの高速アクセス可】と暗記</b>しておきましょう。<br>
      配列などの中では<b>【条件付きでほぼ最速】</b>という認識で大丈夫です。<br>
      まとめて複数の音声をフェードアウトするときはUpdateで音声辞書を秒間60回連続検索することになるので導入しました。<br>
      ちなみにどれくらい高速かは下記リンク参照(ハッシュはO(1)という最速水準の単位です)<br>
      <a href="https://qiita.com/drken/items/872ebc3a2b5caaa4a0d0">https://qiita.com/drken/items/872ebc3a2b5caaa4a0d0</a><br>
    </p>
    <p><code>Sound.hに辞書配列や音量管理関数の定義を追加</code>します。 </p>
    <p class="source">#ifndef SOUND_H_<br>
      #define SOUND_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 音声読み込みの読込み失敗表示用<br>
      #include &lt;string&gt;<br>
      <em>#include &lt;unordered_map&gt; // 音声の辞書【map高速版】https://qiita.com/sileader/items/a40f9acf90fbda16af51<br>
        #include &lt;vector&gt; // シーンのリストに使う<br>
        #include &lt;algorithm&gt; // シーンのリストからのfindに使う</em><br>
      <br>
      class Sound<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; Sound() {}; // 初期化コンストラクタの定義<br>
      &nbsp;&nbsp;&nbsp; ~Sound() {}; // 破棄処理デストラクタの定義<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // メモリ再生音源管理番号<br>
      &nbsp;&nbsp;&nbsp; static int start; // ピロピロリン<br>
      &nbsp;&nbsp;&nbsp; static int bomb; // ボン！<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// ディスク再生音源管理番号<br>
        &nbsp;&nbsp;&nbsp; static int title; // タイトル画面BGM<br>
        &nbsp;&nbsp;&nbsp; static int gameplay; // プレイ画面BGM<br>
        &nbsp;&nbsp;&nbsp; static int ending; // ゲームオーバ画面BGM</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>static std::unordered_map&lt;std::string, int&gt; loadDic; // ロード済の音声辞書<br>
        &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;int, std::string&gt; SE_Dic; // SEファイル名辞書<br>
        &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;int, std::string&gt; BGM_Dic; // BGMファイル名辞書<br>
        &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;std::string, float&gt; volumeDic; // 【音声ごと】の[音量]辞書</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>static float volumeSE; // 効果音のベース音量(0～100%で指定)<br>
        &nbsp;&nbsp;&nbsp; static float volumeBGM; // 音楽BGMのベース音量(0～100%で指定)</em><br>
      &nbsp;&nbsp;&nbsp; static std::string playingMusic; // 再生中のBGM(同一BGMをPlayMusic指定しても再生し直さない<br>
      &nbsp;&nbsp;&nbsp; <em>static int musicId; // 音楽ID -3,-4,-5..メモリ上にのせないが番号を管理し個別に音量設定できるよう</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// シーンを指定してそのシーンで使うサウンドだけロードすればメモリ節約できる</em><br>
      &nbsp;&nbsp;&nbsp; static void Load(<em>std::string scene = ""</em>);<br>
      &nbsp;&nbsp;&nbsp; // メモリから音声を再生(個別の音量設定も効かせられる)<br>
      &nbsp;&nbsp;&nbsp; static void Play(int handle, int PlayType = DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp; // ディスク上の音楽を直接再生する(メモリ上に展開しない)<br>
      &nbsp;&nbsp;&nbsp; static void PlayMusic(std::string file, int PlayType = DX_PLAYTYPE_LOOP);<br>
      &nbsp;&nbsp;&nbsp; <em>// IDからディスク上の音楽を直接再生する(メモリ上に展開しない)<br>
        &nbsp;&nbsp;&nbsp; static void PlayMusic(int musicId, int PlayType = DX_PLAYTYPE_LOOP);<br>
        &nbsp;&nbsp;&nbsp; // ファイルを辞書登録しmusicIDで管理する(メモリにはのせずファイル名とIDだけ登録)<br>
        &nbsp;&nbsp;&nbsp; static int SetMusicFile(std::string file, bool isSE = false);<br>
        &nbsp;&nbsp;&nbsp; // 音声ファイルごとのボリューム設定<br>
        &nbsp;&nbsp;&nbsp; static void SetVolume(float VolumeParcent, int SoundHandle);<br>
        &nbsp;&nbsp;&nbsp; // メモリ音源の音量の更新(再生中に減らせばフェードアウト)<br>
        &nbsp;&nbsp;&nbsp; static int UpdateVolume(int SoundHandle = -1);<br>
        &nbsp;&nbsp;&nbsp; // 再生中のディスク音楽の音量の更新<br>
        &nbsp;&nbsp;&nbsp; static int UpdateMusicVolume();<br>
        &nbsp;&nbsp;&nbsp; // 音声をメモリへ読込み番号GET or シーンで使わない場合はメモリから解放<br>
        &nbsp;&nbsp;&nbsp; static int LoadSoundMem(const TCHAR *FileName, std::string scene, std::vector&lt;std::string&gt; useScenes</em><em><em>, bool isBGM=false</em>, int BufferNum = 3);</em><br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>Sound.cppに音声辞書とメモリ開放と音量調節処理を追加</code>します。<br>
      音声のハンドルを<b>辞書管理してメモリから解放したり個別音量調整できるように</b>します。</p>
    <p class="source">#include "Sound.h"<br>
      <br>
      // メモリ再生音源管理番号<br>
      int Sound::start; // ピロピロリン<br>
      int Sound::bomb; // ボン！<br>
      <br>
      <em>// ディスク再生音源管理番号<br>
        int Sound::title; // タイトル画面BGM<br>
        int Sound::gameplay; // プレイ画面BGM<br>
        int Sound::ending; // ゲームオーバ画面BGM<br>
        <br>
        <br>
        std::unordered_map&lt;std::string, int&gt; Sound::loadDic; // ロード済の音声辞書<br>
        std::unordered_map&lt;int, std::string&gt; Sound::SE_Dic; // SEファイル名辞書<br>
        std::unordered_map&lt;int, std::string&gt; Sound::BGM_Dic; // BGMファイル名辞書<br>
        std::unordered_map&lt;std::string, float&gt; Sound::volumeDic; // 【音声ごと】の[音量]辞書<br>
        <br>
        float Sound::volumeSE{ 100 }; // 効果音のベース音量(0～100%で指定)<br>
        float Sound::volumeBGM{ 100 }; // 音楽BGMのベース音量(0～100%で指定)</em><br>
      std::string Sound::playingMusic{ "" }; // 再生中のBGM(同一BGMをPlayMusic指定しても再生し直さない<br>
      <em>int Sound::musicId{ -3 }; // 音楽ID -3,-4,-5..メモリ上にのせないが番号を管理し個別に音量設定できるよう</em><br>
      <br>
      <em>// シーンを指定してそのシーンで使うサウンドだけロードすればメモリ節約できる</em><br>
      void Sound::Load(<em>std::string scene</em>)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; start = <em>Sound::</em>LoadSoundMem("SE/start.ogg"<em>, scene, { "TitleScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(start != -1); // 読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; <em>// オプションで同時[8つ]爆発音再生を可能に(デフォルトは3)falseをtrueにするとBGM扱い</em><br>
      &nbsp;&nbsp;&nbsp; bomb = <em>Sound::</em>LoadSoundMem("SE/bomb.wav"<em>,scene,{"TitleScene","PlayScene"},false, 8);<br>
        &nbsp;&nbsp;&nbsp; </em>assert(bomb != -1); // 読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>title = SetMusicFile("BGM/title.mp3");<br>
        &nbsp;&nbsp;&nbsp; gameplay = SetMusicFile("BGM/gameplay.mp3");<br>
        &nbsp;&nbsp;&nbsp; ending = SetMusicFile("BGM/ending.mp3");</em><br>
      }<br>
      <br>
      // メモリ上の音声を再生する。<br>
      void Sound::Play(int handle, int PlayType)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; <em>assert(handle != -1 &amp;&amp; "プレイする音声がメモリにない?" != "");</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 音量の更新<br>
        &nbsp;&nbsp;&nbsp; UpdateVolume(handle);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // メモリ上から音声再生<br>
      &nbsp;&nbsp;&nbsp; PlaySoundMem(handle, PlayType);<br>
      }<br>
      <br>
      // ディスク上の音楽を直接再生する(メモリ上に展開しない)<br>
      void Sound::PlayMusic(std::string file, int PlayType)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // プレイ中のBGMを再指定しても初めから再生せず即時return<br>
      &nbsp;&nbsp;&nbsp; if (file == playingMusic) return;<br>
      <br>
      &nbsp;&nbsp;&nbsp; playingMusic = file; // プレイ中のBGM名を設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::PlayMusic(file.c_str(), PlayType); //ディスクから直接再生(メモリにのせない)<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>Sound::UpdateMusicVolume(); // // 音量の更新(プレイ【中】の音楽だから↑PlayMusicしてから)</em><br>
      }<br>
      <br>
      <em>// IDからディスク上の音楽を直接再生する(メモリ上に展開しない)<br>
        void Sound::PlayMusic(int musicId, int PlayType)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (musicId &gt; -1) return;//音楽IDはマイナスのID番号を割り振ったはず<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::string file = "";<br>
        &nbsp;&nbsp;&nbsp; // 辞書から対応するファイル名を取得<br>
        &nbsp;&nbsp;&nbsp; if (BGM_Dic.count(musicId) == 1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; file = BGM_Dic[musicId];<br>
        &nbsp;&nbsp;&nbsp; else if (SE_Dic.count(musicId) == 1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; file = SE_Dic[musicId];<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (file == "") return;//対応する音楽ファイルが辞書に未登録<br>
        &nbsp;&nbsp;&nbsp; // ファイル名から音楽ファイルを再生<br>
        &nbsp;&nbsp;&nbsp; Sound::PlayMusic(file, PlayType);<br>
        }<br>
        <br>
        // ファイルを辞書登録しmusicIDで管理する(メモリにはのせずファイル名とIDだけ登録)<br>
        int Sound::SetMusicFile(std::string file, bool isSE)<br>
        {&nbsp;&nbsp;&nbsp; // 既に辞書登録済なら即時return<br>
        &nbsp;&nbsp;&nbsp; if (loadDic.count(file) == 1) return loadDic[file];<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 新規に辞書にファイル登録<br>
        &nbsp;&nbsp;&nbsp; loadDic[file] = musicId; //IDの辞書に登録<br>
        &nbsp;&nbsp;&nbsp; if (isSE) SE_Dic[musicId] = file; //SEの辞書に登録<br>
        &nbsp;&nbsp;&nbsp; else BGM_Dic[musicId] = file; //BGMの辞書に登録<br>
        <br>
        &nbsp;&nbsp;&nbsp; return musicId--; // 後ろに--つけるとカウントダウン前をreturn<br>
        }<br>
        <br>
        // 音声ファイルごとのボリューム設定<br>
        void Sound::SetVolume(float VolumeParcent, int SoundHandle)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (SoundHandle == -1) return;<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (SE_Dic.count(SoundHandle) == 1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ハンドル番号がSEの辞書で見つかれば<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string file = SE_Dic[SoundHandle];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeDic[file] = VolumeParcent;//個別音量を辞書登録<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (BGM_Dic.count(SoundHandle) == 1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ハンドル番号がBGMの辞書で見つかれば<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string file = BGM_Dic[SoundHandle];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeDic[file] = VolumeParcent;//個別音量を辞書登録<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // セットした後の音声には音量が反映されるが<br>
        &nbsp;&nbsp;&nbsp; // すでに再生中の音量は変わらないので↓UpdateVolumeとセットで実行<br>
        }<br>
        <br>
        // メモリ音源の音量の更新(再生中に減らせばフェードアウト)<br>
        int Sound::UpdateVolume(int SoundHandle)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 特に指定がなければすべての音量を更新<br>
        &nbsp;&nbsp;&nbsp; if (SoundHandle == -1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 辞書のfor文はキーとバリューがペアになってる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int result = 0, resultAll = 0;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; kv : loadDic)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 辞書のキーがkv.first,バリューがkv.second<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int handle = kv.second;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 【★勉強】自分自身を呼出す奥の手<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (handle != -1) //↓【再起呼出し】<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; result = Sound::UpdateVolume(handle);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (result == -1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; resultAll += -1; // 失敗した数ぶん-1がカウントされる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return resultAll; // 全音量更新完了【再起呼出しループで】<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 音源指定があるときはhandleを指定して音量を更新<br>
        &nbsp;&nbsp;&nbsp; int handle = SoundHandle;<br>
        <br>
        &nbsp;&nbsp;&nbsp; int volume = 255;<br>
        &nbsp;&nbsp;&nbsp; float volumeParcent = 100;<br>
        &nbsp;&nbsp;&nbsp; std::string file = "";<br>
        &nbsp;&nbsp;&nbsp; if (SE_Dic.count(handle) == 1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // サウンド番号がSE辞書で見つかれば<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; file = SE_Dic[handle];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeParcent = volumeSE; //音量をSEのベース音量に<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (BGM_Dic.count(handle) == 1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // サウンド番号がBGM辞書で見つかれば<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; file = BGM_Dic[handle];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeParcent = volumeBGM; //音量をSEのベース音量に<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (volumeDic.count(file) == 1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 音量辞書をファイル名で検索して<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float fileParcent = volumeDic[file];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeParcent *= fileParcent / 100; //個別音量%割合反映<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (volumeParcent &lt; 100) // 音量に%パーセントを掛ける<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volume = (int)(((float)volume) * volumeParcent / 100);<br>
        &nbsp;&nbsp;&nbsp; // 音量反映<br>
        &nbsp;&nbsp;&nbsp; int result = ChangeVolumeSoundMem(volume, handle);<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result == 0) // 音量変更成功<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return volume;<br>
        &nbsp;&nbsp;&nbsp; else return result; // 音量変更失敗<br>
        }<br>
        <br>
        // 再生中のディスク音楽の音量の更新<br>
        int Sound::UpdateMusicVolume()<br>
        {<br>
        &nbsp;&nbsp;&nbsp; std::string file = playingMusic;<br>
        <br>
        &nbsp;&nbsp;&nbsp; int volume = 255;<br>
        &nbsp;&nbsp;&nbsp; float volumeParcent = volumeBGM;<br>
        &nbsp;&nbsp;&nbsp; if (volumeDic.count(file) == 1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 音量辞書をファイル名で検索して<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float fileParcent = volumeDic[file];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeParcent *= fileParcent / 100; //個別音量%割合反映<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (volumeParcent &lt; 100) // 音量に%パーセントを掛ける<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volume = (int)(((float)volume) * volumeParcent / 100);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 音量反映<br>
        &nbsp;&nbsp;&nbsp; int result = SetVolumeMusic(volume);<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result == 0) // 音量変更成功<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return volume;<br>
        &nbsp;&nbsp;&nbsp; else return result; // 音量変更失敗<br>
        }<br>
        <br>
        // 音声をメモリへ読込み番号GET or シーンで使わない場合はメモリから解放<br>
        int Sound::LoadSoundMem(const TCHAR *FileName, std::string scene, std::vector&lt;std::string&gt; useScenes, bool isBGM, int BufferNum)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; int result = -1;<br>
        &nbsp;&nbsp;&nbsp; // 次のシーンで使う音声かの判別、useScenesリストにあれば使う判定<br>
        &nbsp;&nbsp;&nbsp; bool use = std::find(useScenes.begin(), useScenes.end(), scene) != useScenes.end();<br>
        &nbsp;&nbsp;&nbsp; if (use)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ロード済み辞書に指定したファイルがある(count=1)のとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (loadDic.count(FileName) == 1 &amp;&amp; loadDic[FileName] != -1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ロード済みなら音声ハンドルを返す(ロード時間短縮)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return loadDic[FileName];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // DXライブラリで音声をロード、BufferNumは同時再生可能数<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; result = DxLib::LoadSoundMem(FileName, BufferNum);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (result != -1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 辞書にサウンドハンドル番号を保管<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int handle = result; //ロード結果からハンドル番号取得<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; loadDic[FileName] = handle;//ロード済辞書に登録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isBGM) BGM_Dic[handle] = FileName;//BGMの辞書に登録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else SE_Dic[handle] = FileName;//SEの辞書に登録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return result; // ロードした結果を返す<br>
        &nbsp;&nbsp;&nbsp; } // ↓ここまでの↑returnに引っかからずif抜けてきたら【シーン利用しないサウンド】<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 今回のシーンでは利用しないサウンドの時はメモリからサウンドを開放して節約<br>
        &nbsp;&nbsp;&nbsp; if (loadDic.count(FileName) == 1 &amp;&amp; loadDic[FileName] != -1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // メモリからサウンド開放 https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N8<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int handle = loadDic[FileName];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; result = DxLib::DeleteSoundMem(handle);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(result != -1 &amp;&amp; "音声メモリ開放失敗" != "");<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 辞書からハンドルを削除<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (SE_Dic.count(handle) == 1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SE_Dic.erase(handle);//SEの辞書から削除<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (BGM_Dic.count(handle) == 1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; BGM_Dic.erase(handle);//BGMの辞書から削除<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; loadDic.erase(FileName); // ID辞書からも索引削除<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; // 今回のシーンでは利用しないサウンドの時は-2を返す<br>
        &nbsp;&nbsp;&nbsp; return -2; // サウンド読込み失敗の-1と区別するため-2を返します<br>
        }</em><br>
    </p>
    <br>
    <br>
    <p><code>TitleScene.hにシーンごとのサウンドのロードと音量調節機能を追加</code>します。<br>
      タイトル画面で<b><b>左右</b>キーを押すと音量調整できるようになり</b><b><b>上下</b><b><b></b></b>キーでSE⇔BGM調整モードを切り替え</b>られます。</p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "Sound.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;<em>// 設定モード<br>
        &nbsp;&nbsp; &nbsp;enum class SettingMode<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BGM=0, // BGM設定モード<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SE, // SE設定モード<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NUM // 列挙数[enumの数を得る] https://qiita.com/k-satoda/items/2985e81216b3ee500956<br>
        &nbsp;&nbsp; &nbsp;};<br>
        &nbsp;&nbsp; &nbsp;SettingMode settingMode = SettingMode::BGM; // 現在の設定モード</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// スタートボタンを押したら音声再生完了を待って画面移動<br>
      &nbsp;&nbsp; &nbsp;bool isStartPushed = false;<br>
      <br>
      &nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;int x = 0; //staticじゃないintはここで=0で初期化できる<br>
      &nbsp;&nbsp; &nbsp;int vx = 0;<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;TitleScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "TitleScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Image::Load("TitleScene"); //画像の読込みとメモリ開放<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>Sound::Load("TitleScene"); //音声の読込みとメモリ開放</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Sound::PlayMusic(<em>Sound::title</em>); //タイトルBGMを再生<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isStartPushed = false; // ボタンのフラグをリセット<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = 10; // ボスの初期速度<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだが終了時だけやりたいリセットの仕方もあるかも)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// ボタン入力に応じた処理<br>
      &nbsp;&nbsp; &nbsp;void HandleInput()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// ボタンを押したらスタート音声を再生<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Sound::Play(Sound::start);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isStartPushed = true; // 画面遷移トリガーON<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <em>if (Input::GetButtonDown(PAD_INPUT_UP))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //上を押すと設定モードを-1する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int index = ((int)settingMode - 1);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (index &lt; 0) //↓番号ループ 0→最大数-1<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; index = ((int)SettingMode::NUM) - 1;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; settingMode = (SettingMode)index;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (Input::GetButtonDown(PAD_INPUT_DOWN))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //下を押すと設定モードを+1する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int index = ((int)settingMode + 1);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (index &gt;= ((int)SettingMode::NUM))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; index = 0; //番号ループ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; settingMode = (SettingMode)index;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(PAD_INPUT_RIGHT))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (settingMode == SettingMode::BGM)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM++;//音量をプラス<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeBGM &gt; 100)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM = 100;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (settingMode == SettingMode::SE)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE++;//音量をプラス<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeSE &gt; 100)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE = 100;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::bomb); //効果音を聞きながら調節<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::UpdateMusicVolume(); //再生中の音量の更新<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (Input::GetButton(PAD_INPUT_LEFT))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (settingMode == SettingMode::BGM)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM--;//音量をマイナス<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeBGM &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM = 0;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (settingMode == SettingMode::SE)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE--;//音量をマイナス<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeSE &lt;0)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE = 0;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::bomb); //効果音を聞きながら調節<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::UpdateMusicVolume(); //再生中の音量の更新<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</em><br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スタートの効果音の再生中は遷移を待つ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (isStartPushed &amp;&amp; CheckSoundMem(Sound::start) == 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// スタート音声再生終了をトリガーとして画面遷移<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sm.LoadScene("PlayScene"); //シーン遷移<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;HandleInput(); // キー入力処理<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = -10; //画面端で移動方向反転<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x += vx; // ボス画像のX位置の更新<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 0, "TitleSceneです。ボタン押下でPlaySceneへ。", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 200, "MAXスコア: " + sm.scoreMax, GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <em>// 音量設定目盛りの文字列の生成<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string volumeBGM = "　";<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (settingMode == SettingMode::BGM)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeBGM = "⇒"; //[選択中]⇒BGM音量設定モード<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeBGM += "BGM音量設定:" + std::to_string((int)Sound::volumeBGM);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int volBGM_NUM = (int)(Sound::volumeBGM / 10);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (volBGM_NUM != 10) volumeBGM += " ";<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; volBGM_NUM; i++) volumeBGM += "■";//音量目盛り表示<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string volumeSE = "　";<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (settingMode == SettingMode::SE)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeSE = "⇒"; //[選択中]⇒BGM音量設定モード<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeSE += " SE音量設定:" + std::to_string((int)Sound::volumeSE);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int volSE_NUM = (int)(Sound::volumeSE / 10);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (volSE_NUM != 10) volumeSE += " ";<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; volSE_NUM; i++) volumeSE += "■";//音量目盛り表示<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 音量設定の表示<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawString(0, Screen::Height - 60, volumeBGM.c_str(), GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawString(0, Screen::Height - 30, volumeSE.c_str(), GetColor(255, 255, 255));</em><br>
      <br>
      <br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawRotaGraphF((float)x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>Game.cppからSoundのロード処理を削除</code>します(シーンごとのロードに変更)。<br>
    </p>
    <p class="source">#include "Game.h"<br>
      <br>
      #include "MyRandom.h"<br>
      <u>#include "Sound.h"</u><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数シードの初期化<br>
      &nbsp;&nbsp;&nbsp; <u>Sound::Load(); //音声の読込み</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; // ゲーム開始して最初はタイトルシーンに遷移<br>
      &nbsp;&nbsp;&nbsp; sm.LoadScene("TitleScene");<br>
      }<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;&nbsp; // シーンの更新処理<br>
      &nbsp;&nbsp;&nbsp; sm.currentScene-&gt;Update();<br>
      }<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // シーンの描画処理<br>
      &nbsp;&nbsp;&nbsp; sm.currentScene-&gt;Draw();<br>
      }<br>
    </p>
    <br>
    <p><code>PlayScene.hに画面ごとのサウンドのロード処理を追加しBGM再生をBGM番号経由に変更</code>します。<br>
    </p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "Sound.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Boss.h"<br>
      #include "PlayerBullet.h"<br>
      #include "EnemyBullet.h"<br>
      #include "Explosion.h"<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp;&nbsp; GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; PlayScene() : Scene()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;tag = "PlayScene";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Image::Load("PlayScene"); //画像の読込みとメモリ開放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>Sound::Load("PlayScene"); //音声の読込みとメモリ開放</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::PlayMusic(<em>Sound::gameplay</em>); //プレイ画面BGMを再生<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ここでプレイヤの初期化などのプレイ開始時の処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵の仮生成<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (中略)...................<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (中略)...................<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ゲームオーバー判定と画面チェンジ処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bool isGameover = (gm.player == nullptr);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isGameover &amp;&amp; gm.player-&gt;isDead) isGameover = true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isGameover)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::PlayMusic(<em>Sound::ending</em>);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.LoadScene("GameOverScene"); //シーン遷移<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (中略)...................<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p>いかがでしょうか？これでタイトル画面で音量調整ができ、<br>
      画面が変わるタイミングでシーンで使わない音声のメモリを解放する処理を実現できました。<br>
      一度実行して試してみましょう。</p>
    <br>
    <br>
    <h1><a id="mozTocId4002" class="mozTocH1"></a>CSVを読み込んで敵を生成するプログラム</h1>
	  <br>
	  以下のタイルマップエディタをダウンロードしてインストールしてください(寄付リンクをクリックしなければ無料)<br>
	  ・Tiledエディタ: <a href="https://qiita.com/muzudho1/items/ac3602a29f8536031fe4">https://qiita.com/muzudho1/items/ac3602a29f8536031fe4</a><br>
	  以下のファイルをダウンロードしてください。<br>
	  ・<a href="image/tile_id.png">tile_id.png (マップに配置する敵のID配置用のタイルチップ)</a><br>
	  ・<a href="image/tile_id.xcf">tile_id.xcf (上記pngタイルチップのGIMPもとファイル。番号の隣に見やすいようにZako0などの画像をGIMPで書き込んでTiledエディタで配置すれば勘違いしにくい？)</a><br><br>
<br>    
<b>[Tiledエディタを起動]</b>して<b>[新しいマップ]</b>を作成します。<br>
<img src="image/tile_map_newmap.png"><br><br>
<b>[新しいタイルセット]</b>もしくは<b>[アイコン]</b>をクリックしてダウンロードしたtile_id.pngの画像を<b>[参照]</b>して、新しいタイルセットを作成します。<br>
<img src="image/tile_map_newtileset1.png"><br><br>
	  新しいタイルセットを<b>[ファイル名をつけて保存]</b>します。<br>
<img src="image/tile_map_newtileset2.png"><br><br>
	  <b>tile_id.tsx</b>というファイル名.ファイル形式で保存します。<br>
<img src="image/tile_map_newtileset3.png"><br><br>
	  idがずらりとならんだタイルセットができました。<br>
<img src="image/tile_map_newtileset4.png"><br><br>
	  Zako0や1や2..などのidをステージに配置します。<br>
<img src="image/tile_map_newtileset5.png"><br><br>
	  <b>[ファイル]→[ファイルに名前をつけて保存]</b>でタイルマップ形式(.tmx)で保存します。<br>
<img src="image/tile_map_newtileset6.png"><br><br>
	  <b>[ファイル]→[名前をつけてエクスポート]</b>でcsv形式(.csv)でstage.csvをDXのプロジェクトのMapフォルダにエクスポート保存します。<br>
<img src="image/tile_map_newtileset7.png"><br><br>
<p>Tiledエディタで敵マップ(stage.csv)を作成したら、<br>
    <code>MapフォルダをImageのフォルダを作ったときのように新規作成して</code>その中に<br>
      stage1.csvを<br>
      <code>Map/stage1.csv</code>にcsv形式でエクスポートした前提条件でそれをロードするプログラムを作成していきます。<br>
      <br>
      csvファイルの準備ができたらマップの読込みプログラムを作成します。</p>
    <p><code>Map.hを新規作成</code>してマップのCSVファイルの読込みとスクロールを作成しましょう。</p>
    <p class="source">#ifndef MAP_H_<br>
      #define MAP_H_<br>
      <br>
      #include &lt;assert.h&gt; // 読込み失敗表示用<br>
      #include &lt;memory&gt; // 回し読みポインタをザコやボスの生成に使う<br>
      #include &lt;vector&gt; // csvを2次元vector配列に格納<br>
      #include &lt;string&gt; // 文字列に必要<br>
      #include &lt;fstream&gt; // ファイル読み出しifstreamに必要<br>
      #include &lt;sstream&gt; // 文字列ストリームに必要<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "GameManager.h"<br>
      #include "Zako0.h"<br>
      #include "Zako1.h"<br>
      #include "Zako2.h"<br>
      #include "Boss.h"<br>
      <br>
      class Map<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp; &nbsp;int Width = 0; // マップデータの横のマス数<br>
      &nbsp;&nbsp; &nbsp;int Height = 0; // マップデータの縦のマス数<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp; &nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; enemyData;// 敵配置データ<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; float position = 0; // マップ読出し位置のスクロール量<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;// filePath : CSVファイルのパス<br>
      &nbsp;&nbsp; &nbsp;// startPosition : 開始位置（デバッグやリスタート時に、面の途中から開始できるように）<br>
      &nbsp;&nbsp; &nbsp;Map(std::string filePath, float startPosition=0)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position = startPosition;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Load(filePath); // csvファイルをロード<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;//デストラクタ<br>
      &nbsp;&nbsp; &nbsp;~Map()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enemyData.clear();<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// csvファイルの読み込み<br>
      &nbsp;&nbsp; &nbsp;void Load(std::string filePath)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::ifstream ifs_csv_file(filePath);<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string line; //1行単位でcsvファイルから文字列を読み込む<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Width = 0; //初期化<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Height = 0; //初期化<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::vector&lt;int&gt; valuelist; // 1行の数字リスト<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::istringstream linestream(line); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string splitted; // カンマで分割された文字列<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int widthCount = 0; //この行の幅をカウント<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (std::getline(linestream, splitted, { ',' }))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::istringstream ss; //文字列ストリームの初期化<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ss = std::istringstream(splitted); //文字列ストリーム<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;widthCount++; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 1行の数字の数が記録を更新してMAXになるかチェック<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (widthCount &gt; MaxWidth) MaxWidth = widthCount; //暫定Max幅を更新<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 数字1行分をvectorに追加<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (valuelist.size() != 0) enemyData.emplace_back(valuelist);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Height++; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Width = MaxWidth; //マップ幅は一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;assert(Width &gt; 0 &amp;&amp;"マップ読込み失敗ファイル名間違いでは?"!="");<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;assert(Height &gt; 0 &amp;&amp;"マップ読込み失敗ファイル名間違いでは?"!="");<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 画面スクロール（位置の更新）<br>
      &nbsp;&nbsp; &nbsp;void Scroll(float delta)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールする前の、画面右端のセルの列番号（x）<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int prevRightCell = (int)(position + Screen::Width) / CellSize;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position += delta; // スクロールする<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールした後の、画面右端のセルの列番号（x）<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int currentRightCell = (int)(position + Screen::Width) / CellSize;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールした後の画面右端のセルがマップの範囲外に出ちゃったら何もしないで終了<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (currentRightCell &gt;= Width)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールする前と後で、画面右端のセルが同じ場合は、何もしないで終了<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (prevRightCell == currentRightCell)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 画面右端のセルの左端のx座標<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float x = currentRightCell * CellSize - position;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 上端のセルから下端のセルまで舐めて、敵データが配置されていたら、敵を生成する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int cellY = 0; cellY &lt; Height; cellY++)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float y = cellY * CellSize;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//【★注意!】2次元vectorではxとyがC#と逆！[行Y][列X]⇒行列の順と覚えよう<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int id = enemyData[cellY][currentRightCell];<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 番号に応じて敵を生成する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (id == -1) continue; // -1は空白なので、何もしない<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (id == 0) gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3(x + 32, y + 32)));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (id == 1) gm.enemies.emplace_back(std::make_shared&lt;Zako1&gt;(Vector3(x + 32, y + 32)));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (id == 2) gm.enemies.emplace_back(std::make_shared&lt;Zako2&gt;(Vector3(x + 32, y + 32)));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (id == 100) gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(x + 90, y + 32))); // ボスは横幅180pxだから90px右に生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else assert("まだ追加してない敵IDがマップCSVにありました。"=="");<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      #endif</p>
    <br>
    <br>
    <p><code>GameManager.hにMapの回し読みポインタの参照リンクを追加</code>します。<br>
    </p>
    <p class="source">#ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      <br>
      #include "Singleton.h"<br>
      <br>
      <em>class Map; //クラス宣言だけでインクルードしないので循環しない(前方宣言)</em><br>
      class Player;<br>
      class PlayerBullet;<br>
      class Enemy;<br>
      class EnemyBullet;<br>
      class Explosion;<br>
      class Item;<br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      <em>&nbsp;&nbsp; &nbsp;std::shared_ptr&lt;Map&gt; map{ nullptr }; // マップ</em><br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機<br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;EnemyBullet&gt;&gt; enemyBullets; // 敵弾のリスト<br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;Explosion&gt;&gt; explosions; // 爆発エフェクトのリスト<br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;Item&gt;&gt; items; // アイテムのリスト<br>
      &nbsp;&nbsp;&nbsp; // 複数リスト↑list ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      <br>
      &nbsp;&nbsp; (中略)..........<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;&nbsp; virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>PlayScene.hにMapの初期化とメモリ参照クリアとスクロール処理を追加</code>します。<b>(シーン分けしていない人はGame.cppで)</b><br>
    </p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "Sound.h"<br>
      <em>#include "Map.h"</em><br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Boss.h"<br>
      #include "PlayerBullet.h"<br>
      #include "EnemyBullet.h"<br>
      #include "Explosion.h"<br>
      #include "Item.h"<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp; &nbsp;int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる<br>
      <br>
      &nbsp;&nbsp; &nbsp;<em>float scrollSpeed = 1.5f; // スクロール速度</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;PlayScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "PlayScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
(中略)......<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Sound::PlayMusic(Sound::gameplay); //プレイ画面BGMを再生<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// マップの初期化<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.map = std::make_shared&lt;Map&gt;("Map/stage1.csv");</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ここでプレイヤの初期化などのプレイ開始時の処理<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵の仮生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<u>//gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));</u><br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだが終了時だけやりたいリセットの仕方もあるかも)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ここにプレイ終了時のメモリのリセット処理(ゲームクリアやゲームオーバー時など)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>gm.map = nullptr; // マップのメモリからの解放</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player = nullptr; // プレイヤのメモリからの解放<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.enemies.clear(); // 敵のメモリからの解放<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.playerBullets.clear(); // プレイヤの弾のメモリからの解放<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.enemyBullets.clear(); // 敵弾のメモリからの解放<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.explosions.clear(); // 爆発エフェクトのメモリからの解放<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.items.clear(); // アイテムのメモリからの解放<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ゲーム終了時のスコアがMAXなら記録して終了<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(score &gt; sm.scoreMax) sm.scoreMax = score;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ここにプレイ中の更新処理を持ってくる<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// マップデータの読出し位置のスクロール<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.map-&gt;Scroll(scrollSpeed);</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; (中略)....................<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; (中略)....................<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <br>
    さて、ここまでで敵が画面の右端から出て来たでしょうか？<br>
    出てこない場合は、大抵以下の原因が多いです。<br>
    <ul>
      <li>【Mapフォルダ】をImageフォルダと同じように新規作成しましたか？</li>
      <li>【Mapフォルダ】にstage1.csvがありますか？</li>
      <li>【stage1..csv】ドットが多くないですか</li>
      <li>【mapのMが小文字】フォルダ名のMが小文字m</li>
      <li>【別のプロジェクトのMapフォルダに間違って入ってた】</li>
      <li>【敵を開始32マス内に配置してた】開始32マスは読込みしません</li>
    </ul>
    <br>
	<br>  
    <b>サンプルのstage.csvを下記に置いておくのでうまくTileMapエディタで書き出せない人やとりあえずプレイしてみたい人はダウンロードしてMapフォルダにコピーしてプレイしてみましょう。</b><br>
    <a href="image/stage1.csv">サンプルのstage1.csv</a><br>
    <br>
    <br>
    <h2><a id="mozTocId40022" class="mozTocH1"></a>カスタムしたデータ構造DataCsv.hでデータ自身にLoadと幅高さ管理を任せる</h2>
    <p>さて、マップ読込みうまくいきましたか？<br>
      現状のコードは敵のみ読込みですが<b>【地形やその他アイテムなどのデータが増えると面倒です】</b><br>
      いちいち<b>Map.hにint stageWidth, int terrainWidth, int itemWidth...などと定義を増やしますか？</b><br>
      いちいち<b>Map.hにLoadTerrain(),LoadItem()など長いロード処理を個別に書きますか？</b><br>
      そんなの<b>僕は嫌だ！</b><br>
      という人はDataCsv.hを取り入れましょう。<br>
      データは<b>データ自身がLoad処理を持ち、幅Width高さHeightを持つ構造になればよい</b>のです。<br>
      <br>
      コードでは<b>【[]演算子を独自定義】</b>しています。<br>
      これはぜひ勉強してほしいテクニックです。<br>
      DataCsv型のデータは<b>[]演算子を使わないと</b>enemyData<b>.Data</b>[y][x]といったアクセスの仕方になってしまいます。<br>
      すると、DataCsvを導入すると<b>すでに書いたコードすべて</b>に<b>.Data[y][x]の書き足し</b>が必要になっちゃいますよね(めんどくさい)。<br>
      <b>[]演算子を間に噛ますだけで【既存のコードの書き直しがゼロ】</b>になるのです！<br>
      <br>
      どうでしょう？<b>[]演算子の威力を実感できそうですか？</b><br>
      <br>
      同じ目的で【関数名かぶらせテクニック】も使っています。<br>
      clear()の定義も同様です。enemyData<b>.Data</b>.clear()と書き直さず<b>enemyData.clear()のまま</b>で済むのです。<br>
      size()の定義も同様です。enemyData<b>.Data</b>.size()と書き直さず<b>enemyData.size()のまま</b>で済むのです。<br>
      <br>
      どうでしょう？<b>【関数名かぶらせテクニック】を実感できそうですか？</b>(C#でも使えるテクニック)<br>
    </p>
    <p><code>DataCsv.hを新規作成</code>します。</p>
    <p class="source">#ifndef DATACSV_H_<br>
      #define DATACSV_H_<br>
      <br>
      #include &lt;assert.h&gt; // 読込み失敗表示用<br>
      #include &lt;vector&gt; // csvを2次元vector配列に格納<br>
      #include &lt;string&gt; // 文字列に必要<br>
      #include &lt;fstream&gt; // ファイル読み出しifstreamに必要<br>
      #include &lt;sstream&gt; // 文字列ストリームに必要<br>
      <br>
      // CSVファイルを読込み幅や高さとデータ本体を保持するデータ型<br>
      struct DataCsv // ←structはC++ではほぼclassと同じ【違いはデフォルトがpublic】<br>
      {&nbsp;&nbsp; // 読込んだデータファイルの情報<br>
      &nbsp;&nbsp; &nbsp;int Width = 0; // csvファイルの表の幅<br>
      &nbsp;&nbsp; &nbsp;int Height = 0;// csvファイルの表の高さ<br>
      &nbsp;&nbsp; &nbsp;bool isInitialized = false; //[2重ロード対策]1度ロードしたらtrueにしてclear()されるまでロード抑止<br>
      <br>
      &nbsp;&nbsp; &nbsp;std::string FilePath { "" };<br>
      &nbsp;&nbsp; &nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; Data;// csvデータ<br>
      <br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 初期化コンストラクタでファイル名を指定して初期化と同時にファイル読込<br>
      &nbsp;&nbsp; &nbsp;DataCsv(std::string filePath = "") :FilePath{ filePath }<br>
      &nbsp;&nbsp; &nbsp;{// csvファイルの読込み★【初期化と同時なのでファイルとデータ型が一心同体で使いやすい】<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (FilePath != "") Load(FilePath); // ファイル読込み<br>
      &nbsp;&nbsp; &nbsp;};<br>
      &nbsp;&nbsp; &nbsp;virtual ~DataCsv()<br>
      &nbsp;&nbsp; &nbsp;{// 仮想デストラクタ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Data.clear();// 2次元配列データのお掃除<br>
      &nbsp;&nbsp; &nbsp;};<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;<b>// ★スムーズに[][]でアクセスできるように[]演算子を独自定義する<br>
        &nbsp;&nbsp; &nbsp;std::vector&lt;int&gt;&amp; operator[](std::size_t index) { // ★ &amp;参照にしないといちいちデータのコピーを返すので遅くなるよ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return Data[index]; // 書き込み<br>
        &nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;std::vector&lt;int&gt; operator[](std::size_t index) const { // ★constは添え字[]読み取りの処理を定義<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return Data[index]; // 読み取り<br>
        &nbsp;&nbsp; &nbsp;}</b><br>
      <br>
      &nbsp;&nbsp; &nbsp;<b>std::size_t size()<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; // size()関数の名前をvectorと被らせることで使う側はvectorインvectorのままのコードで使える<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return Data.size();<br>
        &nbsp;&nbsp; &nbsp;}</b><br>
      <br>
      &nbsp;&nbsp; &nbsp;<b>// データをクリアしてメモリを解放する<br>
        &nbsp;&nbsp; &nbsp;virtual void clear()<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; // データをクリアしてメモリを解放する<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Data.clear();// 2次元配列データのお掃除<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isInitialized = false; //ロード済みフラグをOFF<br>
        &nbsp;&nbsp; &nbsp;}</b><br>
      <br>
      &nbsp;&nbsp; &nbsp;// csvファイルの読み込み<br>
      &nbsp;&nbsp; &nbsp;virtual void Load(std::string filePath)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (filePath == "" || isInitialized) return; //ファイル名がないもしくはロード済<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;FilePath = filePath; // ファイル名を保管<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Data.clear(); //データを一旦クリア<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::ifstream ifs_csv_file(filePath);<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string line; //1行単位でcsvファイルから文字列を読み込む<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int readWidth = 0; //読込みデータの幅<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int maxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int readHeight = 0; //初期化<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//↓2重while文でCSVファイルを読み取る<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::vector&lt;int&gt; valuelist; // 1行の数字リスト<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::istringstream linestream(line); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string splitted; // カンマで分割された文字列<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int widthCount = 0; //この行の幅をカウント<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (std::getline(linestream, splitted, { ',' }))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::istringstream ss; //文字列ストリームの初期化<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ss = std::istringstream(splitted); //文字列ストリーム<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;valuelist.emplace_back(num); // 数字を数字のリスト(valuelist)に追加<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 1行の幅の数が記録を更新してMAXになるかチェック<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (widthCount &gt; maxWidth) maxWidth = widthCount; //暫定Max幅を更新<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 1行分をvectorに追加<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (valuelist.size() != 0) Data.emplace_back(valuelist);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;++readHeight; //読み込んだ行(縦)の数カウントアップ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;readWidth = maxWidth; //読み込んだ列(横)の数は一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;assert(readWidth &gt; 0 &amp;&amp; "CSV読込み失敗ファイル名間違いでは?" != "");<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;assert(readHeight &gt; 0 &amp;&amp; "CSV読込み失敗ファイル名間違いでは?" != "");<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;Width = readWidth; // 読込み成功したデータの幅を記録<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;Height = readHeight; // 読込み成功したデータの高さを記録<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// コンストラクタで初期化でロードの場合とLoad関数経由で読む経路があるから2重ロード対策<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isInitialized = true; // 読込み初期化済みフラグをON<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>Map.hで敵データを2次元vectorからDataCsvの使用に変更</code>しましょう。</p>
    <p class="source">#ifndef MAP_H_<br>
      #define MAP_H_<br>
      <br>
      #include &lt;assert.h&gt; // 失敗表示用<br>
      #include &lt;memory&gt; // 回し読みポインタをザコやボスの生成に使う<br>
      <u>#include &lt;vector&gt; // csvを2次元vector配列に格納</u><br>
      #include &lt;string&gt; // 文字列に必要<br>
      <u>#include &lt;fstream&gt; // ファイル読み出しifstreamに必要<br>
        #include &lt;sstream&gt; // 文字列ストリームに必要</u><br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "GameManager.h"<br>
      #include "Zako0.h"<br>
      #include "Zako1.h"<br>
      #include "Zako2.h"<br>
      #include "Boss.h"<br>
      <br>
      <em>#include "DataCsv.h"</em><br>
      <br>
      class Map<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp; &nbsp;<u>int Width = 0; // マップデータの横のマス数<br>
        &nbsp;&nbsp; &nbsp;int Height = 0; // マップデータの縦のマス数</u><br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp; &nbsp;<em>DataCsv</em> enemyData;// 敵配置データ<br>
      &nbsp;&nbsp; &nbsp;float position; // 現在の位置（画面左端の座標）<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;// filePath : CSVファイルのパス<br>
      &nbsp;&nbsp; &nbsp;// startPosition : 開始位置（デバッグやリスタート時に、面の途中から開始できるように）<br>
      &nbsp;&nbsp; &nbsp;Map(std::string filePath, float startPosition=0)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position = startPosition;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>enemyData.</em>Load(filePath); // csvファイルをロード<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;//デストラクタ<br>
      &nbsp;&nbsp; &nbsp;~Map()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<b>enemyData.clear();</b><br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;<u>// csvファイルの読み込み<br>
        &nbsp;&nbsp; &nbsp;void Load(std::string filePath)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::ifstream ifs_csv_file(filePath);<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string line; //1行単位でcsvファイルから文字列を読み込む<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Width = 0; //初期化<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Height = 0; //初期化<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::vector&lt;int&gt; valuelist; // 1行の数字リスト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::istringstream linestream(line); // 各行の文字列ストリーム<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string splitted; // カンマで分割された文字列<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int widthCount = 0; //この行の幅をカウント<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (std::getline(linestream, splitted, { ',' }))<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::istringstream ss; //文字列ストリームの初期化<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ss = std::istringstream(splitted); //文字列ストリーム<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int num; // 数字単体<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;widthCount++; //この行のカンマで区切られた数字の数をカウントアップ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 1行の数字の数が記録を更新してMAXになるかチェック<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (widthCount &gt; MaxWidth) MaxWidth = widthCount; //暫定Max幅を更新<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 数字1行分をvectorに追加<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (valuelist.size() != 0) enemyData.emplace_back(valuelist);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Height++; //マップの高さをカウントアップ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Width = MaxWidth; //マップ幅は一番数字の個数の多かった行に合わせる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//↓読込んだマップの幅と高さをチェック<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;assert(Width &gt; 0 &amp;&amp;"マップ読込み失敗ファイル名間違いでは?"!="");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;assert(Height &gt; 0 &amp;&amp;"マップ読込み失敗ファイル名間違いでは?"!="");<br>
        &nbsp;&nbsp; &nbsp;}</u><br>
      <br>
      &nbsp;&nbsp; &nbsp;// 画面スクロール（位置の更新）<br>
      &nbsp;&nbsp; &nbsp;void Scroll(float delta)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールする前の、画面右端のセルの列番号（x）<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int prevRightCell = (int)(position + Screen::Width) / CellSize;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position += delta; // スクロールする<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールした後の、画面右端のセルの列番号（x）<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int currentRightCell = (int)(position + Screen::Width) / CellSize;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールした後の画面右端のセルがマップの範囲外に出ちゃったら何もしないで終了<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (currentRightCell &gt;= <em>enemyData.</em>Width)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールする前と後で、画面右端のセルが同じ場合は、何もしないで終了<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (prevRightCell == currentRightCell)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 画面右端のセルの左端のx座標<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float x = currentRightCell * CellSize - position;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 上端のセルから下端のセルまで舐めて、敵データが配置されていたら、敵を生成する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int cellY = 0; cellY &lt; <em>enemyData.</em>Height; cellY++)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float y = cellY * CellSize;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//【★注意!】2次元vectorではxとyがC#と逆！[行Y][列X]⇒行列の順と覚えよう<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int id = <b>enemyData[cellY][currentRightCell];</b><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 番号に応じて敵を生成する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (id == -1) continue; // -1は空白なので、何もしない<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (id == 0) gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3(x + 32, y + 32)));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (id == 1) gm.enemies.emplace_back(std::make_shared&lt;Zako1&gt;(Vector3(x + 32, y + 32)));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (id == 2) gm.enemies.emplace_back(std::make_shared&lt;Zako2&gt;(Vector3(x + 32, y + 32)));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (id == 100) gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(x + 90, y + 32))); // ボスは横幅180pxだから90px右に生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else assert("まだ追加してない敵IDがマップCSVにありました。"=="");<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      #endif</p>
    <br>
    <br>
    <br>
    さて、できるだけ最小限の変更でDataCsvを導入することができたのが実感できましたか？<br>
    これで地形データやアイテムデータなどが増えてきてもすっきりするはずです。<br>
    一度実行してみて、無事に敵が出てくるかは確認してみましょう。<br>

    <br>
    <br>
    <br>
    <h2><a id="mozTocId40023" class="mozTocH1"></a>【3D向け】【高難度】敵データの全方位読出しアルゴリズム</h2>
    <p>さて現状のコードでは縦スクロールの一方向スクロール限定です。<br>
      全方向進めるようなRPGや3Dゲームなどには今のままでは使いづらいです。<br>
      シンプルな解決法としては<b>開始時に全敵キャラを読み込むのも一つの手</b>です。<br>
      ある程度<b>敵の数が限られるゲーム</b>であれば有効な策です。<br>
      しかし広大なマップや大量の敵の出るゲームでやると<br>
      <b>【大量の画面にいない敵も一気に生成してしまうので、大量の当たり判定計算などにより計算が追いつかなくなります】</b><br>
      ゆえにある程度の敵の規模のあるゲームのためには、キャラの移動にあわせて順次<b>【敵マップの全方向読み出し】</b>が必要です。<br>
      敵の読出しのアルゴリズムについては以下スライドを基本的な考え方としています。<br>
      <img src="image/cell_search_spawn.png" alt="" style="width: 581px; height: 462px;"><br> </p>
	  <p><code>CellXY.hを新規作成して</code>マス目の型を定義して、std::unordered_map辞書配列のキーにできるように独自operatorを定義しましょう。</p>
    <p class="source">#ifndef CELLXY_H_<br>
#define CELLXY_H_<br>
<br>
#include &lt;unordered_map&gt; // ハッシュ値計算 std::hashに必要<br>
<br>
#include &lt;cmath&gt;<br>
#include &lt;algorithm&gt; // std::maxに必要<br>
<br>
<br>
// マス目のXとYを保持するデータ型(std::mapやstd::unordered_mapのキーにするためのoperator定義を持つ)<br>
struct CellXY<br>
{<br>
&nbsp;&nbsp;&nbsp; int X = 0, Y = 0, dist = 0; bool distModeOn = false;<br>
&nbsp;&nbsp;&nbsp; CellXY() = default;<br>
<br>
&nbsp;&nbsp;&nbsp; ~CellXY() {};<br>
<br>
&nbsp;&nbsp;&nbsp; CellXY(int X, int Y, bool distModeOn = false) : X{ X }, Y{ Y }, distModeOn{ distModeOn }<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (distModeOn == true) dist = X * X + Y * Y; // 原点(0,0)からの距離比較機能オンの時<br>
&nbsp;&nbsp;&nbsp; };<br>
<br>
&nbsp;&nbsp;&nbsp; // ★連想配列mapのキーで使うため &lt; 比較演算子(連想配列並べ替えのため)をカスタム定義 http://programming-tips.info/use_struct_as_key_of_map/cpp/index.html<br>
&nbsp;&nbsp;&nbsp; virtual bool operator &lt; (const CellXY& other) const {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //★原点からの距離dist順になるようにするとstd::mapにいれれば自動で原点からの距離順にならぶ(敵の近い順に使える)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;distModeOn &amp;&amp; other.distModeOn) return this-&gt;dist &lt; other.dist;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;Y &lt; other.Y) return true; // Yを比較CSVのように左上から列→行の順にならぶ<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (this-&gt;Y &gt; other.Y) return false;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;X &lt; other.X) return true; // Yが同じ時はXを比較<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (this-&gt;X &gt; other.X) return false;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // X と Yがすべて等しい場合<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //★std::unordered_map のキーで使うため == 比較演算子カスタム定義 https://sygh.hatenadiary.jp/entry/2014/02/13/222356<br>
&nbsp;&nbsp;&nbsp; virtual inline bool operator==(const CellXY&amp; other) const {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const CellXY&amp; self = *this;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return self.X == other.X && self.Y == other.Y;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; virtual inline bool operator!=(const CellXY&amp; other) const {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return !(this-&gt;operator==(other));<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; virtual size_t GetHashCode() const //X,Yの値からハッシュ値を計算 https://sygh.hatenadiary.jp/entry/2014/02/13/222356<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::hash&lt;decltype(X)&gt;()(this-&gt;X) ^<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::hash&lt;decltype(Y)&gt;()(this-&gt;Y);<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; struct Hash // ハッシュ値取得用の関数オブジェクト(std::unordered_map のキーで使うため) https://sygh.hatenadiary.jp/entry/2014/02/13/222356<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; size_t operator ()(const CellXY&amp; cellXY) const<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return cellXY.GetHashCode();<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; };<br>
};<br>
<br>
#endif</p>
	  <br>
    <p><code>Map.hで敵データを全方位読み出しできるように変更</code>しましょう。</p>
    <p class="source">#ifndef MAP_H_<br>
      #define MAP_H_<br>
      <br>
      #include &lt;assert.h&gt; // 読込み失敗表示用<br>
      #include &lt;memory&gt; // 回し読みポインタをザコやボスの生成に使う<br>
      #include &lt;string&gt; // 文字列に必要<br>
      <em>#include &lt;cmath&gt; // 敵出現楕円射程のsin cos計算に</em><em></em><br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "GameManager.h"<br>
      #include "Zako0.h"<br>
      #include "Zako1.h"<br>
      #include "Zako2.h"<br>
      #include "Boss.h"<br>
      <br>
      #include "DataCsv.h"<br>
	    <br>
<em>#include "CellXY.h"</em><br>
      <br>
      <em>// 空間をグリッドでマス目として分割する(世界位置worldXをマス目位置番号cellXに変換したりできる)<br>
class MapGridXY<br>
{<br>
public:<br>
&nbsp;&nbsp;&nbsp; int cellWidth = 32; // マス目セルのサイズ<br>
&nbsp;&nbsp;&nbsp; int cellHeight = 32; // マス目セルのサイズ<br>
<br>
&nbsp;&nbsp;&nbsp; // CellXYZをキーにそのマス目にあるboolを得る辞書配列<br>
&nbsp;&nbsp;&nbsp; std::unordered_map&lt;CellXY, bool, CellXY::Hash&gt; cellXY; // 読み込み済マス目の辞書<br>
&nbsp;&nbsp;&nbsp; std::unordered_map&lt;CellXY, bool, CellXY::Hash&gt; rangeXY; // 視界レンジは読み込み済cellXYと別に保管<br>
<br>
&nbsp;&nbsp;&nbsp; virtual int cellX(float worldX)<br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // マイナス方向にも対応<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return (worldX &gt;= 0) ? (int)worldX / cellWidth : (int)worldX / cellWidth - 1;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; virtual int cellY(float worldY)<br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // マイナス方向にも対応<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return (worldY &gt;= 0) ? (int)worldY / cellHeight : (int)worldY / cellHeight - 1;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; bool& operator[](CellXY searchXYZ) { // マス目に入っている先頭の参照を得る<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return cellXY[searchXYZ];<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; virtual void clear()<br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 空のテンポラリオブジェクトでリセット https://stackoverflow.com/questions/42114044/how-to-release-unordered-map-memory/42115076<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::unordered_map&lt;CellXY, bool, CellXY::Hash&gt;().swap(cellXY);<br>
&nbsp;&nbsp;&nbsp; };<br>
<br>
&nbsp;&nbsp;&nbsp; MapGridXY(int cellWidth = 32, int cellHeight = 32)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : cellWidth{ cellWidth }, cellHeight{ cellHeight }<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; clear();<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; virtual ~MapGridXY()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; clear();<br>
&nbsp;&nbsp;&nbsp; }<br>
};</em><br>
      <br>
      <br>
      class Map<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>int spawnRangeX = 0; // 敵出現射程スポーンレンジ【注意！Xの単位はマス目】<br>
        &nbsp;&nbsp;&nbsp; int spawnRangeY = 0; // 敵出現射程スポーンレンジ【注意！Yの単位はマス目】<br>
        &nbsp;&nbsp;&nbsp; MapGridXY spawnGrid{ CellSize, CellSize }; // 敵データの読み込み済のマス目を管理するグリッド</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; DataCsv enemyData;// 敵配置データ<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <em>float positionX = 0; // X位置(マップ読出し位置のXスクロール量）<br>
        &nbsp;&nbsp;&nbsp; float positionY = 0; // Y位置(マップ読出し位置のYスクロール量）</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;// filePath : CSVファイルのパス<br>
      &nbsp;&nbsp; &nbsp;// startPosition : 開始位置（デバッグやリスタート時に、面の途中から開始できるように）<br>
      &nbsp;&nbsp; &nbsp;Map(std::string filePath, float startPosition<em>X = 0, float startPositionY = 0</em>)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>positionX = startPositionX;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;positionX = startPositionY;</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enemyData.Load(filePath); // csvファイルをロード<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>spawnRangeX = Screen::Width / CellSize; // 敵出現射程スポーンレンジ【注意！Xの単位はマス目】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnRangeY = Screen::Height / CellSize; // 敵出現射程スポーンレンジ【注意！Yの単位はマス目】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //【注意！】辞書の初期化をわすれると敵が出てこなくなる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitSpawnGrid(spawnRangeX, spawnRangeY);</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;//デストラクタ<br>
      &nbsp;&nbsp; &nbsp;~Map()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<b>enemyData.clear();</b><b></b><br>
      &nbsp;&nbsp; &nbsp;}<b></b><br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 敵出現射程の辞書初期化【先に計算して辞書化】すると計算が必要なくなり【高速化する】<br>
        &nbsp;&nbsp;&nbsp; //【注意！XとYの単位はマス目】<br>
        &nbsp;&nbsp;&nbsp; void InitSpawnGrid(int rangeCellX, int rangeCellY)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnGrid.clear();//一旦辞書をクリアするのでゲーム中の再設定も可(だが処理時間はかかる)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 敵出現射程の辞書初期化<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★ X = A cosθ Y = B sinθ(←楕円の方程式)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★ 楕円の半径 r = √(A×A×cosθ×cosθ + B×B×sinθ×sinθ)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★ xの2乗 + yの2乗 &lt; rならば楕円の内側<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float A2 = (float)(rangeCellX * rangeCellX); // 2乗<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float B2 = (float)(rangeCellY * rangeCellY); // 2乗<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int x = -rangeCellX; x &lt;= rangeCellX; x++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int y = -rangeCellY; y &lt;= rangeCellY; y++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[逆三角関数] https://cpprefjp.github.io/reference/cmath/atan2.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //float theta = (float)std::atan2(y, x); // ★[逆三角関数]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //float cos_t = std::cos(theta);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //float sin_t = std::sin(theta);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //float r2 = A2 * cos_t * cos_t + B2 * sin_t * sin_t;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (x * x + y * y &lt;= r2) // ★ xの2乗 + yの2乗 &lt; rならば楕円の内側<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //{&nbsp;&nbsp; //楕円の内側なら辞書spawnGrid.rangeXY[(x,y)] = true;として登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; //【★楕円にしたいときはこちら】spawnGrid.rangeXY[CellXY(x,y)] = true; //【例】spawnGrid.rangeXY[(3,2)] = true;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //【★四角形にしたいときはこちら】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnGrid.rangeXY[CellXY(x, y)] = true;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      <br>
      &nbsp;&nbsp; &nbsp;<em>// 画面スクロール（位置の更新）<br>
        &nbsp;&nbsp; &nbsp;void Scroll(float deltaX, float deltaY=0)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; int diffX = spawnGrid.cellX(positionX + deltaX) - spawnGrid.cellX(positionX);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; int diffY = spawnGrid.cellY(positionY + deltaY) - spawnGrid.cellY(positionY);<br>
	      <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; float prevPosX = positionX; // デルタの変化を足す前の位置を保管する<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; float prevPosY = positionY;<br>
	      <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; positionX += deltaX; // 現在の位置を更新<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; positionY += deltaY; // 現在の位置を更新<br>
	      <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (diffX == 0 && diffY == 0)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; return; // 同じマス目のままなら何も変化なし<br>
	      <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // 読み込むマス目の絞り込み判定 (参考:説明スライド)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;CellXY&gt; targetCells;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; for (auto iter = spawnGrid.rangeXY.begin(); iter != spawnGrid.rangeXY.end(); ++iter)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {&nbsp; // ★連想辞書配列のfor文 https://qiita.com/_EnumHack/items/f462042ec99a31881a81<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; CellXY cell = iter->first;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; CellXY target = CellXY(cell.X + diffX, cell.Y + diffY);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; if (spawnGrid.rangeXY.count(target) == 0)<br>
	&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; targetCells.emplace_back(target); // 移動後にレンジの外側にはみ出たマス目を収集<br>
	&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // 敵新規出現マスを探す<br>
	&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; target : targetCells)<br>
	&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
	&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; CellXY cell = CellXY(spawnGrid.cellX(prevPosX) + target.X, spawnGrid.cellY(prevPosY) + target.Y);<br>
	      <br>
	&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; // [判定] count(cell) == 0なら未ロードマス、count(cell) == 1 && cellXY[cell] == falseならロード後falseに戻されたマス<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; if (spawnGrid.cellXY.count(cell) == 0 || spawnGrid.cellXY.count(cell) == 1 && spawnGrid.cellXY[cell] == false)<br>
	&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; int objectID = -1;//出現させる敵ID<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; if (0 <= cell.Y && 0 <= cell.X && cell.Y < enemyData.size() && cell.X < enemyData[cell.Y].size())<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; {&nbsp;&nbsp; //データがアクセスできればIDを取得<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; objectID = enemyData[cell.Y][cell.X];<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; // ★一度出現させたマスはIDを上書きして二重に敵が出現しないように<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; enemyData[cell.Y][cell.X] = -1;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; }<br>
		<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; // ★(cell.X,cell.Y)の位置のマップデータを読み出し！！<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; SpawnObject(cell.X, cell.Y, objectID);<br>
	&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;}</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// オブジェクトを生成・配置する<br>
        &nbsp;&nbsp;&nbsp; void SpawnObject(int mapX, int mapY, int id)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 生成位置<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x = (float)(mapX * CellSize) - positionX;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float y = (float)(mapY * CellSize) - positionY;<br>
<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[コメント外すとテスト表示]if (objectID != -1)printfDx("newID %d (%d,%d,%f,%f)\n", id, mapX, mapY, x, y);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 番号に応じて敵を生成する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (id == -1) return; // -1は空白なので、何もしない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (id == 0) gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3(x + 32, y + 32)));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (id == 1) gm.enemies.emplace_back(std::make_shared&lt;Zako1&gt;(Vector3(x + 32, y + 32)));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (id == 2) gm.enemies.emplace_back(std::make_shared&lt;Zako2&gt;(Vector3(x + 32, y + 32)));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (id == 100) gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(x + 90, y + 32))); // ボスは横幅180pxだから90px右に生成<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else assert("まだ追加してない敵IDがマップCSVにありました。"=="");<br>
        &nbsp;&nbsp; &nbsp;}</em><br>
      };<br>
      #endif</p>
    <br>
    <br>
    <p>うまくいけば、これで全方向のスクロールが可能です。<br>
      Game.cppやPlayScene.hで<b>map-&gt;Scroll(ScrollSpeedX, ScrollSpeedY);</b>でY方向のスクロールもできるようになりました。<br>
      今回はシューティングなのでY方向はデフォルトの0のままで大丈夫です。<br>
    </p>
    <br>
    <br>
    <h1><a id="mozTocId4003" class="mozTocH1"></a>自機狙い弾</h1>
    <h2>点と点を結んだ線の角度を調べる関数</h2>
      インクルードするのは<b>#include &lt;cmath&gt;</b>になります。cmathはスタンダード(<b>ST</b>andar<b>D</b>)ライブラリ所属なので<br>
      つかうときはstd::cos()とか<b>std::atan2()</b>になります。(stdはスタンダードの略)</p>
    <p><code>MyMath.hに逆三角関数でプレイヤへの角度を求める関数を追加</code>しましょう。</p>
    <p class="source">#ifndef _MYMATH_H<br>
      #define _MYMATH_H<br>
      <br>
      <em>#include &lt;cmath&gt;</em><br>
      #include "Vector3.h"<br>
      <br>
      // 数学関連クラス<br>
      class MyMath<br>
      {<br>
      public:<br>
      &nbsp; // C++標準では、静的static定数は【整数型】または【列挙型】のみを.hのクラス内で初期化できます。<br>
      &nbsp; // これが、intやenumの初期化はエラーにならないのに他のstatic floatなどがエラーになる理由です。<br>
      <br>
      &nbsp;&nbsp;&nbsp; // float小数を定義するためだけにcppファイルを作成しないと<br>
      &nbsp;&nbsp;&nbsp; //static const float Sqrt2 =【このイコールでエラー】 1.41421356237f;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ルート2(変数名の定義だけ)<br>
      &nbsp;&nbsp;&nbsp; static const float Sqrt2;// = 1.41421356237f;<br>
      &nbsp;&nbsp;&nbsp; static const float PI; // 円周率 3.14159265359f;<br>
      &nbsp;&nbsp;&nbsp; static const float Deg2Rad; // 度からラジアンに変換する定数 PI / 180f;<br>
      <br>
      &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
      &nbsp;&nbsp;&nbsp; /// 円と円が重なっているかを調べる<br>
      &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;param name="pos1"&gt;円1の中心&lt;/param&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;param name="pos2"&gt;円2の中心&lt;/param&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
      &nbsp;&nbsp;&nbsp; static bool CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 pos1, float radius1,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 pos2, float radius2)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((pos1 - pos2).sqrMagnitude()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt; (radius1 + radius2) * (radius1 + radius2));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;<em>/// &lt;summary&gt;<br>
        &nbsp;&nbsp; &nbsp;/// 点から点への角度（ラジアン）を求める。<br>
        &nbsp;&nbsp; &nbsp;/// &lt;/summary&gt;<br>
        &nbsp;&nbsp; &nbsp;/// &lt;param name="fromXY"&gt;始点&lt;/param&gt;<br>
        &nbsp;&nbsp; &nbsp;/// &lt;param name="toXY"&gt;終点&lt;/param&gt;<br>
        &nbsp;&nbsp; &nbsp;/// &lt;returns&gt;&lt;/returns&gt;<br>
        &nbsp;&nbsp; &nbsp;static float PointToPointAngle(Vector3 fromXY, Vector3 toXY)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return (float)<b>std::atan2</b>(toXY.y - fromXY.y, toXY.x - fromXY.x);<br>
        &nbsp;&nbsp; &nbsp;}</em><br>
      <br>
      }; // 【注意】セミコロン抜けで【宣言が必要ですエラー】<br>
      <br>
      #endif // 【宣言が必要ですエラーは上のセミコロン抜け】</p>
    <br>
    <br>
    <h2>自機狙い弾を撃たせる</h2>
    <p><code>Zako0</code>を改造して自機狙い弾を撃たせてみます（別に他の敵クラスでも構いません）。<br>
      ついでにZako0の<b>画面外に出たら消す処理も入れましょう【敵が消えないとCPUが当たり判定で激重くなりますよ】</b><br>
      これを機に<b>Zako1,Zako2,Zako3の画面外で消す判定も追加しておいた方がいい</b>ですよ。<br>
      敵がステージに100体出て(撃ち漏らしたら)プレイヤが10発弾を撃つとすると【100×10=1000回の当たり判定】になりますから。</p>
    <p class="source">#ifndef ZAKO_0_H_<br>
      #define ZAKO_0_H_<br>
      <br>
      #include "Enemy.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      #include "EnemyBullet.h" // make_sharedなど【実際の弾を撃ち生成処理を行うのでインクルード必要】<br>
      <br>
      <em>#include "Player.h" // Player.hでもZako0.hをインクルードすると循環するので注意</em><br>
      <br>
      // ザコ0クラス<br>
      class Zako0 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int coolTime = 0; // クールタイム（冷却時間。0になるまで次の弾が撃てない）<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Zako0(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Zako0";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x -= 1; // とりあえず左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime--;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (coolTime &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// 自機狙い弾<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float angle = MyMath::PointToPointAngle(position, gm.player-&gt;position);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, <em>angle</em>, 8));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime += 10;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// 【重要】画面外の削除処理【CPU処理重くなる原因】<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (position.x &lt; 0)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 左端の画面外に出たらisDeadしないと<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 画面外の敵の当たり判定で【だんだん処理が重くなるZako1,Zako2..も】<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isDead = true;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako0, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <h2>ばらまき自機狙い弾を撃たせる</h2>
    <p><code>Zako2</code>を改造してばらまき自機狙い弾を撃たせてみます（別に他の敵クラスでも構いません）。<br>
    </p>
    <p class="source">#ifndef ZAKO_2_H_<br>
      #define ZAKO_2_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      #include &lt;cmath&gt; // Sin Cosの計算に使う<br>
      <br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include "MyMath.h"<br>
      #include "MyRandom.h"<br>
      #include "EnemyBullet.h" // make_sharedなど【実際の弾を撃ち生成処理を行うのでインクルード必要】<br>
      <br>
      <em>#include "Player.h" // Player.hでもZako2.hをインクルードすると循環するので注意</em><br>
      <br>
      // ザコ2クラス<br>
      class Zako2 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int coolTime = 0; // クールタイム（冷却時間。0になるまで次の弾が撃てない）<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Zako2(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Zako2";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (position.x &gt; Screen::Width - 200)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { // スクリーンの端から200の位置で止まる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x -= 1; // とりあえず左へ移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime--;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (coolTime &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 自機狙いばらまき弾<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float angle = MyMath::PointToPointAngle(position, gm.player-&gt;position);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float randomAngle = MyRandom::Range(-15.0f, 15.0f); // ±15度の乱数の角度を取得</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, <em>angle + randomAngle * MyMath::Deg2Rad</em>, 8));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime += 10;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 200の位置で止まるので左端にこないから削除処理はなくて済む</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako2, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p>さて、ザコ2の場合は画面内の200で止まるので削除処理を入れませんでした。<br>
      そう、<b>削除処理も敵により臨機応変にやるのですね。例えば下から出て上に向かう敵はyが0以下で削除です。</b><br>
      つまり、<b>削除処理も敵の個性の一つの扱いというわけ</b>です。 </p>
    <br>
    <h1><a id="mozTocId4004" class="mozTocH1"></a>自機に向かってくる敵</h1>
    <p>自機に向かってくる敵も基本は追尾弾と同じですね。</p>
    <p><code>Zako1.hにプレイヤへ向かってくる処理を追加</code>しましょう。</p>
    <p class="source">#ifndef ZAKO_1_H_<br>
      #define ZAKO_1_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      #include &lt;cmath&gt; // Sinの計算に使う<br>
      #include "MyMath.h"<br>
      #include "Image.h"<br>
      <br>
      #include "MyRandom.h" // 乱数でアイテムのドロップを抽選する<br>
      #include "Item0.h"<br>
      <br>
      <em>#include "Player.h" // Player.hでもZako1.hをインクルードすると循環するので注意</em><br>
      <br>
      // ザコ1クラス<br>
      class Zako1 : public Enemy<br>
      {<br>
      public:<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Zako1(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Zako1";//オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life = 5;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// 自機をおいかけてくる処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float angleToPlayer = MyMath::PointToPointAngle(position, gm.player-&gt;position);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float speed = 3;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position += Vector3((float)std::cos(angleToPlayer) * speed, (float)std::sin(angleToPlayer) * speed);</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako1, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アイテムを落とす処理<br>
      &nbsp;&nbsp;&nbsp; void DropItem() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (中略).......<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <br>
    <p>ゆらゆらしながら【自機に】向かってくる敵にしてみましょうか。</p>
    <p><code>Zako1.hにSin波動でゆらゆら【自機に向かってくる】処理を追加</code>しましょう。</p>
    <p class="source">#ifndef ZAKO_1_H_<br>
      #define ZAKO_1_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      #include &lt;cmath&gt; // Sinの計算に使う<br>
      #include "MyMath.h"<br>
      #include "Image.h"<br>
      <br>
      #include "MyRandom.h" // 乱数でアイテムのドロップを抽選する<br>
      #include "Item0.h"<br>
      <br>
      #include "Player.h" // Player.hでもZako1.hをインクルードすると循環するので注意<br>
      <br>
      // ザコ1クラス<br>
      class Zako1 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;<em>float sinMove = 0; // Sinの動きをする際の0～360度<br>
        &nbsp;&nbsp; &nbsp;float sinRadius = 70; // Sinの動きをするときの半径</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Zako1(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Zako1";//オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life = 5;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機をおいかけてくる処理<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float angleToPlayer = MyMath::PointToPointAngle(position, gm.player-&gt;position);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float speed = 3;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position += Vector3((float)std::cos(angleToPlayer) * speed, (float)std::sin(angleToPlayer) * speed);<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>//ゆらゆらSin波動の動きをy上下方向にプラス<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float prevSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sinMove += 2.5f; // Sinの波運動の角度を進める<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float currentSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// (前の角度でのY) - (今の角度でのY)の差を足すことで【ベースのyの位置 ± sinの動き】になる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position.y += currentSinY - prevSinY; // 上下方向のSinの波運動</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako1, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アイテムを落とす処理<br>
      &nbsp;&nbsp;&nbsp; void DropItem() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (中略).......<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p>ゆらゆら向かってくるほうが<b>理論上は避けやすいはずなのに、見た目上は逆に怖く見えませんか？</b></p>
    <br>
    <p>あれ？何か2回、<b>2種類の　y += 〜;</b>やってるけどアリなの？と思った人。<br>
      今から数字のマジックを示すので実感してください。<br>
      毎回 y += 〜;されるということは、つまり</p>
    <p class="source"><b>y = (今の角度のY)-(前の角度のY) + (前の角度のY)-(前の前の角度のY) + (前の前の角度のY)-(前の前の前の角度のY)...</b></p>
    となりますよね。<br>
    <p>そしてここで<b>数字のマジックを見てみましょう</b></p>
    <p class="source"> y = (今の角度のY) <u>-(前の角度のY) + (前の角度のY)</u> <u>-(前の前の角度のY) + (前の前の角度のY)</u> <u>- (前の前の前の角度のY)...</u>.....<br>
      <b>y = (今の角度のY) - (一番最初の角度のY=0)←sin 0°=0だから0<br>
      </b></p>
    <p> おお！<b>見事に打ち消しあって(今の角度のY)だけ残りましたね(一番最初の角度0°のYは0になるので)</b><br>
      じゃあ、<b>最初からy += せずにy = (今の角度のY);にすればいいんじゃ？</b>って思う人もいると思います。<br>
      そうするとどうなるか?2つの違う動きの合成が難しくなります。<br>
    </p>
    <p class="source">y += 1; // 【メイン】の動き(少しづつ下に行く)<br>
      <b>y = (今の角度のY); // あ、上書き固定値で y += 1;の効果消えちゃう..</b></p>
    <p>なので<b>【動きを += ～;で表現しつつも毎回打ち消しあう】</b>必要が出てくるのです。<br>
    </p>
    <p class="source">y += 1; // 【メイン】の動き(少しづつ下に行く)<br>
      <b>y += (今の角度のY) - (前の角度のY); // これなら y += 1;の効果が消えない！</b></p>
    <p>これなら色々な動きを<b>【合成した動きなのに】【お互いの動きを消す心配】がなくなります。</b></p>
    <p> これが<b>±プラマイ0で合成テクニック⇒微分•積分的テクニック</b>です。<br>
      え、<b>微分積分て難しい式なんじゃなかったっけ？</b>って思うでしょうが<br>
      これも<b>すこしトリッキーですが積分的な式です。<a href="https://www.momoyama-usagi.com/entry/math-sabun1#i">(離散数学的に n と n-1 の漸化式を使っている感じ?)</a></b><br>
      積分は<b>【ちりが積もれば山となる式】</b>です。<br>
      で、この場合<b>【「ちり」が微分です】(1フレームごとの値、それを0～60フレーム1秒間ぶん足し合わせるとの移動量が積分されて求まる)</b><br>
      今回の例では<b>【yが山です】</b><br>
      そして<b>【「ちり」が(今の角度のY) - (前の角度のY)です】</b><br>
      これを<b>【(今の角度のsin) - (前の角度のsin)の積分がsinθになった】</b><br>
      逆に言うと<b>【sinθを微分すると(今の角度のsin) - (前の角度のsin)になった】</b>とも言えます。<br>
      式で書くと<b>y += 半径×sinθ1(←今の角度のY) - 半径×sinθ2(←前の角度のY)</b>となってます。<br>
      <br>
      どうでしょう意外と微分積分を身近に感じられませんか？<br>
      数学の難しい式、実際使う場合は意外とシンプルなやり方になったりします。<br>
      この【今と前の差】を+= するテクニックはSin以外でも使えるので心に留めておきましょう。<br>
      たとえばxも同じようにすれば、円を描きながら追ってくる敵も作れます。<br>
      <b>x += 半径×cosθ1(←今の角度のX) - 半径×cosθ2(←前の角度のX)</b><br>
      気になった人は試してみてくださいね。<br>
      
    </p>
追加でcosMove,cosRadiusを定義して..<br>
<p class="source">class Zako1 : public Enemy<br>
{<br>
public:<br>
      &nbsp;&nbsp;&nbsp; float sinMove = 0; // Sinの動きをする際の0～360度<br>
      &nbsp;&nbsp;&nbsp; float sinRadius = 70; // Sinの動きをするときの半径<br>
<br>
      &nbsp;&nbsp;&nbsp; <em>float cosMove = 0; // cosの動きをする際の0～360度<br>
      &nbsp;&nbsp;&nbsp; float cosRadius = 70; // cosの動きをするときの半径</em><br></p>
Update()関数内にX方向の動きも追加すると..<br>
		<p class="source"><em>
&nbsp;&nbsp;&nbsp; &nbsp; //ゆらゆらCos波動の動きをx左右方向にプラス<br>
&nbsp;&nbsp;&nbsp; &nbsp; float prevCosX = std::cos(cosMove * MyMath::Deg2Rad) * cosRadius;<br>
&nbsp;&nbsp;&nbsp; &nbsp; cosMove += 2.5f; // Cosの波運動の角度を進める<br>
&nbsp;&nbsp;&nbsp; &nbsp; float currentCosX = std::cos(cosMove * MyMath::Deg2Rad) * cosRadius;<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp; // (前の角度でのX) - (今の角度でのX)の差を足すことで【ベースのxの位置 ± cosの動き】になる<br>
&nbsp;&nbsp;&nbsp; &nbsp; position.x += currentCosX - prevCosX; // 上下方向のSinの波運動</em><br></p>

		
    <a id="mozTocId5000" class="mozTocH1"></a>
    <p class="title">[C++]シューティングゲーム 5【応用1】</p>
    <br>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId5001">複数コントローラでプレイ</a><br>
      ―<a href="#mozTocId50011">Inputクラスの複数プレイ対応</a><br>
      ―<a href="#mozTocId50012">複数プレイヤの参加処理</a><br>
      ―<a href="#mozTocId50013">[DXのバグ!?仕様?]複数コントローラは4以降があやしい件</a></li><br>
	<li><a href="#mozTocId50014">背景画像を作ってループ表示させてみる</a></li>
	<li><a href="#mozTocId50015">スコアを画面表示させてみる</a></li>
	<li><a href="#mozTocId50016">フォントを変えてみる</a></li>
	<li><a href="#mozTocId50017">スコアの加算と背景の加速</a></li>
	<li><a href="#mozTocId50018">スコアのランキング表示</a></li>
	<li><a href="#mozTocId50019">スコアのセーブ保存とCSVのセルを受けint,float,文字列に柔軟に化けるCsvValue型</a></li>
	<li><a href="#mozTocId50020">キーボードとマウスの入力</a></li>
      	<li><a href="#mozTocId50021">ゲームクリア画面への遷移</a></li>
      	<li><a href="#mozTocId50022">【課題】シューティングとして完成させるための残された課題</a></li>
      
      <br>
      <br>
      <a href="#mozTocId6000"></a><br>
    </ol>
    <h1><a id="mozTocId5001" class="mozTocH1"></a>複数コントローラでプレイ</h1>
    <h2><a id="mozTocId50011" class="mozTocH1"></a>Inputクラスの複数プレイ対応</h2>
    <p>複数コントローラーでプレイするためにはまずはInputクラスの改造が必要です。</p>
    <p><code>Input.hのボタン状態を配列</code>にしてゆきましょう。</p>
    <p class="source">#ifndef INPUT_H_<br>
      #define INPUT_H_<br>
      <br>
      #include "DxLib.h"<br>
      <br>
      <em>// コントローラのパッド番号の列挙型enum<br>
        enum class Pad<br>
        {<br>
        &nbsp;&nbsp; &nbsp;None=-1, // パッド割当て無(やられたり待機中のプレイヤに)<br>
        &nbsp;&nbsp; &nbsp;Key=0, // キーボード<br>
        &nbsp;&nbsp; &nbsp;One, // コントローラ1<br>
        &nbsp;&nbsp; &nbsp;Two, // コントローラ2<br>
        &nbsp;&nbsp; &nbsp;Three, // コントローラ3<br>
        &nbsp;&nbsp; &nbsp;Four, // コントローラ4<br>
        &nbsp;&nbsp; &nbsp;NUM, // コントローラの数NUM=5(ちょうど配列の数にもなる)<br>
        };</em><br>
      <br>
      // 入力クラス<br>
      class Input<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; static int prevState<em>s[(int)Pad::NUM]</em>; // 1フレーム前の状態<br>
      &nbsp;&nbsp;&nbsp; static int currentState<em>s[(int)Pad::NUM]</em>; // 現在の状態<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化。タイトルなどキー入力状態リセット時に<br>
      &nbsp;&nbsp;&nbsp; static void Init()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// キー状態をゼロリセット<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::Key] = currentStates[(int)Pad::Key] = 0;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::One] = currentStates[(int)Pad::One] = 0;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::Two] = currentStates[(int)Pad::Two] = 0;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::Three] = currentStates[(int)Pad::Three] = 0;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::Four] = currentStates[(int)Pad::Four] = 0;</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 最新の入力状況に更新する処理。<br>
      &nbsp;&nbsp;&nbsp; // 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
      &nbsp;&nbsp;&nbsp; static void Update()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>prevStates[(int)Pad::Key] = currentStates[(int)Pad::Key];</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentStates[(int)Pad::Key] = GetJoypadInputState(DX_INPUT_KEY);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::One] = currentStates[(int)Pad::One];<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentStates[(int)Pad::One] = GetJoypadInputState(DX_INPUT_PAD1);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::Two] = currentStates[(int)Pad::Key];<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentStates[(int)Pad::Two] = GetJoypadInputState(DX_INPUT_PAD2);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::Three] = currentStates[(int)Pad::Key];<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentStates[(int)Pad::Three] = GetJoypadInputState(DX_INPUT_PAD3);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::Four] = currentStates[(int)Pad::Key];<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentStates[(int)Pad::Four] = GetJoypadInputState(DX_INPUT_PAD4);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <em>// ↑ちょ！...ちょい待てーい！！待たれ給えよ！！<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // 【こんなのいちいち書いてられるかー！！！！！】</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; }<br>
      (以下略)..................</p>
    <br>
    <p>はい、<b>ダメでござる。こんなのいちいち拙者書きたくないでござる</b>よ！！<br>
      こういう時こそ、<b>for文や辞書配列の出番でござるよ。絶対そのほうが良いでござるよ。</b></p>
    <br>
    <p><code>Input.hの複数プレイのボタン状態を辞書配列とfor文を駆使して書くでござるよ。</code></p>
    <p class="source">#ifndef INPUT_H_<br>
      #define INPUT_H_<br>
      <br>
      <em>#include &lt;unordered_map&gt; // 辞書配列【map高速版】https://qiita.com/sileader/items/a40f9acf90fbda16af51</em><br>
      <br>
      #include "DxLib.h"<br>
      <br>
      // コントローラのパッド番号の列挙型enum<br>
      enum class Pad<br>
      {<br>
      &nbsp;&nbsp; &nbsp;None=-1, // パッド割当て無(やられたり待機中のプレイヤに)<br>
      &nbsp;&nbsp; &nbsp;Key=0, // キーボード<br>
      &nbsp;&nbsp; &nbsp;One, // コントローラ1<br>
      &nbsp;&nbsp; &nbsp;Two, // コントローラ2<br>
      &nbsp;&nbsp; &nbsp;Three, // コントローラ3<br>
      &nbsp;&nbsp; &nbsp;Four, // コントローラ4<br>
      &nbsp;&nbsp; &nbsp;NUM, // コントローラの数NUM=5(ちょうど配列の数にもなる)<br>
      };<br>
      <br>
      // 入力クラス<br>
      class Input<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; static int prevStates[(int)Pad::NUM]; // 1フレーム前の状態<br>
      &nbsp;&nbsp;&nbsp; static int currentStates[(int)Pad::NUM]; // 現在の状態<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>static std::unordered_map&lt;int, int&gt; padDic; // パッド番号からDXの定義への変換辞書</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 辞書配列の初期化<br>
        &nbsp;&nbsp;&nbsp; static void InitPadDictionary()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 辞書配列で対応関係の辞書を作成しておく<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Key] = DX_INPUT_KEY;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::One] = DX_INPUT_PAD1;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Two] = DX_INPUT_PAD2;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Three] = DX_INPUT_PAD3;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Four] = DX_INPUT_PAD4;<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化。タイトルなどキー入力状態リセット時に<br>
      &nbsp;&nbsp;&nbsp; static void Init()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>InitPadDictionary(); // パッドの辞書配列の初期化</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // キー状態をゼロリセット<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i] = 0;</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 最新の入力状況に更新する処理。<br>
      &nbsp;&nbsp;&nbsp; // 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
      &nbsp;&nbsp;&nbsp; static void Update()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <em>for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 現在の状態を一つ前の状態として保存してGetJoypad..</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>prevState<em>s[i]</em> = currentState<em>s[i]</em>;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>currentState<em>s[i]</em> = GetJoypadInputState(<em>padDic[i]</em>);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>}</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが押されているか？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButton(<em>Pad pad, </em>int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if(pad == Pad::None) return false; // Noneなら判別不要</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今ボタンが押されているかどうかを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (currentState<em>s[(int)pad]</em> &amp; buttonId) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが押された瞬間か？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButtonDown(<em>Pad pad, </em>int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if(pad == Pad::None) return false; // Noneなら判別不要</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今は押されていて、かつ1フレーム前は押されていない場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((currentState<em>s[(int)pad]</em> &amp; buttonId) &amp; ~(prevState<em>s[(int)pad]</em> &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが離された瞬間か？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButtonUp(<em>Pad pad, </em>int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if(pad == Pad::None) return false; // Noneなら判別不要</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1フレーム前は押されていて、かつ今は押されている場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((prevState<em>s[(int)pad]</em> &amp; buttonId) &amp; ~(currentState<em>s[(int)pad]</em> &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }; //←【注意】クラス定義の終わりにはコロンが必要だよ！<br>
      <br>
      #endif&nbsp; //ここでエラー出た人は↑【注意】の;コロン忘れ</p>
    <br>
    <p><code>Input.cppの変数定義を変更します。</code></p>
    <p class="source">#include "Input.h"<br>
      <br>
      int Input::prevState<em>s[]</em>; // 1フレーム前の状態<br>
      int Input::currentState<em>s[]</em>; // 現在の状態<br>
      <br>
      <em>std::unordered_map&lt;int, int&gt; Input::padDic; // パッド番号からDXの定義への辞書</em><br>
    </p>
    <br>
    <p> これでボタン判定にはPad番号の指定が必須になりました。<br>
      したがって既存のボタン入力コードにはエラーが出るはずです。<br>
      むしろ出たほうが良いと思い <b>GetButtonDown(int buttonId<em>, Pad pad = Pad::key</em>)</b>みたいな<br>
      <b>デフォルト = Pad::key設定</b>をしませんでした。(デフォルト=があれば省略できたが)<br>
      なぜなら明確にエラーが出ないと<b>複数プレイ対応直し忘れ</b>がでちゃいますからね。<br>
    </p>
    <br>
    <p><code>Player.hにそのプレイヤを操るコントローラpadの定義</code>を追加しましょう。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      #include "GameManager.h"<br>
      <br>
      class Player : public GameObject<br>
      { // 継承は↑: public ～にする。publicをつけ忘れるとGameObjectの変数がすべてprivateとして継承されちゃう<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; <em>Pad pad = Pad::None; // デフォルトは未割当て</em><br>
      &nbsp;&nbsp;&nbsp; const float MoveSpeed = 6; // 移動速度<br>
      &nbsp;&nbsp;&nbsp; int MutekiJikan = 120; // 無敵時間<br>
      <br>
      &nbsp;&nbsp;&nbsp; float collisionRadius = 32; // 当たり判定半径<br>
      <br>
      &nbsp;&nbsp;&nbsp; int lifeMax = 20; // 最大ライフ<br>
      &nbsp;&nbsp;&nbsp; int life = 3; // ライフ<br>
      &nbsp;&nbsp;&nbsp; int mutekiTimer = 0; // 残り無敵時間。0以下なら無敵じゃないってこと<br>
      <br>
      &nbsp;&nbsp;&nbsp; //【★注意！】ここに【x,yの定義が残ってるとGameObjectと被る】ので<br>
      &nbsp;&nbsp;&nbsp; // 名前の同じ変数が2つ【パラレルワールドに存在してしまう！】<br>
      &nbsp;&nbsp;&nbsp; // Playerからx=13,y=5に変えたつもりでも【ベースのGameObjectはx=0,y=0のままの不思議バグで混乱！】<br>
      <br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; <em>// pad : 対応するコントローラ</em><br>
      &nbsp;&nbsp;&nbsp; // pos : 初期位置<br>
      &nbsp;&nbsp;&nbsp; Player(<em>Pad pad, </em>Vector3 pos) : GameObject(pos) //【忘れると】GameObjectの初期化処理が飛ばされて大混乱！<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>this-&gt;pad = pad;</em><br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw();<br>
      <br>
      &nbsp;&nbsp;&nbsp; (中略)....<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 敵にぶつかった時の処理<br>
      &nbsp;&nbsp;&nbsp; void OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 敵弾とぶつかった時の処理<br>
      &nbsp;&nbsp;&nbsp; void OnCollisionEnemyBullet(std::shared_ptr&lt;GameObject&gt; other);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ダメージを受ける処理<br>
      &nbsp;&nbsp;&nbsp; void TakeDamage();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ライフが回復する処理<br>
      &nbsp;&nbsp;&nbsp; void RecoverLife(int amount);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ライフをバーで表示する処理<br>
      &nbsp;&nbsp;&nbsp; void DrawLifeBar();<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Player.cppのInput判定にコントローラpadの指定</code>を追加しましょう。<br>
      なおデフォルトの<b>Pad::Noneの状態のままの時は反応しなくなります！</b></p>
    <p class="source">#include "Player.h"<br>
      #include "MyMath.h"<br>
      <br>
      #include "PlayerBullet.h" // ★弾を生成して【使う処理があるのでインクルード必要】<br>
      <br>
      #include "Explosion.h"<br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; v = Vector3(0, 0, 0); // xyz方向移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(<em>pad, </em>PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.x = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(<em>pad, </em>PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.x = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(<em>pad, </em>PAD_INPUT_UP))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.y = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(<em>pad, </em>PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.y = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 斜め移動も同じ速度になるように調整<br>
      &nbsp;&nbsp;&nbsp; if (v.magnitude() > 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      &nbsp;&nbsp;&nbsp; position += v;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタン押下で自機弾を発射<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(<em>pad, </em>PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // C++ではAddがemplace_backに↓ newがmake_shared↓に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(position, 0));//右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(position, -15 * MyMath::Deg2Rad));//右上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(position, +15 * MyMath::Deg2Rad));//右下<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; mutekiTimer--;// 無敵タイマーは無条件で毎フレームカウントダウン<br>
      }<br>
      <br>
      (以下略)................<br>
    </p>
    <br>
    <p><code>TitleScene.hのInput判定にコントローラpadの指定</code>を書換えましょう。</p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "Sound.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; (中略).....................<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタン入力に応じた処理<br>
      &nbsp;&nbsp;&nbsp; void HandleInput()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// 全部のパッドぶんボタンが押されてるか検査<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>if (Input::GetButtonDown(<em>(Pad)i,</em> PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>{&nbsp;&nbsp;&nbsp; // ボタンを押したらスタート音声を再生<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>&nbsp;&nbsp;&nbsp; Sound::Play(Sound::start);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>&nbsp;&nbsp;&nbsp; isStartPushed = true; // 画面遷移トリガーON<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>}<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>}</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// いや..ちょ、ちょい待たれよー！いちいちfor文書くの??</em><br>
      <br>
      (以下略)................<br>
    </p>
    <p>はい、来ました！<b>使い勝手の悪さを発見しましたね！</b><br>
      <b>いちいち全部のコントローラ確かめるときはfor文で囲うのがめんどくさい</b>ですよね。<br>
      よいアイデアがあります。Inputの方を改造しましょう。</p>
    <br>
    <br>
    <p><code>Input.hのコントローラpadの種類にAll(すべての内どれか押されたら)を指定できるように</code>改造しましょう。</p>
    <p class="source">#ifndef INPUT_H_<br>
      #define INPUT_H_<br>
      <br>
      #include &lt;unordered_map&gt; // 辞書配列【map高速版】https://qiita.com/sileader/items/a40f9acf90fbda16af51<br>
      <br>
      #include "DxLib.h"<br>
      <br>
      // コントローラのパッド番号定義<br>
      enum class Pad<br>
      {<br>
      &nbsp;&nbsp;&nbsp; <em>All = -2, // すべてのうちどれか1つでも押されたとき</em><br>
      &nbsp;&nbsp;&nbsp; None = -1, // パッド割当て無(やられたり待機中のプレイヤに)<br>
      &nbsp;&nbsp;&nbsp; Key=0, // キーボード<br>
      &nbsp;&nbsp;&nbsp; One, // コントローラ1<br>
      &nbsp;&nbsp;&nbsp; Two, // コントローラ2<br>
      &nbsp;&nbsp;&nbsp; Three, // コントローラ3<br>
      &nbsp;&nbsp;&nbsp; Four, // コントローラ4<br>
      &nbsp;&nbsp;&nbsp; NUM, // コントローラの数=5<br>
      };<br>
      <br>
      // 入力クラス<br>
      class Input<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; static int prevStates[(int)Pad::NUM]; // 1フレーム前の状態<br>
      &nbsp;&nbsp;&nbsp; static int currentStates[(int)Pad::NUM]; // 現在の状態<br>
      <br>
      &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;int, int&gt; padDic; // パッド番号からDXの定義への辞書<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 辞書配列の初期化<br>
      &nbsp;&nbsp;&nbsp; static void InitPadDictionary()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 辞書配列で対応関係を結び付けておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Key] = DX_INPUT_KEY;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::One] = DX_INPUT_PAD1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Two] = DX_INPUT_PAD2;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Three] = DX_INPUT_PAD3;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Four] = DX_INPUT_PAD4;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化。タイトルなどキー入力状態リセット時に<br>
      &nbsp;&nbsp;&nbsp; static void Init()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; InitPadDictionary(); // パッドの辞書配列の初期化<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // キー状態をゼロリセット<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i] = 0<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 最新の入力状況に更新する処理。<br>
      &nbsp;&nbsp;&nbsp; // 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
      &nbsp;&nbsp;&nbsp; static void Update()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 現在の状態を一つ前の状態として保存してGetJoypad..<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i];<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; currentStates[i] = GetJoypadInputState(padDic[i]);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが押されているか？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButton(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // GetButtonの中でGetButtonを呼ぶ【再起呼出し】テクニック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetButton((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今ボタンが押されているかどうかを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (currentStates[(int)pad] &amp; buttonId) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが押された瞬間か？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButtonDown(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 再起呼出しテクニック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetButtonDown((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今は押されていて、かつ1フレーム前は押されていない場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((currentStates[(int)pad] &amp; buttonId) &amp; ~(prevStates[(int)pad] &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが離された瞬間か？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButtonUp(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 再起呼出しテクニック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetButtonUp((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1フレーム前は押されていて、かつ今は押されている場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((prevStates[(int)pad] &amp; buttonId) &amp; ~(currentStates[(int)pad] &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }; //←【注意】クラス定義の終わりにはコロンが必要だよ！<br>
      <br>
      #endif&nbsp; //ここでエラー出た人は↑【注意】の;コロン忘れ<br>
    </p>
    <p><b>極意【再起呼出し】(自分自身を呼び出すこと)が炸裂しましたね！(再起はきれいにハマると気持ちいいです)</b><br>
      <b>自分自身を呼び出すなんてそんなのアリ!?</b>ですよね。<br>
      でもこのテク便利です。<b>【if条件の絞りミスると呼出し無限ループしますがね】</b><br>
      あと、もう一つのテク<b>【enumの種類をAll=-2でマイナス方向に拡張してます】</b><br>
      生真面目な人は0から始めたらプラス方向しかできないと思いがちですよね。<br>
      頭が固いです。<b>柔軟にマイナスのenum番号も有効活用すればいい</b>んです。<br>
      0から上はコントローラ番号に割り当てることで<b>for(int i=0;i&lt; (int)Pad::NUM; i++)で全チェックのi</b>に使えます。<br>
      <b>0から上の番号にALLとか例外の番号が割り込んでくるとforで回すのに邪魔</b>ですからね。<br>
      だからマイナスのenum番号は意外に便利なんです。<b>普通はfor文でマイナスのiを使わないからこそ【マイナスの配列番号は絶対空いてるんです】</b></p>
    <br>
    <br>
    <p>さあ、これで<b>使う側はPad::Allを指定するだけ</b>でコントローラのどれか1つでもボタンが押されたら検知できます。<br>
    </p>
    <p><code>TitleScene.hのInput判定にコントローラpadの指定</code>を書換えましょう。</p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "Sound.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; (中略)....................<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタン入力に応じた処理<br>
      &nbsp;&nbsp;&nbsp; void HandleInput()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(<em>Pad::All, </em>PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ボタンを押したらスタート音声を再生<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::start);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isStartPushed = true; // 画面遷移トリガーON<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(<em>Pad::All, </em>PAD_INPUT_UP))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //上を押すと設定モードを-1する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int index = ((int)settingMode - 1);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (index &lt; 0) //↓番号ループ 0→最大数-1<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; index = ((int)SettingMode::NUM) - 1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; settingMode = (SettingMode)index;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (Input::GetButtonDown(<em>Pad::All, </em>PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //下を押すと設定モードを+1する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int index = ((int)settingMode + 1);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (index &gt;= ((int)SettingMode::NUM))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; index = 0; //番号ループ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; settingMode = (SettingMode)index;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(<em>Pad::All, </em>PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (settingMode == SettingMode::BGM)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM++;//音量をプラス<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeBGM &gt; 100)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM = 100;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (settingMode == SettingMode::SE)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE++;//音量をプラス<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeSE &gt; 100)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE = 100;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::bomb); //効果音を聞きながら調節<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::UpdateMusicVolume(); //再生中の音量の更新<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (Input::GetButton(<em>Pad::All, </em>PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (settingMode == SettingMode::BGM)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM--;//音量をマイナス<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeBGM &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (settingMode == SettingMode::SE)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE--;//音量をマイナス<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeSE &lt;0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::bomb); //効果音を聞きながら調節<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::UpdateMusicVolume(); //再生中の音量の更新<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (以下略).....................<br>
    </p>
    <br>
    <p><code>PlayScene.hのプレイヤの生成にパッド番号指定</code>を書き加えましょう。</p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      (中略)...........<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; (中略)............<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (中略)....................<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ここでプレイヤの初期化などのプレイ開始時の処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.player = std::make_shared&lt;Player&gt;(<em>Pad::Key, </em>Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵の仮生成<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (以下略).....................<br>
    </p>
    <br>
    <p><code>GameOverScene.hのInputボタン判定にPad::Allの指定</code>を書き加えましょう。</p>
    <p class="source">#ifndef GAMEOVERSCENE_H_<br>
      #define GAMEOVERSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class GameOverScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; <br>
      (中略).....................<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(<em>Pad::All, </em>PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.LoadScene("TitleScene"); //シーン遷移<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawString(0, 0, "GameOver....ボタン押下でPlaySceneへ", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p>さて、これで大丈夫か！...と思いきや反応しなくなりました。<br>
      原因は<b>Input::Init(); // 入力コントローラの初期化</b> 忘れでした！<br>
      逆にいままでなぜ大丈夫だったかというとint型や配列currentStatesの初期値は0だったからです(たまたま実質0初期化になってた)<br>
    </p>
    <p><code>Game.cppに忘れていたInputの初期化</code>を書き加えましょう。</p>
    <p class="source">#include "Game.h"<br>
      <br>
      #include "MyRandom.h"<br>
      <em>#include "Input.h"</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;&nbsp; <em>Input::Init(); // コントローラ入力の初期化</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; (中略)............<br>
      }<br>
      <br>
      (以下略).....................<br>
    </p>
    <br>
    <p>これでコントローラをつなげばどのコントローラからでもタイトル画面を操作できます。<br>
      なぜ各シーンではなくGame.cppでInput入力とMyRandom乱数はInit初期化するのか？<br>
      それは<b>コントローラ入力と乱数はシーンによらない共通機能</b>だからです。</p>
    <br>
    <br>
    <h2><a id="mozTocId50012" class="mozTocH1"></a>複数プレイヤの参加処理</h2>
    <p>さて、次はプレイヤの参加処理を書いてゆきましょう。<br>
      プレイヤの<b>参加は色んな画面で使うのでInputクラスで共通処理</b>とした方が良さそうです。<br>
      すでに<b>Inputを使い慣れた人も辞書配列の使い道に注目</b>してください。<br>
      <b>辞書配列は【対応関係を結ぶのにめちゃ便利】</b>です。<br>
      <b>辞書配列に慣れると【vector配列が辞書配列の劣化版のようにすら感じるほど】</b>です。<br>
      ですがvector配列はデータがぎっしりとかっつめられているというメモリ節約の利点があります、機動力とメモリ節約の両観点から選択しましょう。<br>
    </p>
    <p><code>Input.hに参加中パッドの辞書と参加チェック処理</code>を書き加えましょう。</p>
    <p class="source">#ifndef INPUT_H_<br>
      #define INPUT_H_<br>
      <br>
      #include &lt;unordered_map&gt; // 辞書配列【map高速版】https://qiita.com/sileader/items/a40f9acf90fbda16af51<br>
      <br>
      #include "DxLib.h"<br>
      <br>
      // コントローラのパッド番号定義<br>
      enum class Pad<br>
      {<br>
      &nbsp;&nbsp;&nbsp; All = -2, // すべてのうちどれか1つでも押されたとき<br>
      &nbsp;&nbsp;&nbsp; None = -1, // パッド割当て無(やられたり待機中のプレイヤに)<br>
      &nbsp;&nbsp;&nbsp; Key=0, // キーボード<br>
      &nbsp;&nbsp;&nbsp; One, // コントローラ1<br>
      &nbsp;&nbsp;&nbsp; Two, // コントローラ2<br>
      &nbsp;&nbsp;&nbsp; Three, // コントローラ3<br>
      &nbsp;&nbsp;&nbsp; Four, // コントローラ4<br>
      &nbsp;&nbsp;&nbsp; NUM, // コントローラの数=5<br>
      };<br>
      <br>
      // 入力クラス<br>
      class Input<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; static int prevStates[(int)Pad::NUM]; // 1フレーム前の状態<br>
      &nbsp;&nbsp;&nbsp; static int currentStates[(int)Pad::NUM]; // 現在の状態<br>
      &nbsp;&nbsp;&nbsp; <em>static std::unordered_map&lt;Pad, bool&gt; isJoin; // 参加中のパッド番号辞書<br>
        &nbsp;&nbsp;&nbsp; // 参加中のパッドかどうか?<br>
        &nbsp;&nbsp;&nbsp; static bool IsJoin(Pad pad) { return isJoin.count(pad) == 1 &amp;&amp; Input::isJoin[pad]; };</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;int, int&gt; padDic; // パッド番号からDXの定義への辞書<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 辞書配列の初期化<br>
      &nbsp;&nbsp;&nbsp; static void InitPadDictionary()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 辞書配列で対応関係を結び付けておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Key] = DX_INPUT_KEY;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::One] = DX_INPUT_PAD1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Two] = DX_INPUT_PAD2;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Three] = DX_INPUT_PAD3;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Four] = DX_INPUT_PAD4;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化。タイトルなどキー入力状態リセット時に<br>
      &nbsp;&nbsp;&nbsp; static void Init()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; InitPadDictionary(); // 辞書配列の初期化<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // キー状態をゼロリセット<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i] = 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 最新の入力状況に更新する処理。<br>
      &nbsp;&nbsp;&nbsp; // 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
      &nbsp;&nbsp;&nbsp; static void Update()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 現在の状態を一つ前の状態として保存してGetJoypad..<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i];<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; currentStates[i] = GetJoypadInputState(padDic[i]);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// プレイヤの参加処理(参加辞書登録して参加中の数も返す)<br>
        &nbsp;&nbsp;&nbsp; static int JoinCheck()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int joinCount = 0;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_1))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>isJoin[(Pad)i] = true; // 参加パッド辞書に登録</b><br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (<b>isJoin.count((Pad)i) == 1 &amp;&amp; isJoin[(Pad)i] == true</b>)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; joinCount++; // 参加中の人数をカウント<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return joinCount; // 参加中のコントローラ数を返す<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      (以下略)...............<br>
    </p>
    <p><code>Input.cppに変数定義を追加します。</code></p>
    <p class="source">#include "Input.h"<br>
      <br>
      int Input::prevStates[]; // 1フレーム前の状態<br>
      int Input::currentStates[]; // 現在の状態<br>
      <em>std::unordered_map&lt;Pad, bool&gt; Input::isJoin; // 参加中のパッド番号辞書</em><br>
      <br>
      std::unordered_map&lt;int, int&gt; Input::padDic; // パッド番号からDXの定義への辞書<br>
    </p>
    <br>
    <p>辞書配列、使う際にはvector配列のように<b>isJoin[(Pad)i] = true;</b>と書けば使えるんですね。<br>
      if文の時はあえてcountを間にはさんでます。<b><br>
        直接isJoin[(Pad)i] == trueの判別するとisJoin[(Pad)i]の登録がなかった時に辞書にfalseで登録が増えちゃうんです。</b><br>
      辞書に未登録のものの<b>判定を行うと気を利かせてデフォルトのfalseとか0を勝手に登録してくれちゃう</b>のです。<br>
      勝手に登録してくれて<b>ありがとうとはなりません。辞書の数が増えると検索数も増えるので無駄なん</b>です。<br>
      <b>.count(～)==1のときだけ判定を行えば辞書に無駄なデフォルト登録が発生せずに済みます。</b><br>
      <b>【辞書配列の判定は.count(～)==1の時だけ行わないと勝手に無駄な項目が増えバグ原因】</b>と覚えておきましょう。<br>
    </p>
    <br>
    <br>
    <p>次に現状では、PAD_INPUT_1(Xボタン)にしか反応しないので他のボタンでも参加できるようにします。<br>
      <code>Input.hのボタン判定処理を増やしましょう。</code></p>
    <p class="source">(中略)..............<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの参加処理(参加辞書登録して参加中の数も返す)<br>
      &nbsp;&nbsp;&nbsp; static int JoinCheck()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int joinCount = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 参加ボタンが押されたら<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <em>// 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_2))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_3))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_4))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// ちょ待ち！、あ、これボタンの数だけめっちゃif文増えるやつだ..やだな</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isJoin.count((Pad)i) == 1 &amp;&amp; isJoin[(Pad)i] == true)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; joinCount++; // 参加中の人数をカウント<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return joinCount; // 参加中のコントローラ数を返す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (以下略)...............<br>
    </p>
    <br>
    <br>
    <p>あ、<b>このままだと【if else文がボタンの数だけめっちゃ増えちゃいます】ね。</b><br>
      もっと良い書きかたが実はあります。<br>
      こんな時のために<br>
      PAD_INPUT_1,PAD_INPUT_2,...の定義は2進数に直すと以下のようになってます。</p>
    <p class="source">パッドボタン&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2進数(32ビット32桁)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ← &nbsp; 16進数&nbsp;&nbsp; <br>
      PAD_INPUT_1&nbsp;&nbsp; 000000000000000000000000000<em>1</em>0000 ← 0x00000010<br>
      PAD_INPUT_2&nbsp;&nbsp; 00000000000000000000000000<em>1</em>00000 ← 0x00000020<br>
      PAD_INPUT_3&nbsp;&nbsp; 0000000000000000000000000<em>1</em>000000 ← 0x00000040<br>
      PAD_INPUT_4&nbsp;&nbsp; 000000000000000000000000<em>1</em>0000000 ← 0x00000080<br>
      PAD_INPUT_5&nbsp;&nbsp; 00000000000000000000000<em>1</em>00000000 ← 0x00000100<br>
      PAD_INPUT_6&nbsp;&nbsp; 0000000000000000000000<em>1</em>000000000 ← 0x00000200<br>
      PAD_INPUT_7&nbsp;&nbsp; 000000000000000000000<em>1</em>0000000000 ← 0x00000400<br>
      PAD_INPUT_8&nbsp;&nbsp; 00000000000000000000<em>1</em>00000000000 ← 0x00000800<br>
      PAD_INPUT_9&nbsp;&nbsp; 0000000000000000000<em>1</em>000000000000 ← 0x00001000<br>
      PAD_INPUT_10&nbsp; 000000000000000000<em>1</em>0000000000000 ← 0x00002000<br>
      ............................................................<br>
      PAD_INPUT_28&nbsp; <em>1</em>0000000000000000000000000000000 ← 0x80000000<br>
    </p>
    <p>おお！<b>見事に1が一つずつ左にずれていってますね。</b><br>
      偶然ではありません。<b>人為的にこういう構造になっているのです。</b><br>
      この左ビットシフト構造を<b>【うまくビット論理和で合体させてみましょう】</b><br>
      <b>【ビット論理和「 | 」(または)演算子を使います】(ただの棒 | ではありませんよ！)</b><br>
      ビット論理和<b>「 | 」は「または」の意味になりA | Bで AまたはB どちらかが1の場合に1となる</b>を表します。<br>
      <b>ボタン1とボタン4をビット論理和「 | 」でかけ合わせると</b>以下のようになります！ </p>
    <p class="source">パッドボタン&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2進数(32ビット32桁)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      PAD_INPUT_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000000000000000000000000000<em>1</em>0000<br>
      PAD_INPUT_4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000000000000000000000000<em>1</em>0000000<br>
      ............................................................<br>
      PAD_INPUT_1&nbsp;|&nbsp;PAD_INPUT_4 000000000000000000000000<em>1</em>00<em>1</em>0000<br>
    </p>
    <p>はい、<b>うまいことビットが合成できて0..0<em>1</em>00<em>1</em>0000で1が2か所</b>にできました。 <br>
      この<b>合成したビットの並びをButton::Joinと名付け</b>ましょう。</p>
    <p class="source">パッドボタン&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2進数(32ビット32桁)&nbsp;&nbsp;&nbsp; <br>
      PAD_INPUT_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000000000000000000000000000<em>1</em>0000<br>
      PAD_INPUT_4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000000000000000000000000<em>1</em>0000000<br>
      .................................................<br>
      Button::Join &nbsp; &nbsp; 000000000000000000000000<em>1</em>00<em>1</em>0000<br>
    </p>
    <br>
    <p>そしてこの合成した<b>ビットを判定に使うときは【ビット論理積「 &amp; 」(かつ)演算子を使います】</b><br>
      ビット論理積<b>「 &amp; 」は「かつ」の意味になりA &amp; Bで AかつB 両方が1の場合に1</b>を表します。<br>
      <b>合成したビットPad::Join と PAD_INPUT_1 の【ビット論理積&amp;】をかけ合わせて</b>みましょう。</p>
    <p class="source">パッドボタン&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2進数(32ビット32桁)&nbsp;&nbsp;&nbsp; <br>
      Button::Join &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00000000000000000000000<em>1</em>000<em>1</em>0000<br>
      PAD_INPUT_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000000000000000000000000000<em>1</em>0000<br>
      ...........................................................<br>
      Button::Join &amp; PAD_INPUT_1 000000000000000000000000000<em>1</em>0000 = true<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1つでも1がある)</p>
    <br>
    <p>この<b>【ビット論理積「 &amp; 」(かつ)演算子】どこかで見たと思いませんか？</b><br>
      そう<b>Input.hのGetButtonの中ボタン押し判定のreturnには【ビット論理積「 &amp; 」演算子】を使っていたのです。</b><br>
      <code>Input.hのGetButtonを見てみてください。</code></p>
    <p class="source">&nbsp;&nbsp;&nbsp; // ボタンが押されているか？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButton(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (pad == Pad::None) return false; // Noneなら判別不要<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (pad == Pad::All) // 全てAllの指定だった時は<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// GetButtonの中でGetButtonを呼ぶ再起呼出しテクニック<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (GetButton((Pad)i, buttonId))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return true; //押されているPadを発見！<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return false; // 一つも押されていなかった<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今ボタンが押されているかどうかを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (currentStates[(int)pad]<em><b> &amp; </b></em>buttonId) != 0;<br>
      &nbsp;&nbsp;&nbsp; }</p>
    <br>
    <p>ただ注意してください。<b>【「 &amp; 」マークは色んな異なる意味がありすぎなので】</b><br>
      ややこしいです<b>【「&amp;&amp;」や「&amp;メモリ参照」など文脈によってビット論理積と勘違いしないように(文脈で判断)しましょう】</b><br>
      まあ普通はあんまりビット演算ばかりやるコードはないので気づけると思います。<br>
    </p>
    <br>
    <p>では【ビット合成】でボタンの種類を合成したButton::Joinを使って<br>
      <code>Input.hのボタン判定処理をすっきり書きましょう。</code></p>
    <p class="source">#ifndef INPUT_H_<br>
      #define INPUT_H_<br>
      <br>
      #include &lt;unordered_map&gt; // 辞書配列【map高速版】https://qiita.com/sileader/items/a40f9acf90fbda16af51<br>
      <br>
      #include "DxLib.h"<br>
      <br>
      // コントローラのパッド番号定義<br>
      enum class Pad<br>
      {<br>
      &nbsp;&nbsp;&nbsp; All = -2, // すべてのうちどれか1つでも押されたとき<br>
      &nbsp;&nbsp;&nbsp; None = -1, // パッド割当て無(やられたり待機中のプレイヤに)<br>
      &nbsp;&nbsp;&nbsp; Key=0, // キーボード<br>
      &nbsp;&nbsp;&nbsp; One, // コントローラ1<br>
      &nbsp;&nbsp;&nbsp; Two, // コントローラ2<br>
      &nbsp;&nbsp;&nbsp; Three, // コントローラ3<br>
      &nbsp;&nbsp;&nbsp; Four, // コントローラ4<br>
      &nbsp;&nbsp;&nbsp; NUM, // コントローラの数=5<br>
      };<br>
      <br>
      <em>// ある動作として反応するボタン一覧(ビット論理和「|または」)<br>
        enum class Button<br>
        {&nbsp;&nbsp;&nbsp; //[反応ボタン一覧定義] https://dixq.net/g/04_05.html<br>
        &nbsp;&nbsp;&nbsp; // 参加ボタン 1=Z 2=X 3=C 4=A 5=S 6=D 7=Q 8=W 9=ESC 10=SPACE<br>
        &nbsp;&nbsp;&nbsp; Join = PAD_INPUT_1 | PAD_INPUT_2 | PAD_INPUT_3 | PAD_INPUT_4<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;| PAD_INPUT_5 | PAD_INPUT_6 | PAD_INPUT_7 | PAD_INPUT_8<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;| PAD_INPUT_9 | PAD_INPUT_10, //1Z～10SPACEキー全て反応<br>
        };</em><br>
      <br>
      // 入力クラス<br>
      class Input<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (中略)..............<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの参加処理(参加辞書登録して参加中の数も返す)<br>
      &nbsp;&nbsp;&nbsp; static int JoinCheck()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int joinCount = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 参加ボタンが押されたら<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i<em>, (int)Button::Join</em>))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <u>// 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_2))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_3))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_4))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ちょ待ち！、あ、これボタンの数だけめっちゃif文増えるやつだ..やだな</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isJoin.count((Pad)i) == 1 &amp;&amp; isJoin[(Pad)i] == true)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; joinCount++; // 参加中の人数をカウント<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return joinCount; // 参加中のコントローラ数を返す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (以下略)...............<br>
    </p>
    <p>最終的に赤部分を消すと以下のようにすっきりします。<br>
      一目瞭然、見事にすっきりしますね<b>【複数ボタンに反応させるときはビット合成テクニックを使いましょう】</b></p>
    <p class="source"><br>
      &nbsp;&nbsp;&nbsp; // プレイヤの参加処理(参加辞書登録して参加中の数も返す)<br>
      &nbsp;&nbsp;&nbsp; static int JoinCheck()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int joinCount = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 参加ボタンが押されたら<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i<em>, (int)Button::Join</em>))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isJoin.count((Pad)i) == 1 &amp;&amp; isJoin[(Pad)i] == true)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; joinCount++; // 参加中の人数をカウント<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return joinCount; // 参加中のコントローラ数を返す<br>
      &nbsp;&nbsp;&nbsp; }<br>
    </p>
    <br>
    <br>
    <p>今度は<b>プレイヤの数を増やすためにプレイヤをリスト化</b>しましょう。<br>
      今までの敵リストのようにvector配列のリストでもいいですが<b>【使い勝手を考えて辞書配列に挑戦】</b>しましょう。<br>
      <br>
      <code>GameManager.hのプレイヤを複数にできるよう辞書配列に変更</code>します。</p>
    <p class="source">#ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      #include &lt;list&gt;<br>
      <em>#include &lt;unordered_map&gt; // 辞書配列【map高速版】</em><br>
      <br>
      #include "Singleton.h"<br>
      <br>
      class Map;<br>
      class Player; //クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      class PlayerBullet;<br>
      class Enemy;<br>
      class EnemyBullet;<br>
      class Explosion;<br>
      class Item;<br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Map&gt; map{ nullptr }; // マップ<br>
      &nbsp;&nbsp;&nbsp; <u>std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機の初期化</u><br>
      &nbsp;&nbsp;&nbsp; <em>std::unordered_map&lt;int, std::shared_ptr&lt;Player&gt;&gt; players; // 自機の辞書配列(複数プレイ対応)</em><br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;EnemyBullet&gt;&gt; enemyBullets; // 敵弾のリスト<br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;Explosion&gt;&gt; explosions; // 爆発エフェクトのリスト<br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;Item&gt;&gt; items; // アイテムのリスト<br>
      &nbsp;&nbsp;&nbsp; // 複数リスト↑list ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; (中略)....................<br>
      <br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;&nbsp; virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><b>playerをplayersに変えたので【つづりの変わった部分は全部エラーになるはず】</b>です。<br>
      逆にいうと<b>【今から変えなきゃいけないとこがエラーになってくれた】</b>のです。<br>
      <b>エラーが出ないと逆に【忘れて謎のバグの原因になりますからね】</b><br>
      変更の必要なところの目印になってくれて逆に方針が立てやすいのです。</p>
    <br>
    <p>今度は<b>プレイヤの数を増やすためにプレイヤをリスト化</b>しましょう。<br>
      今までの敵リストのようにvector配列のリストでもいいですが<b>【使い勝手を考えて辞書配列に挑戦】</b>しましょう。<br>
      <br>
    </p>
    <p>まずはプレイヤをたくさん使ってるだけあってエラーもたくさん出ている<br>
      <code>PlayScene.hのプレイヤを単数から複数に変更</code>するとこから修正を始めましょう。</p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "Map.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Boss.h"<br>
      #include "PlayerBullet.h"<br>
      #include "EnemyBullet.h"<br>
      #include "Explosion.h"<br>
      #include "Item.h"<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp;&nbsp; GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる<br>
      <br>
      &nbsp;&nbsp;&nbsp; float scrollSpeed = 1.5f; // スクロール速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; PlayScene() : Scene()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;tag = "PlayScene";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
(中略).........<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // マップの初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.map = std::make_shared&lt;Map&gt;("Map/stage1.csv");<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// ここでプレイヤの初期化などのプレイ開始時の処理<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int joinCount = Input::JoinCheck(); // プレイヤの参加検出処理<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(joinCount &gt; 0)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MakePlayer(); // プレイヤの生成処理</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <u>//gm.player = std::make_shared&lt;Player&gt;(Pad::Key, Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵の仮生成<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 終了処理(大抵Initializeと同じリセットだが終了時だけやりたいリセットの仕方もあるかも)<br>
      &nbsp;&nbsp;&nbsp; void Finalize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ここにプレイ終了時のメモリのリセット処理(ゲームクリアやゲームオーバー時など)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.map = nullptr; // マップのメモリからの解放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.<em>players.clear()</em>; // プレイヤのメモリからの解放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.enemies.clear(); // 敵のメモリからの解放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.playerBullets.clear(); // プレイヤの弾のメモリからの解放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.enemyBullets.clear(); // 敵弾のメモリからの解放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.explosions.clear(); // 爆発エフェクトのメモリからの解放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.items.clear(); // アイテムのメモリからの解放<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ゲーム終了時のスコアがMAXなら記録して終了<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(score &gt; sm.scoreMax) sm.scoreMax = score;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// プレイヤの生成処理<br>
        &nbsp;&nbsp;&nbsp; void MakePlayer()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 参加辞書登録されたプレイヤの自機の生成<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::IsJoin((Pad)i) &amp;&amp; gm.players.count(i) == 0)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.players[i] = std::make_shared&lt;Player&gt;((Pad)i, Vector3((float)100, (float)(Screen::Height / 2)));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ここにプレイ中の更新処理を持ってくる<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// プレイヤの参加検出処理<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int joinCount = Input::JoinCheck();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (joinCount &gt; 0)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MakePlayer(); // プレイヤの生成処理</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // マップデータの読出し位置のスクロール<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>if(gm.players.size() &gt; 0) //プレイヤ配列0の内はスクロールしない</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>gm.map-&gt;Scroll(scrollSpeed);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// プレイヤの更新処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; pair : gm.players)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto player = pair.second;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!player-&gt;isDead) // 自機が死んでいなければ</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>player</em>-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>}</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾の更新処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp; // autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; b-&gt;Update();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵弾の更新処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.enemyBullets)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; b-&gt;Update();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機と敵弾の衝突判定<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; enemyBullet : gm.enemyBullets)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// 敵弾が死んでたらスキップ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (enemyBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>for (const auto&amp; pair : gm.players)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto player = pair.second;</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>// 自機が死んでたらこれ以上判定しない<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>if (<em>player</em>-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>&nbsp;&nbsp;&nbsp; break;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <u>// 敵弾が死んでたらスキップ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (enemyBullet->isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>// 円同士の衝突判定で調べる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>&nbsp;&nbsp;&nbsp; <em>player</em>-&gt;position, <em>player</em>-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>&nbsp;&nbsp;&nbsp; enemyBullet-&gt;position, enemyBullet-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>{<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>&nbsp;&nbsp;&nbsp; <em>player</em>-&gt;OnCollisionEnemyBullet(enemyBullet);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>}<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>}</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵の更新処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; b-&gt;Update();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾と敵の衝突判定<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; playerBullet : gm.playerBullets)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾と敵が重なっているか？<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; playerBullet-&gt;position, playerBullet-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; playerBullet-&gt;OnCollisionEnemy(enemy);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::bomb); // 効果音の再生<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; break;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機と敵の衝突判定<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// 敵が死んでたらスキップ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>for (const auto&amp; pair : gm.players)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto player = pair.second;</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>// 自機が死んでたらこれ以上判定しない<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>if (<em>player</em>-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>&nbsp;&nbsp;&nbsp; break;<br>
	    <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <u>// 敵が死んでたらスキップ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>// 円同士の衝突判定で調べる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>&nbsp;&nbsp;&nbsp; <em>player</em>-&gt;position, <em>player</em>-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>&nbsp;&nbsp;&nbsp; enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>{<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>&nbsp;&nbsp;&nbsp; <em>player</em>-&gt;OnCollisionEnemy(enemy);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>}<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>}</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 爆発エフェクトの更新処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; e : gm.explosions)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; e-&gt;Update();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // アイテムの更新処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; itm : gm.items)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; itm-&gt;Update();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
	    <br>
	&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機とアイテムの衝突判定<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; itm : gm.items)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// アイテムが死んでたらスキップ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (itm-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue;</em><br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>for (const auto&amp; pair : gm.players)</em><br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>{</em><br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; auto player = pair.second;</em><br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>// 自機が死んでたらこれ以上判定しない<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>if (<em>player</em>-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>&nbsp;&nbsp;&nbsp; break;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<u>// アイテムが死んでたらスキップ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (itm-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue;</u><br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp;&nbsp; </em>// 円同士の衝突判定で調べる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp;&nbsp; </em>if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp;&nbsp; </em> &nbsp; &nbsp;<em>player</em>-&gt;position, <em>player</em>-&gt;collisionRadius,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp;&nbsp; </em> &nbsp; &nbsp;itm-&gt;position, itm-&gt;collisionRadius) )<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp;&nbsp; </em>{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp;&nbsp; </em>&nbsp;&nbsp; &nbsp;itm-&gt;OnCollisionPlayer(<em>player</em>);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp;&nbsp; </em>}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp;&nbsp; }</em><br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; enemyBullet : gm.enemyBullets)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵弾が死んでたらスキップ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (enemyBullet-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 円同士の衝突判定で調べる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;itm-&gt;position, itm-&gt;collisionRadius,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;enemyBullet-&gt;position, enemyBullet-&gt;collisionRadius) )<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enemyBullet-&gt;OnCollisionItem(itm);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;itm-&gt;OnCollisionEnemyBullet(enemyBullet);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾の削除処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;PlayerBullet&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.EraseRemoveIf(gm.enemies,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;Enemy&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.EraseRemoveIf(gm.enemyBullets,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;EnemyBullet&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //爆発エフェクトのリストから死んでるものを除去する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.EraseRemoveIf(gm.explosions,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;Explosion&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //アイテムのリストから死んでるものを除去する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.EraseRemoveIf(gm.items,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;Item&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>int aliveCount = 0; // 生きているプレイヤ数のカウント<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; pair : gm.players)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto player = pair.second;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (player-&gt;isDead != true)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; aliveCount++; // 生存プレイヤ数をカウント<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ゲームオーバー判定と画面チェンジ処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// プレイヤの数が0じゃないのに生存数が0ならゲームオーバー</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bool isGameover = (<em>gm.players.size() != 0 &amp;&amp; aliveCount == 0</em>);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <u>if (!isGameover && gm.player-&gt;isDead) isGameover = true;</u><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isGameover)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::PlayMusic(Sound::ending); //BGMを変更する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.LoadScene("GameOverScene"); //シーン遷移<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ここにプレイ画面の描画処理を持ってくる<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵の描画処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; b-&gt;Draw();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 爆発エフェクトの描画処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; e : gm.explosions)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; e-&gt;Draw();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// プレイヤの描画処理<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; pair : gm.players)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto player = pair.second;</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>if (!<em>player</em>-&gt;isDead) // 自機が死んでいなければ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; </em>&nbsp;&nbsp;&nbsp; <em>player</em>-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>}</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾の描画処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // for文で全自機弾をループで回してUpdateで更新する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp; // autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; b-&gt;Draw();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵弾の描画処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.enemyBullets)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; b-&gt;Draw();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // アイテムの描画処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; itm : gm.items)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; itm-&gt;Draw();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p>さてここで<b>辞書配列のfor文に慣れてしまいましょう。</b><br>
      vector配列との違いは<b>【辞書のキーとバリューを各ループで得られること】</b>です。<br>
      あいうえおの辞書を例にすると<b>【「あ」がキー、「アイス」がバリューですね】</b><br>
      あ、<b>すみません違います！【「アイス」がキー、「アイスとは冷たくておいしいもの(説明)」がバリューです】</b><br>
      ただし<b>一つのキーに複数のバリューのあるタイプの辞書もあり</b><br>
      その場合は<b>【「あ」がキー、「アイス」「愛」..などがバリューですね】</b><br>
      プログラム上では<b>【キーがfirst、バリューがsecondでアクセスできます】</b></p>
    <p class="source">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // プレイヤの描画処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; <em><b>pair</b></em> : gm.players)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto player = pair.<em><b>second</b></em>;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!player-&gt;isDead) // 自機が死んでいなければ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
    </p>
    <br>
    <p>もう一つ<b>辞書配列に登録する際の形も見ておきましょう。</b><br>
      <b>players[i] = ～;のような配列に代入するような形で登録可能</b>です。<br>
      すでに登録済か未登録かは<b>.count(キー)</b>で判別します。<br>
      この<b>count()でキーがあるか探せるのがvector配列より手軽なところ</b><br>
      <b>5文字ぐらいでさらっと登録済かわかるので。</b></p>
    <p class="source">&nbsp;&nbsp;&nbsp; // プレイヤの生成処理<br>
      &nbsp;&nbsp;&nbsp; void MakePlayer()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 参加辞書登録されたプレイヤの自機の生成<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::IsJoin((Pad)i) &amp;&amp; gm.players<em>.count(i) == 0</em>)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.<em>players[i] = </em>std::make_shared&lt;Player&gt;((Pad)i, Vector3((float)100, (float)(Screen::Height / 2)));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; } </p>
    <br>
    <br>
    <br>
    <p>さてタイトル画面などにもプレイヤ参加の検出処理を加えておきましょう。<br>
      プレイに移る前に参加辞書Input::isJoinに1人は登録がないとプレイヤのいない空のプレイ画面から始まるので。<br>
      <br>
      <code>TitleScene.hにプレイヤの参加検出処理を追加</code>します。</p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      (中略)..................<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; (中略)..................<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタン入力に応じた処理<br>
      &nbsp;&nbsp;&nbsp; void HandleInput()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>Input::JoinCheck(); // プレイヤの参加検出処理</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(Pad::All, PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ボタンを押したらスタート音声を再生<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::start);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isStartPushed = true; // 画面遷移トリガーON<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp; (中略)..................<br>
      &nbsp;&nbsp;&nbsp; }<br>
      (以下略)..................</p>
    <br>
    <br>
    <p>他にもザコにプレイヤの追撃弾を撃たせている人は単体のプレイヤを複数対応しなければなりません。<br>
      プレイヤを追撃するにも<b>複数いるとどのプレイヤを追撃するかあいまいになるので。</b><br>
      <b>ここからのザコの処理の修正は人それぞれです。プレイヤを追っかけない独自のザコのままがいい！という人は不要かもしれません。</b><br>
      <br>
      <br>
    </p>
    <code>Zako0.hに複数のプレイヤから一番近いプレイヤを追撃する処理を追加</code>します。
    <p></p>
    <p class="source">#ifndef ZAKO_0_H_<br>
      #define ZAKO_0_H_<br>
      <br>
      <em>#include &lt;memory&gt;</em><br>
      <br>
      #include "Enemy.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      <br>
      #include "Player.h" // Player.hでもZako1.hをインクルードすると循環するので注意<br>
      <br>
      // ザコ0クラス<br>
      class Zako0 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int coolTime = 0; // クールタイム（冷却時間。0になるまで次の弾が撃てない）<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Zako0(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Zako0";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x -= 1; // とりあえず左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime--;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (coolTime &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>float minDistance = 1000000; // 最小の距離<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::shared_ptr&lt;Player&gt; minPlayer = nullptr; // 一番近いプレイヤを探す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; pair : gm.players)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;auto p = pair.second;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float dist = (position - p-&gt;position).magnitude();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (dist &lt; minDistance)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// より小さい距離のプレイヤがいれば記録更新<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;minDistance = dist;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;minPlayer = p;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (minPlayer != nullptr)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>// 自機狙い弾<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>float angle = MyMath::PointToPointAngle(position, <em>minPlayer</em>-&gt;position);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, angle, 8));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>}</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;coolTime += 10;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 【重要】画面外の削除処理【CPU処理重くなる原因】<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 左端の画面外に出たらisDeadしないと<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 画面外の敵の当たり判定で【だんだん処理が重くなるZako1,Zako2..も】<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isDead = true;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako0, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>Zako1.hに複数のプレイヤから一番近いプレイヤを追撃する処理を追加</code>します。</p>
    <p class="source">#ifndef ZAKO_1_H_<br>
      #define ZAKO_1_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      <em>#include &lt;memory&gt;</em><br>
      #include &lt;cmath&gt; // Sinの計算に使う<br>
      #include "MyMath.h"<br>
      #include "Image.h"<br>
      <br>
      #include "Player.h" // Player.hでもZako1.hをインクルードすると循環するので注意<br>
      <br>
      // ザコ1クラス<br>
      class Zako1 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;float sinMove = 0; // Sinの動きをする際の0～360度<br>
      &nbsp;&nbsp; &nbsp;float sinRadius = 70; // Sinの動きをするときの半径<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Zako1(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Zako1";//オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life = 5;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>float minDistance = 1000000; // 最小の距離<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::shared_ptr&lt;Player&gt; minPlayer = nullptr; // 一番近いプレイヤを探す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; pair : gm.players)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;auto p = pair.second;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float dist = (position - p-&gt;position).magnitude();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (dist &lt; minDistance)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// より小さい距離のプレイヤがいれば記録更新<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;minDistance = dist;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;minPlayer = p;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
	      <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (minPlayer != nullptr)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>// 自機をおいかけてくる処理<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>float angleToPlayer = MyMath::PointToPointAngle(position, <em>minPlayer</em>-&gt;position);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>float speed = 3;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>position += Vector3((float)std::cos(angleToPlayer) * speed, (float)std::sin(angleToPlayer) * speed);<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>//ゆらゆらSin波動の動きをy上下方向にプラス<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>float prevSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>sinMove += 2.5f; // Sinの波運動の角度を進める<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>float currentSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>// (前の角度でのY) - (今の角度でのY)の差を足すことで【ベースのyの位置 ± sinの動き】になる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>position.y += currentSinY - prevSinY; // 上下方向のSinの波運動<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>}</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako1, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>Zako2.hに複数のプレイヤから一番近いプレイヤを追撃する処理を追加</code>します。</p>
    <p class="source">#ifndef ZAKO_2_H_<br>
      #define ZAKO_2_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      <em>#include &lt;memory&gt;</em><br>
      #include &lt;cmath&gt; // Sin Cosの計算に使う<br>
      <br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include "MyMath.h"<br>
      #include "MyRandom.h"<br>
      <br>
      #include "Player.h" // Player.hでもZako2.hをインクルードすると循環するので注意<br>
      <br>
      // ザコ2クラス<br>
      class Zako2 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int coolTime = 0; // クールタイム（冷却時間。0になるまで次の弾が撃てない）<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Zako2(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Zako2";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (position.x &gt; Screen::Width - 200)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { // スクリーンの端から200の位置で止まる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x -= 1; // とりあえず左へ移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime--;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (coolTime &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>float minDistance = 1000000; // 最小の距離<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::shared_ptr&lt;Player&gt; minPlayer = nullptr; // 一番近いプレイヤを探す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; pair : gm.players)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// より小さい距離のプレイヤがいれば記録更新<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;auto p = pair.second;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float dist = (position - p-&gt;position).magnitude();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (dist &lt; minDistance)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;minDistance = dist;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;minPlayer = p;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (minPlayer != nullptr)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>// 自機狙いばらまき弾<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>float angle = MyMath::PointToPointAngle(position, <em>minPlayer</em>-&gt;position);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>float randomAngle = MyRandom::Range(-15.0f, 15.0f); // ±15度の乱数の角度を取得<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, angle + randomAngle * MyMath::Deg2Rad, 8));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>coolTime += 10;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 200の位置で止まるので左端にこないから削除処理はなくて済む<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako2, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <br>
    <p>さて、これで独自のザコや弾など単数プレイヤを使用しているコードがなくなれば<br>
      複数プレイヤでプレイできるようになるはずです。<br>
      一度プレイして複数プレイヤでプレイできるか確かめてみましょう。</p>
    <br>
    <br>
    <br>
	 &nbsp;&nbsp;&nbsp; もし複数のコントローラが連動しちゃったりした場合は次の項で対策が必要かもしれません。<br>
    <br>
		
    <h2><a id="mozTocId50013" class="mozTocH1"></a>[DXのバグ!?仕様?]複数コントローラは4以降があやしい件</h2>
		コントローラ7を押すと3としてキャラが反応するなどコントローラ4以降の動作が怪しいのでその対策(DXのバグ?仕様?)をしておきます。<br>
		<p><code>Input.hでコントローラの初回ボタンプッシュを管理して、2つのコントローラの初回プッシュが被ったら同一コントローラ扱いとしてスルーする機能</code>を追加しましょう。</p>
    <p class="source">#ifndef INPUT_H_<br>
      #define INPUT_H_<br>
      <br>
	
      <em>#include &lt;climits&gt; //int型の最大値2147483647につかう</em><br>
      #include &lt;unordered_map&gt; // 辞書配列【map高速版】https://qiita.com/sileader/items/a40f9acf90fbda16af51<br>
      <br>
      #include "DxLib.h"<br>
      <br>
      // コントローラのパッド番号定義<br>
      enum class Pad<br>
      {<br>
      &nbsp;&nbsp;&nbsp; All = -2, // すべてのうちどれか1つでも押されたとき<br>
      &nbsp;&nbsp;&nbsp; None = -1, // パッド割当て無(やられたり待機中のプレイヤに)<br>
      &nbsp;&nbsp;&nbsp; Key=0, // キーボード<br>
      &nbsp;&nbsp;&nbsp; One, // コントローラ1<br>
      &nbsp;&nbsp;&nbsp; Two, // コントローラ2<br>
      &nbsp;&nbsp;&nbsp; Three, // コントローラ3<br>
      &nbsp;&nbsp;&nbsp; Four, // コントローラ4<br>
      &nbsp;&nbsp;&nbsp; NUM, // コントローラの数=5<br>
      };<br>
      <br>
      // 入力クラス<br>
      class Input<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; <em>const int MaxPadNum = (int)Pad::Four + 1; // 最大パッド数(Keyぶん+1)</em><br>
	    <br>
      &nbsp;&nbsp;&nbsp; static int prevStates[(int)Pad::NUM]; // 1フレーム前の状態<br>
      &nbsp;&nbsp;&nbsp; static int currentStates[(int)Pad::NUM]; // 現在の状態<br>
      <br>
      &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;Pad, bool&gt; isJoin; // 参加中のパッド番号辞書<br>
      &nbsp;&nbsp;&nbsp; // 参加中のパッドかどうか?<br>
      &nbsp;&nbsp;&nbsp; static bool IsJoin(Pad pad) { return isJoin.count(pad) == 1 &amp;&amp; Input::isJoin[pad]; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;int, int&gt; padDic; // パッド番号からDXの定義への辞書<br>
	    <br>
      &nbsp;&nbsp;&nbsp; <em>//★【DXコントローラバグ検知】初回プッシュが被ればDXバグで同一コントローラ<br>
      &nbsp;&nbsp;&nbsp; static int firstPushTiming[(int)Pad::Four]; // Pad::Fourが最後だから8とかに増やすなら要書き換え<br>
      &nbsp;&nbsp;&nbsp; static int timing;// = 0;<br>
      &nbsp;&nbsp;&nbsp; static bool isBugCheckMode;// = false; //バグチェックを開始するか</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 辞書配列の初期化<br>
      &nbsp;&nbsp;&nbsp; static void InitPadDictionary()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 辞書配列で対応関係を結び付けておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Key] = DX_INPUT_KEY;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::One] = DX_INPUT_PAD1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Two] = DX_INPUT_PAD2;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Three] = DX_INPUT_PAD3;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Four] = DX_INPUT_PAD4;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化。タイトルなどキー入力状態リセット時に<br>
      &nbsp;&nbsp;&nbsp; static void Init()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; InitPadDictionary(); // パッドの辞書配列の初期化<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // キー状態をゼロリセット<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i] = 0;<br>
      &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; timing = 0, isBugCheckMode = false; //バグチェック</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの参加処理(参加辞書登録して参加中の数も返す)<br>
        &nbsp;&nbsp;&nbsp; static int JoinCheck()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int joinCount = 0;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_1))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>isJoin[(Pad)i] = true; // 参加パッド辞書に登録</b><br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (<b>isJoin.count((Pad)i) == 1 &amp;&amp; isJoin[(Pad)i] == true</b>)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; joinCount++; // 参加中の人数をカウント<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return joinCount; // 参加中のコントローラ数を返す<br>
        &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 最新の入力状況に更新する処理。<br>
      &nbsp;&nbsp;&nbsp; // 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
      &nbsp;&nbsp;&nbsp; static void Update()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 現在の状態を一つ前の状態として保存してGetJoypad..<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i];<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; currentStates[i] = GetJoypadInputState(padDic[i]);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; <br>	    
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isBugCheckMode = true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ++timing; //タイミングのカウントを+1<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (timing == INT_MAX) timing = 0; // int型最大値になったら0にループ</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが押されているか？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButton(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<em>&nbsp;&nbsp;&nbsp; //コントローラバグチェック<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (ControllerBugCheck(pad, buttonId)) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // GetButtonの中でGetButtonを呼ぶ【再起呼出し】テクニック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetButton((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今ボタンが押されているかどうかを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (currentStates[(int)pad] &amp; buttonId) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが押された瞬間か？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButtonDown(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<em>&nbsp;&nbsp;&nbsp; //コントローラバグチェック<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (ControllerBugCheck(pad, buttonId)) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 再起呼出しテクニック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetButtonDown((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今は押されていて、かつ1フレーム前は押されていない場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((currentStates[(int)pad] &amp; buttonId) &amp; ~(prevStates[(int)pad] &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが離された瞬間か？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButtonUp(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<em>&nbsp;&nbsp;&nbsp; //コントローラバグチェック<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (ControllerBugCheck(pad, buttonId)) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 再起呼出しテクニック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetButtonUp((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1フレーム前は押されていて、かつ今は押されている場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((prevStates[(int)pad] &amp; buttonId) &amp; ~(currentStates[(int)pad] &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <em>&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; //コントローラのボタンの初回プッシュを検知し<br>
      &nbsp;&nbsp;&nbsp; //他コントローラと初回タイミングが完全被りかチェックして重複コントローラの判定処理をスルーする対策<br>
      &nbsp;&nbsp;&nbsp; //★コントローラ3を押すと7も反応するなどコントローラ4以降の動作が怪しいのでその対策(DXのバグ?仕様?)<br>
      &nbsp;&nbsp;&nbsp; static bool ControllerBugCheck(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 今は押されていて、かつ1フレーム前は押されていない場合<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bool buttonDown = ((currentStates[(int)pad] & buttonId) & ~(prevStates[(int)pad] & buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //if (isBugCheckMode == false) return false; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //コントローラの初回ボタンプッシュを検知<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (buttonDown && firstPushTiming[(int)pad] == 0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i < (int)Pad::NUM - 1; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //全コントローラ初回プッシュ被りがないかチェック完全同時は怪しいので-1<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bool isDown = ((currentStates[i] & buttonId) & ~(prevStates[i] & buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((Pad)i != pad && isDown ////初回プッシュ被り検出<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; && (timing == firstPushTiming[i] || firstPushTiming[i] == 0))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //初回プッシュのタイミング被りは-1フラグを記録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; firstPushTiming[i] = -1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (firstPushTiming[(int)pad] != -1)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; firstPushTiming[(int)pad] = timing;//初回プッシュを記録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (firstPushTiming[(int)pad] == -1) return true; //DXのコントローラ被りバグ！<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else return false; //コントローラ被りOK!<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; </em><br>
      }; //←【注意】クラス定義の終わりにはコロンが必要だよ！<br>
      <br>
      #endif&nbsp; //ここでエラー出た人は↑【注意】の;コロン忘れ<br>
    </p>
    <br>
	      <p><code>Input.cppに変数定義を追加します。</code></p>
    <p class="source">#include "Input.h"<br>
      <br>
      int Input::prevStates[]; // 1フレーム前の状態<br>
      int Input::currentStates[]; // 現在の状態<br>
      std::unordered_map&lt;Pad, bool&gt; Input::isJoin; // 参加中のパッド番号辞書<br>
      <br>
      std::unordered_map&lt;int, int&gt; Input::padDic; // パッド番号からDXの定義への辞書<br>
<br>
<em>//★【DXコントローラバグ検知】初回プッシュが被ればDXバグで同一コントローラ<br>
int Input::firstPushTiming[(int)Pad::Four]; // Pad::Fourが最後だから8とかに増やすなら要書き換え<br>
int Input::timing{ 0 };<br>
bool Input::isBugCheckMode = false; //バグチェックを開始するか</em><br>
	    <br>
    </p>
    <br>
    <br>
コントローラを4つ以上持っている人は中々いないでしょうが、念のため今後も導入しておいたほうが安心です<br>
		<br>
    <br>
    <br>
		<h2><a id="mozTocId50014" class="mozTocH1"></a>背景画像を作ってループ表示させてみる</h2>
<br>
      まずはGIMPでループさせる背景画像を作ってみましょう。<br>
      GIMPを開いてスクリーンのサイズと合わせて960×540でキャンバスをつくる(横スクロールするなら960より大きくしてみてもよい)。<br>
      <img src="image/bg_gimp1.png" alt="" style="width: 859px; height: 659px;"><br>
      <br>
		
      空の色をイメージして水色でぬりつぶします。<br>
      <img src="image/bg_gimp2.png" alt="" style="width: 617px; height: 667px;"><br>
      <br>
	ブラシを使って白色で雲をえがきます。<br>
      <img src="image/bg_gimp3.png" alt="" style="width: 775px; height: 697px;"><br>
      <br>
	背景画像をエクスポートでImageフォルダにbackground.jpgと名前をつけて保存します。(背景画像は縦×横サイズが大きいのでjpg形式にすることで圧縮して保存サイズが小さくなるようにした)<br>
      <img src="image/bg_gimp4.png" alt="" style="width: 891px; height: 662px;"><br>
      <br>
		<br>
		<p><code>Image.hに背景画像の読み込み定義</code>を追加しましょう。</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
(中略)..........<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; Image() {}; // 初期化コンストラクタの定義だけ<br>
      &nbsp;&nbsp;&nbsp; ~Image() {}; // 破棄する処理デストラクタの定義だけ<br>
(中略)..........<br>
      <br>
      <em>&nbsp;&nbsp;&nbsp; static int background; //背景画像のハンドラ(読込画像番号)</em><br>
      &nbsp;&nbsp;&nbsp; static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;&nbsp; static int player; //プレイヤ画像のハンドラ<br>
(中略)..........<br>
      <br>
      };<br>
      #endif</p>
    <br>
    <p><code>Image.cppにも背景画像の読み込みの処理</code>を追加しましょう。</p>
    <p class="source">#include "Image.h"<br>
      <br>
(中略)..........<br>
      <br>
      <em>int Image::background{ -1 };</em><br>
      int Image::bossImage{ -1 }; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      int Image::player{ -1 };<br>
(中略)..........<br>
      <br>
      void Image::Load()<br>
      {<br>
(中略)..........<br>
      &nbsp;&nbsp;&nbsp; <em>background = LoadGraph("Image/background.jpg"); //[メモリ節約機能付の場合追記→] scene, { "TitleScene" });<br>
      &nbsp;&nbsp;&nbsp; assert(background != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
(中略)..........<br>
	    <br>
      }<br>
    </p>
<p><code>PlayScene.hに背景をえがく処理を追加</code>します。<br>
    </p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "Sound.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Boss.h"<br>
      #include "PlayerBullet.h"<br>
      #include "EnemyBullet.h"<br>
      #include "Explosion.h"<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
(中略)..........<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 背景の描画(<b>一番後ろに表示させるものから最初に描く、描く順が早い方が後ろのレイヤー</b>)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawGraphF(0, 0, Image::background, TRUE); // <b>DrawGraphF関数</b>は<b>DrawRotaGraphFと違い</b>(0,0)を指定すると<b>左上が(0,0)になるように描く。</b><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (中略)...................<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
		<br>
		はい、実行してみて、これで静止した状態で背景が表示されたら一旦は成功です。<br>
		うまく表示されない場合は、background.jpgのつづりは合ってますか?、もしくはImageフォルダにあるかちゃんと確認してくださいね。<br>
		<br>
		<br>
		<br>
		うまく表示出来たら今度は背景をスクロールさせる処理に挑戦してみます。<br>
		<br>
		<br>
		<br>
		<br>
	    <p><code>PlayScene.hに背景をスクロールさせる処理を追加</code>します。ポイントは背景を<b>2枚、画像の幅だけずらして描いている</b>ことです。<br>
    </p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "Sound.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Boss.h"<br>
      #include "PlayerBullet.h"<br>
      #include "EnemyBullet.h"<br>
      #include "Explosion.h"<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp;&nbsp; GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる<br>
      <br>
      &nbsp;&nbsp;&nbsp; float scrollSpeed = 1.5f; // スクロール速度<br>
      <em><br>
      &nbsp;&nbsp;&nbsp; float bgX = 0.0f; // 背景のスクロール位置<br>
      &nbsp;&nbsp;&nbsp; float bgSpeed = 1.5f; // 背景のスクロールスピード<br>
      </em><br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; PlayScene() : Scene()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;tag = "PlayScene";<br>
      &nbsp;&nbsp;&nbsp; }<br>
(中略)..........<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float bgWidth, bgHeight; // 画像の幅と高さ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // &amp;で&amp;bgWidth と &amp;bgHeightを参照渡し↓することでGetGraphSizeF内部で書き換えてもらう(&をつけない渡し方は変数のコピーを渡しだから関数が終わっても書き変わらない)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; GetGraphSizeF(Image::background, &amp;bgWidth, &amp;bgHeight); // 画像の縦横のピクセルサイズを取得する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bgX -= bgSpeed; // マイナスで左方向にスクロール<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (bgX &lt; -bgWidth) bgX = 0; // 画像サイズの幅ぶんスクロールしたら0に戻してループ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 背景の描画(一番後ろに表示させるものから最初に描く、描く順が早い方が後ろのレイヤー)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawGraphF(<em>bgX</em>, 0, Image::background, TRUE); // DrawGraphF関数はDrawRotaGraphFと違い(0,0)を指定すると左上が(0,0)になるように描く。<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// <b>2枚背景を画像の幅のぶんだけ右端にずらして描くことで無限にループしてるようにみせる</b><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawGraphF(bgX + bgWidth, 0, Image::background, TRUE);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (中略)...................<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
      <br>
      <br>
	      いかがですか？背景がスクロールすると画面に動きが出て少し気持ちよさが増したように感じませんか？<br>
<br>
		<br>
		<br>
		<h2><a id="mozTocId50015" class="mozTocH1"></a>スコアを画面表示させてみる</h2>

		<p><code>TitleScene.hには実はすでにスコアを表示するコードがありますが実は文字列の扱い方が間違っていて</code>表示されていません。<br></p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      (中略)...........<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      (中略)...........<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 0, "TitleSceneです。ボタン押下でPlaySceneへ。", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 200, <em>"MAXスコア: " + sm.scoreMax</em>, GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      
      (中略)...........<br>
	    <br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
	    
		<br>
		DrawStringの関数の上で右クリックして「定義をここに表示」してみてください。<br>
		<p class="source">
		// 文字列描画関数<br>
extern	int	DrawString( int x, int y, <b>const TCHAR *String</b>,      unsigned int Color, unsigned int EdgeColor DEFAULTPARAM( = 0 ) ) ;</p>
		<br>
		const TCHAR *String、つまりはconst TCHAR *型ですね<br>
		さらにTCHARの上で右クリックして「定義をここに表示」してみてください。<br>
		<p class="source">typedef char TCHAR, *PTCHAR;</p>
		typedef char ～,～...; つまりはchar型です(C言語の1byteの1文字の<a href="https://www.k-cube.co.jp/wakaba/server/ascii_code.html">アスキーコード</a>型もしくは<a href="https://pg-learning.com/c-lang/type-range/#google_vignette">-127 〜 128の1byteの整数型</a>)<br>
		<br>
		さて、ここまではC++なので使いやすいstd::string型でコードを書いてきました。<br>
		一方、DXライブラリはC言語時代から作られており、C言語でも動かせるように文字列はchar型の*ポインタとして表現されています。<br>
		char *型でなぜ、文字列として扱えているのでしょうか？<br>
		それはC言語時代から文字列は<b>char型の配列</b>として表現されてきており、char*型はその<b>配列の先頭を指すポインタ</b>としての意味を持っているのです。<br>
		下記のスライドでポインタや文字列、ヌルnullptrの概念、データの読み出し方と型の定義の関連、参照&amp;、CDやメモリなど物理データとプログラムのつながりを確認しましょう<br>
		<img src="image/pointer_string.png" alt="" style="width: 1081px; height: 608px;"><br>
		<br>
		上記を踏まえて、<em>"MAXスコア: " + sm.scoreMax</em>の意味を考えると..<br>
		あ、スコアが2だとすると<b>char*型"MAXスコア: "に+2しても..ポインタの先頭位置が+2ずれるだけ</b>..つまり[M][A][X]..のXをポインタが指すようになるだけ..<br>
		つまり、文字列<b>char*型に+で数字を足したところで文字のアクセス位置が変わるだけ</b>という処理になり、バグってしまうコードになるわけです。<br>
		<br>
		ではどうするかというと <b><em>std::string("MAXスコア: ")</em></b> としてC++のstd::string型に変換してから<b><em>std::to_string(sm.scoreMax)</em>で数字を文字列型に変換</b>したうえで、<br>
		<p class="source"><em>std::string("MAXスコア: ") + std::to_string(sm.scoreMax)</em></p>
		として足し合わせて、<br>
		さらに.c_str()関数でもとのchar*型へ戻してやる必要があります。<br>
		<p class="source"><em>( std::string("MAXスコア: ") + std::to_string(sm.scoreMax) ).c_str()</em></p>
		<br>
	<br>	
<p><code>TitleScene.hのスコアを表示するコードを修正します。</code><br></p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
	<em>#include &lt;string&gt;</em><br>
	<br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      (中略)...........<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      (中略)...........<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 0, "TitleSceneです。ボタン押下でPlaySceneへ。", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 200, <em>(std::string("MAXスコア: ") + std::to_string(sm.scoreMax)).c_str()</em>, GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      
      (中略)...........<br>
	    <br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
		<br>
		どうでしょうか、<b>一度自滅してみてスコアを確定させて、タイトル画面にスコアが表示されるか</b>確かめてみましょう。<br>
		スコアは0固定のはずです。なぜなら敵を倒してもスコアを加算する処理はまだ書いてないので(のちほどやる)。<br>
		<br>
	<h2><a id="mozTocId50016" class="mozTocH1"></a>フォントを変えてみる</h2>
	フォントの表示の仕方を色々変えてみましょう。<br>
		たとえば、フォントの色やサイズを変えることもできます。<br>
		<p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
	#include &lt;string&gt;<br>
	<br>
      #include "DxLib.h"<br>
      (中略)...........<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      (中略)...........<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>SetFontLineSpace(40); // 1行ごとのスペース<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int prevFontSize = GetFontSize(); // フォントのサイズを一旦保管<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SetFontSize(40); // フォントのサイズを変える</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 0, "TitleSceneです。<em>\n</em>ボタン押下でPlaySceneへ。", GetColor(<em>0</em>, 255, <em>0</em>));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>SetFontSize(prevFontSize); // フォントのサイズを元に戻す(戻さないと以降のすべての文字が40のサイズになる)</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 200, (std::string("MAXスコア: ") + std::to_string(sm.scoreMax)).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      
      (中略)...........<br>
	    <br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
		<br>
		実行したら、フォントの色とサイズは変わりましたか？<br>
		<br>
		<em>\n</em>は改行を意味する、<a href="https://www.k-cube.co.jp/wakaba/server/ascii_code.html">アスキーコードの特殊文字</a>です。<br>
		<br>
		<br>
		<br>
		さて、うまくはいきましたが<b>実はDraw()関数など1秒間に何回も繰り返される関数内でサイズや太さなどの変更処理</b>をするのは重くなります。<br>
		<a href="https://dxlib.xsrv.jp/function/dxfunc_graph2.html#R17N7">https://dxlib.xsrv.jp/function/dxfunc_graph2.html#R17N7</a><br>
		<a href="https://dxlib.xsrv.jp/function/dxfunc_graph2.html#R17N8">https://dxlib.xsrv.jp/function/dxfunc_graph2.html#R17N8</a><br>
		<br>
		なので、Initialize()関数など開始時に1度だけ呼ばれる関数でCreateFontToHandle関数でフォントを画像データとしてメモリ上に初期化する処理が望ましいです。<br>
		<a href="https://dxlib.xsrv.jp/function/dxfunc_graph2.html#R17N8">https://dxlib.xsrv.jp/function/dxfunc_graph2.html#R17N10</a><br>
		<br>
		<br>
		<p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
	#include &lt;string&gt;<br>
	<br>
      #include "DxLib.h"<br>
      (中略)...........<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      (中略)...........<br>
      &nbsp;&nbsp; &nbsp;<em>int font1 = -1; //フォントのハンドルをCreateFontToHandle関数で得る</em><br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;TitleScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "TitleScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// "ＭＳ 明朝"のフォントで、サイズ４０、太さ7<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// エッジサイズ3、DX_FONTTYPE_ANTIALIASING_EDGE_4X4　: アンチエイリアス＆エッジ付きフォント( 4x4サンプリング )<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// イタリック=TRUEのフォントを作成し<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 作成したデータの識別番号を変数 font1 に保存する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;font1 = DxLib::CreateFontToHandle("ＭＳ 明朝", 40, 7, DX_FONTTYPE_ANTIALIASING_EDGE_4X4, -1, 3, TRUE);</em><br>
      &nbsp;&nbsp; &nbsp;</em><br>
      &nbsp;&nbsp; &nbsp;(中略)...........<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;}<br>
(中略)...........<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SetFontLineSpace<em>ToHandle</em>(40<em>, font1</em>); // 1行ごとのスペース<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<u>int prevFontSize = GetFontSize(); // フォントのサイズを一旦保管<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SetFontSize(40); // フォントのサイズを変える</u><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString<em>ToHandle</em>(0, 0, "TitleSceneです。\nボタン押下でPlaySceneへ。", GetColor(0, 255, 0)<em>, font1, GetColor(0, 0, 255)</em>);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<u>SetFontSize(prevFontSize); // フォントのサイズを元に戻す(戻さないと以降のすべての文字が40のサイズになる)</u><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 200, (std::string("MAXスコア: ") + std::to_string(sm.scoreMax)).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      
      (中略)...........<br>
	    <br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
		<br>
		<br>
		さてうまく<b>"ＭＳ 明朝"のフォント</b>で表示がされたでしょうか？<br>
		このフォント名については"ＭＳ 明朝"以外にも沢山あるうえ、半角や全角やスペースがいりまじって、<b>つづりを間違わない方が難しいです</b>。<br>
		ゆえに下記ツールをダウンロード(64bit VersionのZIP archiveをクリック)して、Infoタブから<b>フォント名を右クリックでコピーできるように</b>しましょう。<br>
		<a href="https://us.fontviewer.de/Download/">https://us.fontviewer.de/Download/</a><br>
		<br>
		[使い方]:MS Minchoを検索したりして探して、見つけたら<b>右下からInfoタブをクリック</b>して、右画面スクロールで<b>[Full font name]</b>を探して、<br>
		<b>必ず右クリックでコピーを選択して</b>フォント名をテキストとしてコピーする(<b>右クリックからやらないとCtrl+Cではうまくコピーされない..</b>)<br>
		<img src="image/font_dp4_fontviewer1.png" alt="" style="width: 847px; height: 716px;"><br>
		<br>
<br>
<br>
		さて、このままでもシンプルに使いこなすことはできるでしょうが、できればImageクラスのようにFont用のクラスをつくって管理しておきたいところです。<br>
		では、さっそくつくっていきましょう。<br>
	<br>
		<p><code>Font.hを新規作成</code>してフォントデータを生成して辞書配列std::unordered_mapで管理するクラスを定義しましょう。<br></p>
		<p class="source">#ifndef FONT_H_<br>
#define FONT_H_<br>
<br>
#include "DxLib.h"<br>
#include &lt;assert.h&gt; // 読込み失敗表示用<br>
#include &lt;string&gt;<br>
#include &lt;unordered_map&gt;<br>
<br>
<br>
// フォント設定の管理や読み込みを行うクラス<br>
class Font<br>
{<br>
public:<br>
      &nbsp;&nbsp; &nbsp;// フォントの設定の構造体<br>
      &nbsp;&nbsp; &nbsp;struct Setting<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int size = -1; // フォントのサイズ( おおよそのドット数 -1にするとデフォルトのサイズ )<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int thick = -1; // フォントの太さ( 0～9 -1にするとデフォルトの太さ )<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int fontType = -1; // フォントのタイプ [参考] https://dxlib.xsrv.jp/function/dxfunc_graph2.html#R17N10<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int charSet = -1;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int edgeSize = -1; // フォントの縁のエッジのサイズ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int italic = FALSE; // イタリック体で表示するか<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int handle = -1; // CreateFontToHandle関数で帰ってくるハンドル https://dxlib.xsrv.jp/function/dxfunc_graph2.html#R17N10<br>
		<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;const std::string tag = ""; // 設定にタグをつけて管理する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string fontName; // 作成するフォント名(NULL にするとデフォルトのフォント)<br>
<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// std::unordered_mapの値に使うにはデフォルトコンストラクタが必要<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Setting() = default;//←これが無いと「クラス、構造体、..に規定のコンストラクタがありません」エラー<br>
		<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Setting(const std::string tag, const TCHAR* FontName, int Size, int Thick,<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int FontType = -1, int CharSet = -1, int EdgeSize = -1, int Italic = FALSE)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;: size{ Size }, thick{ Thick }, fontType{ FontType }, charSet{ CharSet }, edgeSize{ EdgeSize }, italic{ Italic },<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;tag{ tag }, fontName{ (FontName == NULL) ? "" : std::string(FontName) }<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;virtual ~Setting() {}<br>
      &nbsp;&nbsp; &nbsp;};<br>
<br>
      &nbsp;&nbsp; &nbsp;// 自分で設定したフォント設定の辞書<br>
      &nbsp;&nbsp; &nbsp;static std::unordered_map&lt;std::string, Setting&gt; fonts;<br>
<br>
      &nbsp;&nbsp; &nbsp;Font() {}; // 初期化コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;virtual ~Font() {}; // 破棄するデストラクタ<br>
<br>
      &nbsp;&nbsp; &nbsp;static void Init()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ゲーム起動時から終了までずっと使うフォントはまとめてここで読込む形もアリ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//Setting font1{ "設定1", "ＭＳ 明朝", 40, 3 };<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//Load(&amp;font1); // 設定に沿ってフォントをデータ化しておく<br>
      &nbsp;&nbsp; &nbsp;}<br>
<br>
      &nbsp;&nbsp; &nbsp;// Settingに沿ってCreateFontToHandle関数でフォントデータを作成して辞書に登録しておく https://dxlib.xsrv.jp/function/dxfunc_graph2.html#R17N10<br>
      &nbsp;&nbsp; &nbsp;static int Load(Setting* setting = nullptr);<br>
<br>
      &nbsp;&nbsp; &nbsp;// 作成しておいたフォントデータを削除する(ひとつあたり1.2MB程のメモリを使う)<br>
      &nbsp;&nbsp; &nbsp;static int DeleteFontToHandle(Setting* setting = nullptr);<br>
<br>
private:<br>
<br>
};<br>
#endif</p>
		<br>
		<br>Font.cppも必要になります。<br>
		<p><code>Font.cppを新規作成</code>してフォントデータを生成したり、メモリ上から削除して節約したりする処理をつくりましょう。<br></p>
		<p class="source">#include "Font.h"<br>
<br>
std::unordered_map&lt;std::string, Font::Setting&gt; Font::fonts; // フォントの辞書<br>
<br>
<br>
int Font::Load(Setting* setting)<br>
{<br>
      &nbsp;&nbsp; &nbsp;// 設定がnullptrだったらデフォルトのフォントを返す<br>
      &nbsp;&nbsp; &nbsp;if (setting == nullptr)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return GetDefaultFontHandle();<br>
<br>
      &nbsp;&nbsp; &nbsp;// すでに辞書に登録があったら作成したフォントデータを削除しておく<br>
      &nbsp;&nbsp; &nbsp;if (fonts.count(setting-&gt;tag) != 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DxLib::DeleteFontToHandle(fonts[setting-&gt;tag].handle);<br>
<br>
      &nbsp;&nbsp; &nbsp;// https://dxlib.xsrv.jp/function/dxfunc_graph2.html#R17N10<br>
      &nbsp;&nbsp; &nbsp;// フォントを作成し作成したデータの識別番号をsetting-&gt;handle に保存する<br>
      &nbsp;&nbsp; &nbsp;setting->handle = CreateFontToHandle((setting-&gt;fontName == "") ? NULL : setting-&gt;fontName.c_str(), setting-&gt;size, setting-&gt;thick,<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; setting-&gt;fontType, setting-&gt;charSet, setting-&gt;edgeSize, setting-&gt;italic, setting-&gt;handle);<br>
	<br>
      &nbsp;&nbsp; &nbsp;assert(setting-&gt;handle != -1 && "Font名が間違っているかFontフォルダ指定をミスっていませんか?"); // フォント作成失敗<br>
	<br>
      &nbsp;&nbsp; &nbsp;// 読み込んだハンドルを辞書に登録しておく<br>
      &nbsp;&nbsp; &nbsp;fonts.emplace(setting-&gt;tag, *setting);<br>
<br>
      &nbsp;&nbsp; &nbsp;return setting-&gt;handle;<br>
}<br>
<br>
// フォントがメモリを圧迫してるときに使う(フォントデータはひとつ1.2MB程のメモリを使う)<br>
int Font::DeleteFontToHandle(Setting* setting)<br>
{<br>
      &nbsp;&nbsp; &nbsp;// 設定がnullptrだったら何もせずreturn<br>
      &nbsp;&nbsp; &nbsp;if (setting == nullptr)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return 0;<br>
<br>
      &nbsp;&nbsp; &nbsp;// すでに辞書に登録があったら<br>
      &nbsp;&nbsp; &nbsp;if (fonts.count(setting-&gt;tag) != 0)<br>
      &nbsp;&nbsp; &nbsp;{	// 作成したフォントデータを削除<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int result = DxLib::DeleteFontToHandle(fonts[setting-&gt;tag].handle);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(result == 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fonts.erase(setting-&gt;tag); // 辞書からも削除<br>
      &nbsp;&nbsp; &nbsp;}<br>
<br>
      &nbsp;&nbsp; &nbsp;setting->handle = -1; // -1に戻して未ロード状態がわかるようにする<br>
<br>
      &nbsp;&nbsp; &nbsp;return setting-&gt;handle;<br>
}</p>
		<br>
		<p><code>TitleScene.hを修正して</code>Fontクラスから生成したフォントデータからスコアを表示してみましょう。<br></p>
		<p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
	#include &lt;string&gt;<br>
	<br>
      #include "DxLib.h"<br>
      (中略)...........<br>
<em>#include "Font.h"</em><br>
      (中略)...........<br>		
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      (中略)...........<br>
      &nbsp;&nbsp; &nbsp;<em>// ★dp4FontViewerを使ってInfoからFont名を得て↓コピぺすればつづりを間違えない https://us.fontviewer.de/Download/<br>
      &nbsp;&nbsp; &nbsp;Font::Setting font = Font::Setting("設定1", "HG丸ｺﾞｼｯｸM-PRO", 40, 7, DX_FONTTYPE_ANTIALIASING_EDGE_4X4, -1, 3, FALSE);</em><br>
      &nbsp;&nbsp; &nbsp;int font1 = -1; //フォントのハンドルをCreateFontToHandle関数で得る<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;TitleScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "TitleScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>Font::Load(&font); // 設定に沿ってフォントをデータ化しておく<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// "ＭＳ 明朝"のフォントで、サイズ４０、太さ7<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// エッジサイズ3、DX_FONTTYPE_ANTIALIASING_EDGE_4X4　: アンチエイリアス＆エッジ付きフォント( 4x4サンプリング )<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// イタリック=TRUEのフォントを作成し<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 作成したデータの識別番号を変数 font1 に保存する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;font1 = DxLib::CreateFontToHandle("ＭＳ 明朝", 40, 7, DX_FONTTYPE_ANTIALIASING_EDGE_4X4, -1, 3, TRUE);<br>
      &nbsp;&nbsp; &nbsp;</em><br>
      &nbsp;&nbsp; &nbsp;(中略)...........<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;}
(中略)...........<br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>Font::DeleteFontToHandle(&font); // フォントデータを削除してメモリ節約(1フォントあたり1.2MB節約できる)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</em><br>
      &nbsp;&nbsp; &nbsp;(中略)...........<br>
      &nbsp;&nbsp; &nbsp;}
(中略)...........<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SetFontLineSpaceToHandle(40, font1); // 1行ごとのスペース<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawStringToHandle(0, 0, "TitleSceneです。\nボタン押下でPlaySceneへ。", GetColor(0, 255, 0), font1, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>//[テストしやすくするため一旦コメントアウト] </em>if (sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString<em>ToHandle</em>(0, 200, (std::string("MAXスコア: ") + std::to_string(sm.scoreMax)).c_str(), GetColor(255, 255, 255)<em>, Font::fonts["設定1"].handle, GetColor(255, 0, 0)</em>);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      
      (中略)...........<br>
	    <br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
		<br>
		<br>
		<br>
		どうでしょうか？表示されましたか？<br>
		<br>
		ひとつ問題として、同じWindows同士でも入っているフォントが違っていたりすると、<br>
		ゲームをプレイしてもらう相手にフォントがない場合は、フォントが表示されなくなるおそれがあります。<br>
		これを解決するには<b>DXライブラリをインストールしたフォルダに付属しているToolツールフォルダ</b>にある
		<b>CreateDXFontData.exeをコマンドプロンプトで使用</b>して書き出される<b>DFT形式を使用</b>する対策があります。<br>
		<b>Windowsのデフォルトで入っているフォントも著作物</b>ですから、安全を考えて個人商用フリーのフォントをWEBでさがしてみましょう。(<b>利用規約はしっかり読みましょう</b>)<br>
		<a href="https://coliss.com/articles/freebies/japanese-free-fonts.html">https://coliss.com/articles/freebies/japanese-free-fonts.html</a><br>
		<br>
		フリーフォントのインストールの仕方は下記を参考に<br>
		<a href="https://www.pc-koubou.jp/magazine/58097">https://www.pc-koubou.jp/magazine/58097</a><br>
		<br>
		<br>
		<img src="image/font_dp4_fontviewer2.png" alt=""><br>
		<br>
		<br>
		フリーフォントのフォント名がコピー出来たら、左下のWindowsの検索窓から<b>コマンドプロンプトを検索して起動</b>しましょう。<br>
		コマンドプロンプトは<b>GUI</b>(Gグラフィカルな Userユーザー Interfaceインターフェース)と違い、<br>
		1990年代の<b>CUI(Commandコマンド形式のUserユーザー Interfaceインターフェース)</b>で、cdなどの<b>コマンドを文字で打ち込み、フォルダをたどる仕組み</b>です。<br>
		<b>cd \</b>コマンドでWindow C:直下のルートフォルダに移動します。<br>
		<b>cd と打って、タブTabボタンを押す</b>とC:フォルダの中にあるフォルダが順番に表示されますのでDxLib＿VCフォルダを探しましょう。<br>
		<b>あとは順々にDxLib＿VC/Tool/CreateDXFontDataフォルダまで</b>たどりましょう。<br>
		DxLib＿VC/Tool/CreateDXFontDataフォルダには<b>CreateDXFontData.exeがあります</b>ので<br>
		<b>Sampleフォルダにある～.batやreadme.txtをメモ帳に書いてあることを参考に</b><br>
		<b>CreateDXFontData.exe /F"コピーしたフォント名" /B4 /S32 /O"MyFont1.dft"</b>などのコマンドをうちEnterで実行してMyFont1.dftができたら成功です。<br>
		<br>
		<img src="image/font_dp4_fontviewer3.png" alt="" style="width: 1214px; height: 720px;"><br>
		<br>
		<br>
		MyFont1.dftができたら<code>Imageフォルダと同じフォルダにFontフォルダを作成して、生成したMyFont1.dftファイルをコピーしておきましょう</code>
	<br>
		<p><code>Font.hを修正してDFT形式のファイルからフォントデータを生成</code>して表示する処理を定義しましょう。<br></p>
		<p class="source">#ifndef FONT_H_<br>
#define FONT_H_<br>
<br>
#include "DxLib.h"<br>
#include &lt;assert.h&gt; // 読込み失敗表示用<br>
#include &lt;string&gt;<br>
#include &lt;unordered_map&gt;<br>
<br>
<br>
// フォント設定の管理や読み込みを行うクラス<br>
class Font<br>
{<br>
public:<br>
      &nbsp;&nbsp; &nbsp;// フォントの設定の構造体<br>
      &nbsp;&nbsp; &nbsp;struct Setting<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int size = -1; // フォントのサイズ( おおよそのドット数 -1にするとデフォルトのサイズ )<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int thick = -1; // フォントの太さ( 0～9 -1にするとデフォルトの太さ )<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int fontType = -1; // フォントのタイプ [参考] https://dxlib.xsrv.jp/function/dxfunc_graph2.html#R17N10<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int charSet = -1;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int edgeSize = -1; // フォントの縁のエッジのサイズ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int italic = FALSE; // イタリック体で表示するか<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int handle = -1; // CreateFontToHandle関数で帰ってくるハンドル https://dxlib.xsrv.jp/function/dxfunc_graph2.html#R17N10<br>
		<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>bool isDFTFont = false; // DXライブラリ付属ツール C:\DxLib_VC\Tool\CreateDXFontData で書き出したDFT形式を使用するかどうか</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;const std::string tag = ""; // 設定にタグをつけて管理する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string fontName; // 作成するフォント名(NULL にするとデフォルトのフォント)<br>
<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// std::unordered_mapの値に使うにはデフォルトコンストラクタが必要<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Setting() = default;//←これが無いと「クラス、構造体、..に規定のコンストラクタがありません」エラー<br>
		<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Setting(const std::string tag, const TCHAR* FontName, int Size, int Thick,<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int FontType = -1, int CharSet = -1, int EdgeSize = -1, int Italic = FALSE)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;: size{ Size }, thick{ Thick }, fontType{ FontType }, charSet{ CharSet }, edgeSize{ EdgeSize }, italic{ Italic },<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;tag{ tag }, fontName{ (FontName == NULL) ? "" : std::string(FontName) }<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;isDFTFont = false; // 引数を4つ以上指定する初期化ならCreateFontToHandleを使用する</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>Setting(const std::string tag, const TCHAR* DFTFontPath, int EdgeSize = -1)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;: tag{ tag }, fontName{ (DFTFontPath == NULL) ? "" : std::string(DFTFontPath) }, edgeSize{ EdgeSize }<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;isDFTFont = true; // 引数を3つ以下指定する初期化ならDFT形式のフォントをロードする<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</em><br>
<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;virtual ~Setting() {}<br>
      &nbsp;&nbsp; &nbsp;};<br>
<br>
      &nbsp;&nbsp; &nbsp;// 自分で設定したフォント設定の辞書<br>
      &nbsp;&nbsp; &nbsp;static std::unordered_map&lt;std::string, Setting&gt; fonts;<br>
<br>
      &nbsp;&nbsp; &nbsp;Font() {}; // 初期化コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;virtual ~Font() {}; // 破棄するデストラクタ<br>
<br>
      &nbsp;&nbsp; &nbsp;static void Init()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ゲーム起動時から終了までずっと使うフォントはまとめてここで読込む形もアリ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//Setting font1{ "設定1", "ＭＳ 明朝", 40, 3 };<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//Load(&amp;font1); // 設定に沿ってフォントをデータ化しておく<br>
      &nbsp;&nbsp; &nbsp;}<br>
<br>
      &nbsp;&nbsp; &nbsp;// Settingに沿ってCreateFontToHandle関数でフォントデータを作成して辞書に登録しておく https://dxlib.xsrv.jp/function/dxfunc_graph2.html#R17N10<br>
      &nbsp;&nbsp; &nbsp;static int Load(Setting* setting = nullptr);<br>
<br>
      &nbsp;&nbsp; &nbsp;// 作成しておいたフォントデータを削除する(ひとつあたり1.2MB程のメモリを使う)<br>
      &nbsp;&nbsp; &nbsp;static int DeleteFontToHandle(Setting* setting = nullptr);<br>
<br>
private:<br>
<br>
};<br>
#endif</p>
		<br>
		<br>Font.cppも修正が必要になります。<br>
		<p><code>Font.cppを修正してLoadFontDataToHandle関数でDFT形式のフォントファイルを読み込む</code>処理をつくりましょう。<br></p>
		<p class="source">#include "Font.h"<br>
<br>
std::unordered_map&lt;std::string, Font::Setting&gt; Font::fonts; // フォントの辞書<br>
<br>
<br>
int Font::Load(Setting* setting)<br>
{<br>
      &nbsp;&nbsp; &nbsp;// 設定がnullptrだったらデフォルトのフォントを返す<br>
      &nbsp;&nbsp; &nbsp;if (setting == nullptr)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return GetDefaultFontHandle();<br>
<br>
      &nbsp;&nbsp; &nbsp;// すでに辞書に登録があったら作成したフォントデータを削除しておく<br>
      &nbsp;&nbsp; &nbsp;if (fonts.count(setting-&gt;tag) != 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DxLib::DeleteFontToHandle(fonts[setting-&gt;tag].handle);<br>
<br>
      &nbsp;&nbsp; &nbsp;// https://dxlib.xsrv.jp/function/dxfunc_graph2.html#R17N10<br>
      &nbsp;&nbsp; &nbsp;// フォントを作成し作成したデータの識別番号をsetting-&gt;handle に保存する<br>
      &nbsp;&nbsp; &nbsp;<em>if (setting-&gt;isDFTFont == false || setting-&gt;fontName == "")<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</em>setting->handle = CreateFontToHandle((setting-&gt;fontName == "") ? NULL : setting-&gt;fontName.c_str(), setting-&gt;size, setting-&gt;thick,<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; setting-&gt;fontType, setting-&gt;charSet, setting-&gt;edgeSize, setting-&gt;italic, setting-&gt;handle);<br>
      &nbsp;&nbsp; &nbsp;<em>else // ＤＸフォントデータファイルを読込み、フォントハンドルを保存する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;setting->handle = LoadFontDataToHandle(setting-&gt;fontName.c_str(), setting-&gt;edgeSize);</em><br>
	<br>
      &nbsp;&nbsp; &nbsp;assert(setting-&gt;handle != -1 && "Font名が間違っているかFontフォルダ指定をミスっていませんか?"); // フォント作成失敗<br>
	<br>
      &nbsp;&nbsp; &nbsp;// 読み込んだハンドルを辞書に登録しておく<br>
      &nbsp;&nbsp; &nbsp;fonts.emplace(setting-&gt;tag, *setting);<br>
<br>
      &nbsp;&nbsp; &nbsp;return setting-&gt;handle;<br>
}<br>
<br>
// フォントがメモリを圧迫してるときに使う(フォントデータはひとつ1.2MB程のメモリを使う)<br>
int Font::DeleteFontToHandle(Setting* setting)<br>
{<br>
      &nbsp;&nbsp; &nbsp;// 設定がnullptrだったら何もせずreturn<br>
      &nbsp;&nbsp; &nbsp;if (setting == nullptr)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return 0;<br>
<br>
      &nbsp;&nbsp; &nbsp;// すでに辞書に登録があったら<br>
      &nbsp;&nbsp; &nbsp;if (fonts.count(setting-&gt;tag) != 0)<br>
      &nbsp;&nbsp; &nbsp;{	// 作成したフォントデータを削除<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int result = DxLib::DeleteFontToHandle(fonts[setting-&gt;tag].handle);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(result == 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fonts.erase(setting-&gt;tag); // 辞書からも削除<br>
      &nbsp;&nbsp; &nbsp;}<br>
<br>
      &nbsp;&nbsp; &nbsp;setting->handle = -1; // -1に戻して未ロード状態がわかるようにする<br>
<br>
      &nbsp;&nbsp; &nbsp;return setting-&gt;handle;<br>
}</p>
		<br>
		<br>
		<p><code>TitleScene.hを修正して</code>Fontクラスから生成したフォントデータからスコアを表示してみましょう。<br></p>
		<p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
	#include &lt;string&gt;<br>
	<br>
      #include "DxLib.h"<br>
      (中略)...........<br>
#include "Font.h"<br>
      (中略)...........<br>		
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      (中略)...........<br>
      &nbsp;&nbsp; &nbsp;// ★dp4FontViewerを使ってInfoからFont名を得て↓コピぺすればつづりを間違えない https://us.fontviewer.de/Download/<br>
      &nbsp;&nbsp; &nbsp;<em>//</em>Font::Setting font = Font::Setting("設定1", "HG丸ｺﾞｼｯｸM-PRO", 40, 7, DX_FONTTYPE_ANTIALIASING_EDGE_4X4, -1, 3, FALSE);<br>
      &nbsp;&nbsp; &nbsp;<em>Font::Setting font = Font::Setting("設定1", "Font/MyFont1.dft", 2);</em><br>
      &nbsp;&nbsp; &nbsp;int font1 = -1; //フォントのハンドルをCreateFontToHandle関数で得る<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Font::Load(&font); // 設定に沿ってフォントをデータ化しておく<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// "ＭＳ 明朝"のフォントで、サイズ４０、太さ7<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// エッジサイズ3、DX_FONTTYPE_ANTIALIASING_EDGE_4X4　: アンチエイリアス＆エッジ付きフォント( 4x4サンプリング )<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// イタリック=TRUEのフォントを作成し<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 作成したデータの識別番号を変数 font1 に保存する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;font1 = DxLib::CreateFontToHandle("ＭＳ 明朝", 40, 7, DX_FONTTYPE_ANTIALIASING_EDGE_4X4, -1, 3, TRUE);<br>
      &nbsp;&nbsp; &nbsp;</em><br>
      &nbsp;&nbsp; &nbsp;(中略)...........<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;}
(中略)...........<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SetFontLineSpaceToHandle(40, font1); // 1行ごとのスペース<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawStringToHandle(0, 0, "TitleSceneです。\nボタン押下でPlaySceneへ。", GetColor(0, 255, 0), font1, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//[テストしやすくするため一旦コメントアウト] if (sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawStringToHandle(0, 200, (std::string("MAXスコア: ") + std::to_string(sm.scoreMax)).c_str(), GetColor(255, 255, 255), Font::fonts["設定1"].handle, GetColor(<em>0, 255, 255</em>));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      
      (中略)...........<br>
	    <br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
		<br>
		どうでしょうか？これで他の人のPCに入っていないフリーのフォントでも.dtf形式のファイルをFontフォルダにおいてゲームを送れば、文字が表示されない心配がなくなります。<br>
		<br>
		かっこいい<b>フリーのフォントを探して取り入れるだけでもゲームの印象はがらりと宇宙っぽくもデジタルっぽくもポップにも</b>なります。<br>
		<b>センスとはチョイスと組み合わせ</b>です。そしてそこをさぼると<b>ユーザーには確実に作り手の熱量を見抜かれてしまいます</b>。<br>
		<b>探して選んで組み合わせること</b>。その地道な積み上げは<b>暗黙に人に伝わってしまう</b>のです。<br>
		<b>センスとは積み上げられるものです</b>。過去の試行錯誤が<b>結果的に知らない人から見るとひらめきセンスのように見えてしまうだけです</b>。<br>
		<br>
		<br>
		<br>
		<br>
	<h2><a id="mozTocId50017" class="mozTocH1"></a>スコアの加算処理と背景の加速</h2>
		さて現状では、スコアは表示されますが、敵を倒してもスコアは増えていません。<br>
		今度はそこを改造して、スコアをカウントしてみましょう。<br>
		<br>
<br>
		 <p><code>PlayScene.hのプレイヤ弾と敵の衝突判定にスコアをふやす処理</code>を追加してみましょう。</p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
	    (中略)................<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
	    (中略)................<br>
	    int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる
	    (中略)................<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ここにプレイ中の更新処理を持ってくる<br>
      <br>
      
	    (中略)................<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾と敵の衝突判定<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; playerBullet : gm.playerBullets)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾と敵が重なっているか？<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; playerBullet-&gt;position, playerBullet-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; playerBullet-&gt;OnCollisionEnemy(enemy);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::bomb); // 効果音の再生<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>++score; // 敵を倒すとスコアが+1される<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bgSpeed += 0.05f; // 敵を倒せば倒すほど背景を加速させる演出</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; break;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
	    (中略)................<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      
	    (中略)................<br>
      };<br>
      <br>
      #endif<br>
    </p>
<br>
		さて敵をたくさん倒して<b>タイトル画面に戻るとスコアが増えていた</b>でしょうか？<br>
		おまけで<b>スコアが増えるタイミングで背景を加速させる処理も追加</b>しておきました。<br>
		<br>
		画面にはスコアを表示させていませんが、<b>背景の加速でスコアが増えてゲームがヒートアップしていることを実感</b>できるのではないですか？<br>
		<br>
		画面にスコアを表示させるのもいいですが、数字を文字で表現するよりも<b>数字を何かの演出につなげる方が人の直感に訴えかけるものがあります</b>。<br>
		<br>
		私は<b>自分の好きなゲームの面白さを蒐集(しゅうしゅう)して自己分析</b>してきた結果、抽出できた構造は<br>
		<br>
		&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>「ゲームとは状態の遷移でできている」</b>ということです。<br>
		<br>
		たとえば、<b>RPGでレベルが上がるということは「状態(状況)が変わっていく」</b>ということです。<br>
		逆に言うならレベルを上げている最中なかなか<b>レベルが上がらないときには「状態が変わらず」「単調で眠くなる」</b>といえるわけです。<br>
		ソーシャルゲームの開発現場でプレイヤのレベルが上がるのにあわせた並走する形の成長曲線で敵も強くなるという仕様を聞いたとき、<br>
		え、絶対売れないじゃん<b>「プレイヤが俺つよいと感じられる瞬間を数値設計演出できてない → 状態が単調になる」</b>そんな簡単なこともわかってないのか..と思いました。<br>
		<br>
		逆にいうなら、今作っているこんな単純なシューティングでも<b>「背景を加速させるというシンプルな状態の変化の演出」</b>を入れるだけで<b>熱量を感じさせることは可能</b>なのです。<br>
		<br>
		<br>
		少なくとも自分がゲームを作るなら、パワポの上でアイデアを考えるよりも、<br>
		&nbsp;&nbsp;&nbsp; <b>ゲームの状態の遷移とユーザーの心の遷移の連動を頭の中でイメージ</b>してユーザーが<b>どの時点で先を予想できてあきてしまうか</b>、までは見えてしまいます。<br>
		&nbsp;&nbsp;&nbsp; <b>自分の心の遷移の先回りをされていると感じるとき</b>はゲームに<b>明確な作り手の意図を感じられます</b>し、難しすぎるときは<b>自分が無視されているような感覚を感じます</b>。<br>
		&nbsp;&nbsp;&nbsp; そういう意味では<b>作り手(自分)とユーザー(自分や他人)の「表現物としてのゲームを通じた対話」</b>がゲームを作る繰り返しではないかと感じます。<br>
		<br>
		<b>私は自分の気持ち良いと感じる状態遷移を蒐集</b>しました、<br>
		― マリオのスター無敵状態(<b>曲の加速</b>)、<br>
		― テトリスのブロックが上のほうでどんどん積みあがってどんどん追いつめられる瞬間(<b>積みあがる間隔の加速</b>)、<br>
		― 果てはアンドロイドスマホのブラウザスクロールは気持ちよくないのにiPhoneのブラウザのスクロールが気持ちいいのはなぜか？(<b>スクロールの加速の仕方</b>)。<br>
		<br>
		私はおそらく<b>「加速」の状態遷移</b>、が好きなのだと思います。<br>
		<br>
		あなたも、ぜひ<b>「自分の面白さの蒐集(しゅうしゅう)と分析」</b>を始めてみてください。<br>
		あるいは、逆の<b>「面白くなさの蒐集(しゅうしゅう)と分析」</b>もアリかもしれません(面白くなさでゲームをあきらめる「=<a href="https://www.otani.ac.jp/yomu_page/b_yougo/nab3mq0000000qkz.html">あきらかになる</a>」ことも一歩一歩プラスになる)。<br>
		<br>
		さもなくば、知らないうちにあなたの<b>ゲームへの向き合い方の状態はずっと同じ状態【<a href="https://www.excite.co.jp/news/article/E1543214036908/">死 状態</a>】におちいってしまうかも</b>しれません。<br>
		<br>
		<br>
		<br>
		<br>
		
	<h2><a id="mozTocId50018" class="mozTocH1"></a>スコアのランキング表示</h2>
		さて、現状でもこれまでの最大MAXスコアは表示できていますが、<b>MAXを更新しなければ、ユーザーはやりがいを感じられなくなってしまうかも</b>しれません。<br>
		一番簡単な解決策としては、<b>スコアを配列でランキングとして管理</b>して、<br>
		<b>No.1(1位)になれなくてもプレイ結果が今までのプレイと比べてどの順位にいるかわかるだけ</b>でも、<b>繰り返しプレイするときのやりがいは変わってきます</b>。(<b>1プレイごとの状態の変化</b>)<br>
		<br>
		<p><code>SceneManager.hにスコアのランクとランキング配列を定義</code>してランキングを管理できるようにしましょう。</p>
    <p class="source">#ifndef SCNENEMANAGER_H_<br>
      #define SCNENEMANAGER_H_<br>
      <br>
(中略)..........<br>
      <br>
      #include "Singleton.h"<br>
      <br>
      class Scene; //クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      <br>
      class SceneManager : public Singleton&lt;SceneManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;friend class Singleton&lt;SceneManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <b>// マネージャを【どこからでもアクセスしやすい「変数の掲示板」として使えばシーンをまたぐ変数も定義できる】</b><br>
      &nbsp;&nbsp;&nbsp; std::string selectStage = "stage1"; // 選択中のステージ名など<br>
      &nbsp;&nbsp; &nbsp;int scoreMax = -1; // 【シーンをまたぐスコアなど】はマネージャに定義すれば【シーンをまたいだあとも】消えず残る<br>
      &nbsp;&nbsp; &nbsp;<em>int ranking[5] = {-1,-1,-1,-1,-1}; // スコアトップ5を記録しておく配列<br>
      &nbsp;&nbsp; &nbsp;int rank = 0; // 直前のゲーム終了したときの順位</em><br>
      &nbsp;&nbsp;&nbsp; <br>
(中略)..........<br>
	    <br>
      };<br>
      <br>
      #endif</p>
    <br>
		つぎにプレイの画面終了時にスコアを降順に並べ替えながらランキングに登録する処理をくわえます。<br>
		<br>
		<br>
		【勉強】<b>順序を並べ替えるソートの仕方</b>はいろいろ種類があります。<b>プログラミングの仕事をするのであれば常識</b>ですので(<b>就職や転職のオンラインコーディングテストでよく出る</b>)、<br>
		これを機会にぜひ勉強しておきたいところですね。おすすめは<a href="https://book.mynavi.jp/ec/products/detail/id=114278">アルゴリズムビジュアル大辞典</a>です。<br>
		<br>
		<a href="https://yutaka-watanobe.github.io/star-aida/1.0/algorithms/insertion_sort/anim.html">QRコード</a>からデータの動きをアニメーションで見れて、実感がわきやすいです。<br>
      &nbsp;&nbsp;&nbsp; アルゴリズムビジュアル大辞典のアニメ一覧サイト:<a href="https://yutaka-watanobe.github.io/star-aida/books/">https://yutaka-watanobe.github.io/star-aida/books/</a><br>
      &nbsp;&nbsp;&nbsp; 今回使う挿入ソート: <a href="https://yutaka-watanobe.github.io/star-aida/1.0/algorithms/insertion_sort/anim.html">https://yutaka-watanobe.github.io/star-aida/1.0/algorithms/insertion_sort/anim.html</a><br>
		<br>
		下記のサイトで<b>[Run]ボタンを押す</b>と<b>並べ替えの速度の違いを実感</b>できるとおもいます。<br>
      &nbsp;&nbsp;&nbsp; 挿入ソート: <a href="https://ufcpp.net/study/algorithm/sort_insert.html">https://ufcpp.net/study/algorithm/sort_insert.html</a><br>
      &nbsp;&nbsp;&nbsp; バブルソート: <a href="https://ufcpp.net/study/algorithm/sort_bubble.html">https://ufcpp.net/study/algorithm/sort_bubble.html</a><br>
      &nbsp;&nbsp;&nbsp; 選択ソート: <a href="https://ufcpp.net/study/algorithm/sort_select.html">https://ufcpp.net/study/algorithm/sort_select.html</a><br>
      &nbsp;&nbsp;&nbsp; シェルソート: <a href="https://ufcpp.net/study/algorithm/sort_shell.html">https://ufcpp.net/study/algorithm/sort_shell.html</a><br>
      &nbsp;&nbsp;&nbsp; クイックソート: <a href="https://ufcpp.net/study/algorithm/sort_quick.html">https://ufcpp.net/study/algorithm/sort_quick.html</a><br>
      &nbsp;&nbsp;&nbsp; ヒープソート: <a href="https://ufcpp.net/study/algorithm/sort_heap.html">https://ufcpp.net/study/algorithm/sort_heap.html</a><br>
      &nbsp;&nbsp;&nbsp; マージソート: <a href="https://ufcpp.net/study/algorithm/sort_merge.html">https://ufcpp.net/study/algorithm/sort_merge.html</a><br>
      &nbsp;&nbsp;&nbsp; バケットソート: <a href="https://ufcpp.net/study/algorithm/sort_bucket.html">https://ufcpp.net/study/algorithm/sort_bucket.html</a><br>
      &nbsp;&nbsp;&nbsp; 基数ソート: <a href="https://ufcpp.net/study/algorithm/sort_radix.html">https://ufcpp.net/study/algorithm/sort_radix.html</a><br>
		<br>
		基本的には<b>クイックソートが速度の王様だと記憶</b>しておけばよいです。(<a href="https://www.kijineko.co.jp/%E8%BF%B7%E4%BF%A1-%E3%83%87%E3%83%BC%E3%82%BF%E5%88%97%E3%81%AE%E3%82%BD%E3%83%BC%E3%83%88%E3%81%AB%E3%81%AFqsort%E9%96%A2%E6%95%B0%E3%82%92%E4%BD%BF%E3%81%86%E3%81%B9%E3%81%97/">問題設定の条件による</a>)<br>
		std::qsortの使い方 : <a href="https://runebook.dev/ja/docs/cpp/algorithm/qsort">https://runebook.dev/ja/docs/cpp/algorithm/qsort</a><br>
		クイックソートは<b>安定ソートではない不安定ソート(=並べ替え前とあとで同じ値を持つ人の順位の変わる可能性がある)</b>です。<br>
		<b>不安定な具体例. 前回 3位:Aさん(10点)、4位:Bさん(10点) → 次回 3位:<em>Bさん</em>(10点)、4位:<em>Aさん</em>(10点)→おなじ点数なのに順位が毎回不安定..</b><br>
		<br>
		自分でソート処理を書かなくてもC++の<a href="https://cpprefjp.github.io/reference/algorithm/sort.html">std::sort関数を使えば楽</a>だが、<br>
		教養として最低限、<b>std::sort関数</b>が<b>クイックソートの改良版のイントロソート</b>をベースとした<a href="http://blog.livedoor.jp/dgd17/archives/11610522.html">不安定ソートであることを知ったうえで使うべき</a>であり、<br>
		安定ソートが必要な場合は、必要性に応じて、<b>std::stable_sort関数</b>で<a href="https://qiita.com/mima_ita/items/b4cb3be38d64a397216b">安定なマージソート系の並べ替えの仕方もあることも知識として知っている必要</a>はあります。<br>
		(色んなソートの種類があるとを知ったうえで、std::sort関数で1,2行プログラムを書いて並べ替えるのと、何もわからないけどとりあえずstd::sort関数使うだけなのとは、素人の魔法使いと熟練の魔法使いぐらいの差があります)<br>
		<br>
		<br>
		さて、今回は勉強を兼ねて、<b>比較的コードも単純</b>で、<b>安定ソートである挿入ソート</b>を自分で書いて、<b>ランキングにゲームのスコアを挿入する</b>練習をしてみましょう。<br>
		<br>
		<br>
	<code>PlayScene.hのシーンの終了時(GameOver時でもよいが..どこでやるかは迷いどころ)にスコアをランキングに順序をソートしながら登録する</code>修正をくわえましょう。</p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
    (中略).....................<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
    (中略).....................<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 終了処理(大抵Initializeと同じリセットだが終了時だけやりたいリセットの仕方もあるかも)<br>
      &nbsp;&nbsp;&nbsp; void Finalize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
    (中略).....................<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ゲーム終了時のスコアがMAXなら記録<u>して終了</u><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(score &gt; sm.scoreMax) sm.scoreMax = score;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ゲーム終了時のスコアをranking配列に挿入ソートして記録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int j, iSize = sizeof(sm.ranking) / sizeof(int);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (score &lt; sm.ranking[iSize - 1])<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.rank = -1; // ランキング外<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {   // ranking配列の一番後ろは一番小さいのでまずはそれと入れ替え<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.ranking[iSize - 1] = score;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 挿入ソートでランキングを降順に並べ替え<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // https://www.momoyama-usagi.com/entry/info-algo-sort-basic#i-3<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // https://ufcpp.net/study/algorithm/sort_insert.html<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 1; i &lt; iSize; ++i)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; j = i; // 交換要素のためのインデックス<br>
<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // while(j &gt; 0 &amp;&amp; sm.ranking[j-1] &gt; sm.ranking[j]) に変えると昇順ソートになる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while ((j &gt; 0) &amp;&amp; (sm.ranking[j - 1] &lt; sm.ranking[j]))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 整列されていない隣り合う要素を交換する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int tmp = sm.ranking[j - 1];<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.ranking[j - 1] = sm.ranking[j];<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.ranking[j] = tmp;<br>
<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; j--; // 1つ左のデータへ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 何位かを判定<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; iSize; ++i)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (sm.ranking[i] == score)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.rank = i; // ランキング順位 0位～4位<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; break; // スコアが=イコールになるものを見つけたらすぐbreakでfor文を抜ける<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
	    (中略).....................<br>
      };<br>
      <br>
      #endif<br></p>
	    <br>
	     <br>
	     <br>
		<p><code>TitleScene.hを修正してプレイしたスコアのランキングを</code>Fontで文字列を改行しながら表示してみましょう。<br></p>
		<p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
	#include &lt;string&gt;<br>
	<br>
      #include "DxLib.h"<br>
      (中略)...........<br>
#include "Font.h"<br>
      (中略)...........<br>		
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
(中略)...........<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>int lineSize = 40; // 1行の縦方向の改行サイズ</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SetFontLineSpaceToHandle(<em>lineSize</em>, font1); // 1行ごとのスペース<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawStringToHandle(0, 0, "TitleSceneです。\nボタン押下でPlaySceneへ。", GetColor(0, 255, 0), font1, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;</em>if (sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawStringToHandle(0, 200, (std::string("MAXスコア: ") + std::to_string(sm.scoreMax)).c_str(), GetColor(255, 255, 255), Font::fonts["設定1"].handle, GetColor(0, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 順位 0位～4位を1位から5位に直すため +1する→ sm.rank + 1<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string myRankText = (sm.rank &lt; 0) ? std::string("ランク イン シッパイ") : std::string("アナタ ハ イマ  No.") + std::to_string(sm.rank + 1) + std::string(" ") + std::to_string(sm.ranking[sm.rank]);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawStringToHandle(0, 200 + lineSize, myRankText.c_str(), GetColor(255, 255, 255), Font::fonts["設定1"].handle, GetColor(255, 0, 255));<br>
<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string rankText; // ランキングを改行しながら複数行のテキストに<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int i=0, iSize = sizeof(sm.ranking) / sizeof(int); i &lt; iSize; ++i)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(sm.ranking[i] &gt;= 0) // 配列の初期値は-1は表示せずとばす<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;rankText += std::string("No.") + std::to_string(i + 1) + std::string(" ") + std::to_string(sm.ranking[i]) + std::string("\n");<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawStringToHandle(0, 200 + lineSize*2, rankText.c_str(), GetColor(255, 255, 255), Font::fonts["設定1"].handle);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      
      (中略)...........<br>
	    <br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>	

		<br>
		<br>
		さて、うまくランキング表示ができたでしょうか？<b>何度か自滅して5回ぐらい自滅しないとランキングは表示されないのでバグだと勘違いしないでください</b>ね。<br>
		<br>
		<br>
		<br>
	<h2><a id="mozTocId50019" class="mozTocH1"></a>スコアのセーブ保存とCSVのセルを受けint,float,文字列に柔軟に化けるCsvValue型</h2>
		<br>
		<br>
		
		<p><code>DataCsv.hにCSVのセル(int,float,文字列の3種類)を読み取れるCsvValueクラスを追加して、さらにSave機能を追加</code>します。</p>
    <p class="source">#ifndef DATACSV_H_<br>
      #define DATACSV_H_<br>
      <br>
      #include &lt;assert.h&gt; // 読込み失敗表示用<br>
      #include &lt;vector&gt; // csvを2次元vector配列に格納<br>
      #include &lt;string&gt; // 文字列に必要<br>
      #include &lt;fstream&gt; // ファイル読み出しifstreamに必要<br>
      #include &lt;sstream&gt; // 文字列ストリームに必要<br>
      <br>
<em>//★CsvValue型をint型や文字列string型や小数float型として【カメレオン】のように使える。<br>
// 【エクセルはマス目がカメレオン】整数も小数も文字列もありうる。<br>
// それを解消して統一して扱える便利な★CsvValue型。<br>
class CsvValue<br>
{<br>
public:<br>
      &nbsp;&nbsp; &nbsp;enum class Type<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Int,<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Float,<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String,<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NUM<br>
      &nbsp;&nbsp; &nbsp;};<br>
      &nbsp;&nbsp; &nbsp;Type type = Type::String;<br>
      &nbsp;&nbsp; &nbsp;<br>
protected: // 内部データを書き換え禁止:書き換えられるとintと文字列とのずれが起きうる<br>
      &nbsp;&nbsp; &nbsp;// エクセルのCsvデータはマス目がint,float,stringの3種類ありうる<br>
      &nbsp;&nbsp; &nbsp;union {  // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int intData = 0; // 整数int型データを格納<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float floatData; // 小数float型データを格納<br>
      &nbsp;&nbsp; &nbsp;};<br>
      &nbsp;&nbsp; &nbsp;std::string stringData{""}; // 文字列string型データを格納<br>
      &nbsp;&nbsp; &nbsp;<br>
public:<br>
      &nbsp;&nbsp; &nbsp;CsvValue() = default;<br>
      &nbsp;&nbsp; &nbsp;// 3種類のCSVセル(int,float,文字列std::stringとconst char*:計4種)のコンストラクタ<br>
      &nbsp;&nbsp; &nbsp;CsvValue(int intData) : type{ Type::Int }<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this->intData = intData;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this->stringData = std::to_string(intData);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;CsvValue(float floatData) : type{ Type::Float }<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this->floatData = floatData;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this->stringData = std::to_string(floatData);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;CsvValue(std::string& stringData) : type{ Type::String }<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this->stringData = stringData;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;CsvValue(const char* stringData) : type{ Type::String }<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this->stringData = stringData;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;virtual ~CsvValue() {}; // 仮想デストラクタ<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 変換演算子によりCSVのセルをintとしてもstringとしても扱えるように<br>
      &nbsp;&nbsp; &nbsp;// https://programming-place.net/ppp/contents/cpp/language/019.html#conversion_op<br>
      &nbsp;&nbsp; &nbsp;// 3種類の読み取りオペレータ<br>
      &nbsp;&nbsp; &nbsp;inline operator int()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;if (type == Type::Int) return intData;<br>
      &nbsp;&nbsp; &nbsp;else if (type == Type::Float) return (int)floatData;<br>
      &nbsp;&nbsp; &nbsp;else if (type == Type::String && intData == 0)<br>
      &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;intData = intFromString(); // デフォルトで文字列として読込んだデータをintに変換<br>
      &nbsp;&nbsp; &nbsp;return intData;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;inline operator float()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;if (type == Type::Float) return floatData;<br>
      &nbsp;&nbsp; &nbsp;else if (type == Type::Int) return (float)intData;<br>
      &nbsp;&nbsp; &nbsp;else if (type == Type::String && intData == 0)<br>
      &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;floatData = floatFromString(); // デフォルトで文字列として読込んだデータをfloatに変換<br>
      &nbsp;&nbsp; &nbsp;return floatData;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;inline operator std::string()&amp;<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;return stringData;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;int intFromString() // 文字列データからint型への変換する関数<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;std::istringstream ss(stringData); //文字列ストリームの初期化<br>
      &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;ss >> num; // 文字列ストリームから数字への変換<br>
      &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;return num;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;float floatFromString() // 文字列データからfloat型への変換する関数<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;std::istringstream ss(stringData); //文字列ストリームの初期化<br>
      &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;float num; // 数字単体<br>
      &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;ss >> num; // 文字列ストリームから数字への変換<br>
      &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;return num;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
private:<br>
      &nbsp;&nbsp; &nbsp;void clearString() // 文字列をcapacityごとクリアしてメモリ節約<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// https://stackoverflow.com/questions/740030/how-to-release-the-unused-capacity-of-a-string<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string("").swap(stringData); // [capacityをリセットしてメモリ節約]<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
public:<br>
      &nbsp;&nbsp; &nbsp;CsvValue&amp; operator = (const int other) { // 代入=演算子<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;type = Type::Int; // タイプを更新<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (type == Type::Float) floatData = (float)other;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else intData = other;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (type == Type::String) std::to_string(other).swap(stringData); // [swapテクでcapacity節約]<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else clearString();<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this->stringData = std::to_string(intData);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return *this;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;CsvValue&amp; operator = (const float other) { // 代入=演算子<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;type = Type::Float; // タイプを更新<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (type == Type::Int) intData = (int)other;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else floatData = other;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (type == Type::String) std::to_string(other).swap(stringData); // [swapテクでcapacity節約]<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else clearString();<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this->stringData = std::to_string(floatData);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return *this;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;CsvValue&amp; operator = (const std::string&amp; other) { // 代入=演算子<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;type = Type::String; // タイプを更新<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;intData = 0; // 初期値 0 としてリセット<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;stringData = other;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return *this;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;CsvValue&amp; operator = (const char* other) { // 代入=演算子<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;type = Type::String; // タイプを更新<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;intData = 0; // 初期値 0 としてリセット<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;stringData = std::string(other);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return *this;<br>
      &nbsp;&nbsp; &nbsp;}<br>
};<br>
	<br>
namespace { // 無名名前空間で囲んで、.hヘッダにグローバル関数定義をする<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;// ファイル出力ストリーム演算子&lt;&lt;を定義する<br>
&nbsp;&nbsp; &nbsp;std::ostream&amp; operator &lt;&lt; (std::ostream&amp; stream, CsvValue&amp; csvValue)<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (csvValue.type == CsvValue::Type::Int) stream &lt;&lt; (int)csvValue;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (csvValue.type == CsvValue::Type::Float) stream &lt;&lt; (float)csvValue;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (csvValue.type == CsvValue::Type::String) stream &lt;&lt; (std::string)csvValue;<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return stream;<br>
&nbsp;&nbsp; &nbsp;}<br>
&nbsp;&nbsp; &nbsp;<br>
}<br>
</em><br>
	    <br>
      // CSVファイルを読込み幅や高さとデータ本体を保持するデータ型<br>
      struct DataCsv // ←structはC++ではほぼclassと同じ【違いはデフォルトがpublic】<br>
      {&nbsp;&nbsp; // 読込んだデータファイルの情報<br>
      <em>&nbsp;&nbsp; &nbsp;enum class CsvType<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;IntMap,<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;CsvValue<br>
      &nbsp;&nbsp; &nbsp;};</em><br>
      &nbsp;&nbsp; &nbsp;int Width = 0; // csvファイルの表の幅<br>
      &nbsp;&nbsp; &nbsp;int Height = 0;// csvファイルの表の高さ<br>
      &nbsp;&nbsp; &nbsp;bool isInitialized = false; //[2重ロード対策]1度ロードしたらtrueにしてclear()されるまでロード抑止<br>
      <em>&nbsp;&nbsp; &nbsp;bool isForceCreate = false; // ファイルが無い、もしくは空のときにアラートを出さず無理やり(force)新しく作るか(create)<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// isForceCreateをセット[*thisをreturnで関数連鎖テク] https://flat-leon.hatenablog.com/entry/cpp_named_parameter<br>
      &nbsp;&nbsp; &nbsp;DataCsv& IsForceCreate(bool b) { isForceCreate = b; return *this; }</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;std::string FilePath { "" };<br>
      &nbsp;&nbsp; &nbsp;std::vector&lt;std::vector&lt;<em>CsvValue</em>&gt;&gt; Data;// csvデータ<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 初期化コンストラクタでファイル名を指定して初期化と同時にファイル読込<br>
      &nbsp;&nbsp; &nbsp;DataCsv(std::string filePath = ""<em>, CsvType csvType = CsvType::CsvValue</em>) :FilePath{ filePath }<br>
      &nbsp;&nbsp; &nbsp;{// csvファイルの読込み★【初期化と同時なのでファイルとデータ型が一心同体で使いやすい】<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (FilePath != "") Load(FilePath<em>, csvType</em>); // ファイル読込み<br>
      &nbsp;&nbsp; &nbsp;};<br>
      &nbsp;&nbsp; &nbsp;virtual ~DataCsv()<br>
      &nbsp;&nbsp; &nbsp;{// 仮想デストラクタ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Data.clear();// 2次元配列データのお掃除<br>
      &nbsp;&nbsp; &nbsp;};<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// ★スムーズに[][]でアクセスできるように[]演算子を独自定義する<br>
        &nbsp;&nbsp; &nbsp;std::vector&lt;<em>CsvValue</em>&gt;&amp; operator[](std::size_t index) { // ★ &amp;参照にしないといちいちデータのコピーを返すので遅くなるよ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return Data[index]; // 書き込み<br>
        &nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;std::vector&lt;<em>CsvValue</em>&gt; operator[](std::size_t index) const { // ★constは添え字[]読み取りの処理を定義<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return Data[index]; // 読み取り<br>
        &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;std::size_t size()<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; // size()関数の名前をvectorと被らせることで使う側はvectorインvectorのままのコードで使える<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return Data.size();<br>
        &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// データをクリアしてメモリを解放する<br>
        &nbsp;&nbsp; &nbsp;virtual void clear()<br>
        &nbsp;&nbsp; &nbsp;{<em>&nbsp;&nbsp; // [確実にメモリを空にするには] http://vivi.dyndns.org/tech/cpp/vector.html#shrink_to_fit<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::vector&lt;std::vector&lt;CsvValue&gt;&gt;().swap(Data); // 空のテンポラリオブジェクトでリセット</em><br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isInitialized = false; //ロード済みフラグをOFF<br>
        &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// csvファイルの読み込み<br>
      &nbsp;&nbsp; &nbsp;virtual void Load(std::string filePath<em>, CsvType csvType = CsvType::CsvValue</em>)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (filePath == "" || isInitialized) return; //ファイル名がないもしくはロード済<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;FilePath = filePath; // ファイル名を保管<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Data.clear(); //データを一旦クリア<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::ifstream ifs_csv_file(filePath);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// [.good()でファイル存在確認]https://stackoverflow.com/questions/12774207/fastest-way-to-check-if-a-file-exists-using-standard-c-c11-14-17-c<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (isForceCreate &amp;&amp; !ifs_csv_file.good())<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::ofstream ofs_csv_file(filePath);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ofs_csv_file &lt;&lt; ""; // 空文字のファイルを生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string line; //1行単位でcsvファイルから文字列を読み込む<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int readWidth = 0; //読込みデータの幅<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int maxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int readHeight = 0; //初期化<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//↓2重while文でCSVファイルを読み取る<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::vector&lt;<em>CsvValue</em>&gt; valuelist; // 1行の数字リスト<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::istringstream linestream(line); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string splitted; // カンマで分割された文字列<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int widthCount = 0; //この行の幅をカウント<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>if (csvType == CsvType::IntMap)</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>{</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>while (std::getline(linestream, splitted, { ',' }))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>&nbsp;&nbsp; &nbsp;std::istringstream ss; //文字列ストリームの初期化<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>&nbsp;&nbsp; &nbsp;ss = std::istringstream(splitted); //文字列ストリーム<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>&nbsp;&nbsp; &nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>&nbsp;&nbsp; &nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>&nbsp;&nbsp; &nbsp;valuelist.emplace_back(num); // 数字を数字のリスト(valuelist)に追加<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>&nbsp;&nbsp; &nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>}</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>else if (csvType == CsvType::CsvValue)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (std::getline(linestream, splitted, { ',' }))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;valuelist.emplace_back(splitted); // 文字列としてリスト(valuelist)に追加<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;++widthCount; //この行のカンマで区切られた数をカウントアップ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 1行の幅の数が記録を更新してMAXになるかチェック<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (widthCount &gt; maxWidth) maxWidth = widthCount; //暫定Max幅を更新<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 1行分をvectorに追加<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (valuelist.size() != 0) Data.emplace_back(valuelist);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;++readHeight; //読み込んだ行(縦)をカウントアップ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;readWidth = maxWidth; //読み込んだ列(横)の数は一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;if (!isForceCreate) // ファイルがないとき強制的に空ファイルを生成した場合は幅と高さのチェックをスキップする</em><br>
      &nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;{</em><br>
      &nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>&nbsp;&nbsp; &nbsp;//↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>&nbsp;&nbsp; &nbsp;assert(readWidth &gt; 0 &amp;&amp; "CSV読込み失敗ファイル名間違いでは?" != "");<br>
      &nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;</em>&nbsp;&nbsp; &nbsp;assert(readHeight &gt; 0 &amp;&amp; "CSV読込み失敗ファイル名間違いでは?" != "");<br>
      &nbsp;&nbsp; &nbsp;<em>&nbsp;&nbsp; &nbsp;}</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;Width = readWidth; // 読込み成功したデータの幅を記録<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;Height = readHeight; // 読込み成功したデータの高さを記録<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// コンストラクタで初期化でロードの場合とLoad関数経由で読む経路があるから2重ロード対策<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isInitialized = true; // 読込み初期化済みフラグをON<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      &nbsp;&nbsp; &nbsp;}<br>
<br>
      &nbsp;&nbsp; &nbsp;<em>// csvファイルの保存<br>
      &nbsp;&nbsp; &nbsp;void Save(std::string filePath = "")<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string outputPath = filePath;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (filePath == "") // ファイル名がないときは読込時のパス<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;outputPath = FilePath;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (outputPath == "") return; // ファイル名がないとき<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;FilePath = filePath; // ファイル名を保管<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 読み込むcsvファイルを開く(std::ofstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::ofstream ofs_csv_file(filePath);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string line; //1行単位でcsvファイルから文字列を読み込む<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//↓2重for文でCSVファイルを列i,行jごとに書き出していく<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (auto j = 0; j &lt; Data.size(); ++j)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (auto i = 0; i &lt; Data[j].size(); ++i)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (i &gt; 0) ofs_csv_file &lt;&lt; ","; // 区切りのカンマを書き出す<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ofs_csv_file &lt;&lt; Data[j][i]; // Data配列を出力<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ofs_csv_file &lt;&lt; std::endl; // 1行の終わりに改行を出力<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      &nbsp;&nbsp; &nbsp}</em><br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
		上記コードで <b><a href="https://flat-leon.hatenablog.com/entry/cpp_named_parameter">メソッドチェイン</a>(関数連鎖)のテクニック</b>を使いました。<br>
		基本構造は 〇〇型の自分のクラスを定義した際に<br>
		<p class="source">〇〇 & 関数名()<br>
		{<br>
		&nbsp;&nbsp; &nbsp;........<br>   
		&nbsp;&nbsp; &nbsp;return *this; // 最終的に*thisで自分のクラス自身の参照を返す<br>
		}</p><br>
		とやるだけです。<br>
	<p class="source">&nbsp;&nbsp; &nbsp;bool isForceCreate = false; // ファイルが無い、もしくは空のときにアラートを出さず無理やり(force)新しく作るか(create)<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// isForceCreateをセット[*thisをreturnで関数連鎖テク] https://flat-leon.hatenablog.com/entry/cpp_named_parameter<br>
      &nbsp;&nbsp; &nbsp;DataCsv& IsForceCreate(bool b) { isForceCreate = b; return *this; }<br>
      <br></p><br>

		メソッド連鎖を使うと通常2行で書くような次のような処理をすっきりと表現できるようになります。<br>
		<p class="source">DataCsv data;<br>
			data.isForceCreate = true;<br>
			data.Load(filePath, DataCsv::CsvType::CsvValue);<br>
		</p>
		↑これを、下記↓のように書けます。<br>
	      <p class="source">DataCsv data;<br>
	      data<em>.IsForceCreate(true)</em>.Load(filePath, DataCsv::CsvType::CsvValue);<br></p><br>
		<br>
		Setする変数項目が多かったりするときに効果を発揮します。<br>
		<p class="source">DataCsv data;<br>
	      data<em>.SetA(true).SetB(-1).SetC("テスト").SetD(3.145f)</em>.Load(filePath, DataCsv::CsvType::CsvValue);<br></p><br>
		
		<br>Load関数のデフォルト引数でisForceCreateをデフォルト引数として渡すか迷いました。<br>
		<p class="source">void Load(std::string filePath, CsvType csvType = CsvType::CsvValue, bool isForceCreate=false);<br>
		<br>
			........<br>
			data.Load(filePath, DataCsv::CsvType::CsvValue<em>, true</em>); // うーん、<em>あいだに挟まったDataCsv::CsvType::CsvValueをいちいち書かないとtrue渡せない</em>な..省略しにくい<br>
		<br>
		<br></p>
		<br>
		<br>関数連鎖で渡せば、<b>DataCsv::CsvType::CsvValueを省略しやすく</b>なる。<br>
		<p class="source">void Load(std::string filePath, CsvType csvType = CsvType::CsvValue);<br>
		<br>
			........<br>
			data<em>.IsForceCreate(true)</em>.Load(filePath<u>, DataCsv::CsvType::CsvValue, true</u>); // 省略!!<br>
			↓<br>
			data.IsForceCreate(true).Load(filePath); // 省略しても、csvTypeはデフォルトのDataCsv::CsvType::CsvValueになる<br>
		<br>
		<br></p><br>
<br>
	<br>
		つぎにSaveデータを扱うベースとなる基底クラスSaveDataを定義しましょう(これを : 継承してRankingDataクラスをつくります)<br>
		<br>
		<p><code>SaveData.hを新規作成</code>します。</p>
		<p class="source">#ifndef SAVEDATA_H_<br>
#define SAVEDATA_H_<br>
<br>

#include &lt;vector&gt; // セーブデータのファイルパスを複数vector配列で関数に渡すために使用<br>
#include &lt;string&gt; // 文字列に必要<br>
<br>			
struct SaveData // データをSaveするタイプ あいまいなabstract型<br>
{<br>
&nbsp;&nbsp; &nbsp;std::vector&lt;std::string&gt; filePaths{ {""} }; // 複数のファイルを同時に呼び出したい場合のため配列に<br>
&nbsp;&nbsp; &nbsp;SaveData(std::vector&lt;std::string&gt; filePaths = { "" } ) : filePaths { filePaths }<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;}<br>
&nbsp;&nbsp; &nbsp;virtual ~SaveData() {}; // 破棄する処理デストラクタ<br>
<br>
// セーブデータのファイルパスを複数vector配列で関数に渡す<br>
&nbsp;&nbsp; &nbsp;virtual void Load(std::vector&lt;std::string&gt; filePaths = { "" }) {};<br>
&nbsp;&nbsp; &nbsp;virtual void Save(std::vector&lt;std::string&gt; filePaths = { "" }) {};<br>
private:<br>
<br>
};<br>
#endif</p><br>
		<br>
		<p><code>RankingData.hを新規作成してSaveDataを継承してCSVのロードとセーブ機能を実装</code>します。</p>
		<p class="source">#ifndef RANKING_H_<br>
#define RANKING_H_<br>
<br>
#include "SaveData.h"<br>
#include "DataCsv.h"<br>
<br>
struct RankingData : public SaveData<br>
{<br>
public:<br>
&nbsp;&nbsp; &nbsp;const size_t listMAX = 100; // 過去のランキングリストを100位までcsvに保管<br>
&nbsp;&nbsp; &nbsp;DataCsv list;<br>
<br>
&nbsp;&nbsp; &nbsp;std::vector&lt;CsvValue&gt;&amp; operator[](std::size_t index) {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return list[index]; // 読み書き<br>
&nbsp;&nbsp; &nbsp;}<br>
<br>
&nbsp;&nbsp; &nbsp;// コンストラクタ<br>
&nbsp;&nbsp; &nbsp;RankingData(std::vector&lt;std::string&gt; filePaths = { "" }) : SaveData(filePaths)<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; Load(filePaths);<br>
&nbsp;&nbsp; &nbsp;}<br>
<br>
&nbsp;&nbsp; &nbsp;virtual void Load(std::vector&lt;std::string&gt; filepaths = { "" }) override<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (filepaths.size() &gt; 0 &amp;&amp; filepaths[0] != "")<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;filePaths = filepaths;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (std::size_t i = 0, iSize = filePaths.size(); i &lt; iSize; ++i)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (i == 0)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// csvファイルの読み込み<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<b>list.IsForceCreate(true).Load(filePaths[0]);</b><br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (list.size() == 0)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{   // 何もデータがないときは初期生成<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::vector&lt;CsvValue&gt; firstScore = { -1 }; // 0行目: スコア(最後にプレイしたとき)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;list.Data.emplace_back(firstScore);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::vector&lt;CsvValue&gt; firstRank = { 0 }; // 1行目: ランク順位(最後にプレイしたとき)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;list.Data.emplace_back(firstRank);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::vector&lt;CsvValue&gt; firstList = { -1 }; // 2行目: 過去スコアのリスト<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;list.Data.emplace_back(firstList);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//else if (i == 1)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//  // 複数まとめて同時にファイルを読み込みたければi=1,2..も定義<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//}<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
&nbsp;&nbsp; &nbsp;}<br>
<br>
&nbsp;&nbsp; &nbsp;virtual void Save(std::vector&lt;std::string&gt; filepaths = { "" }) override<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (filepaths.size() &gt; 0 && filepaths[0] != "")<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;filePaths = filepaths;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (std::size_t i = 0, iSize = filePaths.size(); i &lt; iSize; ++i)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (i == 0)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// csvファイルの保存<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;list.Save(filePaths[0]);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//else if (i == 1)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//  // 複数まとめて同時にファイルを保存したければi=1,2..も定義<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//}<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
&nbsp;&nbsp; &nbsp;}<br>
};<br>
<br>
#endif</p><br>
		<br>
		つぎにSceneManager.hをSaveDataをRankingDataクラスを使ってLoadする形に変更しますが、<br>
		必ず、Imageフォルダと同じ階層に<code>SaveDataという名前でフォルダを新規作成</code>しておかないと保存もロードも失敗しますので注意してください。<br>
		<br>
		<p><code>SceneManager.hのスコアのランクとランキング配列をRankingDataクラスからロードする形に変えて</code>してランキングを管理できるようにしましょう。</p>
    <p class="source">#ifndef SCNENEMANAGER_H_<br>
      #define SCNENEMANAGER_H_<br>
      <br>
(中略)..........<br>
<em>#include "DataCsv.h"</em><br>
<em>#include "RankingData.h"</em><br>
      <br>
      #include "Singleton.h"<br>
      <br>
      class Scene; //クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      <br>
      class SceneManager : public Singleton&lt;SceneManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;friend class Singleton&lt;SceneManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;<b>// マネージャを【どこからでもアクセスしやすい「変数の掲示板」として使えばシーンをまたぐ変数も定義できる】</b><br>
      &nbsp;&nbsp; &nbsp;std::string selectStage = "stage1"; // 選択中のステージ名など<br>
      &nbsp;&nbsp; &nbsp;<em>RankingData ranking{ {"SaveData/ranking.csv"} }; // スコアのランキング記録するCSV</em><br>
      &nbsp;&nbsp; &nbsp;<em>CsvValue&amp;</em> scoreMax = <em>ranking[0][0]</em>; // <em>今までのMAXスコア &amp;参照でセーブするデータの住所を参照して直接書き換えられるように</em><br>
      &nbsp;&nbsp; &nbsp;<u>// int ranking[5] = {-1,-1,-1,-1,-1}; // スコアトップ5を記録しておく配列</u><br>
      &nbsp;&nbsp; &nbsp;<em>CsvValue&amp;</em> rank = <em>ranking[1][0]</em>; // <em>最後にプレイしたセーブデータのランク</em>順位<em>への&amp;参照</em><br>
      &nbsp;&nbsp;&nbsp; <br>
(中略)..........<br>
	    <br>
      };<br>
      <br>
      #endif</p>
		<br>
		さて、CSVのエクセルのセルが以下のようになっていたとしましょう<br>
		<em>0</em>行目:[ <em>5</em> ][&nbsp;&nbsp;&nbsp;][&nbsp;&nbsp;&nbsp;][&nbsp;&nbsp;&nbsp;]<br>
		<em>1</em>行目:[ <em>2</em> ][&nbsp;&nbsp;&nbsp;][&nbsp;&nbsp;&nbsp;][&nbsp;&nbsp;&nbsp;]<br>
		2行目:[ 5 ][ 3 ][ 1 ][ 1 ].......<br>
		<br>
		<em>0</em>行目<em>0</em>列 : scoreMax 今までのMAXスコアを保存 ( 上図では<em>5</em> )<br>
		<em>1</em>行目<em>0</em>列 : rank 最後にプレイしたセーブデータのランク順位を保存 ( 上図では<em>2</em> 2位)<br>
		2行目以降.. 過去のデータ 5,3,1,1.....
		<br>
		上記を読みだしているコードの対応関係を下記で今後使いこなせるように確認しておきましょう。<br>
		<p class="source">
      &nbsp;&nbsp; &nbsp;CsvValue&amp; scoreMax = ranking[<em>0</em>][<em>0</em>]; // 今までのMAXスコア &amp;参照でセーブするデータの住所を参照して直接書き換えられるように<br>
      &nbsp;&nbsp; &nbsp;CsvValue&amp; rank = ranking[<em>1</em>][<em>0</em>]; // 最後にプレイしたセーブデータのランク順位への&amp;参照</p><br>
		実際にデータを読み出してゆく際には[2]行目にアクセスしてやっていきます。<br>
		TitleSceneやPlaySceneのコードでは[2]に着目しておきましょう。<br>
		<br>
		<code>TitleScene.hのスコアへアクセスする際に、何型かあいまいなCsvValue型を(int)でキャストして型を確定する変更と、CSVのセーブデータ配列の[2]行目形にアクセスする形に修正</code>をくわえましょう。</p>
		<p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
	#include &lt;string&gt;<br>
	<br>
      #include "DxLib.h"<br>
      (中略)...........<br>		
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
(中略)...........<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;(中略)...........<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (<em>(int)</em>sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawStringToHandle(0, 200, (std::string("MAXスコア: ") + std::to_string(<em>(int)</em>sm.scoreMax)).c_str(), GetColor(255, 255, 255), Font::fonts["設定1"].handle, GetColor(0, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 順位 0位～4位を1位から5位に直すため +1する→ sm.rank + 1<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string myRankText = (<em>(int)</em>sm.rank &lt; 0) ? std::string("ランク イン シッパイ") : std::string("アナタ ハ イマ  No.") + std::to_string(<em>(int)</em>sm.rank + 1) + std::string(" ") + <em>(std::string)</em>(sm.ranking<em>[2]</em>[<em>(int)</em>sm.rank]);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawStringToHandle(0, 200 + lineSize, myRankText.c_str(), GetColor(255, 255, 255), Font::fonts["設定1"].handle, GetColor(255, 0, 255));<br>
<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string rankText; // ランキングを改行しながら複数行のテキストに<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int i=0, iSize = <em>sm.ranking[2].size()</em>; i &lt; iSize; ++i)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(<em>(int)</em>sm.ranking<em>[2]</em>[i] &gt;= 0) // 配列の初期値は-1は表示せずとばす<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;rankText += std::string("No.") + std::to_string(i + 1) + std::string(" ") + std::to_string(<em>(int)</em>sm.ranking<em>[2]</em>[i]) + std::string("\n");<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawStringToHandle(0, 200 + lineSize*2, rankText.c_str(), GetColor(255, 255, 255), Font::fonts["設定1"].handle);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      (中略)...........<br>
	    <br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
		<code>PlayScene.hのスコアへアクセスする部分をあいまいなCsvValue型にアクセスする部分は(int)に変換し、CSVのセーブデータ配列の[2]行目形にアクセスする形に修正</code>をくわえましょう。</p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
    (中略).....................<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
    (中略).....................<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 終了処理(大抵Initializeと同じリセットだが終了時だけやりたいリセットの仕方もあるかも)<br>
      &nbsp;&nbsp;&nbsp; void Finalize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
    (中略).....................<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ゲーム終了時のスコアがMAXなら記録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(score &gt; <em>(int)</em>sm.scoreMax) sm.scoreMax = score;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>if (sm.ranking[2].size() &lt; sm.ranking.listMAX)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.ranking[2].emplace_back( -1 ); // sizeがlistMAX以下のときは後ろに-1を追加</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ゲーム終了時のスコアをranking配列に挿入ソートして記録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int j, iSize = <em>sm.ranking[2].size()</em>;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (score &lt; <em>(int)</em>sm.ranking<em>[2]</em>[iSize - 1])<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.rank = -1; // ランキング外<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {   // ranking配列の一番後ろは一番小さいのでまずはそれと入れ替え<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.ranking<em>[2]</em>[iSize - 1] = score;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 挿入ソートでランキングを降順に並べ替え<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // https://www.momoyama-usagi.com/entry/info-algo-sort-basic#i-3<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // https://ufcpp.net/study/algorithm/sort_insert.html<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 1; i &lt; iSize; ++i)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; j = i; // 交換要素のためのインデックス<br>
<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // while(j &gt; 0 &amp;&amp; <em>(int)</em>sm.ranking<em>[2]</em>[j-1] &gt; <em>(int)</em>sm.ranking<em>[2]</em>[j]) に変えると昇順ソートになる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while ((j &gt; 0) &amp;&amp; (<em>(int)</em>sm.ranking<em>[2]</em>[j - 1] &lt; <em>(int)</em>sm.ranking<em>[2]</em>[j]))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 整列されていない隣り合う要素を交換する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int tmp = sm.ranking<em>[2]</em>[j - 1];<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.ranking<em>[2]</em>[j - 1] = sm.ranking<em>[2]</em>[j];<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.ranking<em>[2]</em>[j] = tmp;<br>
<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; j--; // 1つ左のデータへ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 何位かを判定<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; iSize; ++i)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (<em>(int)</em>sm.ranking<em>[2]</em>[i] == score)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.rank = i; // ランキング順位 0位～4位<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; break; // スコアが=イコールになるものを見つけたらすぐbreakでfor文を抜ける<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>sm.ranking.Save(); // 並べ替えたあとにランキングをCSVファイルにセーブする</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
	    (中略).....................<br>
      };<br>
      <br>
      #endif</p>
    <br>
		さて、実行すると<br>
		・<b>SaveDataフォルダにranking.csvファイルが自動生成</b>されていますか？<br>
		・<b>一回ゲームオーバーになったあとranking.csvを右クリックでメモ帳で開く</b>と中にMAXスコアやランクやランキングデータが保存されていましたか？<br>
		<br>
		<br>
		<br>
		これがうまくいけば、あとは自分でいろいろなセーブの仕方を工夫できるようになりますね。<br>
		90's年代ファミコンやゲームボーイが出た<b>当時は、セーブ機能自体がないゲームが普通</b>でした。<br>
		プレイするごとにスコアは0に戻り、ドラゴンクエストでは「ふっかつのじゅもん」を紙やノートに書き写して、毎回それを打ち込んでゲームの状態を再現してプレイを再開していました。<br>
		<br>
		その後、徐々にセーブ機能がでてきました。<br>
		すると、時代はロールプレイングゲームが全盛となっていきました。<br>
		つまり、<b>ユーザーの【プレイ状態を保存できること自体がイノベーションの発火】となり【新たなゲームの形態が流行していった】とも考えられませんか？</b><br>
		<br>
		<b>【今日プレイした状態】を【明日に持ち越せる】こと</b>で、1ヵ月や2ヵ月、はてはポケモンに至っては3,4年の<b>長期間、ユーザーを引き付ける形態のゲームアイデア</b>が実現されていったのです。<br>
		<br>
		&nbsp;&nbsp;&nbsp; <b>◆ 逆に発想するならばセーブできることによって、どんな状態を明日や1ヵ月、1年持ち越せると楽しいか？</b><br>
		<br>
		という視点でゲームを考察したり、アイデアだしをするならば、<br>
		<br>
		ポケモンやソシャゲの本質は<b>【セーブデータの一部の交換や共有や見せあい】</b>であり、今回作ったランキング機能とはその最も簡易な表現形式である、と考えられないでしょうか？<br>
		<br>
		&nbsp;&nbsp;&nbsp; <b>◆ 【セーブできること】自体をあたりまえと思わず、そのありがたさ自体から「再発想」してみるのも哲学的ではないですか？</b><br>
		<br>
		&nbsp;&nbsp;&nbsp; <b>◆ さて、あなたのゲームではなにを未来にセーブして持ち越したら面白いと発想しますか？</b><br>
		<br>
		<br>
		こののプログラムは<b>【そのインフラを提示したにすぎません】。あとは作り手の発想しだい。どんな形態でどのCSVのセルにセーブしてどう使うか。</b><br>
		とんびが鷹(タカ)を生めることを願って、<b>少々難しい「シーン分け、全方位読出、複数プレイヤ、フォント、セーブ」など</b>の<b>基本インフラをゲーム内容より先に準備してきたわけ</b>です。<br>
		<br>
		&nbsp;&nbsp;&nbsp; <b>基本インフラがあれば【作り手によるバリエーション】が生まれる余地</b>がでます。<br>
		&nbsp;&nbsp;&nbsp; プログラミングは<b>無名のプログラマたちの<a href="https://hisui-blog1227.com/hiroaka-oneforall/">歴代インフラのワンフォーオール精神</a>のかたまりだと思ってください。</b><br>
		&nbsp;&nbsp;&nbsp; ある程度経験のあるプログラマはまず<a href="https://www.4gamer.net/games/999/G999905/20151225009/">「ゲームを作るインフラ」のほうに注心しなければゲーム制作がはかどらない</a>ことを知っています。<br>
		&nbsp;&nbsp;&nbsp; ゲームよりゲームを作るインフラのほうがゲームのプログラミング現場で重宝される作業だったりします。
		&nbsp;&nbsp;&nbsp; インフラが整ってくるとアイデアや作業の選択に幅が生まれます。<br>
		&nbsp;&nbsp;&nbsp; ゲーム内容の制作側はオールフォーワンのように、がめつく、計画的に、憎らしいほど、取り込んだ機能(個性)を使いこなせるといいですね。<br>
		<br>
		<br>
		
	<h2><a id="mozTocId50020" class="mozTocH1"></a>キーボードとマウスの入力</h2>
		<br>
		重要なインフラとしてキーボード入力の検知とマウスの入力の検知があります。<br>
		<br>
		DXが用意してくれているキーボードの関数は<br>
		<b>GetHitKeyStateAll()</b>になります。<br>
		<a href="https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28">https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28</a><br>
		この関数をGetButton、GetButtonDown、GetButtonUpに対応させて3種類の入力状態を得られるように対応します。<br>
		<br>
		DXが用意してくれているマウスの関数は下記3つを使います。<br>
		<b>GetMousePoint(&amp;MouseX, &amp;MouseY)</b><br>
		<a href="https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28">https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28</a><br>
		<b>GetMouseInput()</b><br>
		<a href="https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N8">https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N8</a><br>
		<b>GetMouseInputLog2(&amp;MButton, &amp;ClickX, &amp;ClickY, &amp;LogType, TRUE)</b><br>
		<a href="https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N40">https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N40</a><br>
		はい、<b>DXの元の関数だけでは単純にダブルクリックやドラッグを得られるわけではありません</b>。<br>
		プログラマが頑張ってこれら<b>3つの関数を駆使して、独自にダブルクリックやドラッグを得られるよう頑張ってくれ</b>ということですね。<br>
		<br>
		がんばって、それらを得られるようにしましょう。<br>
		<br>
		<p><code>Input.hにキーボードとマウス入力を検知できる機能</code>を追加しましょう。</p>
    <p class="source">#ifndef INPUT_H_<br>
      #define INPUT_H_<br>
      <br>
	
      #include &lt;climits&gt; //int型の最大値2147483647につかう<br>
      #include &lt;unordered_map&gt; // 辞書配列【map高速版】https://qiita.com/sileader/items/a40f9acf90fbda16af51<br>
      <em>#include &lt;string&gt; // キーボード押下の文字列出力につかう</em><br>
      <br>
      #include "DxLib.h"<br>
      <br>
      // コントローラのパッド番号定義<br>
      enum class Pad<br>
      {<br>
      <em>&nbsp;&nbsp;&nbsp; Keyboard = -3, // キーボード入力を得る</em><br>
      &nbsp;&nbsp;&nbsp; All = -2, // すべてのうちどれか1つでも押されたとき<br>
      &nbsp;&nbsp;&nbsp; None = -1, // パッド割当て無(やられたり待機中のプレイヤに)<br>
      &nbsp;&nbsp;&nbsp; Key=0, // キーボード<br>
      &nbsp;&nbsp;&nbsp; One, // コントローラ1<br>
      &nbsp;&nbsp;&nbsp; Two, // コントローラ2<br>
      &nbsp;&nbsp;&nbsp; Three, // コントローラ3<br>
      &nbsp;&nbsp;&nbsp; Four, // コントローラ4<br>
      <em>&nbsp;&nbsp;&nbsp; Mouse, // マウスのボタン判定に</em><br>
      &nbsp;&nbsp;&nbsp; NUM, // コントローラの数=<em>6(マウス込み)</em><br>
      };<br>
<em><br>
enum class Mouse<br>
{<br>
&nbsp;&nbsp;&nbsp; All = -2, // すべてのうちどれか1つでも押されたとき<br>
&nbsp;&nbsp;&nbsp; None = -1,<br>
&nbsp;&nbsp;&nbsp; DownL, //[左クリック押した瞬間=1]<br>
&nbsp;&nbsp;&nbsp; DragL, //[左ドラッグ中=1]<br>
&nbsp;&nbsp;&nbsp; UpL, //[左クリック離した瞬間=1]<br>
&nbsp;&nbsp;&nbsp; DownR, //[右クリック押した瞬間=1]<br>
&nbsp;&nbsp;&nbsp; DragR, //[右ドラッグ中=1]<br>
&nbsp;&nbsp;&nbsp; UpR, //[右クリック離した瞬間=1]<br>
&nbsp;&nbsp;&nbsp; X, // 現在のマウス位置<br>
&nbsp;&nbsp;&nbsp; ReleaseX, // 離した状態のマウス位置(ドラッグ中は開始前位置)<br>
&nbsp;&nbsp;&nbsp; DownLX, //[左] 押した位置<br>
&nbsp;&nbsp;&nbsp; DragLX, //[左] ドラッグ中の位置<br>
&nbsp;&nbsp;&nbsp; UpLX, //[左] 離した位置<br>
&nbsp;&nbsp;&nbsp; DownRX,//[右] 押した位置<br>
&nbsp;&nbsp;&nbsp; DragRX, //[右] ドラッグ中の位置<br>
&nbsp;&nbsp;&nbsp; UpRX, //[右] 離した位置<br>
&nbsp;&nbsp;&nbsp; Y, // 現在のマウス位置<br>
&nbsp;&nbsp;&nbsp; ReleaseY, // 離した状態のマウス位置(ドラッグ中は開始前位置)<br>
&nbsp;&nbsp;&nbsp; DownLY, //[左] 押した位置<br>
&nbsp;&nbsp;&nbsp; DragLY, //[左] ドラッグ中の位置<br>
&nbsp;&nbsp;&nbsp; UpLY, //[左] 離した位置<br>
&nbsp;&nbsp;&nbsp; DownRY,//[右] 押した位置<br>
&nbsp;&nbsp;&nbsp; DragRY, //[右] ドラッグ中の位置<br>
&nbsp;&nbsp;&nbsp; UpRY, //[右] 離した位置<br>
&nbsp;&nbsp;&nbsp; NUM<br>
};</em><br>
      <br>
      // 入力クラス<br>
      class Input<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; const int MaxPadNum = (int)Pad::Four + 1; // 最大パッド数(Keyぶん+1)<br>
	    <br>
      &nbsp;&nbsp;&nbsp; static int prevStates[(int)Pad::NUM]; // 1フレーム前の状態<br>
      &nbsp;&nbsp;&nbsp; static int currentStates[(int)Pad::NUM]; // 現在の状態<br>
      <br>
      &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;Pad, bool&gt; isJoin; // 参加中のパッド番号辞書<br>
      &nbsp;&nbsp;&nbsp; // 参加中のパッドかどうか?<br>
      &nbsp;&nbsp;&nbsp; static bool IsJoin(Pad pad) { return isJoin.count(pad) == 1 &amp;&amp; Input::isJoin[pad]; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;int, int&gt; padDic; // パッド番号からDXの定義への辞書<br>
	    <em><br>
      &nbsp;&nbsp;&nbsp; static int prevMouse; // 1フレーム前のマウス状態<br>
      &nbsp;&nbsp;&nbsp; static int currentMouse; // 現在のマウス状態<br>
      &nbsp;&nbsp;&nbsp; static int MouseX, MouseY; // 現在のマウス位置<br>
      &nbsp;&nbsp;&nbsp; static int ClickX, ClickY, MButton, LogType;<br>
      &nbsp;&nbsp;&nbsp; static float MouseWheel; // マウスのホイールの回転<br>
      &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;Mouse, int&gt; Click;//&lt;Mouse⇒int&gt; マウスのクリックXY位置辞書<br>
<br>
      &nbsp;&nbsp;&nbsp; //[キーボード入力]https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
      &nbsp;&nbsp;&nbsp; static char prevKey[256]; // 1フレーム前のキーボード状態<br>
      &nbsp;&nbsp;&nbsp; static char currentKey[256]; // 現在のキーボード状態<br>
      &nbsp;&nbsp;&nbsp; static std::string KeyString[256];//&lt;キーコード⇒キー文字列&gt;の辞書<br>
      &nbsp;&nbsp;&nbsp; static std::string CapsString[256];//&lt;Caps状態キーコード⇒キー文字列&gt;の辞書<br>
      &nbsp;&nbsp;&nbsp; static bool isCapsLocked;// CapsLock状態か?<br>
      &nbsp;&nbsp;&nbsp; static bool isShifted;// Shiftが押された状態か?<br>
      </em><br>
      &nbsp;&nbsp;&nbsp; //★【DXコントローラバグ検知】初回プッシュが被ればDXバグで同一コントローラ<br>
      &nbsp;&nbsp;&nbsp; static int firstPushTiming[(int)Pad::Four]; // Pad::Fourが最後だから8とかに増やすなら要書き換え<br>
      &nbsp;&nbsp;&nbsp; static int timing;// = 0;<br>
      &nbsp;&nbsp;&nbsp; static bool isBugCheckMode;// = false; //バグチェックを開始するか<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 辞書配列の初期化<br>
      &nbsp;&nbsp;&nbsp; static void InitPadDictionary()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 辞書配列で対応関係を結び付けておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Key] = DX_INPUT_KEY;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::One] = DX_INPUT_PAD1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Two] = DX_INPUT_PAD2;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Three] = DX_INPUT_PAD3;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Four] = DX_INPUT_PAD4;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <em><br>
      &nbsp;&nbsp;&nbsp; // マウスの状態初期化<br>
      &nbsp;&nbsp;&nbsp; static void InitMouse()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MouseX = -1, MouseY = -1; // 現在のマウス位置を-1で初期状態では画面外として初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ClickX = -1, ClickY = -1, MButton = 0, LogType = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::ReleaseX] = -1; Click[Mouse::ReleaseY] = -1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::UpLX] = -1;     Click[Mouse::UpLY] = -1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::UpRX] = -1;     Click[Mouse::UpRY] = -1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::DownLX] = -1;   Click[Mouse::DownLY] = -1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::DownRX] = -1;   Click[Mouse::DownRY] = -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
<br>
      &nbsp;&nbsp;&nbsp; // キーボードの状態初期化<br>
      &nbsp;&nbsp;&nbsp; static void InitKeyboard()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // キー状態をゼロリセット<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i < 256; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevKey[i] = currentKey[i] = 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      </em><br>
      &nbsp;&nbsp;&nbsp; // 初期化。タイトルなどキー入力状態リセット時に<br>
      &nbsp;&nbsp;&nbsp; static void Init()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; InitPadDictionary(); // パッドの辞書配列の初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>InitKeyString(); // キーボード辞書配列の初期化</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // キー状態をゼロリセット<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i] = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>InitMouse(); // マウスの状態初期化</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>InitKeyboard(); // キーボードの状態初期化</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; timing = 0, isBugCheckMode = false; //バグチェック<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの参加処理(参加辞書登録して参加中の数も返す)<br>
        &nbsp;&nbsp;&nbsp; static int JoinCheck()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int joinCount = 0;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_1))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isJoin.count((Pad)i) == 1 &amp;&amp; isJoin[(Pad)i] == true)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; joinCount++; // 参加中の人数をカウント<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return joinCount; // 参加中のコントローラ数を返す<br>
        &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 最新の入力状況に更新する処理。<br>
      &nbsp;&nbsp;&nbsp; // 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
      &nbsp;&nbsp;&nbsp; static void Update()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 現在の状態を一つ前の状態として保存してGetJoypad..<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i];<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; currentStates[i] = GetJoypadInputState(padDic[i]);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>UpdateMouse(); // マウス状態を更新</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>UpdateKeyboard(); // キーボード状態を更新</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>	    
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isBugCheckMode = true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ++timing; //タイミングのカウントを+1<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (timing == INT_MAX) timing = 0; // int型最大値になったら0にループ<br>
      &nbsp;&nbsp;&nbsp; }<br>
<br>
      <em>&nbsp;&nbsp;&nbsp; // キーボードの状態を更新する<br>
      &nbsp;&nbsp;&nbsp; static void UpdateKeyboard()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; memcpy(prevKey, currentKey, sizeof(prevKey));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // キーボードの状態配列を更新する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; GetHitKeyStateAll(currentKey); // https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetButtonUp(Pad::Keyboard, KEY_INPUT_CAPSLOCK))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isCapsLocked != isCapsLocked; // CapsLock状態を反転<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // シフトが押された状態かを更新<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isShifted = (GetButton(Pad::Keyboard, KEY_INPUT_LSHIFT) || GetButton(Pad::Keyboard, KEY_INPUT_RSHIFT));<br>
      &nbsp;&nbsp;&nbsp; }</em><br>
<br>
      <em>&nbsp;&nbsp;&nbsp; // マウスの状態を更新する<br>
      &nbsp;&nbsp;&nbsp; static void UpdateMouse()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::DownL] = 0; Click[Mouse::DownR] = 0; //Click[Mouse.UpL] = 0; Click[Mouse.UpR] = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::All] = 0; // 状態辞書の0リセット<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevMouse = currentMouse; // 前フレームの最新のマウス情報を1つ前の情報とする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[(int)Pad::Mouse] = currentMouse;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MouseWheel = GetMouseWheelRotVolF(); // マウスのホイール回転量を更新<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // マウスの位置を取得<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; GetMousePoint(&amp;MouseX, &amp;MouseY);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::X] = MouseX; Click[Mouse::Y] = MouseY;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; currentMouse = GetMouseInput(); // マウス状態を得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; currentStates[(int)Pad::Mouse] = currentMouse; // マウス状態をパッド状態にも併合<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 押してない離した状態のマウス位置を更新<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (currentMouse == 0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::ReleaseX] = MouseX; Click[Mouse::ReleaseY] = MouseY;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else Click[Mouse::All] = 1; // マウスのいずれかのボタンが押されている<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 左マウスドラッグ中のXY位置を更新<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetButton(Pad::Mouse, MOUSE_INPUT_LEFT) &amp;&amp; !GetButtonDown(Pad::Mouse, MOUSE_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::DragLX] = MouseX; Click[Mouse::DragLY] = MouseY; Click[Mouse::DragL] = 1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::DragL] = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 右マウスドラッグ中のXY位置を更新<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetButton(Pad::Mouse, MOUSE_INPUT_RIGHT) &amp;&amp; !GetButtonDown(Pad::Mouse, MOUSE_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::DragRX] = MouseX; Click[Mouse::DragRY] = MouseY; Click[Mouse::DragR] = 1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::DragR] = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //[マウスクリック検知] https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N40<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // マウスのボタンが押されたり離されたりしたかどうかの情報を取得する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetMouseInputLog2(&amp;MButton, &amp;ClickX, &amp;ClickY, &amp;LogType, TRUE) == 0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // [左ボタン]が押されたり離されたりしていた<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((MButton & MOUSE_INPUT_LEFT) != 0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // クリックされた瞬間と離された瞬間のマウス位置を記録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (LogType == MOUSE_INPUT_LOG_DOWN)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::DownLX] = ClickX; Click[Mouse::DownLY] = ClickY; Click[Mouse::DownL] = 1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (LogType == MOUSE_INPUT_LOG_UP)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::UpLX] = ClickX; Click[Mouse::UpLY] = ClickY; Click[Mouse::UpL] = 1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }// [右ボタン]が押されたり離されたりしていた<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if ((MButton & MOUSE_INPUT_RIGHT) != 0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // クリックされた瞬間と離された瞬間のマウス位置を記録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (LogType == MOUSE_INPUT_LOG_DOWN)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::DownRX] = ClickX; Click[Mouse::DownRY] = ClickY; Click[Mouse::DownR] = 1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (LogType == MOUSE_INPUT_LOG_UP)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Click[Mouse::UpRX] = ClickX; Click[Mouse::UpRY] = ClickY; Click[Mouse::UpR] = 1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが押されているか？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButton(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //コントローラバグチェック<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (ControllerBugCheck(pad, buttonId)) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (pad == Pad::All) // All指定の時は全てのパッド<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // GetButtonの中でGetButtonを呼ぶ【再起呼出し】テクニック<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetButton((Pad)i, buttonId))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <em>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(pad == Pad::Keyboard) // 今ボタンが押されているかどうかを返却<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return (currentKey[buttonId] ==1); //https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今ボタンが押されているかどうかを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (currentStates[(int)pad] &amp; buttonId) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが押された瞬間か？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButtonDown(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //コントローラバグチェック<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (ControllerBugCheck(pad, buttonId)) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 再起呼出しテクニック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetButtonDown((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <em>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pad == Pad::Keyboard) //https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return (currentKey[buttonId] == 1) &amp;&amp; (prevKey[buttonId] != 1);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今は押されていて、かつ1フレーム前は押されていない場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((currentStates[(int)pad] &amp; buttonId) &amp; ~(prevStates[(int)pad] &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが離された瞬間か？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButtonUp(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //コントローラバグチェック<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (ControllerBugCheck(pad, buttonId)) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (pad == Pad::All) // All指定の時は全てのパッド<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 再起呼出しテクニック<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetButtonUp((Pad)i, buttonId))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <em>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>		
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pad == Pad::Keyboard) //https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return (prevKey[buttonId] == 1) &amp;&amp; (currentKey[buttonId] != 1);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1フレーム前は押されていて、かつ今は押されている場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((prevStates[(int)pad] &amp; buttonId) &amp; ~(currentStates[(int)pad] &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; //コントローラのボタンの初回プッシュを検知し<br>
      &nbsp;&nbsp;&nbsp; //他コントローラと初回タイミングが完全被りかチェックして重複コントローラの判定処理をスルーする対策<br>
      &nbsp;&nbsp;&nbsp; //★コントローラ3を押すと7も反応するなどコントローラ4以降の動作が怪しいのでその対策(DXのバグ?仕様?)<br>
      &nbsp;&nbsp;&nbsp; static bool ControllerBugCheck(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 今は押されていて、かつ1フレーム前は押されていない場合<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bool buttonDown = ((currentStates[(int)pad] & buttonId) & ~(prevStates[(int)pad] & buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //if (isBugCheckMode == false) return false; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //コントローラの初回ボタンプッシュを検知<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (buttonDown && firstPushTiming[(int)pad] == 0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i < (int)Pad::NUM - 1; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //全コントローラ初回プッシュ被りがないかチェック完全同時は怪しいので-1<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bool isDown = ((currentStates[i] & buttonId) & ~(prevStates[i] & buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((Pad)i != pad && isDown ////初回プッシュ被り検出<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; && (timing == firstPushTiming[i] || firstPushTiming[i] == 0))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //初回プッシュのタイミング被りは-1フラグを記録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; firstPushTiming[i] = -1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (firstPushTiming[(int)pad] != -1)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; firstPushTiming[(int)pad] = timing;//初回プッシュを記録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (firstPushTiming[(int)pad] == -1) return true; //DXのコントローラ被りバグ！<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else return false; //コントローラ被りOK!<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; <br>
    <em>&nbsp;&nbsp;&nbsp; // キーボードのキーと文字列の対応関係配列の初期化 https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N2<br>
&nbsp;&nbsp;&nbsp; static void InitKeyString()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 辞書配列で対応関係を結び付けておく<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_BACK] = "BackSpace";//"\b";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_TAB] = "\t";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RETURN] = "\n";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LSHIFT] = "ShiftL";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RSHIFT] = "ShiftR";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LCONTROL] = "CtrlL";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RCONTROL] = "CtrlR";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SPACE] = " ";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PGUP] = "PgUp";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PGDN] = "PgDn";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_END] = "End";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_HOME] = "Home";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LEFT] = "Left";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_UP] = "Up";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RIGHT] = "Right";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DOWN] = "Down";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_INSERT] = "Insert";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DELETE] = "Delete";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_MINUS] = "-"; CapsString[KEY_INPUT_MINUS] = "=";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_YEN] = "\\"; CapsString[KEY_INPUT_YEN] = "|";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PREVTRACK] = "^"; CapsString[KEY_INPUT_PREVTRACK] = "~";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PERIOD] = "."; CapsString[KEY_INPUT_PERIOD] = ">";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SLASH] = "/";  CapsString[KEY_INPUT_SLASH] = "?";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LALT] = "AltL";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RALT] = "AltR";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SCROLL] = "Scroll";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SEMICOLON] = ";"; CapsString[KEY_INPUT_SEMICOLON] = "+";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_COLON] = ":"; CapsString[KEY_INPUT_COLON] = "*";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LBRACKET] = "["; CapsString[KEY_INPUT_LBRACKET] = "{";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RBRACKET] = "]"; CapsString[KEY_INPUT_RBRACKET] = "}";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_AT] = "@"; CapsString[KEY_INPUT_AT] = "`";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_BACKSLASH] = "\\"; CapsString[KEY_INPUT_BACKSLASH] = "_";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_COMMA] = ","; CapsString[KEY_INPUT_COMMA] = "<";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_CAPSLOCK] = "CapsLock";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PAUSE] = "Pause";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD0] = "0";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD1] = "1";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD2] = "2";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD3] = "3";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD4] = "4";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD5] = "5";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD6] = "6";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD7] = "7";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD8] = "8";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD9] = "9";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_MULTIPLY] = "*";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_ADD] = "+";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SUBTRACT] = "-";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DECIMAL] = ".";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DIVIDE] = "/";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPADENTER] = "\n";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F1] = "F1";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F2] = "F2";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F3] = "F3";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F4] = "F4";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F5] = "F5";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F6] = "F6";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F7] = "F7";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F8] = "F8";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F9] = "F9";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F10] = "F10";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F11] = "F11";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F12] = "F12";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_A] = "a"; CapsString[KEY_INPUT_A] = "A";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_B] = "b"; CapsString[KEY_INPUT_B] = "B";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_C] = "c"; CapsString[KEY_INPUT_C] = "C";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_D] = "d"; CapsString[KEY_INPUT_D] = "D";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_E] = "e"; CapsString[KEY_INPUT_E] = "E";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F] = "f"; CapsString[KEY_INPUT_F] = "F";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_G] = "g"; CapsString[KEY_INPUT_G] = "G";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_H] = "h"; CapsString[KEY_INPUT_H] = "H";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_I] = "i"; CapsString[KEY_INPUT_I] = "I";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_J] = "j"; CapsString[KEY_INPUT_J] = "J";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_K] = "k"; CapsString[KEY_INPUT_K] = "K";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_L] = "l"; CapsString[KEY_INPUT_L] = "L";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_M] = "m"; CapsString[KEY_INPUT_M] = "M";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_N] = "n"; CapsString[KEY_INPUT_N] = "N";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_O] = "o"; CapsString[KEY_INPUT_O] = "O";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_P] = "p"; CapsString[KEY_INPUT_P] = "P";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_Q] = "q"; CapsString[KEY_INPUT_Q] = "Q";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_R] = "r"; CapsString[KEY_INPUT_R] = "R";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_S] = "s"; CapsString[KEY_INPUT_S] = "S";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_T] = "t"; CapsString[KEY_INPUT_T] = "T";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_U] = "u"; CapsString[KEY_INPUT_U] = "U";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_V] = "v"; CapsString[KEY_INPUT_V] = "V";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_W] = "w"; CapsString[KEY_INPUT_W] = "W";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_X] = "x"; CapsString[KEY_INPUT_X] = "X";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_Y] = "y"; CapsString[KEY_INPUT_Y] = "Y";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_Z] = "z"; CapsString[KEY_INPUT_Z] = "Z";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_0] = "0";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_1] = "1"; CapsString[KEY_INPUT_1] = "!";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_2] = "2"; CapsString[KEY_INPUT_2] = "\"";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_3] = "3"; CapsString[KEY_INPUT_3] = "#";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_4] = "4"; CapsString[KEY_INPUT_4] = "$";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_5] = "5"; CapsString[KEY_INPUT_5] = "%";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_6] = "6"; CapsString[KEY_INPUT_6] = "&amp;";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_7] = "7"; CapsString[KEY_INPUT_7] = "'";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_8] = "8"; CapsString[KEY_INPUT_8] = "(";<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_9] = "9"; CapsString[KEY_INPUT_9] = ")";<br>
&nbsp;&nbsp;&nbsp; }</em><br>
<br>
      }; //←【注意】クラス定義の終わりにはコロンが必要だよ！<br>
      <br>
      #endif&nbsp; //ここでエラー出た人は↑【注意】の;コロン忘れ<br>
    </p>
    <br>
	      <p><code>Input.cppに変数定義を追加します。</code></p>
    <p class="source">#include "Input.h"<br>
      <br>
      int Input::prevStates[]; // 1フレーム前の状態<br>
      int Input::currentStates[]; // 現在の状態<br>
      std::unordered_map&lt;Pad, bool&gt; Input::isJoin; // 参加中のパッド番号辞書<br>
      <br>
      std::unordered_map&lt;int, int&gt; Input::padDic; // パッド番号からDXの定義への辞書<br>
<em><br>
int Input::prevMouse; // 1フレーム前のマウス状態<br>
int Input::currentMouse; // 現在のマウス状態<br>
int Input::MouseX{ -1 }, Input::MouseY{ -1 }; // 現在のマウス位置<br>
float Input::MouseWheel{ 0 };<br>
int Input::ClickX{ -1 }, Input::ClickY{ -1 }, Input::MButton{ 0 }, Input::LogType{ 0 };<br>
std::unordered_map&lt;Mouse, int&gt; Input::Click;//&lt;Mouse⇒int&gt; マウスのクリックXY位置辞書<br>
<br>
//[キーボード入力]https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
char Input::prevKey[256]; // 1フレーム前のキーボード状態<br>
char Input::currentKey[256]; // 現在のキーボード状態<br>
std::string Input::KeyString[256];//&lt;キーコード⇒キー文字列&gt;の辞書<br>
std::string Input::CapsString[256];//&lt;Caps状態キーコード⇒キー文字列&gt;の辞書<br>
bool Input::isCapsLocked{ false };// CapsLock状態か?<br>
bool Input::isShifted{ false };// Shiftが押された状態か?<br>
</em><br>
//★【DXコントローラバグ検知】初回プッシュが被ればDXバグで同一コントローラ<br>
int Input::firstPushTiming[(int)Pad::Four]; // Pad::Fourが最後だから8とかに増やすなら要書き換え<br>
int Input::timing{ 0 };<br>
bool Input::isBugCheckMode = false; //バグチェックを開始するか<br>
	    <br>
    </p>
    <br>
    <br>
<code>TitleScene.hにマウスとキーボード入力を表示するデモのコード</code>をくわえましょう。<br>
		<p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
	#include &lt;string&gt;<br>
	<br>
      #include "DxLib.h"<br>
      (中略)...........<br>		
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
(中略)...........<br>
<br>
<em>&nbsp;&nbsp; &nbsp;std::string keyboardText{""}; // キーボード入力テキスト<br>
&nbsp;&nbsp; &nbsp;int keyDownCount[256]; // 各キーを押している時間をカウントして長押し動作<br>
&nbsp;&nbsp; &nbsp;int longPushNum = 30; // 30フレーム0.5秒長押しで文字がだーっと出る<br></em>
<br>
&nbsp;&nbsp; &nbsp;// コンストラクタ<br>
&nbsp;&nbsp; &nbsp;TitleScene() : Scene()<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "TitleScene";<br>
&nbsp;&nbsp; &nbsp;}<br>
<br>
&nbsp;&nbsp; &nbsp;(中略)...........<br>
<br>
&nbsp;&nbsp; &nbsp;// ボタン入力に応じた処理<br>
&nbsp;&nbsp; &nbsp;void HandleInput()<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;(中略)...........<br>	
<br>
<em>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// キーボードでテキスト入力<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;bool isEntered = false; // テンキーのEnterと普通のEnterダブり問題対策<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int i = 0; i &lt; 256; ++i)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (i == KEY_INPUT_RETURN || i == KEY_INPUT_NUMPADENTER)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!isEntered) isEntered = true;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else continue;<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::GetButtonDown(Pad::Keyboard, i))<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;keyDownCount[i] = 0; // キーが押された瞬間からカウントアップ開始<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if(Input::GetButton(Pad::Keyboard, i))<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;++keyDownCount[i]; // キーが押されてる時間をカウントアップ<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (0 &lt; keyDownCount[i] &amp;&amp; keyDownCount[i] &lt; longPushNum)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue; // Downの瞬間=0かlongPush以上時間経過してない場合は文字を増やさない<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::GetButton(Pad::Keyboard, i))<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (i == KEY_INPUT_BACK || i == KEY_INPUT_DELETE)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (keyboardText.size() &gt; 0)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;keyboardText.pop_back(); // 末尾の文字を1つ削除する<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (i == KEY_INPUT_LSHIFT || i == KEY_INPUT_RSHIFT)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// シフト文字は出力しない SHIFT + a ⇒ A 大文字表示に<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (Input::isCapsLocked || Input::isShifted) //CapsLockかShift押下中は大文字<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;keyboardText += (Input::CapsString[i] != "") ? Input::CapsString[i] : Input::KeyString[i];<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;keyboardText += Input::KeyString[i]; // 押された文字をテキスト列に追加<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</em><br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;}<br>
(中略)...........<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;(中略)...........<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      <em>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// キーボードのデモ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 100, keyboardText.c_str(),GetColor(255,255,255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// マウスのデモ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::Click[Mouse::All] == 1)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// ドラッグしたら<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::Click[Mouse::DragL] == 1)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// ドラッグしたら開始XYと四角 □ を表示<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string drawString = "Drag開始(X,Y)=(" + std::to_string(Input::Click[Mouse::DownLX]) + "," + std::to_string(Input::Click[Mouse::DownLY]) + ")";<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(Input::Click[Mouse::DownLX], Input::Click[Mouse::DownLY], drawString.c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 選択範囲の四角を表示<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawLineBox(Input::Click[Mouse::DownLX], Input::Click[Mouse::DownLY], Input::Click[Mouse::DragLX], Input::Click[Mouse::DragLY], GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// [1] if(Input::GetButton(Pad::Mouse, MOUSE_INPUT_RIGHT) と<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// [2] if(Input::Click[Mouse::DragR] == 1) は 同じ意味になる([2]のほうが短く書ける)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::Click[Mouse::DragR] == 1 &amp;&amp; Input::MouseX &gt;= 0 &amp;&amp; Input::MouseY &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string drawString = "マウス右(X,Y)=(" + std::to_string(Input::MouseX) + "," + std::to_string(Input::MouseY) + ")";<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(Input::MouseX, Input::MouseY, drawString.c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (Input::MouseX >= 0 &amp;&amp; Input::MouseY &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string drawString = "(X,Y)=(" + std::to_string(Input::MouseX) + "," + std::to_string(Input::MouseY) + ")";<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(Input::MouseX, Input::MouseY, drawString.c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// クリックを離した位置は記録が残る<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::Click[Mouse::UpLX] != -1 &amp;&amp; Input::Click[Mouse::UpLY] != -1)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string drawString = "離した(X,Y)=(" + std::to_string(Input::Click[Mouse::UpLX]) + "," + std::to_string(Input::Click[Mouse::UpLY]) + ")";<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(Input::Click[Mouse::UpLX], Input::Click[Mouse::UpLY], drawString.c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ドラッグ開始XYも残るので範囲エリアの四角内のキャラ選択などにも使える<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::Click[Mouse::DownLX] != -1 &amp;&amp; Input::Click[Mouse::DownLY] != -1)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string drawString = "Drag開始(X,Y)=(" + std::to_string(Input::Click[Mouse::DownLX]) + "," + std::to_string(Input::Click[Mouse::DownLY]) + ")";<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(Input::Click[Mouse::DownLX], Input::Click[Mouse::DownLY], drawString.c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</em><br>
      (中略)...........<br>
	    <br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>	
    <br>
		いかがでしょうか？実行するとタイトル画面でマウスドラッグや右クリックやキーボードのテキスト入力が表示されたでしょうか？<br>
		<b>全角や日本語入力についてはMakeKeyInput関数</b>を使ったまた別のやり方になります。<br>
		<a href="https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N13">https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N13</a><br>
		気が向いたらトライしてみるのもよいかもしれません。<br>
    <br>
    <br>
	<h2><a id="mozTocId50021" class="mozTocH1"></a>ゲームクリア画面への遷移</h2>
    <br>
    <p><code>GameClearScene.hを新規作成</code>して、ベースのScene.hを継承してクリア画面を作成しましょう。</p>
    <p class="source">#ifndef GAMECLEARSCENE_H_<br>
      #define GAMECLEARSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class GameClearScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;GameClearScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "GameClearScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(Pad::All, PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.LoadScene("TitleScene"); //シーン遷移<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawString(0, 0, "おめでとう!!!!GameClear....ボタン押下でPlaySceneへ", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>SceneManager.cppにGameClearシーンの生成処理を追加</code>してクリアシーンへ遷移する機能を作成しましょう。</p>
    <p class="source">#include "SceneManager.h"<br>
      <br>
      #include "Scene.h"<br>
      #include "TitleScene.h"<br>
      #include "PlayScene.h"<br>
      #include "GameOverScene.h"<br>
      <em>#include "GameClearScene.h"</em><br>
      <br>
      bool SceneManager::isChanging(const std::string&amp; nextSceneName)<br>
      {<br>
      &nbsp;&nbsp; &nbsp;if (currentSceneName != nextSceneName) //シーン名不一致<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return true; // シーン名が変更<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;return false; // シーン名に変更無し<br>
      }<br>
      <br>
      void SceneManager::NextScene(const std::string&amp; nextSceneName)<br>
      {<br>
      &nbsp;&nbsp; &nbsp;// 遷移予定nextシーン名と現在のシーン名を比較、何の変化もなければfalseでシーン移動不必要の判定<br>
      &nbsp;&nbsp; &nbsp;if (isChanging(nextSceneName) == false) return; //特に変更なしでシーン移動の必要なし<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;changingSceneName = nextSceneName; // 次に移動予定のシーン名を保管しておく<br>
      }<br>
      <br>
      void SceneManager::LoadScene(const std::string&amp; sceneName)<br>
      {<br>
      &nbsp;&nbsp; &nbsp;std::string loadSceneName = sceneName;
      &nbsp;&nbsp; &nbsp;// sceneNameの指定が空の場合にはNextScene()での事前のシーン変更予約があるかチェック<br>
      &nbsp;&nbsp; &nbsp;if (sceneName == "" &amp;&amp; changingSceneName != "")<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;loadSceneName = changingSceneName;<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;if (loadSceneName == "") return; // シーン指定がないときは終了<br>
      &nbsp;&nbsp; &nbsp;// 現在のシーンの終了処理<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;if(currentScene !=nullptr)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentScene-&gt;Finalize(); // 終了処理を呼び出す<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;if (loadSceneName == "TitleScene")<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 次のシーンの生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentScene = std::make_shared&lt;TitleScene&gt;();<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;else if (loadSceneName == "PlayScene")<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 次のシーンの生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentScene = std::make_shared&lt;PlayScene&gt;();<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;else if (loadSceneName == "GameOverScene")<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 次のシーンの生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentScene = std::make_shared&lt;GameOverScene&gt;();<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<em>else if (loadSceneName == "GameClearScene")<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 次のシーンの生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentScene = std::make_shared&lt;GameClearScene&gt;();<br>
      &nbsp;&nbsp; &nbsp;}</em><br>
      &nbsp;&nbsp; &nbsp;else<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;assert("指定されたシーン名の生成処理が見つからなかった→SceneManager.cppを見直しましょう" == "");<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;currentSceneName = loadSceneName; // 現在のシーン名の更新<br>
      &nbsp;&nbsp; &nbsp;changingSceneName = ""; // NextScene関数のシーン予約名をリセット(リセットしないと次回LoadSceneを引数なしで呼ぶと残存したchangingSceneNameへ飛んじゃう)<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 次のシーンの初期化<br>
      &nbsp;&nbsp; &nbsp;currentScene-&gt;Initialize(); // 初期化を呼び出す<br>
      }</p>
    <br>
      <code>PlayScene.hにゲームクリア画面への遷移予約がある場合に遷移させるため、引数無しのLoadScene();関数呼び出し</code>を追加しましょう。</p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
(中略).........<br>	    
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
<br>
      &nbsp;&nbsp;&nbsp; (中略).........<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (中略).........<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (中略).........<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isGameover)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::PlayMusic(Sound::ending); //BGMを変更する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.LoadScene("GameOverScene"); //シーン遷移<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>sm.LoadScene(); // シーン遷移予約がNextScneneで事前予約されていたら遷移</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; (中略).........<br>
      <br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
例として<code>Boss.hがisDead=true;になったタイミングで連動してGameClearSceneに遷移するように</code>NextScene関数の呼び出しを追加します(ついでにボスの爆発も乱数でハデにします)</p>
<p class="source">#ifndef BOSS_H_<br>
      #define BOSS_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      (中略).........<br>
      <br>
      <br>
      <em>#include "SceneManager.h"</em><br>
      <br>
      // ボスクラス。Enemyを継承して作る<br>
      class Boss : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; (中略).........<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <em>SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Boss(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Boss"; // オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life = 100; // ライフ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collisionRadius = 70; // 当たり判定半径<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state == State::Appear) // 登場状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (中略).........<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Normal) // 通常状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (中略).........<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Swoon) // 気絶状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (中略).........<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Angry) // 発狂モード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (中略).........<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Dying) // 死亡中<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dyingTime--; // タイマー減少<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if (dyingTime % 5 == 0) // カウント 5 おきに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // やられたら ±(当たり判定の半径 + 40.0の乱数) の位置に爆発を出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float rangeX = MyRandom::Range(-40.0f - collisionRadius, 40.0f + collisionRadius);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float rangeY = MyRandom::Range(-40.0f - collisionRadius, 40.0f + collisionRadius);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 爆発を生成<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.explosions.emplace_back(std::make_shared&lt;Explosion&gt;(Vector3(position.x + rangeX, position.y + rangeY)));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dyingTime &lt;= 0) // タイマーが0になったら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isDead = true; // 完全に消滅<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>sm.NextScene("GameClearScene"); // ゲームクリア画面への遷移を予約</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (中略).........<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 自機弾に当たったときの処理をoverride（上書き）する<br>
      &nbsp;&nbsp; &nbsp;void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet) override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (中略).........<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp; (中略).........<br>
      };<br>
      <br>
      #endif</p>
<br>
    <br>
    <br>
    いかがですか？ボスを倒したらゲームクリア画面に遷移するようになりましたか？<br>
    <br>
    <br>
    <br>
	<h2><a id="mozTocId50022" class="mozTocH1"></a>【課題】シューティングとして完成度を上げるための残された課題</h2>
    <br>
    さて、ここまでで、ひととおりのインフラは整いました。<br>
    ここまであえて残してきた、下記の未完成ポイントをここまで導入してきた要素を応用して埋めてみてください。<br>
    <b>[1][2]は<a href="https://www.youtube.com/watch?v=A4H4Evy4aW8">愛でカバー</a>できる<a href="https://www.youtube.com/watch?v=BUN1Zen6JeA">努力義務</a>の範囲、[3][4][5]はプログラミング応用力と拡張力(<a href="https://qiita.com/knknkn1162/items/9a65ca65b558f31121f0">Zakoなどストラテジーパターン</a>など)の証明、[6][7][8]はシーン遷移とゲームシステムの拡張力の証明。</b><br>
<br>
    ・[1]タイルマップエディタでステージを自作して<b>ゲームバランスを自分で調整</b>する。<br>
<br>
    ・[2]タイトル画面の機能を整理して、<b>背景画像などを自作したりフォントのロゴを工夫して「タイトル画面らしくする」</b>。<br>
<br>
    ・[3]<b>プレイヤの画面外へのはみ出しをif, else if, else文で判定</b>して<b>画面はしっこに沿わせる</b>処理<b>(ヒント:Player.cppで左端position.x = collisionRadius や 右端position.y = Screen::Width - collisionRadius で画面はしっこに沿わせる)</b><br>
<br>
    ・[4]<b>Zako4,Zako5..や Item2,Item3....Boss2,Boss3.h</b>など自作のクラスを作成してオブジェクト指向の<b>クラスの設計を体得、練習</b>する。<br>
<br>
    ・[5]<b>Map.hのSpawnObject関数のなか</b>にザコ0などだけではなく、<b>Item0.hなどの生成処理を自作:例えばアイテムはid=20～30に対応</b>させて<b>タイルエディタでアイテム配置</b>できるようにする。<br>
<br>
    ・[6]ボスを倒した場合以外の<b>自作のゲームクリア条件</b>で別のゲームクリア画面2へ進む処理を考えてみる(スコアが一定数を超えると<b>隠しクリア画面</b>へ進むなど)。<br>
<br>
    ・[7]ScoreScene.hやSoundScene.hなどを自作して、<b>スコアのランキング専用のページやサウンド設定専用のページを自作</b>する。<br>
<br>
    ・[8]タイトル画面 → ステージ選択画面など<b>ステージ1,ステージ2などを選べる画面SelectStageScene.hなどを自作</b>して、複数ステージで遊べるようにする。<br>
<br>
    ◆[1]-[8]ができれば<b>「ゲームの基本ベース構造についての免許が皆伝」</b>(あとはシューティング以外の<b>「ゲーム内容」にフォーカスできる準備が整った</b>ということ)<br>
<br>
<br>
ここまでを総括してゲーム制作の最小構成要件を押さえておきます。<br>
    ◆ゲームの原材料は<br>
・「画像、音など素材系」<br>・「ステージやパラメータやセーブなどデータ系」<br>
    ◆ゲームのプログラミング要項は<br>
・「Inputなど操作系」<br>・「フォントや音量オプションなどOS系」<br>・「Vector3やMathなど数学系」<br>・「跳ね返りやジャンプや物理などのダイナミクス系」<br>・「ZakoやBossなどのルーチン・AI系」<br>
上記の構成要素を体感したうえで、ゲームの原材料と作業量をイメージした上で<br>
<b>「完成させられそうな現実路線のゲームアイデア」= 基本作業時間 と 拡張作業時間</b> を分けて考えたうえでゲームの制作に入ることが大事です。(人の時間は有限なので)<br>
<br>	
  </body>
</html>
