<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>[C++]シューティングゲーム</title>
    <link rel="stylesheet" href="style.css">
    <style>
      
    </style>
  </head>
  <body>
    <p class="title">[C++]シューティングゲーム 1</p>
    <br>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId0001">シューティングC++で目指すところ(意義)</a></li>
      <li><a href="#mozTocId0002">プロジェクトの作成</a></li>
      <li><a href="#mozTocId0003">画像ファイルの追加</a></li>
      <li><a href="#mozTocId0004">Imageクラスの作成</a></li>
      <li><a href="#mozTocId0005">Gameクラスの作成</a></li>
      <li><a href="#mozTocId0006">自機の作成</a><br>
        <a href="#mozTocId00061">- Playerクラスの作成</a> </li>
      <li><a href="#mozTocId0007">自機弾の作成</a><br>
        <a href="#mozTocId00071">- 循環参照・インクルードの罠</a><br>
        <a href="#mozTocId00072">- シングルトン型:唯一物体タイプの追加</a><br>
        <a href="#mozTocId00073">- 仲介マネージャーGameManagerの追加</a><br>
        <a href="#mozTocId00074">- 【※メモリから弾を削除】自機弾PlayerBulletの削除処理</a><br>
        <a href="#mozTocId00075">- 共通削除機能を【テンプレートとして定義】</a><br>
        <a href="#mozTocId00076">- 【実験】メモリ浪費弾の実験</a><br>
        <a href="#mozTocId00077">- 自機弾の角度を変えられるようにする</a><br>
        <a href="#mozTocId00078">- vectorとlistの性能考察</a> </li>
      <li><a href="#mozTocId0008">ベクトル構造体でX,Y,ZをVector3型でまとめて管理する</a><br>
        <a href="#mozTocId00081">- ベクトルの基本</a><br>
        <a href="#mozTocId00082">- ベクトルの計算</a><br> </li>
      <li><a href="#mozTocId0009">敵の作成</a><br>
        <a href="#mozTocId00091">- 共通のベースとなるGameObjectを作成する</a><br>
        <a href="#mozTocId00092">- Zako0クラスの作成</a><br>
      </li>
      <br>
      <p>テキスト2もこのファイル内にまとめた。</p>
      <a href="#mozTocId2000">[C++]シューティングゲーム 2</a><br>
      <br>
      <p>このHTMLのWEBテキストはBlueGriffonという無料のソフトで書いた<a href="https://forest.watch.impress.co.jp/library/software/bluegriffon/">https://forest.watch.impress.co.jp/library/software/bluegriffon/</a><br>
      <a href="https://prog-8.com/docs/github-pages">githubで自分のサイトを無料公開できるので自作サイトにも挑戦しては</a></p>
      <br>
    </ol>
    <h1><a id="mozTocId0001" class="mozTocH1"></a>シューティング[C++]で目指すところ(意義)</h1>
    <p>シューティングの制作をC++で行うこと以下を作業を通じて【体得しよう】。</p>
    <ul>
      <li>C++でのクラス定義をC#との違いを比較しながら習得</li>
      <li>DXライブラリの公式のサンプルはC++なのでそれを動かせるようになる</li>
      <li>C++でのリストやforeachの使い方の違いを習得</li>
      <li>C++での画像読み込みとそのメモリのお掃除(メモリ開放)</li>
    </ul>
    <p>最終的には、C++で制作したゲームの完成を目標にしましょう。<br>
      頑張ってください！</p>
    <br>
    <p>なお、<b>C++は下手にお金出して本を買うくらいなら以下のサイトが教科書代わりになりそう</b>です。<br>
    <a href="https://ezoeryou.github.io/cpp-intro/">https://ezoeryou.github.io/cpp-intro/</a><br>
    前半はうちらの使っているVisualStudioと違うgccというビルドコンパイルについての解説なので飛ばして中盤以降の条件分岐あたりから読むとよい<br>
    <a href="https://ezoeryou.github.io/cpp-intro/#%E6%9D%A1%E4%BB%B6%E5%88%86%E5%B2%90%E3%81%AE%E6%9E%9C%E3%81%A6%E3%81%AE%E3%83%AC%E3%82%B9%E3%83%88%E3%83%A9%E3%83%B3">条件分岐あたりへのリンク</a></p>
    <p>質も量もおなかいっぱいなので、自分のゲームで使っているところを拾い読むスタイルじゃないと眠くなります。適度な【適当さ】も必要。物を作るのと学問は必ずしもイコールじゃない。</p>
    <h1><a id="mozTocId0002" class="mozTocH1"></a>プロジェクトの作成</h1>
    <h2>まずはDXライブラリ公式のC++のライブラリをダウンロード</h2>
    以下のDXライブラリの公式サイトからC++のDXライブラリをダウンロードしてください。<br>
    <a href="https://dxlib.xsrv.jp/dxdload.html">https://dxlib.xsrv.jp/dxdload.html</a> <br>
    ダウンロードできたらzipファイルを【C:ドライブ直下に展開】してください<br>
    <p> <img src="image/img_dxdownload.png" alt=""></p>
    <br>
    <br>
    <h2>ダウンロードできたらzipファイルを【C:ドライブ直下に展開】</h2>
    <p> <img src="image/img_dxlibextract_c_drive.png" alt=""></p>
    <br>
    <br>
    <h2>プロジェクト作成</h2>
    Visual Studio 2019を起動してください。<br>
    <br>
    起動したら、<code>新しいプロジェクトの作成</code>をクリック<br>
    <br>
    <code>C++ 空のプロジェクト</code>を選択して次へ
    <p> <img src="image/making_cpp_prj.png" alt="" style="width: 1156px; height: 853px;"></p>
    <p>今回のプロジェクト名は【1】「自分の作るゲーム名」か【2】毎回C++のプロジェクトを作るのが面倒な人は今回作るプロジェクトをフォルダごと量産するとして「DXLibGameBase」(ゲームの基礎ベース、コピペで量産用プロジェクト)にしましょう。</p>
    <p></p>
    <p>プロジェクトが作成されたら、まず【main.cpp】作りましょう。</p>
    <br>
    <p>少なくとも一つ【～.cpp】作らないと出てこない次にやる設定↓で【出てこない項目】があります(【C/C++全般】が出てこない！)</p>
    <br>
    <h2>次にプロジェクトのややこしい設定をしっかりやる</h2>
    プロジェクトの【設定を開く前に】最低限一つだけでもcppファイルがプロジェクトにないと【出てこない設定項目がある】ので新しい項目を追加でC++ソースファイル(.cpp)のファイルを一つ作成しておく。<br>
    <br>
    <p> <img src="image/need_one_cpp.png" alt="" style="width: 1152px; height: 713px;"></p>
    <br>
    <br>
    表示モードを切り替えてみて、main.cppができたかを確認する。<br>
    <p> <img src="image/foldermode.png" alt="" style="width: 1599px; height: 426px;"></p>
    <br>
    一つだけcppファイルを作成した後、プロジェクトを右クリックして<code>プロパティ</code>をクリック<br>
    <br>
    <p> <img src="image/open_setting.png" alt="" style="width: 1128px; height: 642px;"></p>
    <br>
    <h2>【設定】マルチバイト文字セットを使用</h2>
    <br>
    設定画面の【構成プロパティ】→【詳細】の【文字セット】を<code>マルチバイト文字セットを使用</code>に変更<br>
    <p> <img src="image/setting_multibyte_moji.png" alt="" style="width: 982px; height: 682px;"></p>
    <br>
    <h2>【設定】C/C++→全般→追加のインクルードディレクトリにDXライブラリのフォルダ位置(PATH)を追加</h2>
    <br>
    設定画面の【C/C++全般】→【全般】の【追加のインクルードディレクトリ】に<code>DXライブラリのフォルダ位置(PATH)</code>を設定<br>
    <p> <img src="image/setting_cpp_add_include_dir.png" alt="" style="width: 1047px; height: 682px;"></p>
    <br>
    フォルダのパス(位置)文字列は以下のgifアニメのようにコピーして貼り付け<br>
    <p> <img src="image/setting_howto_copy_dir.gif" alt="" style="width: 892px; height: 554px;"></p>
    <br>
    <h2>【設定】リンカ→全般→追加のライブラリディレクトリにDXライブラリのフォルダ位置(PATH)を追加</h2>
    <br>
    設定画面の【リンカー】→【全般】の【追加のライブラリディレクトリ】に<code>DXライブラリのフォルダ位置(PATH)</code>を設定<br>
    <p> <img src="image/setting_linker_add_lib_dir.png" alt="" style="width: 1046px; height: 682px;"></p>
    <br>
    フォルダのパス(位置)文字列は以下のgifアニメのようにコピーしたものを貼り付け<br>
    <p> <img src="image/setting_howto_paste_dir.gif" alt="" style="width: 1075px; height: 805px;"></p>
    <br>
    <br>
    <h2>【設定】リンカ→システム→サブシステムをウィンドウに(コンソールのままだと黒画面の文字ベースシステムになる)</h2>
    <br>
    設定画面の【リンカー】→【システム】の【サブシステム】を<code>Windows(SUBSYSTEM:WINDOWS)</code>に設定<br>
    この設定をするとプログラムの開始位置(エントリポイントという)がWinMainというところから始まるようになる。(Consoleの場合はMain)<br>
    <p> <img src="image/setting_entry_point.png" alt="" style="width: 985px; height: 682px;"></p>
    <br>
    <br>
    以上で設定項目は終わり。OKをおして設定を反映しよう<br>
    <br>
    <br>
    <h2>設定を反映させたらサンプルプログラムをmain.cppにコピペして動作を確認</h2>
    <p>以下の【ウィンドウを出すだけの最小限サンプル】を動かして設定を確認しましょう</p>
    <p><code>main.cpp【ウィンドウを出すだけの最小限サンプル】</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode( 960 , 540 , 32 ) ; // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(960, 540);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// この位置にウィンドウの中に画像を描く処理などを書く<br>
      &nbsp;&nbsp;// DXライブラリ公式の色々なサンプルを試してみよう！<br>
      &nbsp;&nbsp;// https://dxlib.xsrv.jp/dxfunc.html<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <h2>解像度の定義</h2>
    <p>【C++で】画面解像度を定義するクラスを作ってみましょう。ソリューションエクスプローラーのプロジェクトを右クリックし、追加＞ヘッダファイル(.h)<br>
      Screen.hという名前でヘッダファイルを生成し、そのファイルにクラスを記述します。</p>
    <p><code>Screen.h</code>を編集します：</p>
    <p class="source">#ifndef _SCREEN_H<br>
      #define _SCREEN_H<br>
      // ＃ifndefは「_SCREEN_H」がifもしもn(not) def(定義)されていないなら＃endifに挟まれたコードまでを有効化する(だから2度目以降は無効になる)<br>
      // 二重定義を防止するために＃から始まる【プリプロセッサ】を使っている<br>
      //　【プリプロセッサ】はビルドする段階でコード自体に【前処理】として影響を与える<br>
      // たとえば<br>
      // ・ファイルの読み込み (including) →＃includeがこれ<br>
      // ・マクロの展開（シンボルを、あらかじめ定義された規則に従って置換する）<br>
      // ・コンパイル条件によるソースコードの部分的選択→【＃ifndef　～ ＃endifに囲まれた部分】は一度(＃defineで)定義されると無効化<br>
      // ・コメントの削除 【&nbsp;//&nbsp;】のコメントの削除も【プリプロセス＝前段階で行われる】<br>
      <br>
      // 画面解像度<br>
      class Screen<br>
      {<br>
      public: //publicはC＃と違いpublic:以下にまとめて書かれるスタイル<br>
      &nbsp;&nbsp;static const int Width = 960; // 幅<br>
      &nbsp;&nbsp;static const int Height = 540; // 高さ C＃と違いstaticクラスではなく個々の【すべての変数にstaticをつけて】staticなクラスとする<br>
      };// C＃と違ってクラスの定義も;セミコロンで終わる<br>
      #endif</p>
    <br>
    <br>
    <br>
    <p><code>main.cpp</code>を編集してScreen.hを読み込ませます：</p>
    <p class="source">#include "DxLib.h"<br>
      <em>#include "Screen.h"</em><br>
      // ↑＃includeで別ファイルのヘッダファイル.hをこのコード内に読み込む<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode( <em>Screen::Width, Screen::Height,</em> 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(<em>Screen::Width, Screen::Height</em>);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      <br>
      <br>
      &nbsp;&nbsp;// (中略).....................................<br>
      <br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <h1><a id="mozTocId0003" class="mozTocH1"></a>画像ファイルの追加</h1>
    <p>次は画像ファイルをプロジェクトに追加します。フォルダは【ウィンドウズ上のエクスプローラで作成】します。<br>
      <br>
      <br>
      <img src="image/open_folder_with_explorer.png" alt="" style="width: 1397px; height: 475px;"><br>
      <br>
      <img src="image/gimp6.png" alt="" style="width: 362px; height: 180px;"><br>
      <br>
      <img src="image/new_image_folder.png" alt="" style="width: 362px; height: 180px;"><br>
      <br>
      GIMPをダウンロードして画像をつくってみましょう。<br>
      <a href="https://forest.watch.impress.co.jp/library/software/gimp/">https://forest.watch.impress.co.jp/library/software/gimp/</a><br>
      <br>
      ダウンロードしたら起動して【ファイル】→【新しい画像】<br>
      <img src="image/gimp1.png" alt="" style="width: 1097px; height: 736px;"><br>
      <br>
      キャンバスのサイズはとりあえず64×64でつくってみます(自由につくってもよいがサイズをおぼえておいて、あとで自分のプログラムで読み込むときに合わせないといけないよ)<br>
      <img src="image/gimp2.png" alt="" style="width: 502px; height: 612px;"><br>
      <br>
      透明のレイヤーをつくって背景が透けるようにしておく<br>
      <img src="image/gimp2_1.png" alt="" style="width: 707px; height: 517px;"><br>
      <br>
      消しゴムで消して透明にしておく<br>
      <img src="image/gimp2_2.png" alt="" style="width: 965px; height: 559px;"><br>
      <br>
      新しいレイヤをつくって、そこのレイヤに自分の画像をえがいていく<br>
      <img src="image/gimp2_3.png" alt="" style="width: 635px; height: 743px;"><br>
      <br>
      <img src="image/gimp2_4.png" alt="" style="width: 598px; height: 574px;"><br>
      <br>
      <br>
      マウスで長押しして楕円選択をえらんで円形にえがくエリアをえらぶ<br>
      <img src="image/gimp3.png" alt="" style="width: 793px; height: 594px;"><br>
      <br>
      <br>
      ぬりつぶしの色を決めて、えらんでいるエリアを円形にぬりつぶす<br>
      <img src="image/gimp4.png" alt="" style="width: 653px; height: 614px;"><br>
      <br>
      <br>
      テキストのボタンをおして円のうちがわに自機という文字をうちこむ<br>
      <img src="image/gimp5.png" alt="" style="width: 853px; height: 595px;"><br>
      <br>
      <br>
      画像を保存するフォルダをつくっておく<br>
      <img src="image/gimp6.png" alt="" style="width: 662px; height: 273px;"><br>
      <br>
      <br>
      つくったフォルダにエクスポートする<br>
      <img src="image/gimp7.png" alt="" style="width: 586px; height: 559px;"><br>
      <br>
      <img src="image/gimp8.png" alt="" style="width: 939px; height: 496px;"><br>
      <br>
      <br>
      自分でboss1.png、boss2.png、boss3.pngを180×180など別のサイズでつくってみたり、<br>
      webでゲーム素材、フリーなどのワードで検索して、素材をさがしてみよう(著作権や利用規約をよく読んで注意しないとお金とられて財布が空になっちゃうので注意！！)<br>
      <a href="https://pipoya.net/sozai/">https://pipoya.net/sozai/</a><br>
      <a href="https://qiita.com/TD12734/items/5dc8068732f94452efe2">https://qiita.com/TD12734/items/5dc8068732f94452efe2</a><br>
      
      <img src="image/gimp9.png" alt="" style="width: 668px; height: 160px;"><br>
      <br>
      えがいた画像をべつのフォルダに保存した場合は、下のアニメようにウィンドウズでImageフォルダーにコピーして貼り付けしてください。</p>
    <img src="image/image_copy_paste.gif" alt=""><br>
    <br>
    <img src="image/image_add_project.gif" alt=""><br>
    <p><br>
    </p>
    <h2>試しに表示してみる</h2>
    <p><code>main.cpp</code>にプログラムを追加し、画像が正しく表示できるかテストします。</p>
    <p class="source">#include "DxLib.h"<br>
      <em>#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用</em><br>
      #include "Screen.h"<br>
      // ＃includeで別ファイルのヘッダファイル.hをこのコード内に読み込む<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      <br>
      <br>
      <em> &nbsp;&nbsp;//表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;// これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;SetDrawScreen(DX_SCREEN_BACK);<br>
        <br>
        &nbsp;&nbsp;// これまでInitでやってきてた初期化処理<br>
        &nbsp;&nbsp;int bossImage = -1;<br>
        &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
        &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;int x = 100; // Xの初期位置<br>
        &nbsp;&nbsp;int vx = 10;<br>
        <br>
        &nbsp;&nbsp;ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;while (ProcessMessage() == 0) <br>
        &nbsp;&nbsp;{// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;// これまではUpdateでやってきてた更新処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (x &lt; 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // X位置の更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;// これまではDrawでやってきてた描画処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, bossImage, TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;}<br>
      </em> <br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <p><br>
    </p>
    <h1><a id="mozTocId0004" class="mozTocH1"></a>Imageクラスの作成</h1>
    <h2>Imageクラスの作成</h2>
    <p>Imageクラスを作成しましょう。Imageクラスの役割は次の2つです。</p>
    <ul>
      <li>画像の読み込み</li>
      <li>読み込んだ画像ハンドルの保持</li>
    </ul>
    <p><br>
    </p>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「Image」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Image.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;static void Load();<br>
      <br>
      &nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <p>次に対となるcppファイルを作成します。<br>
      ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞cppファイル<br>
      「Image.cpp」という名前でcppファイルを作り、クラスを実装します。<br>
      <br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
      <br>
      int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      <br>
      void Image::Load()<br>
      {<br>
      &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      }</p>
    <br>
    <br>
    <h2>試しに【Image.hを使って】表示してみる</h2>
    <p><code>main.cpp</code>のプログラムを変更し、画像が正しく表示できるかテストします。</p>
    <p class="source">#include "DxLib.h"<br>
      #include "Screen.h"<br>
      <em>#include "Image.h"&nbsp;// 画像読み込みクラス</em><br>
      <br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;//表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;// これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;SetDrawScreen(DX_SCREEN_BACK);<br>
      <br>
      &nbsp;&nbsp;// これまでInitでやってきてた初期化処理<br>
      &nbsp;&nbsp;<em>Image::Load();</em><br>
      &nbsp;&nbsp;int x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;int vx = 10;<br>
      <br>
      &nbsp;&nbsp;ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0) <br>
      &nbsp;&nbsp;{// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// これまではUpdateでやってきてた更新処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// これまではDrawでやってきてた描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, <em>Image::bossImage</em>, TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <p><br>
    </p>
    <h1><a id="mozTocId0005" class="mozTocH1"></a>Gameクラスの作成</h1>
    <h2>Gameクラスの作成</h2>
    <p>Gameクラスを作成しましょう。Gameクラスの重要な役割は次の3つ。<br>
      これがあれば前期のようにGameクラスに処理を書いて開発できる！</p>
    <ul>
      <li>初期処理Init()</li>
      <li>更新処理Update()</li>
      <li>描画処理Draw()</li>
    </ul>
    <p><br>
    </p>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「Game」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Game.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef GAME_H_<br>
      #define GAME_H_<br>
      <br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <br>
      class Game<br>
      {<br>
      public :<br>
      &nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↓{ }を.hに書くことでcppに分けて書くはずの処理ぶぶんを.hに書いてもよい */<br>
      &nbsp;&nbsp;Game() {&nbsp; }; // 初期化コンストラクタ<br>
      &nbsp;&nbsp;~Game() {&nbsp; }; // 破棄処理デストラクタ<br>
      &nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
      &nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
      &nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
      <br>
      &nbsp;&nbsp;int x = 0; //staticじゃないintはここで=0で初期化できる<br>
      &nbsp;&nbsp;int vx = 0;<br>
      <br>
      };<br>
      #endif</p>
    <br>
    <p>次に対となるcppファイルを作成します。<br>
      ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞cppファイル<br>
      「Game」という名前でcppファイルを作り、クラスの処理を実装します。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Game.h"<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10; // ボスの初期速度<br>
      }<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10; //画面端で移動方向反転<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // ボス画像のX位置の更新<br>
      <br>
      }<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      }</p>
    <h2>【Gameクラスを使って】表示してみる</h2>
    <p><code>main.cpp</code>のプログラムを変更し、画像が正しくGameクラスで表示できるかテストします。</p>
    <p class="source">#include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Image.h"&nbsp;// 画像読み込みクラス<br>
      <em>#include "Game.h"&nbsp;</em><br>
      <br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;//表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;// これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;SetDrawScreen(DX_SCREEN_BACK);<br>
      <br>
      &nbsp;&nbsp;// Init初期化処理<br>
      &nbsp;&nbsp;<em>Game game; //Gameの定義と同時にC++ではコンストラクタで初期化される<br>
        &nbsp;&nbsp;game.Init(); // gameのInit準備</em><br>
      <br>
      &nbsp;&nbsp;ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0) <br>
      &nbsp;&nbsp;{// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Update更新処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>game.Update(); // gameの更新処理</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Draw描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>game.Draw();</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <p><br>
    </p>
    <h1><a id="mozTocId0006" class="mozTocH1">自機の作成</a></h1>
    <h2>プレイヤを操作するには便利クラスInputクラスが必須！</h2>
    <p>Inputクラスを作成しましょう。</p>
    <ul>
      <li>static int のstaticタイプの変数は.hだけではシンボリックエラーになるのでこのためだけに最低限.cppファイルを作成する必要がある</li>
    </ul>
    <p> </p>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「Input.h」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Input.h</code>に以下を実装</p>
    <p class="source">#ifndef INPUT_H_<br>
        #define INPUT_H_<br>
        <br>
        #include "DxLib.h"<br>
      <br>
      <br>
      // 入力クラス<br>
      class Input<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;static int prevState; // 1フレーム前の状態<br>
      &nbsp;&nbsp;static int currentState; // 現在の状態<br>
      <br>
      &nbsp;&nbsp;// 初期化。最初に1回だけ呼んでください。<br>
      &nbsp;&nbsp;static void Init()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;prevState = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;currentState = 0;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 最新の入力状況に更新する処理。<br>
      &nbsp;&nbsp;// 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
      &nbsp;&nbsp;static void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;prevState = currentState;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;currentState = &nbsp;GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// ボタンが押されているか？<br>
      &nbsp;&nbsp;static bool GetButton(int buttonId)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 今ボタンが押されているかどうかを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return (currentState &amp; buttonId) != 0;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// ボタンが押された瞬間か？<br>
      &nbsp;&nbsp;static bool GetButtonDown(int buttonId)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 今は押されていて、かつ1フレーム前は押されていない場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return ((currentState &amp; buttonId) &amp; ~(prevState &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// ボタンが離された瞬間か？<br>
      &nbsp;&nbsp;static bool GetButtonUp(int buttonId)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1フレーム前は押されていて、かつ今は押されていない場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return ((prevState &amp; buttonId) &amp; ~(currentState &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;}<br>
      }<em>;&nbsp;//←【注意】クラス定義の終わりにはコロンが必要だよ！</em><br>
      <br>
      #endif<em>&nbsp;&nbsp;//ここでエラー出た人は↑【注意】の;コロン忘れ</em></p>
    <br>
    <p>次に対となるcppファイルを作成します。<br>
      ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞cppファイル<br>
      「Input.cpp」という名前でcppファイルを作ります(たった2行の初期化static int変数の初期化のために必須)。<br>
      <br>
      <code>Input.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Input.h"<br>
      <br>
      int <em>Input::</em>prevState <em>{ 0 }</em>; // 1フレーム前の状態<br>
      int <em>Input::</em>currentState <em>{ 0 }</em>; // 現在の状態<br>
      <em>// ↑static intのときはこの行書かないとシンボリックエラーになる件(このためだけにcpp書かなきゃならん)</em><br>
      <br>
    </p>
    <p>Playerクラスを作成する前に、忘れずにプレイヤ画像はImageフォルダにコピー貼り付けしましょう。<br>
      Imageフォルダにコピーしたらプロジェクトで</p>
    <p>次は画像ファイルをプロジェクトに追加します。画像は【プロジェクトを右クリックで「追加」→「既存の項目」で画像を追加】します。<br>
      <img src="image/player_image_add.gif" alt=""><br>
      <br>
      <code>Image.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;static void Load();<br>
      <br>
      &nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;<em>static int player; //プレイヤ画像のハンドラ</em><br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
      <br>
      int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      <em>int Image::player{-1};</em><br>
      <br>
      void Image::Load()<br>
      {<br>
      &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;<em>player= LoadGraph("Image/player.png");<br>
        &nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      }</p>
    <br>
    <br>
    <h2><a id="mozTocId00061" class="mozTocH1"></a>Playerクラスの作成</h2>
    <p>Playerクラスを作成しましょう。<br>
      Playerクラスをつくるだけで安心すると【落とし穴】があります。Game.cppでInput.Update();を忘れるとプレイヤが動きません。</p>
    <p>Update()やDraw()やInput.Update()を忘れないように注意して進めましょう。<br>
    </p>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「Player.h」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Player.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <br>
      class Player<br>
      {<br>
      public:<br>
      &nbsp;<em>&nbsp;</em>const float MoveSpeed = <em>6;</em> // 移動速度<br>
      <br>
      &nbsp;<em>&nbsp;</em>float x; // x座標<br>
      &nbsp;<em>&nbsp;</em>float y; // y座標<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;// x : 初期位置x<br>
      &nbsp;&nbsp;// y : 初期位置y<br>
      &nbsp;<em>&nbsp;</em>Player(float x, float y)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;x = x</em>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;y = y</em>;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;<em>&nbsp;</em>void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(<em>&nbsp;</em>PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input<em>::</em>GetButton(<em>&nbsp;</em>PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input<em>::</em>GetButton(<em>&nbsp;</em>PAD_INPUT_UP))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input<em>::</em>GetButton(<em>&nbsp;</em>PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 実際に位置を動かす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;<em>&nbsp;</em>void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;<em>&nbsp;</em>DrawRotaGraphF(x, y, 1, 0, <em>Image::</em>player<em>, TRUE</em>);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>Game.h</code>にPlayerを追加します：</p>
    <p class="source">#ifndef GAME_H_<br>
      #define GAME_H_<br>
      <br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <em>#include "Player.h"</em><br>
      <br>
      class Game<br>
      {<br>
      public :<br>
      &nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↓{ }を.hに書くことでcppに分けて書くはずの処理ぶぶんを.hに書いてもよい */<br>
      &nbsp;&nbsp;Game() {&nbsp; }; // 初期化コンストラクタ<br>
      &nbsp;&nbsp;~Game() {&nbsp; }; // 破棄処理デストラクタ<br>
      &nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
      &nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
      &nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
      <br>
      &nbsp;&nbsp;int x = 0; //staticじゃないintはここで=0で初期化できる<br>
      &nbsp;&nbsp;int vx = 0;<br>
      <br>
      &nbsp;&nbsp;<em>Player player{ 100, Screen::Height / 2 }; // 自機の初期化</em><br>
      };<br>
      #endif</p>
    <p>次にGame.cppファイルにUpdateとDraw処理を追加してプレイヤの動作を確認しましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Game.h"<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10; // ボスの初期速度<br>
      }<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;<em>Input::Update();&nbsp;//【注意】これ忘れるとキー入力押してもキャラ動かない</em><br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10; //画面端で移動方向反転<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // ボス画像のX位置の更新<br>
      <br>
      &nbsp;&nbsp;<em>player.Update(); // プレイヤの更新【忘れるとプレイヤが動かない】</em><br>
      }<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;<em>player.Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】</em><br>
      }</p>
    <p>さて、無事にプレイヤをキー入力(↑↓←→)で動かせるようになりましたか？？？。</p>
    <br>
    <ul>
      <li>【プレイヤ画像が出ない】→Game.cppで【player.Draw();しましたか？】</li>
      <li>【プレイヤ画像が動かない1】→Game.cppで【player.Update();しましたか？】</li>
      <li>【プレイヤ画像が動かない2】→Game.cppで【Input.Update();しましたか？】</li>
    </ul>
    <br>
    <h2>√2の定義</h2>
    <p>【C++でも】斜め方向の移動速度を√2で割って補正するために、自分用数学定義クラスを作ってみましょう。ソリューションエクスプローラーのプロジェクトを右クリックし、追加＞ヘッダファイル(.h)<br>
      MyMath.hという名前でヘッダファイルを生成し、そのファイルにクラスを記述します。</p>
    <p><code>MyMath.h</code>を編集します：</p>
    <p class="source">#ifndef _MYMATH_H<br>
      #define _MYMATH_H<br>
      // 数学関連クラス<br>
      class MyMath<br>
      {<br>
      public: <br>
      &nbsp; // C ++標準では、静的static定数の【整数型】または【列挙型】のみをクラス内で初期化できます。<br>
      &nbsp; // これが、一部の初期化が許可されているのに他のstatic floatなどが初期化できない理由です。<br>
      <br>
      &nbsp; // ルート2(変数名の定義だけ)<br>
      static const float Sqrt2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // = 1.41421356237f;<br>
      <br>
      }; // 【注意】セミコロン抜けで【宣言が必要ですエラー】<br>
      <br>
      #endif // 【宣言が必要ですエラーは上のセミコロン抜け】</p>
    <br>
    <br>
    <br>
    <p><code>MyMath.cpp</code>を編集して変数名に1.41421356237f を 割り当てます。</p>
    <p class="source">#include "MyMath.h"<br>
      <br>
      const float MyMath::Sqrt2 = 1.41421356237f;//(floatは有効桁は実質7桁まで正確だがそれ以降は環境によって誤差出る)<br>
      <br>
    <p><br>
      <br>
      定義だけじゃなく、実際にプレイヤを動かしているPlayer.hも編集しなきゃ意味がないよ！お忘れなく！！<br>
      <code>Player.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <em>#include "MyMath.h"</em><br>
      <br>
      class Player<br>
      {<br>
      public:<br>
      &nbsp;const float MoveSpeed = 6; // 移動速度<br>
      <br>
      &nbsp;float x; // x座標<br>
      &nbsp;float y; // y座標<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;// x : 初期位置x<br>
      &nbsp;&nbsp;// y : 初期位置y<br>
      &nbsp;Player(float x, float y)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// 斜め移動も同じ速度になるように調整<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (vx != 0 &amp;&amp; vy != 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx /= MyMath::Sqrt2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 実際に位置を動かす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::player, TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <br>
    <h1><a id="mozTocId0007" class="mozTocH1"></a>自機弾PlayerBulletクラスの作成</h1>
    <h2>PlayerBulletクラスを作成しましょう。 </h2>
    <br>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「PlayerBullet.h」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>PlayerBullet.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      <br>
      // 自機弾クラス<br>
      class PlayerBullet<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      <br>
      &nbsp;&nbsp;float x; // x座標<br>
      &nbsp;&nbsp;float y; // y座標<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;PlayerBullet(float x, float y)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += Speed;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      <br>
      #endif</p>
    <br>
    <code>Image.h</code>に自機弾PlayerBullet画像定義を追加します：
    <p></p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;static void Load();<br>
      <br>
      &nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int player; //プレイヤ画像のハンドラ<br>
      &nbsp;&nbsp;<em>static int playerBullet; //プレイヤの弾画像のハンドラ</em><br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
      <br>
      int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      int Image::player{-1};<br>
      <em>int Image::playerBullet{-1};</em><br>
      <br>
      void Image::Load()<br>
      {<br>
      &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;player= LoadGraph("Image/player.png");<br>
      &nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;<em>playerBullet = LoadGraph("Image/player_bullet.png");<br>
        &nbsp;&nbsp;assert(playerBullet!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      }</p>
    <br>
    <br>
    <br>
    <p><code>Game.h</code>にPlayerBulletを追加します：</p>
    <p class="source">#ifndef GAME_H_<br>
      #define GAME_H_<br>
      <br>
      <em>#include&nbsp;&lt;vector&gt;//C#のListリストの代わりのC++版<br>
        #include&nbsp;&lt;memory&gt;//スマートなポインタを使うのに必要(shared_ptrなど)</em><br>
      <br>
      #include&nbsp;"Image.h"<br>
      #include&nbsp;"Screen.h"<br>
      <br>
      <em>#include&nbsp;"Player.h"<br>
        <br>
        <br>//前方宣言でPlayerという【ポインタの型】があることだけは宣言しておく(.hで定義されている型の定義はロードするが.cppの実装はロードしない<br>
        class&nbsp;Player;&nbsp;//←【エラー地獄に注意！】ここにPlayerクラスがあるものとして書くことで【循環相互インクルード問題】を回避<br>
        class&nbsp;PlayerBullet;</em><br>
      <br>
      class&nbsp;Game<br>
      {<br>
      public&nbsp;:<br>
      &nbsp;&nbsp;Game()&nbsp;{}; // 初期化コンストラクタ<br>
      &nbsp;&nbsp;~Game()&nbsp;{}; // 破棄処理デストラクタ<br>
      &nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
      &nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
      &nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
      <br>
      &nbsp;&nbsp;int x = 0;<br>
      &nbsp;&nbsp;int vx = 0;<br>
      <br>
      &nbsp;&nbsp;<em>std::shared_ptr&lt;Player&gt;&nbsp;player{ std::make_shared&lt;Player&gt;(100, Screen::Height / 2, this) }; // 自機の初期化</em><br>
      &nbsp;&nbsp;<em>//↑プレイヤを回し読みポインタ型に。std::make_shared&lt;Player&gt;でメモリ上に実体を生成<br>
        &nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト</em><br>
      &nbsp;&nbsp;//&nbsp;List↑と同じvector&nbsp;↑【shared_ptr】<br>
      <br>
      &nbsp;&nbsp;//&nbsp;★【shared_ptr】とは【データの回し読み(読まれなくなったら廃棄)】<br>
      &nbsp;&nbsp;//&nbsp;「兄弟で週刊少年ジャンプを【回し読みする】が<br>
      &nbsp;&nbsp;//&nbsp;おかんに【全員読み終わるまでは捨てられないように】する<br>
      &nbsp;&nbsp;//&nbsp;【読むつもりの人カウンタ】がゼロになると【おかんに捨てられる(リンク切れ廃棄)】」<br>
      <br>
      };<br>
      <br>
      #endif</p>
    <p>次にGame.cppファイルにUpdateとDrawに自機弾更新と描画の処理を追加しましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include&nbsp;"Game.h"<br>
      <br>
      <em>#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      };<br>
      <br>
      void&nbsp;Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;player<em>-&gt;</em>Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      &nbsp;&nbsp;<em>//ポインタ↑になると.から-&gt;でのアクセスになる</em><br>
      <br>
      &nbsp;&nbsp;<em>// 自機弾の更新処理<br>
        &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
        &nbsp;&nbsp;for (const auto&amp; b : playerBullets)<br>
        &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
        &nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>//【放置厳禁！！！このままここに弾削除処理書かないとメモリがどんどん減ってくよ(気づかないうちにね..怖)】</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;player<em>-&gt;</em>Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      &nbsp;&nbsp;<em>//ポインタ↑になると.から-&gt;でのアクセスになる</em><br>
      <br>
      &nbsp;&nbsp;<em>// 自機弾の描画処理<br>
        &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
        &nbsp;&nbsp;for (const auto&amp; b : playerBullets)<br>
        &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
        &nbsp;&nbsp;}</em><br>
      };<br>
    </p>
    <br>
    <br>
    <br>
    <p><code>Player.h</code>にPlayerBulletへの参照を得るため<em>Gameへのポインタ参照を追加</em>します：</p>
    <p class="source">#ifndef&nbsp;PLAYER_H_<br>
      #define&nbsp;PLAYER_H_<br>
      <br>
      #include&nbsp;"DxLib.h"<br>
      #include&nbsp;"Input.h"<br>
      #include&nbsp;"Image.h"<br>
      #include&nbsp;"MyMath.h"<br>
      <br>
      <em>class&nbsp;Game;&nbsp;//←【エラー地獄に注意！】ここにGameクラスがあるものとして書くことで【循環相互インクルード問題】を回避<br>
        <br>
        //↑Gameクラス内にPlayer変数を持っているからPlayerの定義が終わらないとGameの定義が完了しない(未定義エラー)<br>
        //【なのに】Playerクラス内にGame変数を持っているからPlayerの定義も終わらない！！(未定義エラー)<br>
        //【つまりPlayerとGameが互いに定義が終わるのを待つ】【循環相互インクルードどうぞどうぞ状態】になる<br>
        //【解決するために】とりあえずclass Game;とだけここに書いてGameは定義完了済と見せかけているわけです！<br>
        //[エラー:Playerは未定義です]とか[エラー:Gameは未定義です]とか定義してるはずのものが未定義の場合は大体これ！！</em><br>
      <br>
      class&nbsp;Player<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
      <br>
      &nbsp;&nbsp;float x; // x座標<br>
      &nbsp;&nbsp;float y; // y座標<br>
      <br>
      &nbsp;&nbsp;<em>Game* game { nullptr }; // Gameのインスタンスの参照<br>
        &nbsp;&nbsp;//↑ * ポインタ型です！プレイヤの【内部に】ゲームの情報を【メモリ実体として持つ】と<br>
        &nbsp;&nbsp;//そのプレイヤを親のゲームがもつと【延々とループで終わりなきメモリ爆発ループ】になるから<br>
        &nbsp;&nbsp;//メモリに対しての参照=【レコードの針をGameに指して】【Gameの住所アドレスだけをプレイヤ内部に持つ】</em><br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;// x : 初期位置x<br>
      &nbsp;&nbsp;// y : 初期位置y<br>
      &nbsp;&nbsp;Player(float x, float y<em>, Game* game</em>)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;game = game;</em><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;<em>void Update();//【★←Player.cppを新規作成してそちらに処理を書き移す】</em><br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;<em>void Draw();//【★←Player.cppを新規作成してそちらに処理を書き移す】</em><br>
      <br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>↑Player.hにあった上記処理部分を↓Player.cppを新規作成して書き移します</code></p>
    <p><code>Player.cpp</code>にPlayerBulletの発射処理を追加します：</p>
    <p class="source"> #include&nbsp;"Player.h"<br>
      <br>
      <em>#include&nbsp;"Game.h"&nbsp;//&nbsp;★game-&gt;playerBulletsなどClass Game;でカバーできない【定義の内部のplayerBulletsにアクセスするのでインクルード必要】<br>
        #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★弾を生成して【使う処理があるのでインクルード必要】</em><br>
      <br>
      <br>
      <br>
      // 更新処理【書き移す際にはPlayer::という形で::所属が必要になります】<br>
      void&nbsp;<em>Player::</em>Update()<br>
      {<br>
      &nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
      &nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
      <br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
      &nbsp;&nbsp;if (vx != 0 &amp;&amp; vy != 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 実際に位置を動かす<br>
      &nbsp;&nbsp;x += vx;<br>
      &nbsp;&nbsp;y += vy;<br>
      <br>
      &nbsp;&nbsp;<em>// ボタン押下で自機弾を発射<br>
        &nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;【C#版→】game-&gt;playerBullets.Add(new PlayerBullet(x, y));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;C++ではAddがemplace_backに↓&nbsp;newがmake_shared↓に<br>
        &nbsp;&nbsp;&nbsp;&nbsp;game-&gt;playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(x, y));<br>
        &nbsp;&nbsp;}</em><br>
      }<br>
      <br>
      // 描画処理<br>
      void&nbsp;<em>Player::</em>Draw()<br>
      {<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::player, TRUE);<br>
      }<br>
      <br>
    </p>
    <br>
    <br>
    <br>
    <p>【確認してみましょう】ここまでで一旦弾が打てるかチェックしてみましょう！【メモリは削除されないバージョンなので要注意！！】</p>
    <br>
    <br>
    <br>
    <br>
    <h2><a id="mozTocId00071" class="mozTocH1"></a>循環参照・インクルードの罠</h2>
    <p>【さてここで大量のエラーで詰んだ人も多いのでは】おそらくは【Player.hに弾を弾を撃つ処理を書いたのでは】</p>
    <p>それにしても【なぜヘッダh.ファイルとcppファイルに書く違いだけで大量のエラー】が出てしまうのでしょう？</p>
    <br>
    <p> <img src="image/include_loop_error.png" alt="" style="width: 700px; height: 538px;"></p>
    <br>
    <p>原因である【循環参照・循環インクルード】について説明します。<br>
      実はインクルードしたPlayer.hやGame.hは【⇒ビルド】した際に【Player.hの中身が#include "Player.h"へとコピペ】されるのです<br>
      そして問題は相互に【Player.hで#include "Game.h"】⇔【Game.hで#include "Player.h"】すると<br>
      互いへの【コピペがループする】ため【延々とGameかPlayerの定義が完成せず】<br>
      結果、邪悪なことに【全然関係ないPlayerBulletが未定義などと、とばっちりエラーが起こる】のです</p>
    <p> <img src="image/include_loop.png" alt="" style="width: 672px; height: 382px;"></p>
    <br>
    <p>さてこの【循環参照・循環インクルード】への対策をどうするかが問題です。<br>
      <br>
      【1】 ヘッダ.hでのインクルードを避け.cppファイルでインクルードするのが基本的には有効です(ヘッダ.h同士が相互にコピペしあわないから)<br>
      【2】 しかし根本的には【★相互に参照しあう構造の設計自体すっきりさせたい】です。<br>
      <br>
      今はPlayer⇔Gameの1対1の関係でまだ把握可能ですが、ザコや敵の弾などが他に増えてくると<br>
      恐怖の三角関係や四角関係など【どこかで一周回ると無限インクルード発生】が起こってきます。<br>
      まだ【1対1の循環なら見抜ける】けど【★三角ループや四角ループは発見が難しすぎ】です。</p>
    <p> <img src="image/include_loop_meditator.png" alt="" style="width: 801px; height: 852px;"></p>
    <p>そう、相互に行き来する【★矢印を一つへ集中させる】のです。<br>
      こういったパターンを【★仲介者(Meditator)パターン】と呼びます。<br>
      このパターンは【循環参照問題以外にも色んな利点】があり多用されます。<br>
      一点に集中させれば【メモリの状況もここに集中します】し<br>
      ここを経由すれば【どこからでもどこへでも連絡でき指令が出せます】<br>
      そしていちいち初期化の時に【参照の連絡先の交換が必要なくなります】</p>
    <p>ついでにもう一つ【★唯一物(シングルトン)パターン】も取り入れておきます。</p>
    <p> <img src="image/include_loop_singleton.png" alt="" style="width: 565px; height: 946px;"></p>
    <p>こういった先人の生み出したパターンを【デザインパターン】といいます。</p>
    <p>有用なデザインパターンは23ほどあり、状況に合わせてうまく取り入れることが上級者への道で<br>
      変な構造で作っていると起こる面倒な時間のロスが減り【残業時間が減ります】<br>
      案外【ブラックな現場は構造のデザインそのものが悪かった】ことも多いです(なんかいちいちやりづらい環境)<br>
      こういう【構造自体に疑問を持てる人が開発のリーダーシップを取れる】と心地よく制作が進むので<br>
      時間とスキルに余裕ができたら将来のリーダーに向けて【デザイン構造パターン】を勉強するとよいかもしれません。</p>
    <br>
    <br>
    <p>さて、ではまず<code>Singleton.h</code>を追加しましょう。<br>
      コード中身は難しい文法が多いですが、<br>
      基本の要点は<br>
      <br>
      【1】「代入」「コピー」「実体ポインタへの直接アクセス」を★private:として【外部から禁止】<br>
      【2】「実体へは★GetInstance()関数経由でしかアクセスできない」よう窓口を絞り<br>
      【3】「テンプレ化」★template&lt;class T&gt;して何でも唯一化できるようになっています</p>
    <br>
    <h2><a id="mozTocId00072" class="mozTocH1"></a>シングルトン型:唯一物体タイプの追加</h2>
    <p>難しいコードなので導入するだけでも良いですが、<br>
      C++の「代入」「コピー」「テンプレ化」は基礎として大事なので頑張って6割ほどは理解できるようになりたいですね。<br>
      2,3年後上級者となって読み返して9割ほど理解できるようになるよう成長してゆきましょう。</p>
    <p><code>Singleton.h</code></p>
    <p class="source"> #ifndef SINGLETON_H_<br>
      #define SINGLETON_H_<br>
      <br>
      // テンプレートT型シングルトンSingleton&lt;～&gt; ～になんでも指定して唯一物にできる<br>
      // ★Singleton&lt;T&gt;型は【必ず唯一で複製不可】(使い方:どこからでもアクセスし変数を共有するクラス向き)<br>
      // ★ゲーム内の【どこからアクセスしても統一性が保たれる】(唯一だから)「クラス名と実体が一致」<br>
      template&lt;class T&gt;<br>
      class Singleton<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;// GetInstanceを通して【しか】T型クラスをつくれないうえに、<br>
      &nbsp;&nbsp;// ★作ったものは【かならず唯一で複製不可】<br>
      &nbsp;&nbsp;// それが【シングルトン型】！<br>
      &nbsp;&nbsp;// ゲーム中で唯一で複製不可にしたい【ゲームを一律管理するクラス】などに最適！<br>
      &nbsp;&nbsp;// https://teratail.com/questions/17416<br>
      &nbsp;&nbsp;// http://rudora7.blog81.fc2.com/blog-entry-393.html<br>
      &nbsp;&nbsp;// ②↓同じ関数の定義はプログラム全体で１つだけしか許されません。(static関数名は被らない)<br>
      &nbsp;&nbsp;static inline T&amp; GetInstance()<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;//①↓関数の中で定義されたstatic変数は、関数の定義毎に１つ領域が確保されます。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;static T instance; //メモリ上にstatic変数確保(静かに常に待機するinstance)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return instance; //①=(常駐)②=(唯一) ①と②両方満たすinstanceは【メモリ上に唯一】<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;//★【{}内のローカルstaticの特性:ラベル(上の例ではinstance)がリセットされずに常駐】https://monozukuri-c.com/langc-static-memory/<br>
      &nbsp;&nbsp;//つまり、ゲームマネージャなどを★リセットされず常駐状態にできるわけです<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;Singleton() {} // 外部でのインスタンス作成は禁止(protected:内部公開、外部禁止)<br>
      &nbsp;&nbsp;virtual ~Singleton() {} // 仮想デストラクタ(シングルトンを【継承するためには忘れちゃダメ】)<br>
      <br>
      private:&nbsp;&nbsp;//代入やコピーをprivateにして外部クラスからアクセスできないように【縛る】<br>
      &nbsp;&nbsp;void operator=(const Singleton&amp; obj) {} // 代入演算子禁止<br>
      &nbsp;&nbsp;Singleton(const Singleton&amp; obj) {} // コピーコンストラクタ禁止(コピーできない【唯一】)<br>
      &nbsp;&nbsp;static T* instance; // private:だから外部アクセスできない【GetInstance()経由しかアクセスできないように縛る】<br>
      };<br>
      <br>
      // いつもcppで書いたstatic変数初期化も★【Tテンプレートクラスだからすべて.hヘッダにまとめて書いた】<br>
      template&lt; class T &gt;<br>
      T* Singleton&lt; T &gt;::instance = 0; //cppでの定義を.h内に書いた(static変数はclass内で初期化できないから)<br>
      <br>
      #endif<br>
    </p>
    <br>
    <h2><a id="mozTocId00073" class="mozTocH1"></a>仲介マネージャーGameManagerの追加</h2>
    <p>続いて仲介の役割を担当する<code>GameManager.h</code>を作成します。</p>
    <p class="source"> #ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      <br>
      #include&nbsp;"Singleton.h"<br>
      <br>
      class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      class&nbsp;PlayerBullet;<br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機の初期化<br>
      <br>
      &nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;// List↑と同じvector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Game.h</code>からGameManager.hに移行した処理を消して代わりにGameMangerへの連絡先gmを確保します。</p>
    <p class="source">#ifndef GAME_H_<br>
      #define GAME_H_<br>
      <br>
      #include&nbsp;&lt;vector&gt;//C#のListリストの代わりのC++版<br>
      #include&nbsp;&lt;memory&gt;//スマートなポインタを使うのに必要(shared_ptrなど)<br>
      <br>
      #include&nbsp;"Image.h"<br>
      #include&nbsp;"Screen.h"<br>
      <em>#include&nbsp;"Input.h"</em><br>
      <br>
      <u>#include&nbsp;"Player.h"</u><br>
      <br>
      <u>class&nbsp;Player;&nbsp;//←【エラー地獄に注意！】ここにPlayerクラスがあるものとして書くことで【循環相互インクルードどうぞどうぞ問題】を回避<br>
        class&nbsp;PlayerBullet;</u><br>
      <br>
      <em>#include&nbsp;"GameManager.h"</em><br>
      <br>
      class&nbsp;Game<br>
      {<br>
      public&nbsp;:<br>
      &nbsp;&nbsp;Game()&nbsp;{}; // 初期化コンストラクタ<br>
      &nbsp;&nbsp;~Game()&nbsp;{}; // 破棄処理デストラクタ<br>
      <br>
      &nbsp;&nbsp;<em>//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
        &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る</em><br>
      <br>
      &nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
      &nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
      &nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
      <br>
      &nbsp;&nbsp;int x = 0;<br>
      &nbsp;&nbsp;int vx = 0;<br>
      <br>
      &nbsp;&nbsp;<u>std::shared_ptr&lt;Player&gt;&nbsp;player{ std::make_shared&lt;Player&gt;(100, Screen::Height / 2, this) }; // 自機の初期化<br>
        &nbsp;&nbsp;//↑プレイヤを回し読みポインタ型に。std::make_shared&lt;Player&gt;でメモリ上に実体を生成<br>
        &nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト</u><br>
      <br>
      };<br>
      <br>
      #endif</p>
    <p>次にGame.cppファイルのPlayerやPlayerBulletのアクセスをGamaManagerのgm経由に書き換えましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のように変更します：</p>
    <p class="source">#include "Game.h"<br>
      <br>
      <em>#include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      <br>
      &nbsp;&nbsp;<em>gm.player = std::make_shared&lt;Player&gt;((float)100, (float)(Screen::Height / 2)); // 自機の初期化</em><br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;<em>gm.</em>player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      &nbsp;&nbsp;//ポインタ↑になると.から-&gt;でのアクセスになる<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : <em>gm.</em>playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//【放置厳禁！！！このままここに弾削除処理書かないとメモリがどんどん減ってくよ(気づかないうちにね..怖)】<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;<em>gm.</em>player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      &nbsp;&nbsp;//ポインタ↑になると.から-&gt;でのアクセスになる<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : <em>gm.</em>playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      };<br>
    </p>
    <br>
    <p><code>Player.h</code>もGameManagerのgm経由でのアクセスにするので#include "Game.h"やGame*のポインタはなくなります。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      <br>
      <u>class Game;//←【エラー地獄に注意！】ここにGameクラスがあるものとして書くことで【循環相互インクルードどうぞどうぞ問題】を回避</u><br>
      <br>
      <em>#include&nbsp;"GameManager.h"</em><br>
      <br>
      class Player<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
      <br>
      &nbsp;&nbsp;float x; // x座標<br>
      &nbsp;&nbsp;float y; // y座標<br>
      <br>
      &nbsp;&nbsp;<em>//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
        &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る</em><br>
      <br>
      &nbsp;&nbsp;<u>Game* game { nullptr }; // Gameのインスタンスの参照<br>
        &nbsp;&nbsp;//↑ * ポインタ型です！プレイヤの【内部に】ゲームの情報を【メモリ実体として持つ】と<br>
        &nbsp;&nbsp;//そのプレイヤを親のゲームがもつと【延々とループで終わりなきメモリ爆発ループ】になるから<br>
        &nbsp;&nbsp;//メモリに対しての参照=【レコードの針をGameに指して】【Gameの住所アドレスだけをプレイヤ内部に持つ】</u><br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;// x : 初期位置x<br>
      &nbsp;&nbsp;// y : 初期位置y<br>
      &nbsp;&nbsp;Player(float x, float y<u>, Game* game</u>)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>this-&gt;game = game;</u><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理の関数定義<br>
      &nbsp;&nbsp;void Update();<br>
      <br>
      &nbsp;&nbsp;// 描画処理の関数定義<br>
      &nbsp;&nbsp;void Draw();<br>
      <br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>Player.cpp</code>もGameManagerのgm経由でのアクセスに書き換えます</p>
    <p class="source"> #include&nbsp;"Player.h"<br>
      <br>
      <u>#include "Game.h"</u><br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★弾を生成して【使う処理があるのでインクルード必要】<br>
      <br>
      // 更新処理【書き移す際にはPlayer::という形で::所属が必要になります】<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
      &nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
      <br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
      &nbsp;&nbsp;if (vx != 0 &amp;&amp; vy != 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 実際に位置を動かす<br>
      &nbsp;&nbsp;x += vx;<br>
      &nbsp;&nbsp;y += vy;<br>
      <br>
      &nbsp;&nbsp;// ボタン押下で自機弾を発射<br>
      &nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;【C#版→】game-&gt;playerBullets.Add(new PlayerBullet(x, y));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;C++ではAddがemplace_backに↓&nbsp;newがmake_shared↓に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>gm.</em>playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(x, y));<br>
      &nbsp;&nbsp;}<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::player, TRUE);<br>
      }<br>
      <br>
    </p>
    <h2><a id="mozTocId00074" class="mozTocH1"></a>【※メモリから弾を削除】自機弾PlayerBulletの削除処理</h2>
    <p>PlayerBulletクラスを改造しましょう。<br>
    </p>
    <p><code>PlayerBullet.h</code>の内容を次のように【改造】します：</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      <em>#include "Screen.h"</em><br>
      <br>
      // 自機弾クラス<br>
      class PlayerBullet<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      &nbsp;&nbsp;<em>const int VisibleRadius = 16; // 見た目の半径</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
      &nbsp;&nbsp;//【使用注意】int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ<br>
      <br>
      &nbsp;&nbsp;float x; // x座標<br>
      &nbsp;&nbsp;float y; // y座標<br>
      &nbsp;&nbsp;<em>bool isDead = false; // 死亡フラグ</em><br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;PlayerBullet(float x, float y)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += Speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// 画面外に出たら、死亡フラグを立てる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (x - VisibleRadius &gt; Screen::Width)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      </em> &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      <br>
      #endif</p>
    <br>
    <p>次にGame.cppファイルに自機弾PlayerBulletの【削除処理】を追加しましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      <br>
      &nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;((float)100, (float)Screen::Height / 2); // 自機の初期化<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
        &nbsp;&nbsp;<br>
        &nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
        &nbsp;&nbsp;// 非常に複雑な式に見えるがこれでisDeadのものを削除<br>
        &nbsp;&nbsp;// https://stackoverflow.com/questions/42723205/remove-if-from-a-stdvector-of-shared-pointers-with-a-member-function<br>
        &nbsp;&nbsp;gm.playerBullets.erase(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;std::remove_if(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int usingCount = -1;//テスト用コード(以下のコメントアウト部分は省略可)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if (ptr-&gt;isDead) usingCount = ptr.use_count();//おかんのコレ捨てるよカウンタ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//弾を捨てるまでの残り↑カウント(1だとisDeadがtrueなら0になり削除へ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.end()<br>
        &nbsp;&nbsp;);</em><br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      };<br>
    </p>
    <br>
    <p>さて、削除部分の処理が非常に複雑ですね。C#と比較してみましょう。<br>
      【C#】<br>
      playerBullets.RemoveAll(pb =&gt; pb.isDead);<br>
      【C++】<br>
    </p>
    <p class="source"> gm.playerBullets.erase(<br>
      &nbsp;&nbsp;std::remove_if(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int usingCount = -1;//テスト用コード(以下のコメントアウト部分は省略可)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if (ptr-&gt;isDead) usingCount = ptr.use_count();//おかんのコレ捨てるよカウンタ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//弾を捨てるまでの残り↑カウント(1だとisDeadがtrueなら0になり削除へ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}),<br>
      &nbsp;&nbsp;gm.playerBullets.end()<br>
      );<br>
    </p>
    <br>
    テスト用のコードを消して読みやすくしてみましょう。<br>
    【C++】<br>
    <p class="source"> gm.playerBullets.<em>erase</em>(<br>
      &nbsp;&nbsp;std::<em>remove_if</em>(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}),<br>
      &nbsp;&nbsp;gm.playerBullets.end()<br>
      );<br>
    </p>
    <br>
    これでもまだ複雑ですが、なぜ複雑に見えるか？<br>
    【実は二つの処理が同時に行われている】ためです。<br>
    <br>
    【1】erase処理&nbsp;:&nbsp;<a href="https://cpprefjp.github.io/reference/vector/vector/erase.html">指定した配列の要素を削除する処理です。</a><br>
    基本構文は<br>
    &nbsp;&nbsp;v.erase(【削除開始位置】, 【終了位置】);<br>
    で、プレイヤ弾の削除処理では<br>
    <p class="source"> gm.playerBullets.erase(<br>
      &nbsp;&nbsp;……<br>
      &nbsp;&nbsp;&nbsp;&nbsp;……<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;……<br>
      &nbsp;&nbsp;&nbsp;&nbsp;……,<br>
      &nbsp;&nbsp;gm.playerBullets.end()<br>
      );<br>
    </p>
    よく見ると実は<br>
    gm.playerBullets.erase(【複雑な何か】,&nbsp;gm.playerBullets.end()&nbsp;);<br>
    となっているだけで実は【複雑な何か】 ～ 【end()終了位置】までの削除処理を行っているだけだとわかります。<br>
    こういう風にカンマ,や(かっこ)で区切られた構造を読み解く力が身に付けば複雑なコードでも<br>
    <br>
    【分解ステップを踏んでゆけば読み解けるようになります】<br>
    <br>
    そして次の「複雑な何か↓」も分解して読み解いてみましょう。<br>
    【2】remove_if処理&nbsp;:&nbsp;<a href="https://cpprefjp.github.io/reference/algorithm/remove_if.html">ある条件を①満たすものを【配列の後ろ】に、②満たさないものを【前に】集め①の始まりの位置を返す</a><br>
    基本構文はvを配列とすると<br>
    &nbsp;&nbsp;std::remove_if(v.begin(), v.end(), 条件);//配列v開始位置から終了位置まで「条件」に従い分離並べ替えし条件を満たす後ろに並べ替えられたものの分離された先頭位置を返す<br>
    つまりremove_ifは配列の後ろに条件を満たすものを分離する処理の担当で削除すべきものの先頭の位置をeraseに渡す担当だとわかります。<br>
    <br>
    要するに【1】と【2】で協力して「削除」と「分離並べ替え」を【分担していただけ】だったわけです。<br>
    <br>
    そしてその条件式が<br>
    <p class="source"> [](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {&nbsp;<em>return ptr-&gt;isDead;</em>&nbsp;}<br>
    </p>
    というスタイルでisDeadがtrueかfalseかreturnするという【ちょっとクセの強い条件式の書き方】で書かれていたということです。<br>
    <br>
    ここは【慣れてゆくしかないです】何度も見て【見慣れる】ことです。<br>
    <p></p>
    <p>しかし、なぜ【わざわざeraseとremove_ifを組合わせる必要があるのか】<br>
      それは【erase単体だけだと削除処理が遅い】からです。<br>
      vectorはメモリ上にデータが【隙間なく詰まってます】ゆえに【通常性能は速いです】<br>
      ただ引き換えに【あいだのデータを1個消す】だけで【隙間を埋める座席移動が発生】します。<br>
      100万のデータが座ってる中、中央付近のデータを1個消すだけで【50万回ぶん一つずつ隙間を埋める座席移動が発生】します。<br>
      これがeraseだけ異様に遅い理由です。<br>
      逆に映画館の座席で通路付近に座ってる人を思い浮かべてください。<br>
      映画が終わると通路付近の座席の人はすぐに立って横に出れば最初に通路への出られますよね。<br>
      ゆえに配列の【後ろから】一つ削除する【pop_back処理は速い】です。<br>
      したがって【後ろに消したいものを先に集めてしまえばよいのです】<br>
      これが【remove_if】処理です。remove_ifは条件を指定して【削除候補を後ろに並べ替えます】<br>
      ゆえに【2】remove_ifで先に後ろに並べ替えて【1】eraseでまとめて削除の【1】【2】のハイブリッドが必要なのです。<br>
    </p>
    <p> <img src="image/erase_remove_if_fast.png" alt="" style="width: 620px; height: 701px;"></p>
    <p>ただ、毎回この複雑なコードを書くと【コードが見にくくなる】ので【テンプレート化】に挑戦してみましょう。</p>
    <h2><a id="mozTocId00075" class="mozTocH1"></a>共通削除機能を【テンプレートとして定義】</h2>
    <p><code>GameManager.h</code>に共通の削除機能として【テンプレート機能】として追加してみましょう。</p>
    <p class="source"> #ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      <br>
      #include&nbsp;"Singleton.h"<br>
      <br>
      class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      class&nbsp;PlayerBullet;<br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機の初期化<br>
      <br>
      &nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;// List↑と同じvector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      <br>
      <br>
      &nbsp;&nbsp;<em>//&nbsp;★削除処理を共通テンプレート関数にする<br>
        &nbsp;&nbsp;//&nbsp;[共通テンプレート関数]https://programming-place.net/ppp/contents/cpp/language/009.html#function_template<br>
        &nbsp;&nbsp;template&nbsp;&lt;typename&nbsp;T,&nbsp;class&nbsp;T_if&gt;<br>
        &nbsp;&nbsp;void&nbsp;EraseRemoveIf(std::vector&lt;T&gt;&nbsp;&amp;v,&nbsp;T_if&nbsp;if_condition)<br>
        &nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特定のタイプT↑&nbsp;&nbsp;↑配列v&nbsp;&nbsp;&nbsp;↑条件式if_condition<br>
        &nbsp;&nbsp;&nbsp;&nbsp;v.erase(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::remove_if(v.begin(),&nbsp;v.end(),if_condition),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.end()&nbsp;//&nbsp;&nbsp;↓remove_ifの位置<br>
        &nbsp;&nbsp;&nbsp;&nbsp;);//例.[生][生][死][死][死]←&nbsp;v.end()の位置<br>
        &nbsp;&nbsp;};</em><br>
      <br>
      protected:<br>
      &nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p>そして<code>Game.cpp</code>の削除処理をシンプルに書き直します</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      <br>
      &nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;((float)100, (float)Screen::Height / 2); // 自機の初期化<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 自機弾の削除処理<br>
        &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<u>// 自機弾のリストから死んでるものを除去する<br>
        &nbsp;&nbsp;// 非常に複雑な式に見えるがこれでisDeadのものを削除<br>
        &nbsp;&nbsp;// https://stackoverflow.com/questions/42723205/remove-if-from-a-stdvector-of-shared-pointers-with-a-member-function<br>
        &nbsp;&nbsp;gm.playerBullets.erase(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;std::remove_if(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int usingCount = -1;//テスト用コード(以下のコメントアウト部分は省略可)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if (ptr-&gt;isDead) usingCount = ptr.use_count();//おかんのコレ捨てるよカウンタ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//弾を捨てるまでの残り↑カウント(1だとisDeadがtrueなら0になり削除へ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.end()<br>
        &nbsp;&nbsp;);</u><br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      };<br>
    </p>
    <p>さて、使う側はすっきり2行にまとまりました。<br>
      これなら削除するリストがenemiesやenemyBulletsなど増えてきても書きやすいです。</p>
    <p>テンプレート化template&nbsp;&lt;typename&nbsp;T&gt;を習得することは上級者への第一歩です。<br>
      C++だけでなく【C#でもテンプレート化ができます】ぜひ練習して習得してゆきましょう。<br>
      逆の目線で言うと【実は今まではテンプレート化された使いやすい機能を使わせてもらっていた】のです。意識せずに。<br>
      使う側が意識しなくていいほど【使いやすいテンプレート】を自力で作れることが理想形です。トライしてゆきましょう。<br>
    </p>
    <br>
    <h2><a id="mozTocId00076" class="mozTocH1"></a>【実験】メモリ浪費弾の実験</h2>
    <p> ここまでで一応弾の削除処理は書けました。しかし本当に弾が削除されているか実感がありません。<br>
      弾1個は現状では【かなり微小なメモリしか】使用しません。<br>
      実行して【メモリのグラフを見ても増えているか減っているか見えないほど微小です】<br>
      そこで【人為的に弾1個のメモリを大きくする】実験をしてみましょう。<br>
      注意が必要です【危険な実験】です(ほったらかすと)。【実験コードは必ず元に戻してください！！】<br>
      では実験を始めてみましょう。<br>
    </p>
    <p><code>PlayerBullet.h</code>の内容を次のように【改造】します：</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <br>
      // 自機弾クラス<br>
      class PlayerBullet<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      &nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
      &nbsp;&nbsp;<em>int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ</em><br>
      <br>
      &nbsp;&nbsp;float x; // x座標<br>
      &nbsp;&nbsp;float y; // y座標<br>
      &nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;PlayerBullet(float x, float y)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += Speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 画面外に出たら、死亡フラグを立てる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (x - VisibleRadius &gt; Screen::Width)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      <br>
      #endif</p>
    <br>
    <p>無駄メモリをあえて人為的に定義して弾を撃ってみましょう。<br>
      メモリの【グラフがうなぎ上りに上昇しなければ】プレイヤの弾に関してはメモリの削除と開放が成功している証拠です。<br>
      <br>
    </p>
    <p> <img src="image/memory_valance_and.png" alt="" style="width: 773px; height: 467px;"></p>
    <p>試しに<code>Game.cpp</code>で削除処理をわすれた場合の実験をしてみましょう。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      <br>
      &nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;((float)100, (float)Screen::Height / 2); // 自機の初期化<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 自機弾の削除処理<br>
        &nbsp;&nbsp;//gm.EraseRemoveIf(gm.playerBullets,<br>
        &nbsp;&nbsp;//&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      };<br>
    </p>
    <p> <img src="image/memory_leak.png" alt="" style="width: 728px; height: 433px;"></p>
    <p>実験が終わったら実験コードをもとに戻しましょう<code>PlayerBullet.h</code>の内容を次のようにします</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <br>
      // 自機弾クラス<br>
      class PlayerBullet<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      &nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
      &nbsp;&nbsp;<em>//【実験コード】int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ</em><br>
      <br>
      &nbsp;&nbsp;float x; // x座標<br>
      &nbsp;&nbsp;float y; // y座標<br>
      &nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;PlayerBullet(float x, float y)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += Speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 画面外に出たら、死亡フラグを立てる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (x - VisibleRadius &gt; Screen::Width)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      <br>
      #endif</p>
    <br>
    <p><code>Game.cpp</code>の削除処理ももとに戻しましょう。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      <br>
      &nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;((float)100, (float)Screen::Height / 2); // 自機の初期化<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 自機弾の削除処理<br>
        &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      };<br>
    </p>
    <br>
    <h2><a id="mozTocId00077" class="mozTocH1"></a>自機弾の角度を変えられるようにする</h2>
    数学の基礎のおさらい【cosθとsinθはx,yに対応する】【たて×よこの比率(範囲:min:-1～1:max)】<br>
    <img src="image/cos_sin.png" alt="" style="width: 785px; height: 444px;"><br>
    <br>
    <p><code>PlayerBullet.h</code>に角度をつけられるようにします</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      <em>#include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要</em><br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <br>
      // 自機弾クラス<br>
      class PlayerBullet<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      &nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
      &nbsp;&nbsp;//【実験コード】int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ<br>
      <br>
      &nbsp;&nbsp;float x; // x座標<br>
      &nbsp;&nbsp;float y; // y座標<br>
      &nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
      <br>
      &nbsp;&nbsp;<em>float vx; // x方向移動速度</em><br>
      &nbsp;&nbsp;<em>float vy; // y方向移動速度</em><br>
      &nbsp;&nbsp;<em>float angle; // 移動角度</em><br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;PlayerBullet(float x, float y<em>, float angle</em>)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;angle = angle;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>vx = (float)std::cos(angle) * Speed;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>vy = (float)std::sin(angle) * Speed;</em><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>x += vx;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>y += vy;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 画面外に出たら、死亡フラグを立てる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (<em>x + VisibleRadius &lt; 0 || x - VisibleRadius &gt; Screen::Width || <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y + VisibleRadius &lt; 0 || y - VisibleRadius &gt; Screen::Height</em>)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, <em>angle</em>, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      <br>
      #endif</p>
    <br>
    <p><code>MyMath.h</code>を編集します：</p>
    <p class="source">#ifndef _MYMATH_H<br>
      #define _MYMATH_H<br>
      // 数学関連クラス<br>
      class MyMath<br>
      {<br>
      public: <br>
      &nbsp;&nbsp;static const float Sqrt2;&nbsp;&nbsp;// = 1.41421356237f;<br>
      &nbsp;&nbsp;<em>static const float PI; // 円周率 3.14159265359f;</em><br>
      &nbsp;&nbsp;<em>static const float Deg2Rad; // 度からラジアンに変換する定数 PI / 180f;</em><br>
      <br>
      }; // 【注意】セミコロン抜けで【宣言が必要ですエラー】<br>
      <br>
      #endif //【宣言が必要ですエラーは上のセミコロン抜け】</p>
    <br>
    <p><code>MyMath.cpp</code>を編集して変数に数値を割り当て。</p>
    <p class="source">#include "MyMath.h"<br>
      <br>
      const float MyMath::Sqrt2 = 1.41421356237f;//(floatは有効桁は実質7桁まで正確だがそれ以降は環境によって誤差出る)<br>
      <em>const float MyMath::PI = 3.14159265359f; // 円周率<br>
        const float MyMath::Deg2Rad = MyMath::PI / 180; // 度からラジアンに変換する定数</em><br>
      <br>
    </p>
    <p><code>Player.cpp</code>のプレイヤの弾の生成を改修します。</p>
    <p class="source">#include "Player.h"<br>
      <em>#include "MyMath.h"<br>
      </em> <br>
      (前略)...................................<br>
      <br>
      &nbsp;&nbsp;// ボタン押下で自機弾を発射<br>
      &nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;C++ではAddがemplace_backに↓&nbsp;newがmake_shared↓に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(x, y, 0));//右</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(x, y, -15 * MyMath::Deg2Rad));//右上</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(x, y, +15 * MyMath::Deg2Rad));//右下</em><br>
      &nbsp;&nbsp;}<br>
      }<br>
      <br>
      (以下略) </p>

    <br>
    
    <h2><a id="mozTocId00078" class="mozTocH1"></a>vectorとlistの性能考察</h2>
    データのリスト(今回は弾のリスト)をどうデータ管理するかにはstd::vectorとstd::listの2パターンの格納方法が考えられます。
    <img src="image/vector_vs_list.png" alt="" style="width: 799px; height: 439px;"><br>
    <br>
    ※vectorは大量の弾が増えてきたときにまとまったメモリの領域を割り当てる必要が出てくるので、ランダムアクセスしたいなどの用途がない場合は、<br>
    list構造にしておくほうが、メモリの再確保などで遅くなる可能性を回避できるので、listに書き換えてみましょう。<br>
    <br>
    <p><code>GameManager.h</code>で管理しているPlayerBulletのvector配列をlist構造に変更してみましょう。</p>
    <p class="source"> #ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      <em>#include &lt;list&gt;</em><br>
      <br>
      #include&nbsp;"Singleton.h"<br>
      <br>
      class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      class&nbsp;PlayerBullet;<br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機の初期化<br>
      <br>
      &nbsp;&nbsp;std::<em>list</em>&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;// List↑と同じvector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      <br>
      <br>
      &nbsp;&nbsp;//&nbsp;★削除処理を共通テンプレート関数にする<br>
        &nbsp;&nbsp;//&nbsp;[共通テンプレート関数]https://programming-place.net/ppp/contents/cpp/language/009.html#function_template<br>
        &nbsp;&nbsp;template&nbsp;&lt;typename&nbsp;T,&nbsp;class&nbsp;T_if&gt;<br>
        &nbsp;&nbsp;void&nbsp;EraseRemoveIf(std::<em>vector</em>&lt;T&gt;&nbsp;&amp;v,&nbsp;T_if&nbsp;if_condition)<br>
        &nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特定のタイプT↑&nbsp;&nbsp;↑配列v&nbsp;&nbsp;&nbsp;↑条件式if_condition<br>
        &nbsp;&nbsp;&nbsp;&nbsp;v.erase(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::remove_if(v.begin(),&nbsp;v.end(),if_condition),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.end()&nbsp;//&nbsp;<em>&nbsp;</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;);<em>&nbsp;</em><br>
        &nbsp;&nbsp;};<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>

    <h1><a id="mozTocId0008" class="mozTocH1"></a>ベクトル構造体でX,Y,ZをVector3型でまとめて管理する</h1>
    <h2><a id="mozTocId00081" class="mozTocH1">ベクトルの基本</h2>
    <p>現状ではX,Yは別々の変数として定義していますが、これを数学のベクトルを扱うVector3型を定義してそちらに置き換えましょう(std::vectorとはつづりが同じだけどまったく別のもの)<br>

    <p><code>Vector3.h</code>を作成します(拡張も見越して3DのZ座標も導入しておきます)</p>
    <p class="source">#ifndef VECTOR3_H_<br>
      #define VECTOR3_H_<br>
      <br>
      #include &lt;array&gt; //vector配列と基本同じだが【有限】の個数である違いがあるxyzなど3つ固定の個数ならstd::vectorよりstd::array型がよい<br>
      #include &lt;cmath&gt;<br>
      #include &lt;limits&gt; // 無限大などをstd::numeric_limits&lt;float&gt;::infinity()で取得<br>
      <br>
      //★【UnityのVector演算コード】<br>
      // https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
      <br>
      // 3変数x,y,zを持つ構造体。3つの数字をまとめて扱うならXYZ座標以外にも使えるよ。x,y,z別々に足したり引いたり面倒でしょう。<br>
      struct Vector3<br>
      {<br>
      // struct型はpublic:がなくてもデフォルトがpublic:&nbsp;&nbsp;private:を書けばプライベートにもできる<br>
      &nbsp;&nbsp;float x = 0; // x座標<br>
      &nbsp;&nbsp;float y = 0; // y座標<br>
      &nbsp;&nbsp;float z = 0; //【3D】z座標<br>
      <br>
      &nbsp;&nbsp;Vector3() = default; // デフォルト初期化コンストラクタ<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Vector3(float x, float y, float z = 0.f) //初期化 z = 0.fでzのデフォルト値があるので2Dとしても使える<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z = z;<br>
      &nbsp;&nbsp;} <br>
      &nbsp;&nbsp;//仮想デストラクタ<br>
      &nbsp;&nbsp;virtual ~Vector3()<br>
      &nbsp;&nbsp;{<br>
      <br>
      &nbsp;&nbsp;}<br>
      <br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p><br>
    基本的にはX,Y,Zを上記コードでVector3型で一つの定義にまとめることができます。<br>
    <br>
    次に少し便利にすべく少しトリッキーですが、共用体を使ってx,y,zをstd::array型でxyzとしてまとめて扱えるようにしてみましょう<br>
    <p><code>Vector3.h</code>を書き換えます。</p>
    <p class="source">#ifndef VECTOR3_H_<br>
      #define VECTOR3_H_<br>
      <br>
      #include &lt;array&gt; //vector配列と基本同じだが【有限】の個数である違いがあるxyzなど3つ固定の個数ならstd::vectorよりstd::array型がよい<br>
      #include &lt;cmath&gt;<br>
      #include &lt;limits&gt; // 無限大などをstd::numeric_limits&lt;float&gt;::infinity()で取得<br>
      <br>
      //★【UnityのVector演算コード】<br>
      // https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
      <br>
      // 3変数x,y,zを持つ構造体。3つの数字をまとめて扱うならXYZ座標以外にも使えるよ。x,y,z別々に足したり引いたり面倒でしょう。<br>
      struct Vector3<br>
      {<br>
      // struct型はpublic:がなくてもデフォルトがpublic:&nbsp;&nbsp;private:を書けばプライベートにもできる<br>
      &nbsp;&nbsp;<em>//float x = 0; // x座標<br>
      &nbsp;&nbsp;//float y = 0; // y座標<br>
      &nbsp;&nbsp;//float z = 0; // z座標&nbsp;3つの定義をunionで配列xyzと共用することでxyz[1]=5.5f;とすると yも5.5となる【運命共用体】(メモリ上は同じ位置になる)<br>
      <br>
      &nbsp;&nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
		  &nbsp;&nbsp;&nbsp;&nbsp;struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float x;// x座標<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float y;// y座標<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float z;// z座標<br>
		  &nbsp;&nbsp;&nbsp;&nbsp;}; //[匿名共用体とは] https://zenn.dev/block/articles/beda29f11f05afc147ef<br>
		  &nbsp;&nbsp;&nbsp;&nbsp;std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
	    &nbsp;&nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる</em><br>

      &nbsp;&nbsp;Vector3() = default; // デフォルト初期化コンストラクタ<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Vector3(float x, float y, float z = 0.f) //初期化 z = 0.fでzのデフォルト値があるので2Dとしても使える<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;xyz = { x,y,z };// たった1行で書ける</em><br>
      &nbsp;&nbsp;} <br>
      &nbsp;&nbsp;//仮想デストラクタ<br>
      &nbsp;&nbsp;virtual ~Vector3()<br>
      &nbsp;&nbsp;{<br>
      <br>
      &nbsp;&nbsp;}<br>
      <br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p><br>
	  
    <h2><a id="mozTocId00082" class="mozTocH1">ベクトルの計算</h2>
    次にベクトル同士を足したり引いたり割ったりできるように、ベクトルの計算関数を追加しましょう。<br>
    <p><code>Vector3.h</code>を書き換えます。</p>
    <p class="source">#ifndef VECTOR3_H_<br>
      #define VECTOR3_H_<br>
      <br>
      #include &lt;array&gt; //vector配列と基本同じだが【有限】の個数である違いがあるxyzなど3つ固定の個数ならstd::vectorよりstd::array型がよい<br>
      #include &lt;cmath&gt;<br>
      #include &lt;limits&gt; // 無限大などをstd::numeric_limits&lt;float&gt;::infinity()で取得<br>
      <br>
      //★【UnityのVector演算コード】<br>
      // https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
      <br>
      // 3変数x,y,zを持つ構造体。3つの数字をまとめて扱うならXYZ座標以外にも使えるよ。x,y,z別々に足したり引いたり面倒でしょう。<br>
      struct Vector3<br>
      {<br>
      // struct型はpublic:がなくてもデフォルトがpublic:&nbsp;&nbsp;private:を書けばプライベートにもできる<br>
      &nbsp;&nbsp;//float x = 0; // x座標<br>
      &nbsp;&nbsp;//float y = 0; // y座標<br>
      &nbsp;&nbsp;//float z = 0; // z座標&nbsp;3つの定義をunionで配列xyzと共用することでxyz[1]=5.5f;とすると yも5.5となる【運命共用体】(メモリ上は同じ位置になる)<br>
      <br>
      &nbsp;&nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
		  &nbsp;&nbsp;&nbsp;&nbsp;struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float x;// x座標<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float y;// y座標<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float z;// z座標<br>
		  &nbsp;&nbsp;&nbsp;&nbsp;}; //[匿名共用体とは] https://zenn.dev/block/articles/beda29f11f05afc147ef<br>
		  &nbsp;&nbsp;&nbsp;&nbsp;std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
	    &nbsp;&nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>

      &nbsp;&nbsp;Vector3() = default; // デフォルト初期化コンストラクタ<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Vector3(float x, float y, float z = 0.f) //初期化 z = 0.fでzのデフォルト値があるので2Dとしても使える<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;xyz = { x,y,z };// たった1行で書ける<br>
      &nbsp;&nbsp;} <br>
      &nbsp;&nbsp;//仮想デストラクタ<br>
      &nbsp;&nbsp;virtual ~Vector3()<br>
      &nbsp;&nbsp;{<br>
      <br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;<em>// Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
      &nbsp;&nbsp;static const Vector3 zero;// = { 0.f,  0.f,  0.f };<br>
      &nbsp;&nbsp;static const Vector3 one; // = { 1.f,  1.f,  1.f };<br>
      &nbsp;&nbsp;static const Vector3 forward;// = { 0.f,  0.f,  1.f };<br>
      &nbsp;&nbsp;static const Vector3 back;   // = { 0.f,  0.f, -1.f };<br>
      &nbsp;&nbsp;static const Vector3 up;  // = { 0.f,  1.f,  0.f };<br>
      &nbsp;&nbsp;static const Vector3 down;// = { 0.f, -1.f,  0.f };<br>
      &nbsp;&nbsp;static const Vector3 left; // = {-1.f, 0.f,  0.f };<br>
      &nbsp;&nbsp;static const Vector3 right;// = { 1.f, 0.f,  0.f };<br>
      &nbsp;&nbsp;//[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
      &nbsp;&nbsp;static const Vector3 negativeInfinity;<br>
      &nbsp;&nbsp;//[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
      &nbsp;&nbsp;static const Vector3 positiveInfinity;<br>
<br>
<br>
      &nbsp;&nbsp;// 2つのベクトルの内積<br>
      &nbsp;&nbsp;static float dot(const Vector3& leftVec, const Vector3& rightVec)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return leftVec.x * rightVec.x + leftVec.y * rightVec.y + leftVec.z * rightVec.z; //普通にx同士,y同士,z同士掛けるだけ<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// 2つのベクトルの外積<br>
      &nbsp;&nbsp;static Vector3 cross(const Vector3& leftVec, const Vector3& rightVec)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return Vector3{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftVec.y * rightVec.z - leftVec.z * rightVec.y,  // x = 左y * 右z - 左z * 右y<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftVec.z * rightVec.x - leftVec.x * rightVec.z,  // y = 左z * 右x - 左x * 右z<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftVec.x * rightVec.y - leftVec.y * rightVec.x };// z = 左x * 右y - 左y * 右x //行列独特の特殊な掛け方<br>
      &nbsp;&nbsp;}<br>
<br>
<br>
      &nbsp;&nbsp;// ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)(スタティック版)<br>
      &nbsp;&nbsp;static float _sqrMagnitude(const Vector3& _vec)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return _vec.x * _vec.x + _vec.y * _vec.y + _vec.z * _vec.z; // x*x + y*y + z*z<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// ベクトルの長さ(0から点(x,y,z)までの距離)(スタティック版)<br>
      &nbsp;&nbsp;static float _magnitude(const Vector3& _vec)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return std::sqrt(_sqrMagnitude(_vec)); // √x*x + y*y + z*z<br>
      &nbsp;&nbsp;}<br>
<br>
<br>
      &nbsp;&nbsp;// destArrayにデータを保管しておく<br>
      &nbsp;&nbsp;Vector3& copyToArray(std::array&lt;float, 3&gt;& destArray)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;destArray = this-&gt;xyz;//配列としてコピー<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;// sourceArray配列からVector3データを生成<br>
      &nbsp;&nbsp;Vector3 fromArray(std::array&lt;float, 3&gt;& sourceArray)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return Vector3{ sourceArray[0], sourceArray[1], sourceArray[2] }; //配列から初期化 <br>
      &nbsp;&nbsp;}<br>
<br>
<br>
      &nbsp;&nbsp;// ベクトルの長さ(0から点(x,y,z)までの距離)<br>
      &nbsp;&nbsp;float magnitude()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return std::sqrt(x * x + y * y + z * z); // √(x*x + y*y + z*z)<br>
      &nbsp;&nbsp;};<br>
<br>
      &nbsp;&nbsp;// ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)<br>
      &nbsp;&nbsp;float sqrMagnitude()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return x * x + y * y + z * z; // x*x + y*y + z*z <br>
      &nbsp;&nbsp;};<br>
<br>
<br>
      &nbsp;&nbsp;// 正規化したベクトルを返す<br>
      &nbsp;&nbsp;Vector3 normalized()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float mag = magnitude();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (mag &lt; 0.00001f) // ほぼ0ベクトルか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Vector3{ x / mag, y / mag, z / mag }; // x / |x|, y / |y|, z / |z|<br>
      &nbsp;&nbsp;}<br>
<br>
<br>
<br>
      &nbsp;&nbsp;/*-----　演算子オーバーロード　-----*/<br>
<br>
      &nbsp;&nbsp;// 逆ベクトル<br>
      &nbsp;&nbsp;inline Vector3 operator - () const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this*-1;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// Vectorをそのまま足し合わせる<br>
      &nbsp;&nbsp;inline Vector3 operator + () const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// Vector同士の足し算 x,y,z個別に足し合わせる<br>
      &nbsp;&nbsp;Vector3 operator + (const Vector3 add_v3) const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Vector3 v3; //★*thisじゃダメな理由 a = vec1 + vec2のとき vec1の数値が書き変わったらあかんから<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.x = this-&gt;x + add_v3.x; //[コレはダメ] this->x = this->x + add_v3.x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.y = this-&gt;y + add_v3.y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.z = this-&gt;z + add_v3.z;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return v3;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// Vector同士の引き算 x,y,z個別に引き合わせる<br>
      &nbsp;&nbsp;Vector3 operator - (const Vector3 minus_v3) const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Vector3 v3;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.x = this-&gt;x - minus_v3.x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.y = this-&gt;y - minus_v3.y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.z = this-&gt;z - minus_v3.z;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return v3;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// Vector同士の掛け算 x,y,z個別に掛け合わせる<br>
      &nbsp;&nbsp;Vector3 operator * (float multiply_num) const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Vector3 v3;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.x = this-&gt;x * multiply_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.y = this-&gt;y * multiply_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.z = this-&gt;z * multiply_num;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return v3;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// Vector同士の割り算 x,y,z個別に割り合わせる<br>
      &nbsp;&nbsp;// 0.fでは割れないようにしてある<br>
      &nbsp;&nbsp;Vector3 operator / (float divide_num) const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (divide_num == 0.0f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Vector3 v3;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.x = this-&gt;x / divide_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.y = this-&gt;y / divide_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v3.z = this-&gt;z / divide_num;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return v3;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;Vector3& operator += (const Vector3 add_v3)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x += add_v3.x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y += add_v3.y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z += add_v3.z;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this; //*thisを返すことで v1 + v2 + v3見たく数珠繋ぎできる<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;Vector3& operator -= (const Vector3 minus_v3)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x -= minus_v3.x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y -= minus_v3.y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z -= minus_v3.z;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;Vector3& operator *= (float multiply_num)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x *= multiply_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y *= multiply_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z *= multiply_num;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// 0.fでは割れないようにしてある<br>
      &nbsp;&nbsp;Vector3& operator /= (float divide_num)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (divide_num == 0.0f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x /= divide_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y /= divide_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z /= divide_num;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// 代入演算子 x,y,zを全部 change_numに変える<br>
      &nbsp;&nbsp;Vector3& operator = (float change_num)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = change_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = change_num;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z = change_num;<br>
<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// 一致演算子 x,y,zを全部一致するか 一つでも違えばfalse<br>
      &nbsp;&nbsp;bool operator == (const Vector3& v3_other)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (this-&gt;x != v3_other.x) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (this-&gt;y != v3_other.y) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (this-&gt;z != v3_other.z) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return true;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// 不一致演算子 x,y,zを全部不一致か 一つでも同じならfalse<br>
      &nbsp;&nbsp;bool operator != (const Vector3& v3_other)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (this-&gt;x == v3_other.x) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (this-&gt;y == v3_other.y) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (this-&gt;z == v3_other.z) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return true;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;/*---- 以下 DXライブラリ向けにVector3とDX版Vectorの変換方法を用意  ---------------*/<br>
<br>
// DXlibを#includeしていればDX_LIB_Hも定義済みなので下記関数も定義される VECTORの定義はDXライブラリ版のVector3<br>
#ifdef DX_LIB_H<br>
      &nbsp;&nbsp;// Vector3からDxLibのVECTORへの変換<br>
      &nbsp;&nbsp;VECTOR Vec3ToVec()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;VECTOR Result;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Result.x = this-&gt;x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Result.y = this-&gt;y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Result.z = this-&gt;z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return Result;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// 左辺値がDXのVECTOR型のときの=代入対応<br>
      &nbsp;&nbsp;inline operator VECTOR() const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;VECTOR Result;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Result.x = this-&gt;x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Result.y = this-&gt;y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Result.z = this-&gt;z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return Result;<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;// 右辺値がDXのVECTOR型のときの=代入対応<br>
      &nbsp;&nbsp;Vector3 operator=(const VECTOR& other)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = other.x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = other.y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z = other.z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
#endif</em><br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p><br>
<br>
	  
      <code>Vector3.cppを新規作成して</code>その内容を次のようにします：<br>
<p class="source">#include "Vector3.h"<br>
      <br>
// Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
Vector3 const Vector3::zero = Vector3(0.f,  0.f,  0.f );<br>
Vector3 const Vector3::one  = Vector3(1.f,  1.f,  1.f );<br>
Vector3 const Vector3::forward = Vector3(0.f,  0.f,  1.f );<br>
Vector3 const Vector3::back    = Vector3(0.f,  0.f, -1.f );<br>
Vector3 const Vector3::up   = Vector3(0.f,  1.f,  0.f );<br>
Vector3 const Vector3::down = Vector3(0.f, -1.f,  0.f );<br>
Vector3 const Vector3::left  = Vector3(-1.f,  0.f, 0.f );<br>
Vector3 const Vector3::right = Vector3(1.f,  0.f,  0.f );<br>
//[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
Vector3 const Vector3::negativeInfinity = Vector3(-std::numeric_limits&lt;float&gt;::infinity(), -std::numeric_limits&lt;float&gt;::infinity(), -std::numeric_limits&lt;float&gt;::infinity() );<br>
//[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
Vector3 const Vector3::positiveInfinity = Vector3(std::numeric_limits&lt;float&gt;::infinity(), std::numeric_limits&lt;float&gt;::infinity(), std::numeric_limits&lt;float&gt;::infinity() );<br>
</p>
<br>
	プレイヤや弾のクラスのx,yをVector3型に置きかえてみます<br>
	  <p><code>PlayerBullet.h</code>のx,yをVector3型におきかえます。</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      #include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <em>#include "Vector3.h"</em><br>
      <br>
      // 自機弾クラス<br>
      class PlayerBullet<br>
      {<br>
      public:<br>
	    <br>
      &nbsp;&nbsp;<em>Vector3 position; // xyz座標</em><br>
      &nbsp;&nbsp;<em>Vector3 v; // xyz方向移動速度</em><br>
	    <br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      &nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
      &nbsp;&nbsp;<br>
      <br>
      <br> 
      &nbsp;<u>float x; // x座標<br>
      &nbsp;float y; // y座標</u><br>
      <br>
      &nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
      <br>
      &nbsp;&nbsp;<u>float vx; // x方向移動速度<br>
      &nbsp;&nbsp;float vy; // y方向移動速度</u><br>
      &nbsp;&nbsp;float angle; // 移動角度<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;PlayerBullet(<em>Vector3 pos</em>, float angle)<em> : position { pos }</em><br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;</u><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angle = angle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>v = Vector3((float)std::cos(angle) * Speed,(float)std::sin(angle) * Speed, 0);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>vx = (float)std::cos(angle) * Speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy = (float)std::sin(angle) * Speed;</u><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>position += v;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>x += vx;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 画面外に出たら、死亡フラグを立てる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (<em>position.x + VisibleRadius &lt; 0 || position.x - VisibleRadius &gt; Screen::Width || <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.y + VisibleRadius &lt; 0 || position.y - VisibleRadius &gt; Screen::Height</em>)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(<em>position.x, position.y</em>, 1, angle, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      <br>
      #endif</p>
    <br>
      <code>Player.h</code>の内容を次のようにします：<br>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      <em>#include "Vector3.h"</em><br>
<br>
      #include "GameManager.h"<br>
      <br>
      class Player<br>
      {<br>
      public:<br>
      <br>
      &nbsp;&nbsp;<em>Vector3 position; // xyz座標</em><br>
      <br>
      &nbsp;const float MoveSpeed = 6; // 移動速度<br>
      <br> 
      &nbsp;<u>float x; // x座標<br>
      &nbsp;float y; // y座標</u><br>
      <br>
      &nbsp;&nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
        &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;<em>// pos : 初期位置</em><br>
      &nbsp;Player(<em>Vector3 pos</em>) <em>: position { pos }</em><br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;</u><br>
      &nbsp;&nbsp;}<br>
	    <br>
      &nbsp;&nbsp;<em>virtual ~Player() {}; // 仮想デストラクタ ※無いと【削除された関数を参照しようとしてますエラー】が出るかも</em><br>

      <br>
      &nbsp;&nbsp;// 更新処理の関数定義<br>
      &nbsp;&nbsp;void Update();<br>
      <br>
      &nbsp;&nbsp;// 描画処理の関数定義<br>
      &nbsp;&nbsp;void Draw();<br>
      <br>
      };<br>
      <br>
      #endif</p>
    <p><code>Player.cpp</code>もVector3での処理に書き換えます</p>
    <p class="source"> #include&nbsp;"Player.h"<br>
      <br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★弾を生成して【使う処理があるのでインクルード必要】<br>
      <br>
      // 更新処理【書き移す際にはPlayer::という形で::所属が必要になります】<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;<u>float vx = 0; // x方向移動速度<br>
      &nbsp;&nbsp;float vy = 0; // y方向移動速度</u><br>
      &nbsp;&nbsp;<em>Vector3 v{0,0,0}; // xyz方向移動速度</em><br>
      <br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>v.x</em> = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>v.x</em> = MoveSpeed; // 右<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>v.y</em> = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>v.y</em> = MoveSpeed; // 下<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
      &nbsp;&nbsp;if (<em>v.magnitude() > 0</em>)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>v /= MyMath::Sqrt2;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>vx /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;</u><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 実際に位置を動かす<br>
      &nbsp;&nbsp;<em>position += v;</em><br>
      &nbsp;&nbsp;<u>x += vx;<br>
      &nbsp;&nbsp;y += vy;</u><br>
      <br>
      &nbsp;&nbsp;// ボタン押下で自機弾を発射<br>
      &nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// C++ではAddがpush_backに↓ newがmake_shared↓に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(<em>position</em>, 0));//右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(<em>position</em>, -15 * MyMath::Deg2Rad));//右上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(<em>position</em>, +15 * MyMath::Deg2Rad));//右下<br>
      &nbsp;&nbsp;}
	    <br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;DrawRotaGraphF(<em>position.x, position.y</em>, 1, 0, Image::player, TRUE);<br>
      }<br>
      <br>
    </p>
	<p>次にGame.cppファイルのPlayerの生成処理をVector3に対応する形に書き換えましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のように変更します：</p>
    <p class="source">#include "Game.h"<br>
      <br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      <br>
      &nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;(<em>Vector3((float)100, (float)(Screen::Height / 2))</em>); // 自機の初期化<br>
      };<br>
      <br>
      <br>
      (中略)...<br>
      <br>
      };<br>
    </p>
	  
    <h1><a id="mozTocId0009" class="mozTocH1"></a>敵の作成【共通のGameObjectを継承する】</h1>
    <h2>Enemyクラスを作成するにあたって共通の基底(ベース)クラスとなるGameObjectを導入する</h2>
    <p>Enemyクラスを定義してそれを継承する形でZako0をつくることもできますが<br>
      その構造で作り進めると循環参照インクルードが起こってしまいがちです。<br>
      なぜなら、衝突判定で【PlayerBullet⇔Enemy⇔Playerの相互の矢印の参照ループが生まれやすくなります】<br>
      そこで共通の基底(ベース)クラスとなるGameObject、すなわち全てのものが継承する【ベースとなる継承元】を導入します。<br>
      これで矢印はGameObjectにまとまりオブジェクト同士の参照をせずに済みます。<br>
    </p>
    <p> <img src="image/include_base_gameobject.png" alt="" style="width: 702px; height: 758px;"></p>
    <h2><a id="mozTocId00091" class="mozTocH1">共通のベースとなるGameObjectを作成する</h2>
    <p><code>GameObject.h</code>を作成します(拡張も見越して3DのZ座標も導入しておきます)。</p>
    <p class="source">#ifndef GAMEOBJECT_H_<br>
      #define GAMEOBJECT_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Vector3.h"<br>
      #include &lt;string&gt; //文字タグのため<br>
      #include &lt;memory&gt; //回し読みポインタの定義のため<br>
      <br>
      // ゲーム上に表示される物体の基底クラス。<br>
      // プレイヤーや敵、アイテムなどはこのクラスを継承して作る。<br>
      class GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Vector3 position {0,0,0}; // xyz座標<br>
      &nbsp;&nbsp;Vector3 v{0,0,0}; //xyz方向の速度<br>
	    <br>
      &nbsp;&nbsp;bool isDead = false; // 死んだ（削除対象）フラグ<br>
	    <br>
      &nbsp;&nbsp;std::string tag = ""; // Zako0やBossやPlayerなど小カテゴリ<br>
      &nbsp;&nbsp;std::string typeTag = ""; // EnemyやPlayerなど大カテゴリ<br>
      &nbsp;&nbsp;std::string statusTag = ""; // 爆発状態やアイテムゲット状態など自由に使えばよい<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;GameObject(Vector3 pos) : position{ pos }<br>
      &nbsp;&nbsp;{<br>
      <br>
      &nbsp;&nbsp;} <br>
      &nbsp;&nbsp;//★仮想デストラクタ【忘れるとメモリがヤバいダメ絶対】<br>
      &nbsp;&nbsp;//【注意！】ベースの基底では必ず定義しないとstringなどが浪費され極悪なメモリ被害に発展<br>
      &nbsp;&nbsp;virtual ~GameObject()<br>
      &nbsp;&nbsp;{<br>
      <br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;//★純粋仮想関数=0は継承したZakoやPlayerなどの必須機能(継承したら絶対override必須縛り)<br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;virtual void Update() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;virtual void Draw() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      <br>
      &nbsp;&nbsp;//★virtual仮想関数は共通カスタマイズ機能(継承してもoverride必須ではないご自由にカスタマイズ)<br>
      &nbsp;&nbsp;// 衝突したときの関数(仮のvirtual関数←純粋仮想関数と違い継承してもoverride必須ではない)<br>
      &nbsp;&nbsp;virtual void OnCollision(std::shared_ptr&lt;GameObject&gt; other)<br>
      &nbsp;&nbsp;{<br>
      <br>
      &nbsp;&nbsp;}<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Enemy.h</code>を作成します。</p>
    <p class="source">#ifndef ENEMY_H_<br>
      #define ENEMY_H_<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      #include "GameManager.h"<br>
      <br>
      // 敵の基底クラス。<br>
      // 全ての敵は、このクラスを継承して作る。<br>
      // ★【勉強】abstract型はC++にない!!【純粋仮想関数】を使って作る<br>
      class Enemy : public GameObject<br>
      {<br>
      public:<br>
      <br>
      &nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Enemy(Vector3 pos) :  GameObject( pos ) // GameObjectをベースとして初期化処理を継承する<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;typeTag = "Enemy";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;virtual void Update() = 0;//virtual ～ = 0;で【純粋仮想関数に】これで【C#のabstract型に】<br>
      <br>
      &nbsp;&nbsp;// 描画処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;virtual void Draw() = 0; //virtual ～ = 0;で【純粋仮想関数に】【関数 = 0で未定義状態を表現】<br>
      <br>
      &nbsp;&nbsp;//【勉強】関数 = 0って何?と思った人は【関数もメモリ上では住所アドレスに過ぎない】ことを知ろう<br>
      &nbsp;&nbsp;// ★関数 = 0はつまり関数の住所ポインタの針が【メモリ上の何かを針で参照してない(住所不定無処理)】<br>
      &nbsp;&nbsp;// つまり【関数が未定義ってこと】＝【あいまい部分があるabstractクラスってこと】<br>
      &nbsp;&nbsp;//http://etc2myday.jugem.jp/?eid=204<br>
      &nbsp;&nbsp;//http://wisdom.sakura.ne.jp/programming/c/c54.html<br>
      &nbsp;&nbsp;//逆にいうと【関数を配列】にするっていうトリッキーなこともできる!<br>
      &nbsp;&nbsp;//http://www.ced.is.utsunomiya-u.ac.jp/lecture/2012/prog/p3/kadai3/virtualfunc2.php<br>
      <br>
      &nbsp;&nbsp;// 自機弾に当たったときの処理<br>
      &nbsp;&nbsp;virtual void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Player.h</code>も共通のベースとなるGameObjectを継承するように書き換えます。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      #include "Vector3.h"<br>
      <br>
      <em>#include&nbsp;"GameObject.h"</em><br>
      <br>
      #include&nbsp;"GameManager.h"<br>
      <br>
      <em>// 継承するときは↓ : public ～にする。publicをつけ忘れると色々エラー出るので注意</em><br>
      class Player <em>: public GameObject</em><br>
      {<br>
      public:<br>
	    <br>
      &nbsp;&nbsp;<em>//【★注意！】ここに【positionの定義が残ってるとGameObjectと被る】ので<br>
        &nbsp;&nbsp;// 名前の同じ変数が2つ【パラレルワールドに存在してしまう！】<br>
        &nbsp;&nbsp;// Playerからx=13,y=5に変えたつもりでも【ベースのGameObjectはx=0,y=0のままの不思議バグで混乱！】</em><br>
      &nbsp;&nbsp;<u>Vector3 position; // xyz座標</u><br>
	          <br>
      &nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
      <br>
      <br>
      &nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;// pos : 初期位置<br>
      &nbsp;&nbsp;Player(Vector3 pos) : <em>GameObject( pos ) //【忘れると】GameObjectの初期化処理が飛ばされて大混乱！</em><br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;virtual ~Player() {}; // 仮想デストラクタ<br>
	    <br>
      &nbsp;&nbsp;// 更新処理の関数定義<br>
      &nbsp;&nbsp;void Update();<br>
      <br>
      &nbsp;&nbsp;// 描画処理の関数定義<br>
      &nbsp;&nbsp;void Draw();<br>
      <br>
      };<br>
      <br>
      #endif</p>
    <p><code>PlayerBullet.h</code>もGameObjectを継承する形に書き換えます。</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      #include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include "Vector3.h"<br>
      <br>
      <em>#include "GameObject.h"</em><br>
      <br>
      // 自機弾クラス<br>
      <em>// 継承するときは↓ : public ～にする。publicをつけ忘れると色々エラー出るので注意</em><br>
      class PlayerBullet<em>: public GameObject</em><br>
      {<br>
      public:<br>
	    &nbsp;&nbsp;<em>//【★注意！GameObjectと被る変数は全部消す】</em><br>
      &nbsp;&nbsp;<u>Vector3 position; // xyz座標<br>
        &nbsp;&nbsp;Vector3 v; // xyz方向移動速度</u><br>
        <br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      &nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
      &nbsp;&nbsp;<br>
      <br>
	    &nbsp;&nbsp;<u>bool isDead = false; // 死亡フラグ</u><br>
      <br>
      &nbsp;&nbsp;float angle; // 移動角度<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;PlayerBullet(Vector3 pos, float angle) <em>: GameObject( pos )</em><br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;tag = "PlayerBullet";</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angle = angle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v = Vector3((float)std::cos(angle) * Speed, (float)std::sin(angle) * Speed, 0);<br>
      &nbsp;&nbsp;}<br>
      <br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;(中略)....................<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, angle, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      <br>
      #endif</p>
    <h2><a id="mozTocId00092" class="mozTocH1"></a>Zako0クラスの作成</h2>
    <p><code>Zako0.h</code>を作成します。</p>
    <p class="source">#ifndef ZAKO_0_H_<br>
      #define ZAKO_0_H_<br>
      <br>
      #include "Enemy.h"<br>
      #include "Image.h"<br>
      <br>
      // ザコ0クラス<br>
      class Zako0 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Zako0(Vector3 pos)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;: Enemy( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako0";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;position.x -= 1; // とりあえず左へ移動<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako0, TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Image.h</code>にザコ0,1,2,3と敵弾の画像定義を追加します：</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;static void Load();<br>
      <br>
      &nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int player; //プレイヤ画像のハンドラ<br>
      &nbsp;&nbsp;static int playerBullet; //プレイヤの弾画像のハンドラ<br>
      &nbsp;&nbsp;<em>static int enemyBullet16; //敵弾 画像のハンドラ(読込画像番号)</em><br>
      &nbsp;&nbsp;<em>static int zako0; //ザコ0 画像のハンドラ(読込画像番号)</em><br>
      &nbsp;&nbsp;<em>static int zako1; //ザコ1 画像のハンドラ(読込画像番号)</em><br>
      &nbsp;&nbsp;<em>static int zako2; //ザコ2 画像のハンドラ(読込画像番号)</em><br>
      &nbsp;&nbsp;<em>static int zako3; //ザコ3 画像のハンドラ(読込画像番号)</em><br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
      <br>
      int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      int Image::player{-1};<br>
      int Image::playerBullet{-1};<br>
      <em>int Image::enemyBullet16{-1};</em><br>
      <em>int Image::zako0{-1};</em><br>
      <em>int Image::zako1{-1};</em><br>
      <em>int Image::zako2{-1};</em><br>
      <em>int Image::zako3{-1};</em><br>
      <br>
      void Image::Load()<br>
      {<br>
      &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;player= LoadGraph("Image/player.png");<br>
      &nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;playerBullet = LoadGraph("Image/player_bullet.png");<br>
      &nbsp;&nbsp;assert(playerBullet!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;<em>enemyBullet16 = LoadGraph("Image/enemy_bullet_16.png");<br>
        &nbsp;&nbsp;assert(enemyBullet16!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      &nbsp;&nbsp;<em>zako0 = LoadGraph("Image/zako0.png");<br>
        &nbsp;&nbsp;assert(zako0!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      &nbsp;&nbsp;<em>zako1 = LoadGraph("Image/zako1.png");<br>
        &nbsp;&nbsp;assert(zako1!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      &nbsp;&nbsp;<em>zako2 = LoadGraph("Image/zako2.png");<br>
        &nbsp;&nbsp;assert(zako2!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      &nbsp;&nbsp;<em>zako3 = LoadGraph("Image/zako3.png");<br>
        &nbsp;&nbsp;assert(zako3!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      }<br>
    </p>
    <h2>敵を管理する仕組みの作成</h2>
    <p><code>GameManager.h</code>に敵のリストを追加しましょう。</p>
    <p class="source"> #ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      <br>
      #include&nbsp;"Singleton.h"<br>
      <br>
      class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      class&nbsp;PlayerBullet;<br>
      <em>class&nbsp;Enemy;</em><br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機のポインタ<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;<em>std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト</em><br>
      &nbsp;&nbsp;// List↑と同じvector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      <br>
      (中略).............. <br>
      protected:<br>
      &nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Game.cpp</code>に敵の生成と更新と描画処理を追加しましょう。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <em>#include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;vx = 10;<br>
      <br>
      &nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)Screen::Height / 2)); // 自機の初期化<br>
      &nbsp;&nbsp;<em>// とりあえず適当に敵を生成</em><br>
      &nbsp;&nbsp;<em>gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)600, (float)100)));</em><br>
      &nbsp;&nbsp;<em>gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)1000, (float)500)));</em><br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;x += vx; // X位置の更新<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 敵の更新処理<br>
        &nbsp;&nbsp;for (const auto&amp; b : gm.enemies)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
        &nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;<em>// 敵の描画処理<br>
        &nbsp;&nbsp;for (const auto&amp; b : gm.enemies)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
        &nbsp;&nbsp;}</em><br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      };<br>
    </p>
    <br>
    <br>
    <br>
    <a id="mozTocId2000" class="mozTocH1"></a>
    <p class="title">[C++]シューティングゲーム 2</p>
    <br>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId2001">敵と自機弾の当たり判定の作成</a></li>
      <li><a href="#mozTocId2002">敵に耐久力を持たせる(おまけでSinの波運動のコード例も)</a></li>
      <li><a href="#mozTocId2003">自機と敵の当たり判定</a></li>
      <li><a href="#mozTocId2004">自機のライフの作成</a></li>
      <li><a href="#mozTocId2005">敵弾の作成</a><br>
        <a href="#mozTocId20052">- 練習問題(MyRandomで±15度に散乱弾を撃つ敵キャラ)</a><br>
        <a href="#mozTocId20053">- 練習問題(やられると点滅後自爆する敵キャラ)</a> </li>
      <br>
      <p>次のテキスト3はこちら。</p>
      <br>
      <a href="#mozTocId3000">[C++]シューティングゲーム 3</a><br>
    </ol>
    <h1><a id="mozTocId2001" class="mozTocH1"></a>敵と自機弾の当たり判定の作成</h1>
    <p>当たり判定を移植してゆきます。</p>
    <p><code>MyMath.h</code>を編集します：</p>
    <p class="source">#ifndef _MYMATH_H<br>
      #define _MYMATH_H<br>
	    <br>
<em>#include "Vector3.h"</em><br>
	    <br>
      // 数学関連クラス<br>
      class MyMath<br>
      {<br>
      public: <br>
      &nbsp;&nbsp;static const float Sqrt2;&nbsp;&nbsp;// = 1.41421356237f;<br>
      &nbsp;&nbsp;static const float PI; // 円周率 3.14159265359f;<br>
      &nbsp;&nbsp;static const float Deg2Rad; // 度からラジアンに変換する定数 PI / 180f;<br>
      <br>
      &nbsp;&nbsp;<em>/// &lt;summary&gt;<br>
        &nbsp;&nbsp;/// 円と円が重なっているかを調べる<br>
        &nbsp;&nbsp;/// &lt;/summary&gt;<br>
        &nbsp;&nbsp;/// &lt;param name="pos1"&gt;円1の中心&lt;/param&gt;<br>
        &nbsp;&nbsp;/// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;/// &lt;param name="pos2"&gt;円2の中心&lt;/param&gt;<br>
        &nbsp;&nbsp;/// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;/// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;static bool CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Vector3 pos1, float radius1,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;Vector3 pos2, float radius2)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;return ((pos1 - pos2)sqrMagnitude()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt; (radius1 + radius2) * (radius1 + radius2));<br>
        &nbsp;&nbsp;}</em><br>
      }; // 【注意】セミコロン抜けで【宣言が必要ですエラー】<br>
      <br>
      #endif //【宣言が必要ですエラーは上のセミコロン抜け】</p>
    <br>
    <p><code>Enemy.h</code>を改修します。当たり判定の半径を表す変数と、死亡フラグ、被弾時の処理を追加します。</p>
    <p class="source">#ifndef ENEMY_H_<br>
      #define ENEMY_H_<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      #include "GameManager.h"<br>
      <br>
      // 敵の基底クラス。<br>
      // 全ての敵は、このクラスを継承して作る。<br>
      // ★【勉強】abstract型はC++にない!!【純粋仮想関数】を使って作る<br>
      class Enemy : public GameObject<br>
      {<br>
      public:<br>
      <br>
      &nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;<em>float collisionRadius = 32; // 当たり判定の半径</em><br>
      &nbsp;&nbsp;<em>float life = 1; // 耐久力</em><br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Enemy(Vector3 pos) : GameObject( pos ) // GameObjectをベースとして初期化処理を継承する<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;typeTag = "Enemy";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;virtual void Update() = 0;//virtual ～ = 0;で【純粋仮想関数に】これで【C#のabstract型に】<br>
      <br>
      &nbsp;&nbsp;// 描画処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;virtual void Draw() = 0; //virtual ～ = 0;で【純粋仮想関数に】【関数 = 0で未定義状態を表現】<br>
      <br>
      &nbsp;&nbsp;//【勉強】関数 = 0って何?と思った人は【関数もメモリ上では住所アドレスに過ぎない】ことを知ろう<br>
      &nbsp;&nbsp;// ★関数 = 0はつまり関数の住所ポインタの針が【メモリ上の何かを針で参照してない(住所不定無処理)】<br>
      &nbsp;&nbsp;// つまり【関数が未定義ってこと】＝【あいまい部分があるabstractクラスってこと】<br>
      &nbsp;&nbsp;//http://etc2myday.jugem.jp/?eid=204<br>
      &nbsp;&nbsp;//http://wisdom.sakura.ne.jp/programming/c/c54.html<br>
      &nbsp;&nbsp;//逆にいうと【関数を配列】にするっていうトリッキーなこともできる!<br>
      &nbsp;&nbsp;//http://www.ced.is.utsunomiya-u.ac.jp/lecture/2012/prog/p3/kadai3/virtualfunc2.php<br>
      <br>
      &nbsp;&nbsp;// 自機弾に当たったときの処理 関数の【★引数をGameObject型↓にすることで循環インクルード抑止】<br>
        &nbsp;&nbsp;virtual void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<em>life -= 1; // ライフを減らす<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;// ライフが無くなったら、死亡<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (life &lt;= 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
        &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>PlayerBullet.h</code>を改修します。当たり判定を表す変数を追加します。</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      #include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      // 自機弾クラス<br>
      // 継承するときは↓ : public ～にする。publicをつけ忘れると色々エラー出るので注意<br>
      class PlayerBullet: public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
      &nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
      &nbsp;&nbsp;<br>
      <br>
      &nbsp;&nbsp;<em>float collisionRadius = 16; // 当たり判定の半径</em><br>
      &nbsp;&nbsp;float angle; // 移動角度<br>
      <br>
      <br>
      &nbsp;&nbsp;(中略)....................<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;(中略)....................<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, angle, Image::playerBullet,TRUE);<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;<em>// 敵にぶつかった時の処理<br>
        &nbsp;&nbsp;void OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
        &nbsp;&nbsp;}</em><br>
      };<br>
      <br>
      #endif</p>
    <p><code>Game.cpp</code>を改修します。自機弾と敵が当たっているか調べる処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 敵の更新処理<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 自機弾と敵の衝突判定<br>
        &nbsp;&nbsp;for(const auto&amp; playerBullet : gm.playerBullets)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 自機弾が死んでたらスキップする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾と敵が重なっているか？<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;position, playerBullet-&gt;collisionRadius,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;OnCollisionEnemy(enemy);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      <br>
      &nbsp;&nbsp;<em>// 敵のリストから死んでるものを除去する<br>
        &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      (以下略)............<br>
    </p>
    <h1><a id="mozTocId2002" class="mozTocH1"></a>敵に耐久力を持たせる(おまけでSinの波運動のコード例も)</h1>
    <p><code>Zako1.h</code>のlifeを5にすることでZako1を硬くしてみましょう。<br>
      ついでにsinの波運動も試してみましょう。</p>
<p><code>Zako1.hを新規作成</code>します。黄色の部分がZako0との違いです。</p>
    <p class="source">#ifndef ZAKO_1_H_<br>
      #define ZAKO_1_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      <em>#include &lt;cmath&gt; // Sinの計算に使う<br>
        #include "MyMath.h"</em><br>
      #include "Image.h"<br>
      <br>
      // ザコ1クラス<br>
      class Zako1 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;<em>float sinMove = 0; // Sinの動きをする際の0～360度</em><br>
      &nbsp;&nbsp;<em>float sinRadius = 70; // Sinの動きをするときの半径</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Zako1(Vector3 pos) : Enemy ( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako1";//オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>life = 5;</em><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;position.x -= 1; // 左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>float prevSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>sinMove += 2.5f; // Sinの波運動の角度を進める</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>float currentSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// (前の角度でのY) - (今の角度でのY)の差を足すことで【ベースのyの位置 ± sinの動き】になる</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>position.y += currentSinY - prevSinY; // 上下方向のSinの波運動</em><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako1, TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Game.cpp</code>にZako1の生成処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <em>#include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;// とりあえず適当に敵を生成<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)600, (float)100)));<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)1000, (float)500)));<br>
      &nbsp;&nbsp;<em>gm.enemies.emplace_back(std::make_shared&lt;Zako1&gt;(Vector3((float)1000, (float)150)));</em><br>
      };<br>
      <br>
    </p>
    <h1><a id="mozTocId2003" class="mozTocH1"></a>自機と敵の当たり判定</h1>
    <p><code>Player.h</code>に当たり判定半径を定義します。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      #include "Vector3.h"<br>
      <br>
      #include&nbsp;"GameObject.h"<br>
      <br>
      #include&nbsp;"GameManager.h"<br>
      <br>
      // 継承するときは↓ : public ～にする。publicをつけ忘れると色々エラー出るので注意<br>
      class Player : public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
      <br>
      &nbsp;&nbsp;<em>float collisionRadius = 32; // 当たり判定半径</em><br>
      <br>
      &nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;// pos : 初期位置<br>
      &nbsp;&nbsp;Player(Vector3 pos) : GameObject( pos ) //【忘れると】GameObjectの初期化処理が飛ばされて大混乱！<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;}<br>
	    <br>
      &nbsp;&nbsp;virtual ~Player() {}; // 仮想デストラクタ ※無いと【削除された関数を参照しようとしてますエラー】が出るかも
      <br>
      &nbsp;&nbsp;// 更新処理の関数定義<br>
      &nbsp;&nbsp;void Update();<br>
      <br>
      &nbsp;&nbsp;// 描画処理の関数定義<br>
      &nbsp;&nbsp;void Draw();<br>
      <br>
      &nbsp;&nbsp;<em>// 敵にぶつかった時の処理<br>
        &nbsp;&nbsp;void OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other);</em><br>
      };<br>
      <br>
      #endif</p>
    <p><code>Player.cpp</code>に敵との当たり判定処理を追加します。</p>
    <p class="source"> #include&nbsp;"Player.h"<br>
      <br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;弾を生成して【使う処理があるのでインクルード必要】<br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;// 継承したGameObjectにvがあるのでvをfloatで定義し直さないように注意<br>
      &nbsp;&nbsp;v = Vector3(0,0,0); // xyz方向移動速度<br>
      <br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.x = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.x = MoveSpeed; // 右<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.y = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.y = MoveSpeed; // 下<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
      &nbsp;&nbsp;if (v.magnitude() > 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 実際に位置を動かす<br>
      &nbsp;&nbsp;position += v;<br>
      <br>
      &nbsp;&nbsp;// ボタン押下で自機弾を発射<br>
      &nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// C++ではAddがpush_backに↓ newがmake_shared↓に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(position, 0));//右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(position, -15 * MyMath::Deg2Rad));//右上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(position, +15 * MyMath::Deg2Rad));//右下<br>
      &nbsp;&nbsp;}
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::player, TRUE);<br>
      }<br>
      <br>
      <em>// 敵にぶつかった時の処理<br>
        void Player::OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other)<br>
        {<br>
        &nbsp;&nbsp;isDead = true;<br>
        }</em><br>
    </p>
    <p><code>Game.cpp</code>を改修します。自機が死んだとき消す処理と自機と敵の衝突判定を追加します。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;<em>if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;</em>gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 敵の更新処理<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾と敵の衝突判定<br>
      &nbsp;&nbsp;for(const auto&amp; playerBullet : gm.playerBullets)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 自機弾が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾と敵が重なっているか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;position, playerBullet-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;OnCollisionEnemy(enemy);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 自機と敵の衝突判定<br>
        &nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gtposition, gm.player-&gt;collisionRadius,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;OnCollisionEnemy(enemy);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      <br>
      &nbsp;&nbsp;// 敵のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;// 敵の描画処理<br>
      &nbsp;&nbsp;for (const auto&amp; e : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;<em>if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;</em>gm.player-&gt;Draw(); // プレイヤの描画【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      };<br>
    </p>
    <h1><a id="mozTocId2004" class="mozTocH1"></a>自機のライフの作成</h1>
    <p><code>Player.h</code>にライフと無敵時間を定義します。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      <br>
      #include&nbsp;"GameObject.h"<br>
      <br>
      #include&nbsp;"GameManager.h"<br>
      <br>
      // 継承するときは↓ : public ～にする。publicをつけ忘れると色々エラー出るので注意<br>
      class Player : public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
      &nbsp;&nbsp;<em>int MutekiJikan = 120; // 無敵時間</em><br>
      <br>
      &nbsp;&nbsp;float collisionRadius = 32; // 当たり判定半径<br>
      <br>
      &nbsp;&nbsp;<em>int life = 3; // ライフ</em><br>
      &nbsp;&nbsp;<em>int mutekiTimer = 0; // 残り無敵時間。0以下なら無敵じゃないってこと</em><br>
      <br>
      &nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;// pos : 初期位置<br>
      &nbsp;&nbsp;Player(Vector3 pos) : GameObject( pos ) //【忘れると】GameObjectの初期化処理が飛ばされて大混乱！<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;virtual ~Player() {}; // 仮想デストラクタ ※無いと【削除された関数を参照しようとしてますエラー】が出るかも
	    <br>
      &nbsp;&nbsp;// 更新処理の関数定義<br>
      &nbsp;&nbsp;void Update();<br>
      <br>
      &nbsp;&nbsp;// 描画処理の関数定義<br>
      &nbsp;&nbsp;void Draw();<br>
      <br>
      &nbsp;&nbsp;// 敵にぶつかった時の処理<br>
      &nbsp;&nbsp;void OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other);<br>
      <br>
      &nbsp;&nbsp;<em>// ダメージを受ける処理<br>
        &nbsp;&nbsp;void TakeDamage();</em><br>
      };<br>
      <br>
      #endif</p>
    <p><code>Player.cpp</code>に敵との当たり判定処理を追加します。</p>
    <p class="source"> #include&nbsp;"Player.h"<br>
      <br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;弾を生成して【使う処理があるのでインクルード必要】<br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;// 継承したGameObjectにvがあるのでvをfloatで定義し直さないように修正<br>
      &nbsp;&nbsp;v = Vector3(0,0,0); // xyz方向移動速度<br>
      <br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.x = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.x = MoveSpeed; // 右<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.y = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.y = MoveSpeed; // 下<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
      &nbsp;&nbsp;if (v.magnitude() > 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 実際に位置を動かす<br>
      &nbsp;&nbsp;position += v;<br>
      <br>
      &nbsp;&nbsp;// ボタン押下で自機弾を発射<br>
      &nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// C++ではAddがpush_backに↓ newがmake_shared↓に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(position, 0));//右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(position, -15 * MyMath::Deg2Rad));//右上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(position, +15 * MyMath::Deg2Rad));//右下<br>
      &nbsp;&nbsp;}
      <br>
      &nbsp;&nbsp;<em>mutekiTimer--; // 無敵タイマーは無条件で毎フレームカウントダウン</em><br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;<em>// 無敵ではない場合は描画<br>
        &nbsp;&nbsp;// 無敵中は2フレームに1回描画（点滅）<br>
        &nbsp;&nbsp;if (mutekiTimer &lt;= 0 || mutekiTimer % 2 == 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;</em>DrawRotaGraphF(position.x, position.y, 1, 0, Image::player, TRUE);<br>
      }<br>
      <br>
      // 敵にぶつかった時の処理<br>
      void Player::OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other)<br>
      {<br>
      &nbsp;&nbsp;<em>// 無敵じゃなければダメージを受ける<br>
        &nbsp;&nbsp;if (mutekiTimer &lt;= 0)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;TakeDamage();<br>
        &nbsp;&nbsp;}</em><br>
      }<br>
      <br>
      <em>// ダメージを受ける処理<br>
        void Player::TakeDamage()<br>
        {<br>
        &nbsp;&nbsp;life -= 1; // ライフ減少<br>
        <br>
        &nbsp;&nbsp;if (life &lt;= 0)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// ライフが無くなったら死亡<br>
        &nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;else<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 無敵時間発動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;mutekiTimer = MutekiJikan;<br>
        &nbsp;&nbsp;}<br>
        }</em><br>
    </p>
    <h1><a id="mozTocId2005" class="mozTocH1"></a>敵弾の作成</h1>
    <h2><a id="mozTocId20051" class="mozTocH1"></a>敵弾の作成(発射間隔を空けて撃つ方法を学ぶ)</h2>
    <p><code>EnemyBullet.h</code>を新規作成します。</p>
    <p class="source">#ifndef ENEMYBULLET_H_<br>
      #define ENEMYBULLET_H_<br>
      <br>
      #include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include "Vector3.h"<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      // 敵弾クラス<br>
      class EnemyBullet: public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const int VisibleRadius = 8; // 見た目の半径<br>
      &nbsp;&nbsp;<br>
      <br>
      &nbsp;&nbsp;float angle; // 移動角度(垂直Vertical)<br>
      &nbsp;&nbsp;float angleH=0; // 移動角度(水平Horizontal)<br>
      <br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;EnemyBullet(Vector3 pos, float angle, float speed) : GameObject( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angle = angle;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 角度からx方向の移動速度を算出<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.x = (float)std::cos(angle) * speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 角度からy方向の移動速度を算出<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.y = (float)std::sin(angle) * speed;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;EnemyBullet(Vector3 pos, float angleV, float angleH, float speed) : GameObject( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angle = angleV;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angleH = angleH;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [3Dの角度は水平・垂直に分割]https://teratail.com/questions/126004<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float cosAngleV = (float)std::cos(angle);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 角度からx方向の移動速度を算出<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.x = cosAngleV * (float)std::sin(angleH) * speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 角度からy方向の移動速度を算出<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.y = (float)std::sin(angle) * speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 角度からz方向の移動速度を算出<br>
      &nbsp;&nbsp;&nbsp;&nbsp;v.z = cosAngleV * (float)std::cos(angleH) * speed;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度の分だけ移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;position += v;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 画面外に出たら死亡フラグを立てる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (position.y + VisibleRadius &lt; 0 || position.y - VisibleRadius &gt; Screen::Height ||<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.x + VisibleRadius &lt; 0 || position.x - VisibleRadius &gt; Screen::Width)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, angle, Image::enemyBullet16,TRUE);<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// プレイヤにぶつかった時の処理<br>
      &nbsp;&nbsp;void OnCollisionPlayer(std::shared_ptr&lt;GameObject&gt; other)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <p><code>GameManager.h</code>にEnemyBulletを管理するリストの定義を追加します。</p>
    <p class="source"> #ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      <br>
      #include&nbsp;"Singleton.h"<br>
      <br>
      class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      class&nbsp;PlayerBullet;<br>
      class&nbsp;Enemy;<br>
      <em>class&nbsp;EnemyBullet;</em><br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機のポインタ<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
      &nbsp;&nbsp;<em>std::list&lt;std::shared_ptr&lt;EnemyBullet&gt;&gt; enemyBullets; // 敵弾のリスト</em><br>
      &nbsp;&nbsp;// List↑と同じvector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      <br>
      (中略).............. <br>
      protected:<br>
      &nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Game.cpp</code>にEnemyBulletの更新Updateと削除Remove、描画Drawの処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <em>#include&nbsp;"EnemyBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      #include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;<em>// 敵弾の更新処理<br>
        &nbsp;&nbsp;for (const auto&amp; b : gm.enemyBullets)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
        &nbsp;&nbsp;}</em><br>
      <br>
      &nbsp;&nbsp;// 敵の更新処理<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾と敵の衝突判定<br>
      &nbsp;&nbsp;for(const auto&amp; playerBullet : gm.playerBullets)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 自機弾が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾と敵が重なっているか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;position, playerBullet-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;OnCollisionEnemy(enemy);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機と敵の衝突判定<br>
      &nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;OnCollisionEnemy(enemy);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;// 敵のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;// 敵弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;<em>gm.EraseRemoveIf(gm.enemyBullets,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;EnemyBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      <br>
      &nbsp;&nbsp;// 敵の描画処理<br>
      &nbsp;&nbsp;for (const auto&amp; e : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;Draw(); // プレイヤの描画【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の描画処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 敵の描画処理<br>
      &nbsp;&nbsp;for (const auto&amp; e : gm.enemyBullets)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;<em>// 敵弾の描画処理<br>
        &nbsp;&nbsp;for (const auto&amp; b : gm.enemyBullets)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
        &nbsp;&nbsp;}</em><br>
      };<br>
    </p>
    <p><code>Zako0.h</code>に弾を発射間隔を開けながら撃たせます。</p>
    <p class="source">#ifndef ZAKO_0_H_<br>
      #define ZAKO_0_H_<br>
      <br>
      #include "Enemy.h"<br>
      #include "Image.h"<br>
      <em>#include "MyMath.h"</em><br>
      <em>#include&nbsp;"EnemyBullet.h"&nbsp;// make_sharedなど【実際の弾を撃ち生成処理を行うのでインクルード必要】</em><br>
      <br>
      // ザコ0クラス<br>
      class Zako0 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;<em>int counter = 0;</em><br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Zako0(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako0";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;position.x -= 1; // とりあえず左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>counter++;</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (counter % 10 == 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, 180 * MyMath::Deg2Rad, 8));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako0, TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Zako0.h</code>の弾の発射間隔を開ける方法は別のやり方もあります。</p>
    <p class="source">#ifndef ZAKO_0_H_<br>
      #define ZAKO_0_H_<br>
      <br>
      #include "Enemy.h"<br>
      #include "Image.h"<br>
      <em>#include "MyMath.h"</em><br>
      <em>#include&nbsp;"EnemyBullet.h"&nbsp;// make_sharedなど【実際の弾を撃ち生成処理を行うのでインクルード必要】</em><br>
      <br>
      // ザコ0クラス<br>
      class Zako0 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;<em>int coolTime = 0; // クールタイム（冷却時間。0になるまで次の弾が撃てない）</em><br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Zako0(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako0";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;position.x -= 1; // とりあえず左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>coolTime--;</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (coolTime &lt;= 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, 180 * MyMath::Deg2Rad, 8));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coolTime += 10;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako0, TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <h2><a id="mozTocId20052" class="mozTocH1"></a>練習問題(色んな弾の撃ち方を試す)</h2>
    <p>弾の発射角度の方向を180度 + (-15度～+15度)にすることで散乱弾を実現します。</p>
    <p>まず、乱数生成に必要な乱数クラス<code>MyRandom.h</code>を作成します。</p>
    <p class="source">#ifndef MYRANDOM_H_<br>
      #define MYRANDOM_H_<br>
      <br>
      #include &lt;random&gt;<br>
      <br>
      class MyRandom<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;// ゲーム中で唯一のインスタンス<br>
      &nbsp;&nbsp;static std::random_device rnd;// 非決定的な乱数生成器<br>
      &nbsp;&nbsp;static std::mt19937 random; // メルセンヌ・ツイスタの32ビット版<br>
      <br>
      &nbsp;&nbsp;// 初期化（シード指定無し）<br>
      &nbsp;&nbsp;static void Init()<br>
      &nbsp;&nbsp;{ // https://cpprefjp.github.io/reference/random/random_device.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;random.seed(rnd()); // 乱数をシードにすることで毎回ランダムにする<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 初期化（シードを指定）<br>
      &nbsp;&nbsp;static void Init(int seed)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;random.seed(seed);<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 指定した範囲の整数の乱数を取得する（maxは出ないので注意）<br>
      &nbsp;&nbsp;static int Range(int min, int max)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::uniform_int_distribution&lt;&gt; randRange(min, max); // [0, 99] 範囲の一様乱数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return randRange(random);<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 指定した範囲の小数の乱数を取得する（maxは出ないので注意）<br>
      &nbsp;&nbsp;static float Range(float min, float max)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::uniform_real_distribution&lt;&gt; randRange(min, max); // [0, 99] 範囲の一様乱数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return (float)randRange(random);<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 指定した確率（％）でtrueになる<br>
      &nbsp;&nbsp;static bool Percent(float probability)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return Range(0.0f, 1.0f) * 100 &lt;= probability;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 指定した範囲で乱数を返却する。<br>
      &nbsp;&nbsp;// 例えば1.5fを指定すると、-1.5～+1.5の範囲の値を返却する。<br>
      &nbsp;&nbsp;static float PlusMinus(float value)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return Range(-value, value);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <p>staticなクラスなので<code>MyRandom.cpp</code>を作成して変数をcppで定義初期化します。</p>
    <p class="source">#include "MyRandom.h"<br>
      <br>
      std::random_device MyRandom::rnd;// 非決定的な乱数生成器<br>
      std::mt19937 MyRandom::random; // メルセンヌ・ツイスタの32ビット版 https://qiita.com/angel_p_57/items/971d0208186f81d5d044<br>
    </p>
    <p><code>Zako2.h</code>を作成して弾の発射方向を-15度～+15度までランダムに散らすようにしてみます。</p>
    <p class="source">#ifndef ZAKO_2_H_<br>
      #define ZAKO_2_H_<br>
      <br>
      #include "Enemy.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include &lt;cmath&gt; // Sin Cosの計算に使う<br>
      #include "MyMath.h"<br>
      #include "MyRandom.h"<em></em><br>
      #include&nbsp;"EnemyBullet.h"&nbsp;// make_sharedなど【実際の弾を撃ち生成処理を行うのでインクルード必要】<br>
      <br>
      // ザコ2クラス<br>
      class Zako2 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;int coolTime = 0; // クールタイム（冷却時間。0になるまで次の弾が撃てない）<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Zako2(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako2";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(position.x &gt; Screen::Width - 200)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ // スクリーンの端から200の位置で止まる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.x -= 1; // とりあえず左へ移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;coolTime--;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (coolTime &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float bulletAngle = MyRandom::Range(-15.0f,15.0f); // ±15度の乱数の角度を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, (180 + bulletAngle) * MyMath::Deg2Rad, 8));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coolTime += 10;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako2, TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Game.cpp</code>にMyRandom乱数とザコ2の初期化を追加します。</p>
    <p class="source">#include "Game.h"<br>
      <em>#include&nbsp;"MyRandom.h"&nbsp;</em><br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"EnemyBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <em>#include&nbsp;"Zako2.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;<em>MyRandom::Init(); // 乱数シードの初期化</em><br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;// とりあえず適当に敵を生成<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)600, (float)100)));<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)1000, (float)500)));<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako1&gt;(Vector3((float)1000, (float)150)));<br>
      &nbsp;&nbsp;<em>gm.enemies.emplace_back(std::make_shared&lt;Zako2&gt;(Vector3((float)1200, (float)250)));</em><br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
    </p>
    <br>
    <p>どうでしょうか(-15度～+15度)の散乱弾を撃つ敵キャラを作れましたか？</p>
    <p>まずはザコ2を試してみましょう。うまくいったら次のザコ3を試してみましょう。</p>
    <p> <img src="image/gif01.gif" alt=""></p>
    <br>
    <p><a id="mozTocId20053" class="mozTocH1"></a>こんどは<code>Zako3.h</code>を作成して10ダメージ受けると点滅状態(5秒=5×60=300フレーム)になり、isDeadと同時に弾を全方向に0度～360度に散らすようにしてみます。</p>
    <p>勉強になるテクニックとして【共通処理の上書きオーバーライド】や【点滅処理の条件式】や【ド・モルガンの定理】を使っているので上級者も1度は試してみましょう。</p>
    <p class="source">#ifndef ZAKO_3_H_<br>
      #define ZAKO_3_H_<br>
      <br>
      #include "Enemy.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include &lt;cmath&gt; // Sin Cosの計算に使う<br>
      #include "MyMath.h"<br>
      #include "Vector3.h"<br>
      #include "MyRandom.h"<em></em><br>
      #include&nbsp;"EnemyBullet.h"&nbsp;// make_sharedなど【実際の弾を撃ち生成処理を行うのでインクルード必要】<br>
      <br>
      // ザコ3クラス(自爆型機雷タイプの敵キャラ)<br>
      class Zako3 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;int bombCounter = -1; // やられたときのisDeadまでのカウントダウン<br>
      &nbsp;&nbsp;int BombTime = 300; // 爆発までのカウント時間<br>
      &nbsp;&nbsp;int life = 10; // 敵ライフ<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Zako3(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako3";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(position.x &gt; Screen::Width - 350)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ // スクリーンの端から350の位置で止まる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.x -= 1; // とりあえず左へ移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ // スクリーン端から350の位置で自爆モードに入る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;life = 0; // 画面中央付近で勝手にlife=0で自爆モードに入る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;bombCounter--; // 爆発カウンタは常にカウントダウン(-1から始まるときは0を通過しないので爆発しない)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(life &lt;= 0 &amp;&amp; bombCounter &lt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bombCounter = BombTime; // 爆発モードに入る(bombCounterがプラス値になり0になると爆発)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (bombCounter == 0) // 初期状態は-1からカウントダウン-1,-2,-3..するからここには入らずに済む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i=0; i &lt; 360; i = i+10) //【勉強】for文は1ずつプラスじゃなくてもよい<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(position, (180 + i) * MyMath::Deg2Rad, 6));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // 爆発カウンタ==0で初めてisDead状態に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 【勉強】共通処理を上書きオーバーライドで上塗りして共通処理を無効化・乗っ取るテクニック<br>
      &nbsp;&nbsp;// 自機弾との衝突処理を★【上書きオーバーライド】して死亡フラグが立たないように<br>
      &nbsp;&nbsp;void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet) override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;life -= 1; // ライフを減らす<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 死亡フラグはこのザコ3だけ特別に衝突ではONにしない<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;//【ド・モルガンの定理を学ぼう】||と&amp;&amp;の逆の関係性の法則<br>
      &nbsp;&nbsp;&nbsp;&nbsp;//【勉強】条件【または||】は条件【かつ&amp;&amp;】の(life &lt;= 0 &amp;&amp; bombCounter &gt; 0)のちょうど逆条件！<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(life &gt; 0 || bombCounter &lt;= 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp; || (bombCounter % 8 &lt; 4) ) //[点滅]パラパラ8枚の周期で余り4以下の時だけ描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::zako3, TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Game.cpp</code>にザコ3の生成処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"EnemyBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako2.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <em>#include&nbsp;"Zako3.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;// とりあえず適当に敵を生成<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)600, (float)100)));<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)1000, (float)500)));<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako1&gt;(Vector3((float)1000, (float)150)));<br>
      &nbsp;&nbsp;gm.enemies.emplace_back(std::make_shared&lt;Zako2&gt;(Vector3((float)1200, (float)250)));<br>
      &nbsp;&nbsp;<em>gm.enemies.emplace_back(std::make_shared&lt;Zako3&gt;(Vector3((float)1300, (float)400)));</em><br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
    </p>
    <br>
    <p>どうでしょうか爆弾っぽい自爆タイプの敵キャラが作れましたか？</p>
    <p> <img src="image/zako3_selfbomb.gif" alt=""></p>
    <br>
    <a id="mozTocId3000" class="mozTocH1"></a>
    <p class="title">[C++]シューティングゲーム 3</p>
    <br>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId3001">自機と敵弾の当たり判定</a></li>
      <li><a href="#mozTocId3002">爆発エフェクトの作成(分割画像DivImage型の定義)</a><br>
        <a href="#mozTocId30022">爆発クラスの作成</a><br>
        <a href="#mozTocId30023">管理する仕組みの作成</a><br>
        <a href="#mozTocId30024">爆発を出す処理(Enemyで敵の共通の爆発を生成)</a><br>
      </li>
      <li><a href="#mozTocId3003">ボスの作成</a></li>
      <br>
      <p>次のテキスト4はこちら。</p>
      <br>
      <a href="#mozTocId4000">[C++]シューティングゲーム 4</a><br>
    </ol>
    <h1><a id="mozTocId3001" class="mozTocH1"></a>自機と敵弾の当たり判定</h1>
    <p>自機と敵弾がぶつかったら、自機がダメージを受けるようにしましょう。</p>
    <p><code>EnemyBullet.h</code>に当たり判定の大きさを表す変数を追加します。</p>
    <p class="source">#ifndef ENEMYBULLET_H_<br>
      #define ENEMYBULLET_H_<br>
      <br>
      #include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要<br>
      <br>
      #include "DxLib.h"<br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      // 敵弾クラス<br>
      class EnemyBullet: public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;const int VisibleRadius = 8; // 見た目の半径<br>
      &nbsp;&nbsp;<em>float collisionRadius = 8; // 当たり判定半径</em><br>
      <br>
      &nbsp;&nbsp;(以下略)........................<br>
    </p>
    <p><code>Player.h</code>に敵弾とぶつかったときの処理の定義を追加します。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      <br>
      #include&nbsp;"GameObject.h"<br>
      <br>
      #include&nbsp;"GameManager.h"<br>
      <br>
      // 継承するときは↓ : public ～にする。publicをつけ忘れると色々エラー出るので注意<br>
      class Player : public GameObject<br>
      {<br>
      public:<br>
      <br>
      &nbsp;&nbsp;(中略)...........<br>
      <br>
      &nbsp;&nbsp;// 敵にぶつかった時の処理<br>
      &nbsp;&nbsp;void OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other);<br>
      <br>
      &nbsp;&nbsp;<em>// 敵弾とぶつかった時の処理<br>
        &nbsp;&nbsp;void OnCollisionEnemyBullet(std::shared_ptr&lt;GameObject&gt; other);</em><br>
      <br>
      &nbsp;&nbsp;// ダメージを受ける処理<br>
      &nbsp;&nbsp;void TakeDamage();<br>
      };<br>
      <br>
      #endif</p>
    <p><code>Player.cpp</code>に敵弾とぶつかったときの処理を追加します。</p>
    <p class="source"> #include&nbsp;"Player.h"<br>
      <br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;弾を生成して【使う処理があるのでインクルード必要】<br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;(中略).........<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;(中略).........<br>
      }<br>
      <br>
      // 敵にぶつかった時の処理<br>
      void Player::OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other)<br>
      {<br>
      &nbsp;&nbsp;// 無敵じゃなければダメージを受ける<br>
      &nbsp;&nbsp;if (mutekiTimer &lt;= 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;TakeDamage();<br>
      &nbsp;&nbsp;}<br>
      }<br>
      <br>
      <em>// 敵弾とぶつかった時の処理<br>
        void Player::OnCollisionEnemyBullet(std::shared_ptr&lt;GameObject&gt; other)<br>
        {<br>
        &nbsp;&nbsp;// 無敵じゃなければダメージを受ける<br>
        &nbsp;&nbsp;if (mutekiTimer &lt;= 0)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;TakeDamage();<br>
        &nbsp;&nbsp;}<br>
        }</em><br>
      <br>
      // ダメージを受ける処理<br>
      void Player::TakeDamage()<br>
      {<br>
      &nbsp;&nbsp;life -= 1; // ライフ減少<br>
      <br>
      &nbsp;&nbsp;if (life &lt;= 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ライフが無くなったら死亡<br>
      &nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 無敵時間発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;mutekiTimer = MutekiJikan;<br>
      &nbsp;&nbsp;}<br>
      }<br>
    </p>
    <p><code>Game.cpp</code>に当たり判定の処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
      #include&nbsp;"MyRandom.h"<br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"EnemyBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako2.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako3.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;// 自機弾の更新処理<br>
      &nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 敵弾の更新処理<br>
      &nbsp;&nbsp;for (const auto&amp; b : gm.enemyBullets)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 自機と敵弾の衝突判定<br>
        &nbsp;&nbsp;for (const auto&amp; enemyBullet : gm.enemyBullets)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 敵弾が死んでたらスキップ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (enemyBullet-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemyBullet-&gt;position, enemyBullet-&gt;collisionRadius))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;OnCollisionEnemyBullet(enemyBullet);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;}</em><br>
      <br>
      &nbsp;&nbsp;// 敵の更新処理<br>
      &nbsp;&nbsp;for (const auto&amp; e : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Update();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾と敵の衝突判定<br>
      &nbsp;&nbsp;for(const auto&amp; playerBullet : gm.playerBullets)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 自機弾が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾と敵が重なっているか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;position, playerBullet-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;OnCollisionEnemy(enemy);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機と敵の衝突判定<br>
      &nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;OnCollisionEnemy(enemy);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      <br>
      &nbsp;&nbsp;// 敵のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;(中略)......<br>
      };<br>
    </p>
    <h1><a id="mozTocId3002" class="mozTocH1"></a>爆発エフェクトの作成(分割画像DivImage型の定義)</h1>
    <h2>分割画像DivImage型でデータ内部に分割画像の分割XY数や画像サイズ、画像数も覚えておく</h2>
    <p><code>DivImage.h</code>を新規作成して、カスタムしたデータタイプ【DivImage型】を定義して縦2×横8の分割された爆発画像を読込みましょう。</p>
    爆発画像は <a href="https://twitter.com/jetyam/status/887664013936541696">https://twitter.com/jetyam/status/887664013936541696</a>の縦2×横8の64pixの画像を想定<br>
    <p class="source">#ifndef DIVIMAGE_H_<br>
      #define DIVIMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 画像の2のべき乗チェックに使う<br>
      <br>
      // 分割画像を読込むためのデータ構造(画像数や画像ハンドル配列、3Dに使う場合の2のべき乗チェック機能をもつ)<br>
      class DivImage<br>
      {&nbsp;&nbsp;// 2Dの分割画像や3Dに分割Div画像を使うと画像全体が使われてしまうのを回避するための情報<br>
      public:<br>
      &nbsp;&nbsp;int XNum = 0;<br>
      &nbsp;&nbsp;int YNum = 0;<br>
      &nbsp;&nbsp;int XSize = 0;<br>
      &nbsp;&nbsp;int YSize = 0;<br>
      &nbsp;&nbsp;int* HandleArray = nullptr;<br>
      &nbsp;&nbsp;int AllNum = 0;<br>
      &nbsp;&nbsp;bool is3DTexture = false;<br>
      <br>
      // 初期化 : X方向分割画像数 XNum, Y方向分割画像数 YNum, 画像 横 幅XSizeピクセル, 画像 縦 高さYSizeピクセル<br>
      &nbsp;&nbsp;DivImage(int XNum, int YNum, int XSize, int YSize, bool is3DTexture=false)<br>
      &nbsp;&nbsp;{ // 初期化コンストラクタ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;XNum = XNum; // X方向分割画像数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;YNum = YNum; // Y方向分割画像数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;XSize = XSize; // 画像 横 幅XSize(ピクセルドット数)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;YSize = YSize; // 画像 縦 高さYSize(ピクセルドット数)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;AllNum = XNum * YNum; // トータルの分割画像数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;is3DTexture = is3DTexture; // 3Dテクスチャ分割画像かtrueだと2のべき乗チェックが入る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ★div分割画像読込ハンドラ保存用のint配列メモリを確保し-1で初期化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;HandleArray = new int[AllNum]; // 配列を確保し-1で初期化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; AllNum; i++) HandleArray[i] = -1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;//↑【演習★】初期化後の動的配列をデバッガで見てみよう[ary,256として再評価ボタン]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// http://visualstudiostudy.blog.fc2.com/blog-entry-17.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int* ary = HandleArray;<br>
      #ifdef _DEBUG // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(is3DTexture==true) ImagePowCheck((*this)); // *(this)でthisポインタの示す変数内容を表す<br>
      #endif<br>
      &nbsp;&nbsp;};<br>
      <br>
      &nbsp;&nbsp;~DivImage()<br>
      &nbsp;&nbsp;{ // デストラクタでメモリを解放<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (this-&gt;HandleArray != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete[] this-&gt;HandleArray;<br>
      &nbsp;&nbsp;};<br>
      <br>
      &nbsp;&nbsp;//【勉強 []添え字演算子を独自に定義】https://programming.pc-note.net/cpp/operator.html<br>
      &nbsp;&nbsp;// 内部のHandleArrayへ今までの様にImage::explosion[5]とかで簡単アクセスできるように【あいだに噛ます】<br>
      &nbsp;&nbsp;int const&amp; operator [](int index) const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(index&lt;0 || AllNum&lt;=index) assert("画像データのアクセス番号がおかしい！" == "");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return HandleArray[index];<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;int&amp; operator [](int index)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(index&lt;0 || AllNum&lt;=index) assert("画像データのアクセス番号がおかしい！" == "");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return HandleArray[index];<br>
      &nbsp;&nbsp;}<br>
      <br>
      #ifdef _DEBUG // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;bool is_pow2(unsigned int x) // 2のべき乗か計算<br>
      &nbsp;&nbsp;{ // https://programming-place.net/ppp/contents/c/rev_res/math012.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return (x != 0) &amp;&amp; (x &amp; (x - 1)) == 0;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;void ImagePowCheck(DivImage&amp; divImage)<br>
      &nbsp;&nbsp;{ // ★3Dに使う画像は2のべき乗でなければ受け付けないようにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// https://yttm-work.jp/gmpg/gmpg_0031.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// https://yappy-t.hatenadiary.org/entry/20100110/1263138881<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (divImage.XSize &gt; 0 &amp;&amp; divImage.YSize &gt; 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; is_pow2(divImage.XSize) &amp;&amp; is_pow2(divImage.YSize)) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else assert("3Dに使うなら2のべき乗の画像サイズにしなきゃ" == "");<br>
      &nbsp;&nbsp;}<br>
      #endif<br>
      <br>
      private: // コピーと代入をプライベートにして禁止する<br>
      &nbsp;&nbsp;&nbsp; // コピーコンストラクタの禁止privateオーバーロード<br>
      &nbsp;&nbsp;&nbsp; DivImage(const DivImage&amp; divImage) {};<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 代入演算子の禁止privateオーバーロード<br>
      &nbsp;&nbsp;&nbsp; void operator=(const DivImage&amp; divImage) {};<br>
      };<br>
      <br>
      #endif</p>
    <p><code>Image.h</code>でカスタムしたデータタイプ【DivImage型】で縦2×横8の分割された爆発画像を読込みましょう。</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      <em>#include "DivImage.h" // 分割画像の読込みに使う</em><br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;static void Load();<br>
      &nbsp;&nbsp;<em>static int LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage);</em><br>
      <br>
      &nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int player; //プレイヤ画像のハンドラ<br>
      &nbsp;&nbsp;static int playerBullet; //プレイヤの弾画像のハンドラ<br>
      &nbsp;&nbsp;static int enemyBullet16; //敵弾 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako0; //ザコ0 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako1; //ザコ1 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako2; //ザコ2 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako3; //ザコ3 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;<em>static DivImage explosion; // [分割画像]爆発エフェクト</em><br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
      <br>
      int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      int Image::player{-1};<br>
      int Image::playerBullet{-1};<br>
      int Image::enemyBullet16{-1};<br>
      int Image::zako0{-1};<br>
      int Image::zako1{-1};<br>
      int Image::zako2{-1};<br>
      int Image::zako3{-1};<br>
      <em>// ★分割画像は初期化のときに{X方向画像数, Y方向画像数, 画像横幅XSize,画像縦幅YSize}を指定</em><br>
      <em>DivImage Image::explosion{ 8, 2, 64, 64 };<br>
      //↑どのような画像を使うかで変わる<br>
      // 例えば https://pipoya.net/sozai/assets/effects/effect-event-1/ のイベントエフェクト.zipの<br>
      // 1800×180の縦一列のみなら DivImage Image::explosion{ 10, 1, 180, 180 };となる</em><br>
      <br>
      void Image::Load()<br>
      {<br>
      &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;player= LoadGraph("Image/player.png");<br>
      &nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;playerBullet = LoadGraph("Image/player_bullet.png");<br>
      &nbsp;&nbsp;assert(playerBullet!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;enemyBullet16 = LoadGraph("Image/enemy_bullet_16.png");<br>
      &nbsp;&nbsp;assert(enemyBullet16!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako0 = LoadGraph("Image/zako0.png");<br>
      &nbsp;&nbsp;assert(zako0!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako1 = LoadGraph("Image/zako1.png");<br>
      &nbsp;&nbsp;assert(zako1!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako2 = LoadGraph("Image/zako2.png");<br>
      &nbsp;&nbsp;assert(zako2!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako3 = LoadGraph("Image/zako3.png");<br>
      &nbsp;&nbsp;assert(zako3!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;<em>Image::LoadDivGraph("Image/explosion.png", explosion); // div分割画像をロード<br>
        &nbsp;&nbsp;for (int i = 0; i &lt; explosion.AllNum; i++)<br>
        &nbsp;&nbsp;{ // 画像読込失敗<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (explosion.HandleArray[i] == -1) assert("爆発分割画像読込失敗" == "");<br>
        &nbsp;&nbsp;}</em><br>
      }<br>
      <br>
      <em>// DXライブラリのLoadDivGraphを使いやすくラッピング<br>
        // ★関数に参照渡しを行う<br>
        // 関数の引数に参照渡しを行うことでdivImageの中身を書き換えることができる(値渡しでは書換不可)<br>
        //　https://qiita.com/agate-pris/items/05948b7d33f3e88b8967<br>
        // https://qiita.com/RuthTaro/items/f35c3a26779c0ca1a41a<br>
        int Image::LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage)<br>
        {<br>
        &nbsp;&nbsp;return DxLib::LoadDivGraph(FileName, divImage.XNum * divImage.YNum,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;divImage.XNum, divImage.YNum, divImage.XSize, divImage.YSize, divImage.HandleArray);<br>
        };</em><br>
    </p>
    <h2><a id="mozTocId30022" class="mozTocH1"></a>爆発クラスの作成</h2>
    <p><code>Explosion.h</code>を新規作成して爆発エフェクトを表示するクラスを作ります。</p>
    <p class="source">#ifndef EXPLOSION_H_<br>
      #define EXPLOSION_H_<br>
      <br>
      #include "Image.h"<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      // 爆発エフェクトクラス<br>
      class Explosion : public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;int counter = 0; // 時間を計るための変数<br>
      &nbsp;&nbsp;int imageIndex = 0; // 表示すべき画像の番号<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Explosion(Vector3 pos) : GameObject( pos )<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Explosion";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理<br>
      &nbsp;&nbsp;void Update() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;counter++;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;imageIndex = counter / 3; // そのままだと速すぎるので、3で割る<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 絵は16枚しかない（0～15）ので、<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 16番目を表示しようとしたら終了。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (imageIndex &gt;= 16)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw() override<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;// 分割して読み込んだ絵のハンドルが各要素に格納されているので、<br>
      &nbsp;&nbsp;// 要素番号を指定してハンドルを取り出して使う。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(position.x, position.y, 1, 0, Image::explosion[imageIndex], TRUE);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <h2><a id="mozTocId30023" class="mozTocH1"></a>管理する仕組みの作成</h2>
    <p><code>GameManager.h</code>にExplosionを管理するリストの定義を追加します。</p>
    <p class="source"> #ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      <br>
      #include&nbsp;"Singleton.h"<br>
      <br>
      class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      class&nbsp;PlayerBullet;<br>
      class&nbsp;Enemy;<br>
      class&nbsp;EnemyBullet;<br>
      <em>class&nbsp;Explosion;</em><br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機のポインタ<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
      &nbsp;&nbsp;std::list&lt;std::shared_ptr&lt;EnemyBullet&gt;&gt; enemyBullets; // 敵弾のリスト<br>
      &nbsp;&nbsp;<em>std::list&lt;std::shared_ptr&lt;Explosion&gt;&gt; explosions; // 爆発エフェクトのリスト</em><br>
      &nbsp;&nbsp;// List↑と同じlist ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      <br>
      (中略).............. <br>
      protected:<br>
      &nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Game.cpp</code>に当たり判定の処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
	    <br>
      #include&nbsp;"MyRandom.h"<br>
	    <br>
      #include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"EnemyBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <em>#include&nbsp;"Explosion.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      #include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako2.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include&nbsp;"Zako3.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      };<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;(中略)..................<br>
      <br>
      &nbsp;&nbsp;// 自機と敵の衝突判定<br>
      &nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;OnCollisionEnemy(enemy);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 爆発エフェクトの更新処理<br>
        &nbsp;&nbsp;for (const auto&amp; e : gm.explosions)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Update();<br>
        &nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;<br>
      <br>
      &nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;// 敵のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;// 敵弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;gm.EraseRemoveIf(gm.enemyBullets,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;EnemyBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
      &nbsp;&nbsp;<em>//爆発エフェクトのリストから死んでるものを除去する<br>
        &nbsp;&nbsp;gm.EraseRemoveIf(gm.explosions,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Explosion&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;(中略)......<br>
      <br>
      &nbsp;&nbsp;// 敵の描画処理<br>
      &nbsp;&nbsp;for (const auto&amp; e : gm.enemies)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Draw();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 爆発エフェクトの描画処理<br>
        &nbsp;&nbsp;for (const auto&amp; e : gm.explosions)<br>
        &nbsp;&nbsp;{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Draw();<br>
        &nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;(中略)......<br>
      <br>
      };<br>
    </p>
    <h2><a id="mozTocId30024" class="mozTocH1"></a>爆発を出す処理(Enemyで敵の共通の爆発を生成)</h2>
    <p><code>Enemy.h</code>を改修して、敵が死んだときに爆発エフェクトを出すようにしましょう。</p>
    <p class="source">#ifndef ENEMY_H_<br>
      #define ENEMY_H_<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      #include "GameManager.h"<br>
      <br>
      <em>#include "Explosion.h"</em><br>
      <br>
      // 敵の基底クラス。<br>
      // 全ての敵は、このクラスを継承して作る。<br>
      // ★【勉強】abstract型はC++にない!!【純粋仮想関数】を使って作る<br>
      class Enemy : public GameObject<br>
      {<br>
      public:<br>
      <br>
      &nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;float collisionRadius = 32; // 当たり判定の半径<br>
      &nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
      &nbsp;&nbsp;float life = 1; // 耐久力<br>
      <br>
      &nbsp;&nbsp;// コンストラクタ<br>
      &nbsp;&nbsp;Enemy(Vector3 pos) : GameObject( pos ) // GameObjectをベースとして初期化処理を継承する<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;this-&gt;typeTag = "Enemy";<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;// 更新処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;virtual void Update() = 0;//virtual ～ = 0;で【純粋仮想関数に】これで【C#のabstract型に】<br>
      <br>
      &nbsp;&nbsp;// 描画処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;virtual void Draw() = 0; //virtual ～ = 0;で【純粋仮想関数に】【関数 = 0で未定義状態を表現】<br>
      <br>
      <br>
      &nbsp;&nbsp;// 自機弾に当たったときの処理<br>
      &nbsp;&nbsp;virtual void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;life -= 1; // ライフを減らす<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ライフが無くなったら、死亡<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (life &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>// 爆発を出す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.explosions.emplace_back(std::make_shared&lt;Explosion&gt;(Vector3(position.x, position.y)));</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      #endif<br>
    </p><br>
	  ここまでで、実行して爆発が出るか試してみましょう！<br>
    <h1><a id="mozTocId3003" class="mozTocH1"></a>ボスの作成</h1>
    <p>まずはボスの3状態の画像をImageフォルダに用意しておきましょう。</p>
    <ul>
      <li>boss1.png</li>
      <li>boss2.png</li>
      <li>boss3.png</li>
    </ul>
    <p><code>Image.h</code>にboss1.png、boss2.png、boss3.pngの読込み処理を追加します。</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "DivImage.h" // 分割画像の読込みに使う<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;static void Load();<br>
      &nbsp;&nbsp;static int LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage);<br>
      <br>
      &nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int player; //プレイヤ画像のハンドラ<br>
      &nbsp;&nbsp;static int playerBullet; //プレイヤの弾画像のハンドラ<br>
      &nbsp;&nbsp;static int enemyBullet16; //敵弾 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako0; //ザコ0 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako1; //ザコ1 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako2; //ザコ2 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static int zako3; //ザコ3 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;<em>static int boss1; //ボス通常 画像のハンドラ(読込画像番号)</em><br>
      &nbsp;&nbsp;<em>static int boss2; //ボス2気絶 画像のハンドラ(読込画像番号)</em><br>
      &nbsp;&nbsp;<em>static int boss3; //ボス3発狂 画像のハンドラ(読込画像番号)</em><br>
      &nbsp;&nbsp;static DivImage explosion; // [分割画像]爆発エフェクト<br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
      <br>
      int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      int Image::player{-1};<br>
      int Image::playerBullet{-1};<br>
      int Image::enemyBullet16{-1};<br>
      int Image::zako0{-1};<br>
      int Image::zako1{-1};<br>
      int Image::zako2{-1};<br>
      int Image::zako3{-1};<br>
      <em>int Image::boss1{-1};</em><br>
      <em>int Image::boss2{-1};</em><br>
      <em>int Image::boss3{-1};</em><br>
      // ★分割画像は初期化のときに{X方向画像数, Y方向画像数, 画像横幅XSize,画像縦幅YSize}を指定<br>
      DivImage Image::explosion{ 8, 2, 64, 64 };<br>
      <br>
      void Image::Load()<br>
      {<br>
      &nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;player= LoadGraph("Image/player.png");<br>
      &nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;playerBullet = LoadGraph("Image/player_bullet.png");<br>
      &nbsp;&nbsp;assert(playerBullet!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;enemyBullet16 = LoadGraph("Image/enemy_bullet_16.png");<br>
      &nbsp;&nbsp;assert(enemyBullet16!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako0 = LoadGraph("Image/zako0.png");<br>
      &nbsp;&nbsp;assert(zako0!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako1 = LoadGraph("Image/zako1.png");<br>
      &nbsp;&nbsp;assert(zako1!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako2 = LoadGraph("Image/zako2.png");<br>
      &nbsp;&nbsp;assert(zako2!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;zako3 = LoadGraph("Image/zako3.png");<br>
      &nbsp;&nbsp;assert(zako3!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;<em>boss1 = LoadGraph("Image/boss1.png");<br>
        &nbsp;&nbsp;assert(boss1!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      &nbsp;&nbsp;<em>boss2 = LoadGraph("Image/boss2.png");<br>
        &nbsp;&nbsp;assert(boss2!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      &nbsp;&nbsp;<em>boss3 = LoadGraph("Image/boss3.png");<br>
        &nbsp;&nbsp;assert(boss3!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      &nbsp;&nbsp;Image::LoadDivGraph("Image/explosion.png", explosion); // div分割画像をロード<br>
      &nbsp;&nbsp;for (int i = 0; i &lt; explosion.AllNum; i++)<br>
      &nbsp;&nbsp;{ // 画像読込失敗<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (explosion.HandleArray[i] == -1) assert("爆発分割画像読込失敗" == "");<br>
      &nbsp;&nbsp;}<br>
      }<br>
      <br>
      // DXライブラリのLoadDivGraphを使いやすくラッピング<br>
      // ★関数に参照渡しを行う<br>
      // 関数の引数に参照渡しを行うことでdivImageの中身を書き換えることができる(値渡しでは書換不可)<br>
      //　https://qiita.com/agate-pris/items/05948b7d33f3e88b8967<br>
      // https://qiita.com/RuthTaro/items/f35c3a26779c0ca1a41a<br>
      int Image::LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage)<br>
      {<br>
      &nbsp;&nbsp;return DxLib::LoadDivGraph(FileName, divImage.XNum * divImage.YNum,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;divImage.XNum, divImage.YNum, divImage.XSize, divImage.YSize, divImage.HandleArray);<br>
      };<br>
    </p>
    <br>
    <p><code>Boss.h</code>を新規作成してif else でStateに応じて行動を遷移させてみましょう。</p>
    <p>「<b>登場</b>」画面右から出てくる<br>
      　↓<br>
      「<b>通常</b>」通常の状態。通常の攻撃を行う<br>
      　↓<br>
      「<b>気絶</b>」気絶状態の絵になる<br>
      　↓<br>
      「<b>発狂</b>」怒った絵になる。激しい攻撃を繰り広げてくる<br>
      　↓<br>
      「<b>死亡</b>」少し時間をかけて死亡の演出を行う<br>
      　↓<br>
      完全に消滅</p>
    <p><br>
    </p>
    <p class="source">#ifndef BOSS_H_<br>
      #define BOSS_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      #include "Image.h"<br>
      <br>
      // ボスクラス。Enemyを継承して作る<br>
      class Boss : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // ボスの状態種別<br>
      &nbsp;&nbsp;&nbsp; enum class State<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Appear, // 登場<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Normal, // 通常時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Swoon, // 気絶時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Angry, // 発狂モード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dying, // 死亡<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; State state = State::Appear; // 現在の状態<br>
      &nbsp;&nbsp;&nbsp; int swoonTime = 120; // 残り気絶時間<br>
      &nbsp;&nbsp;&nbsp; int dyingTime = 180; // 死亡時のアニメーション時間<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Boss(Vector3 pos) : Enemy( pos )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Boss"; // オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life = 100; // ライフ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collisionRadius = 70; // 当たり判定半径<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state == State::Appear) // 登場状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position.x -= 1; // 左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (position.x &lt;= 750) // x座標が750以下になったら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = State::Normal; // 通常状態へ移行<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Normal) // 通常状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Swoon) // 気絶状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; swoonTime--; // タイマー減少<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (swoonTime &lt;= 0) // タイマーが0になったら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = State::Angry; // 発狂モードへ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Angry) // 発狂モード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Dying) // 死亡中<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dyingTime--; // タイマー減少<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dyingTime &lt;= 0) // タイマーが0になったら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isDead = true; // 完全に消滅<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state == State::Appear || state == State::Normal) // 登場時と通常時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss1, TRUE); // 普通の画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Swoon) // 気絶時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss2, TRUE); // 気絶時の画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Angry) // 発狂モード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss3, TRUE); // 怒ってる画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (state == State::Dying) // 死亡中<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(position.x, position.y, 1, 0, Image::boss2, TRUE); // 気絶時の画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 自機弾に当たったときの処理をoverride（上書き）する<br>
      &nbsp;&nbsp; &nbsp;void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet) override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 登場時、気絶時、死亡時は被弾しても何もしない<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (state == State::Appear || state == State::Swoon || state == State::Dying)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;life -= 1; // ライフを減らす<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (life &lt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ライフが無くなったら、すぐ消滅するのではなく、死亡状態へ移行<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;state = State::Dying;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (state == State::Normal &amp;&amp; life &lt;= 50)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 通常状態でライフが50以下になったら、気絶する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;state = State::Swoon;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <p><code>Game.cpp</code>にボスの生成処理を追加してボスが期待通りに状態遷移することを確認しましょう。</p>
    <p class="source">#include "Game.h"<br>
	    <br>
      #include "MyRandom.h"<br>
      <br>
      #include "Player.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
      #include "PlayerBullet.h"<br>
      #include "EnemyBullet.h"<br>
      #include "Explosion.h"<br>
      #include "Zako0.h"<br>
      #include "Zako1.h"<br>
      #include "Zako2.h"<br>
      #include "Zako3.h"<br>
      <em>#include "Boss.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;&nbsp; Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数シードの初期化<br>
      <br>
      &nbsp;&nbsp;&nbsp; (中略).................<br>
      <br>
      &nbsp;&nbsp;&nbsp; gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化<br>
      &nbsp;&nbsp;&nbsp; // とりあえず適当に敵を生成<br>
      &nbsp;&nbsp;&nbsp; <em>gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));</em><br>
      }<br>
      <br>
      (以下略).................</p>
    <br>
    <a id="mozTocId4000" class="mozTocH1"></a>
    <p class="title">[C++]シューティングゲーム 4</p>
    <br>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId4001">シーンを分ける(循環インクルードを避けメモリも管理するには?)</a><br>
        <a href="#mozTocId40012">【高難度】画面やステージごとにImageのメモリを開放する</a><br>
        <a href="#mozTocId40013">サウンドの読込みと再生機能</a><br>
        <a href="#mozTocId40014">【高難度】画面やステージごとにサウンドをメモリ読込み・解放(音量調整機能も追加)</a><br>
      </li>
      <li><a href="#mozTocId4002">CSVを読み込んで敵を生成するプログラム</a><br>
        <a href="#mozTocId40022">カスタムしたデータ構造DataCsv.hでデータ自身にLoadと幅高さ管理を任せる</a><br>
        <a href="#mozTocId40023">【高難度】敵データの全方位読出しアルゴリズム</a><br>
      </li>
      <li><a href="#mozTocId4003">自機狙い弾</a></li>
      <li><a href="#mozTocId4004">自機に向かってくる敵</a></li>
      <br>
      <p>次のテキスト5はこちら。</p>
      <br>
      <a href="#mozTocId5000">[C++]シューティングゲーム 5【応用1】</a><br>
    </ol>
    <h1><a id="mozTocId4001" class="mozTocH1"></a>シーンを分ける(循環インクルードを避けメモリも管理するには?)</h1>
    <p>タイトルやプレイ画面やゲームオーバーのシーンを分けましょう。<br>
      シーンは構造的に<code>タイトル⇒プレイ画面⇒ゲームオーバー⇒タイトル...とループする</code>ので<br>
      普通に考えれば循環インクルードしやすいですね。<br>
      ということで基本方針としては</p>
    <ol>
      <li>マネージャの.hヘッダに現在のシーンと一つ前のシーンを保持</li>
      <li>マネージャの.cppで各シーンをインクルードして画面チェンジ機能の処理を作成する</li>
      <li>各シーンではマネージャの.hをインクルードして画面チェンジ機能を呼び出す</li>
    </ol>
    <p>上記の構造であれば、マネージャの.hヘッダで循環は止まります、なぜか?<br>
      マネージャの.hヘッダには【画面チェンジ機能の定義だけ】があり、各シーンをインクルード必要としません。<br>
      実際の<b>【画面チェンジ機能の処理はcppに書き】【cppで各シーンの.hヘッダをインクルードします】</b><br>
    </p>
    <p>さて、実際のプログラムをしてみましょう。<br>
      <b>【シーン専門のマネージャーSceneManagerを作ることにしましょう】</b>(GameManagerでやっても良いですが)。 <br>
      管理方針は人によりますが、現状のマネージャーの役割は一度ここで整理しておいた方がよいですね</p>
    <ol>
      <li>【ゲームのマネージャ役】敵リストなど<b>メモリへのリンクを保持</b>する</li>
      <li>【ゲームのマネージャ役2】メモリから<b>isDeadの要素などを高速削除</b>する機能</li>
      <li>【ゲームのマネージャ役3】メモリの<b>要素同士の連絡の【参照を集約】</b>して隠れた参照をしないように整理する</li>
      <li>【シーンのマネージャ役】現在と前の画面の<b>メモリへのリンクを保持</b>する</li>
      <li>【シーンのマネージャ役2】次の画面へ<b>シーンをチェンジ</b>する(チェンジするだけでなく前画面の<b>弾などのメモリ参照を外さないとメモリに残り続ける</b>)</li>
      <li>【シーンのマネージャ役3】<b>前の画面の弾など【終了時のメモリ参照の掃除】</b>を<b>【各シーンに号令をかける】</b></li>
    </ol>
    <p>シーンの遷移こそがある意味【一番のメモリの管理の「要所」】。</p>
    <p>なぜなら<b>【画面チェンジは実質≒前の画面のメモリへの参照リンクお掃除】</b>に近いですから。</p>
    <p>気をつけてくださいね<b>【メモリの回し読みポインタの参照リンクお掃除しないと】</b>前の画面の<b>メモリはフリーになりません</b></p>
    <h2>シーンマネージャで画面遷移を作成する(Game.cppからコードを画面に分けて移植)</h2>
    <p>Scene.hを新規作成してベースとなるシーンの基底クラスを定義しましょう。<br>
      <b>ポイント要点は【開始Initialize()】と【終了Finalize()】を区別していることです。</b><br>
      いままでもInit()や初期化コンストラクタはありましたが<br>
      <b>【終了の Finalize() 】を分けることでシーンの切替えのタイミングで弾のメモリなどのリセットの処理を書けます。</b><br>
      <b>【Initialize()には生成や初期化】【Finalize()にはメモリなどのリセット処理】</b>を書き分けましょう。<br>
      つまり<b>【シーンの移り変わりが出てきたからこそ】【終了のFinalize()の概念も必要になってきた】</b>ということですね。<br>
      逆に今までは1つの画面しかなかったので初期化のInit()だけでよかったわけですね。</p>
    <p><code>Scene.hを新規作成</code>してベースとなるシーンの基底クラスを定義します。</p>
    <p class="source">#ifndef SCENE_H_<br>
      #define SCENE_H_<br>
      <br>
      #include &lt;string&gt; // シーンの判別文字列tagに使う<br>
      <br>
      // シーンの基底クラス あいまいなabstract型タイプ<br>
      class Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;std::string tag = ""; // シーンの種類の判別に使う<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;//★仮想デストラクタ【忘れるとメモリがヤバいダメ絶対】<br>
      &nbsp;&nbsp; &nbsp;//【注意！】ベースの基底では必ず定義しないとstringなどが浪費され極悪なメモリ被害に発展<br>
      &nbsp;&nbsp; &nbsp;virtual ~Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 特に配列とかなくても★string文字列も内部では実質配列だから！5文字分のメモリとかがすり減ってく..<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 仮想デストラクタはstringなど暗黙に内部に配列を持つ要素のデストラクタを暗黙に呼んでくれている！<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;//★純粋仮想関数=0は継承したPlaySceneなどの必須機能(継承したら絶対override必須縛り)<br>
      &nbsp;&nbsp; &nbsp;// 必須縛りによってSceneを継承したものは【Update,Drawが実装されてるはずの確証があるので】<br>
      &nbsp;&nbsp; &nbsp;// for文であいまいなSceneのまま【まとめてUpdate,Drawできる】のだ。<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;virtual void Initialize() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じくリセット処理を行うがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp; &nbsp;virtual void Finalize() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;virtual void Update() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;virtual void Draw() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>SceneManager.hを新規作成</code>してシーンを管理するクラスを定義しましょう。</p>
    <p class="source">#ifndef SCNENEMANAGER_H_<br>
      #define SCNENEMANAGER_H_<br>
      <br>
      #include &lt;vector&gt;<br>
      #include &lt;memory&gt;<br>
      #include &lt;string&gt;<br>
      #include &lt;assert.h&gt; // シーン読み込みの失敗表示用<br>
      <br>
      #include "Singleton.h"<br>
      <br>
      class Scene; //クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      <br>
      class SceneManager : public Singleton&lt;SceneManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;friend class Singleton&lt;SceneManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <b>// マネージャを【どこからでもアクセスしやすい「変数の掲示板」として使えばシーンをまたぐ変数も定義できる】</b><br>
      &nbsp;&nbsp;&nbsp; std::string selectStage = "stage1"; // 選択中のステージ名など<br>
      &nbsp;&nbsp; &nbsp;int scoreMax = -1; // 【シーンをまたぐスコアなど】はマネージャに定義すれば【シーンをまたいだあとも】消えず残る<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp; &nbsp;std::shared_ptr&lt;Scene&gt; prevScene{ nullptr }; // 一つ前のシーン<br>
      &nbsp;&nbsp; &nbsp;std::shared_ptr&lt;Scene&gt; currentScene{ nullptr }; // 現在のシーン<br>
	    <br>
      &nbsp;&nbsp; &nbsp;std::string currentSceneName = ""; // 現在のシーン名を保管しておく<br>
      &nbsp;&nbsp; &nbsp;std::string changingSceneName = ""; // 予約された次のシーンのクラス名(次に移動予定のシーン名を保管しておく)<br>
	    <br>
      &nbsp;&nbsp; &nbsp;// シーン名を比較、何の変化もなければfalseでシーン移動不必要の判定<br>
      &nbsp;&nbsp; &nbsp;bool isChanging(const std::string&amp; nextSceneName);<br>
	    <br>
      &nbsp;&nbsp; &nbsp;// 次のシーンの予約だけして、元のシーンのUpdateが終わるまで待つUpdateが終わったらシーンを遷移する<br>
      &nbsp;&nbsp; &nbsp;void NextScene(const std::string&amp; nextSceneName);<br>
	    <br>
      &nbsp;&nbsp; &nbsp;// シーンをチェンジし遷移する(前のシーンのリセット処理もする)<br>
      &nbsp;&nbsp; &nbsp;void LoadScene(const std::string&amp; sceneName);<br>
      <br>
      protected:<br>
      &nbsp;&nbsp; &nbsp;SceneManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp; &nbsp;virtual ~SceneManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>TitleScene.hを新規作成</code>してタイトル画面のひな型を作成しましょう。</p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;TitleScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "TitleScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sm.LoadScene("PlayScene"); //シーン遷移<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 0, "TitleSceneです。ボタン押下でPlaySceneへ。", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 200, "MAXスコア: " + sm.scoreMax, GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>GameOverScene.hを新規作成</code>してゲームオーバー画面のひな型を作成しましょう。</p>
    <p class="source">#ifndef GAMEOVERSCENE_H_<br>
      #define GAMEOVERSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class GameOverScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;GameOverScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "GameOverScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sm.LoadScene("TitleScene"); //シーン遷移<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 0, "GameOver....ボタン押下でPlaySceneへ", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>PlayScene.hを新規作成</code>してプレイ画面のひな型を作成しましょう。<br>
      なお、<b>実際のプレイに関するコードはGame.cppから頑張って移植</b>してみましょう。<br>
      ここに全部書くと逆にシーン遷移に関するコードがわかりづらくなりますから。<br>
      個々人で作成中の<code>Game.cppのゲームのコードをUpdate(),Draw(),Init()はInitialize()へ移植</code>してみましょう。</p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      #include "Player.h"<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp; &nbsp;int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;PlayScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "PlayScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;</em>// ここでプレイヤの初期化などのプレイ開始時の処理<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;</em>// ここにプレイ終了時のメモリのリセット処理(ゲームクリアやゲームオーバーなど)<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ゲーム終了時のスコアがMAXなら記録して終了<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(score &gt; sm.scoreMax) sm.scoreMax = score;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;</em>// ここにプレイ中の更新処理を持ってくる<br>
      <br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ゲームオーバー判定と画面チェンジ処理<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;bool isGameover = (gm.player == nullptr);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!isGameover &amp;&amp; gm.player-&gt;isDead) isGameover = true;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (isGameover)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sm.LoadScene("GameOverScene"); //シーン遷移<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>&nbsp;</em>// ここにプレイ画面の描画処理を持ってくる<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>SceneManager.cppを新規作成</code>してシーンを遷移する機能を作成しましょう。</p>
    <p class="source">#include "SceneManager.h"<br>
      <br>
      #include "Scene.h"<br>
      #include "TitleScene.h"<br>
      #include "PlayScene.h"<br>
      #include "GameOverScene.h"<br>
      <br>
      bool SceneManager::isChanging(const std::string&amp; nextSceneName)<br>
      {<br>
      &nbsp;&nbsp; &nbsp;if (currentSceneName != nextSceneName) //シーン名不一致<br>
      &nbsp;&nbsp; &nbsp;return true; // シーン名が変更<br>
<br>
      &nbsp;&nbsp; &nbsp;return false; // シーン名に変更無し<br>
      }<br>
<br>
      void SceneManager::NextScene(const std::string&amp; nextSceneName)<br>
      {<br>
      &nbsp;&nbsp; &nbsp;// シーン名とオプションを比較、何の変化もなければfalseでシーン移動不必要の判定<br>
      &nbsp;&nbsp; &nbsp;if (isChanging(nextSceneName) == false) return; //特に変更なしでシーン移動の必要なし<br>

      &nbsp;&nbsp; &nbsp;changingSceneName = nextSceneName; // 次に移動予定のシーン名を保管しておく<br>
      }<br>
<br>
      void SceneManager::LoadScene(const std::string&amp; sceneName)<br>
      {<br>
      &nbsp;&nbsp; &nbsp;std::string loadSceneName = sceneName;
      &nbsp;&nbsp; &nbsp;// sceneNameの指定が空の場合にはNextScene()での事前のシーン変更予約があるかチェック<br>
      &nbsp;&nbsp; &nbsp;if (sceneName == "" &amp;&amp; changingSceneName != "")<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;loadSceneName = changingSceneName;<br>
<br>
          &nbsp;&nbsp; &nbsp;if (loadSceneName == "") return; // シーン指定がないときは終了<br>
      &nbsp;&nbsp; &nbsp;// 現在のシーンの終了処理<br>
	    <br>
      &nbsp;&nbsp; &nbsp;if(currentScene !=nullptr)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentScene-&gt;Finalize(); // 終了処理を呼び出す<br>
      <br>
      &nbsp;&nbsp; &nbsp;if (loadSceneName == "TitleScene")<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 次のシーンの生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentScene = std::make_shared&lt;TitleScene&gt;();<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;else if (loadSceneName == "PlayScene")<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 次のシーンの生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentScene = std::make_shared&lt;PlayScene&gt;();<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;else if (loadSceneName == "GameOverScene")<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 次のシーンの生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentScene = std::make_shared&lt;GameOverScene&gt;();<br>
      &nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;else<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;assert("指定されたシーン名の生成処理が見つからなかった→SceneManager.cppを見直しましょう" == "");<br>
<br>
      &nbsp;&nbsp; &nbsp;currentSceneName = loadSceneName; // 現在のシーン名の更新<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 次のシーンの初期化<br>
      &nbsp;&nbsp; &nbsp;currentScene-&gt;Initialize(); // 初期化を呼び出す<br>
      }</p>
    <br>
    <br>
    <br>
    <p><code>Game.cppからPlayScene.h、TitleScene.hにプレイに関するコードを移植してみます</code><br>
      ですが、<b>あくまでも移植【例】です。</b><br>
      皆さん独自の敵などいますからあくまで移植の【例】です。</p>
    <br>
    <br>
    <p><code>Game.cppからTitleScene.hにテスト用のボス表示のコードを移植してみます。</code></p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      <em>#include "Screen.h"</em><br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;<em>// テスト用のボス画像をタイトル画面で左右移動させる<br>
        &nbsp;&nbsp; &nbsp;int x = 0; //staticじゃないintはここで=0で初期化できる<br>
        &nbsp;&nbsp; &nbsp;int vx = 0;</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;TitleScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "TitleScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// テスト用のボス画像をタイトル画面で左右移動させる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x = 100; // Xの初期位置<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = 10; // ボスの初期速度</em><br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sm.LoadScene("PlayScene"); //シーン遷移<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// テスト用のボス画像をタイトル画面で左右移動させる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (x &lt; 0)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = 10; //速度の変更<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (x &gt; Screen::Width)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = -10; //画面端で移動方向反転<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x += vx; // ボス画像のX位置の更新</em><br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// テスト用のボス画像をタイトル画面で左右移動させる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawRotaGraphF((float)x, 200, 0.9f, 0, Image::bossImage, TRUE);</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 0, "TitleSceneです。ボタン押下でPlaySceneへ。", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 200, "MAXスコア: " + sm.scoreMax, GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>Game.hから移植したコードを削除します。</code></p>
    <p class="source">#ifndef GAME_H_<br>
      #define GAME_H_<br>
      <br>
      #include &lt;vector&gt;//C#のListリストの代わりのC++版<br>
      #include &lt;memory&gt;//スマートなポインタを使うのに必要(shared_ptrなど)<br>
      <br>
      #include "Image.h"<br>
      <u>#include "Screen.h"</u><br>
      #include "Input.h"<br>
      <br>
      #include "GameManager.h"<br>
      <br>
      class Game<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↓{ }を.hに書くことでcppに分けて書くはずの処理ぶぶんを.hに書いてもよい */<br>
      &nbsp;&nbsp;&nbsp; Game() {&nbsp; }; // 初期化コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; ~Game() {&nbsp; }; // 破棄処理デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; void Init(); // Init処理(定義だけ)<br>
      &nbsp;&nbsp;&nbsp; void Update(); // 更新処理(定義だけ)<br>
      &nbsp;&nbsp;&nbsp; void Draw();// 描画処理(定義だけ)<br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>int x = 0; //staticじゃないintはここで=0で初期化できる<br>
        &nbsp;&nbsp;&nbsp; int vx = 0;</u><br>
      <br>
      };<br>
      #endif</p>
    <p><code>Game.cppから移植したコードを削除します。</code></p>
    <p class="source">#include "Game.h"<br>
      <br>
      (中略)............<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;&nbsp; Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数シードの初期化<br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>x = 100; // Xの初期位置<br>
        &nbsp;&nbsp;&nbsp; vx = 10; // ボスの初期速度</u><br>
      }<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>if (x &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vx = 10; //速度の変更<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (x &gt; Screen::Width)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vx = -10; //画面端で移動方向反転<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; x += vx; // ボス画像のX位置の更新</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;&nbsp; (中略)......................<br>
      }<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;&nbsp; <u>DrawRotaGraphF((float)x, 200, 0.9f, 0, Image::bossImage, TRUE);</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; (中略)..................<br>
      }</p>
    <br>
    <p><code>Game.cppからPlayScene.hにプレイ中に関するコードを移植してみます。</code></p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      <em>#include "Screen.h"</em><br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      <em>#include "Player.h"<br>
        #include "Boss.h"<br>
        #include "PlayerBullet.h"<br>
        #include "EnemyBullet.h"<br>
        #include "Explosion.h"</em><br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp; &nbsp;int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;PlayScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "PlayScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// ここでプレイヤの初期化などのプレイ開始時の処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵の仮生成<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));</em><br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ここにプレイ終了時のメモリのリセット処理(ゲームクリアやゲームオーバーなど)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>gm.player = nullptr; // プレイヤのメモリからの解放<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.enemies.clear(); // 敵のメモリからの解放<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.playerBullets.clear(); // プレイヤの弾のメモリからの解放<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.enemyBullets.clear(); // 敵弾のメモリからの解放<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.explosions.clear(); // 爆発エフェクトのメモリからの解放</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ゲーム終了時のスコアがMAXなら記録して終了<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(score &gt; sm.scoreMax) sm.scoreMax = score;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ここにプレイ中の更新処理を持ってくる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機弾の更新処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; b : gm.playerBullets)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp; // autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b-&gt;Update();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵弾の更新処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; b : gm.enemyBullets)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b-&gt;Update();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機と敵弾の衝突判定<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; enemyBullet : gm.enemyBullets)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機が死んでたらこれ以上判定しない<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (gm.player-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵弾が死んでたらスキップ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (enemyBullet-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 円同士の衝突判定で調べる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enemyBullet-&gt;position, enemyBullet-&gt;collisionRadius))<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player-&gt;OnCollisionEnemyBullet(enemyBullet);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵の更新処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; b : gm.enemies)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b-&gt;Update();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機弾と敵の衝突判定<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; playerBullet : gm.playerBullets)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機弾が死んでたらスキップする<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (playerBullet-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; enemy : gm.enemies)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵が死んでたらスキップする<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (enemy-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機弾と敵が重なっているか？<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;playerBullet-&gt;position, playerBullet-&gt;collisionRadius,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;playerBullet-&gt;OnCollisionEnemy(enemy);<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (playerBullet-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機と敵の衝突判定<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; enemy : gm.enemies)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機が死んでたらこれ以上判定しない<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (gm.player-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵が死んでたらスキップ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (enemy-&gt;isDead)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 円同士の衝突判定で調べる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enemy-&gt;position, enemy-&gt;collisionRadius))<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player-&gt;OnCollisionEnemy(enemy);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 爆発エフェクトの更新処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; e : gm.explosions)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;e-&gt;Update();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機弾の削除処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵のリストから死んでるものを除去する<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.EraseRemoveIf(gm.enemies,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵弾のリストから死んでるものを除去する<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.EraseRemoveIf(gm.enemyBullets,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[](std::shared_ptr&lt;EnemyBullet&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//爆発エフェクトのリストから死んでるものを除去する<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.EraseRemoveIf(gm.explosions,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[](std::shared_ptr&lt;Explosion&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除</em><br>
      <br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ゲームオーバー判定と画面チェンジ処理<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;bool isGameover = (gm.player == nullptr);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!isGameover &amp;&amp; gm.player-&gt;isDead) isGameover = true;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (isGameover)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sm.LoadScene("GameOverScene"); //シーン遷移<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ここにプレイ画面の描画処理を持ってくる<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// 敵の描画処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; b : gm.enemies)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b-&gt;Draw();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 爆発エフェクトの描画処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; e : gm.explosions)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;e-&gt;Draw();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機弾の描画処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; b : gm.playerBullets)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp; // autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b-&gt;Draw();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵弾の描画処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; b : gm.enemyBullets)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b-&gt;Draw();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</em><br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>Game.cppから移植したコードを削除します。</code></p>
    <p class="source">#include "Game.h"<br>
      <br>
      #include "MyRandom.h"<br>
      <u>#include "Player.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
        #include "PlayerBullet.h"<br>
        #include "EnemyBullet.h"<br>
        #include "Explosion.h"<br>
        #include "Zako0.h"<br>
        #include "Zako1.h"<br>
        #include "Zako2.h"<br>
        #include "Zako3.h"<br>
        #include "Boss.h" // 初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</u><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;&nbsp; Image::Load("PlayScene"); //画像の読込み<br>
      &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数シードの初期化<br>
	    <br>
      &nbsp;&nbsp;&nbsp; <u>gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化<br>
      &nbsp;&nbsp;&nbsp; // とりあえず適当に敵を生成<br>
      &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)600, (float)100)));<br>
      &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3((float)1000, (float)500)));<br>
      &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Zako1&gt;(Vector3((float)1000, (float)150)));<br>
      &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Zako2&gt;(Vector3((float)1200, (float)250)));<br>
      &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Zako3&gt;(Vector3((float)1300, (float)400)));<br>
<br>
      &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));</u><br>
	    <br>
      }<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 自機弾の更新処理<br>
        &nbsp;&nbsp;&nbsp; // C#のforeach文と同じく全自機弾を更新できる<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.playerBullets)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp; // autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b-&gt;Update();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 敵弾の更新処理<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.enemyBullets)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b-&gt;Update();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; (中略)................<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 自機と敵の衝突判定<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; enemy : gm.enemies)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 自機が死んでたらこれ以上判定しない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (gm.player-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 敵が死んでたらスキップ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (enemy-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円同士の衝突判定で調べる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MyMath::CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.player-&gt;position, gm.player-&gt;collisionRadius,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enemy-&gt;position, enemy-&gt;collisionRadius))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.player-&gt;OnCollisionEnemy(enemy);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 爆発エフェクトの更新処理<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; e : gm.explosions)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e-&gt;Update();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 自機弾の削除処理<br>
        &nbsp;&nbsp;&nbsp; gm.EraseRemoveIf(gm.playerBullets,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;PlayerBullet&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
        <br>
        &nbsp;&nbsp;&nbsp; (中略)..............<br>
        <br>
        &nbsp;&nbsp;&nbsp; //爆発エフェクトのリストから死んでるものを除去する<br>
        &nbsp;&nbsp;&nbsp; gm.EraseRemoveIf(gm.explosions,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;Explosion&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除</u><br>
      <br>
      <br>
      <br>
      <br>
      }<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;<u>// 敵の描画処理<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.enemies)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b-&gt;Draw();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 爆発エフェクトの描画処理<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; e : gm.explosions)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e-&gt;Draw();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 自機弾の描画処理<br>
        &nbsp;&nbsp;&nbsp; // C#のforeach文と同じく全自機弾を更新できる<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.playerBullets)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp; // autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b-&gt;Draw();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 敵弾の描画処理<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.enemyBullets)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b-&gt;Draw();<br>
        &nbsp;&nbsp;&nbsp; }</u><br>
      }</p>
    <br>
    <br>
    <br>
    <p>さて、移植しただけではゲームは動きません。<br>
      <code>Game.hとGame.cppにシーンの初期遷移、更新、描画の処理</code>を追加しましょう。</p>
    <br>
    <br>
    <p><code>Game.hにシーンのマネージャへの連絡先sm</code>を追加しましょう。</p>
    <p class="source">#ifndef GAME_H_<br>
      #define GAME_H_<br>
      <br>
      #include &lt;vector&gt;//C#のListリストの代わりのC++版<br>
      #include &lt;memory&gt;//スマートなポインタを使うのに必要(shared_ptrなど)<br>
      <br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      #include "GameManager.h"<br>
      <em>#include "SceneManager.h"<br>
        #include "Scene.h"</em><br>
      <br>
      class Game<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↓{ }を.hに書くことでcppに分けて書くはずの処理ぶぶんを.hに書いてもよい */<br>
      &nbsp;&nbsp;&nbsp; Game() {&nbsp; }; // 初期化コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; ~Game() {&nbsp; }; // 破棄処理デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;<em>SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る</em><br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; void Init(); // Init処理(定義だけ)<br>
      &nbsp;&nbsp;&nbsp; void Update(); // 更新処理(定義だけ)<br>
      &nbsp;&nbsp;&nbsp; void Draw();// 描画処理(定義だけ)<br>
      };<br>
      #endif</p>
    <p><code>Game.cppにシーンの初期遷移、更新、描画の処理</code>を追加しましょう。</p>
    <p class="source">#include "Game.h"<br>
      <br>
      #include "MyRandom.h"<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;&nbsp; Image::Load(); //画像の読込み<br>
      &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数シードの初期化<br>
      <br>
      &nbsp;&nbsp; &nbsp;<em>// ゲーム開始して最初はタイトルシーンに遷移<br>
        &nbsp;&nbsp; &nbsp;sm.LoadScene("TitleScene");</em><br>
      }<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Input::Update(); //【注意】これ忘れると<em>全シーン反応しない</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;<em>// シーンの更新処理<br>
        &nbsp;&nbsp; &nbsp;sm.currentScene-&gt;Update();</em><br>
      }<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;<em>// シーンの描画処理<br>
        &nbsp;&nbsp; &nbsp;sm.currentScene-&gt;Draw();</em><br>
      }</p>
    <br>
    <br>
    <br>
    <br>
    <p>さて、ここまでで画面遷移できるようになりました。<br>
      <b>一度実行して画面遷移できるか確認</b>してみてください。<br>
    </p>
    <br>
    <br>
    <br>
    <h2><a id="mozTocId40012" class="mozTocH1"></a>【高難度】画面やステージごとにImageのメモリを開放する</h2>
    <p>さて、画面遷移は実現しましたが、<b>現状ではメモリの節約効果は薄いです</b>。<br>
      なぜか？ 答えはImageクラスではゲーム<b>開始時に全画像データを読み込んだままずっと持ち続け</b>てます。<br>
      ゆえにゲームが壮大になれば<b>【冒険で使う全画像データがメモリにのり続けてしまい】</b>ます。<br>
      よって<b>【画面やステージマップごと】</b>に<b>【使用する画像以外をメモリから解放する】</b>処理を取り入れましょう。<br>
      <br>
      【補足と考察】<br>
      (実はプレイ中の<b>敵や弾[1個=数byte]の削除処理はメモリより【当たり判定のCPU計算を軽くする】効果の方が強かった</b>)<br>
      (<b>敵や弾[1個=数byte]×1000個でも1000バイト=1KBキロバイト</b>、一方で<b>【大きめの背景画像ファイルは1個で1～1000KBキロバイト=1MBメガバイト】</b>)<br>
      (<b>つまり画像1つ分で弾数万発ぶんのメモリ節約</b>、まあでも<b>【数万発の当たり判定したらCPU重くて画面フリーズしますが】</b>)<br>
    </p>
    <br>
    <br>
    <p><code>Image.hにロード済み画像の辞書に関する定義</code>を追加しましょう(mapタイプ型 = 辞書配列型)。</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
      <em>#include &lt;unordered_map&gt; // ロード済の画像辞書に使う</em><br>
      <em>#include &lt;string&gt; // 文字列string</em><em><br>
        #include &lt;memory&gt; // 辞書の指す先を回し読みポインタにする<br>
        #include &lt;vector&gt; // シーンのリストに使う<br>
        #include &lt;algorithm&gt; // シーンのリストからのfindに使う</em><br>
      #include "DivImage.h" // 分割画像の読込みに使う<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; Image() {}; // 初期化コンストラクタの定義だけ<br>
      &nbsp;&nbsp;&nbsp; ~Image() {}; // 破棄する処理デストラクタの定義だけ<br>
      &nbsp;&nbsp;&nbsp; static void Load(<em>std::string scene=""</em>); <em>// シーンを指定して使う画像だけロードもできる</em><br>
      &nbsp;&nbsp;&nbsp; static int LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage<em>, std::string scene="", std::vector&lt;std::string&gt; useScenes={""}</em>);<br>
      &nbsp;&nbsp;&nbsp; static int LoadGraph(const TCHAR* FileName<em>, std::string scene = "", std::vector&lt;std::string&gt; useScenes = { "" }</em>);<br>
      &nbsp;&nbsp;&nbsp; <em>static std::map&lt;std::string, DivImage*&gt; loadDic; // ロード済の画像辞書</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;&nbsp; static int player; //プレイヤ画像のハンドラ<br>
      &nbsp;&nbsp;&nbsp; static int playerBullet; //プレイヤの弾画像のハンドラ<br>
      &nbsp;&nbsp;&nbsp; static int enemyBullet16; //敵弾 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;&nbsp; static int zako0; //ザコ0 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;&nbsp; static int zako1; //ザコ1 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;&nbsp; static int zako2; //ザコ2 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;&nbsp; static int zako3; //ザコ3 画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;&nbsp; static int boss1; // ボス通常時<br>
      &nbsp;&nbsp;&nbsp; static int boss2; // ボス気絶<br>
      &nbsp;&nbsp;&nbsp; static int boss3; // ボス発狂<br>
      &nbsp;&nbsp;&nbsp; static DivImage explosion; // [分割画像]爆発エフェクト<br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif</p>
    <br>
    <p><code>Image.cppにロード済み画像を辞書に登録しシーンで使わない画像を開放する処理</code>を追加しましょう。</p>
    <p class="source">#include "Image.h"<br>
      <br>
      <em>std::unordered_map&lt;std::string, DivImage*&gt; Image::loadDic;</em><br>
      <br>
      int Image::bossImage{ -1 }; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      int Image::player{ -1 };<br>
      int Image::playerBullet{ -1 };<br>
      int Image::enemyBullet16{ -1 };<br>
      int Image::zako0{ -1 };<br>
      int Image::zako1{ -1 };<br>
      int Image::zako2{ -1 };<br>
      int Image::zako3{ -1 };<br>
      int Image::boss1{ -1 };<br>
      int Image::boss2{ -1 };<br>
      int Image::boss3{ -1 };<br>
      // ★分割画像は初期化のときに{X方向画像数, Y方向画像数, 画像横幅XSize,画像縦幅YSize}を指定<br>
      DivImage Image::explosion{ 8, 2, 64, 64 };<br>
      <br>
      void Image::Load(<em>std::string scene</em>)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; bossImage = LoadGraph("Image/boss1.png"<em>, scene, { "TitleScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; player = LoadGraph("Image/player.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(player != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; playerBullet = LoadGraph("Image/player_bullet.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(playerBullet != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; enemyBullet16 = LoadGraph("Image/enemy_bullet_16.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(enemyBullet16 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; zako0 = LoadGraph("Image/zako0.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(zako0 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; zako1 = LoadGraph("Image/zako1.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(zako1 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; zako2 = LoadGraph("Image/zako2.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(zako2 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; zako3 = LoadGraph("Image/zako3.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(zako3 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; boss1 = LoadGraph("Image/boss1.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(boss1 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; boss2 = LoadGraph("Image/boss2.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(boss2 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; boss3 = LoadGraph("Image/boss3.png"<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(boss3 != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // div分割画像をロード<em> or メモリ開放</em><br>
      &nbsp;&nbsp;&nbsp; Image::LoadDivGraph("Image/explosion.png", explosion<em>, scene, { "PlayScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; <u>for (int i = 0; i &lt; explosion.AllNum; i++)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 画像読込失敗<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (explosion.HandleArray[i] == -1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert("画像読込失敗(画像ファイル名やフォルダが正しい?)" == "");<br>
        &nbsp;&nbsp;&nbsp; }</u><br>
      }<br>
      <br>
      <em>// DXライブラリのLoadGraphを同じ関数名でラッピング(既存コードの書換えを最小限にする工夫)<br>
        // シーンごとにすでにメモリにロードしてある画像でシーンに使わないものはメモリから解放する<br>
        int Image::LoadGraph(const TCHAR* FileName, std::string scene, std::vector&lt;std::string&gt; useScenes)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; DivImage divImage{ 1,1,1,1 }; // 1×1の1分割画像として分割画像とロードを共通化<br>
        &nbsp;&nbsp;&nbsp; return Image::LoadDivGraph(FileName, divImage, scene, useScenes);<br>
        }</em><br>
      <br>
      // DXライブラリのLoadDivGraphを使いやすくラッピング<br>
      // ★関数に参照渡しを行う<br>
      // 関数の引数に参照渡しを行うことでdivImageの中身を書き換えることができる(値渡しでは書換不可)<br>
      // https://qiita.com/agate-pris/items/05948b7d33f3e88b8967<br>
      // https://qiita.com/RuthTaro/items/f35c3a26779c0ca1a41a<br>
      int Image::LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage<em>, std::string scene, std::vector&lt;std::string&gt; useScenes</em>)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; <em>int result = -1;<br>
        &nbsp;&nbsp;&nbsp; // 次のシーンで使う画像かの判別、useScenesリストにあれば使う判定<br>
        &nbsp;&nbsp;&nbsp; bool use = std::find(useScenes.begin(), useScenes.end(), scene) != useScenes.end();<br>
        &nbsp;&nbsp;&nbsp; if (use)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; &nbsp;// ロード済み辞書に指定したファイルがある(count=1)のとき<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (loadDic.count(FileName) == 1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; loadDic[FileName] != nullptr &amp;&amp; loadDic[FileName]-&gt;HandleArray != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 画像ハンドルをfor文で書き写す(単一:AllNum=1,分割画像:AllNum&gt;1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; loadDic[FileName]-&gt;AllNum; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; divImage.HandleArray[i] = loadDic[FileName]-&gt;HandleArray[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ロード済みなら画像ハンドルを返す(ロード時間短縮)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (loadDic[FileName]-&gt;AllNum == 1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return loadDic[FileName]-&gt;HandleArray[0];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else return 0; // 分割画像なら成功:0を返す(本家LoadDivGraphに合わせて)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXライブラリで画像をロードし辞書に登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (divImage.AllNum == 1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 単一画像のロードと画像サイズ取得<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = divImage.HandleArray[0] = DxLib::LoadGraph(FileName);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetGraphSize(result, &amp;(divImage.XSize), &amp;(divImage.YSize)); // 画像サイズ取得<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (divImage.AllNum &gt; 1) // 複数分割画像の読込み<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = </em>DxLib::LoadDivGraph(FileName, divImage.XNum * divImage.YNum,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; divImage.XNum, divImage.YNum, divImage.XSize, divImage.YSize, divImage.HandleArray);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>for (int i = 0; i &lt; divImage.AllNum; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { // 画像読込失敗<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (divImage.HandleArray[i] == -1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert("画像読込失敗(画像ファイル名やフォルダが正しい?)" == "");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 辞書用にdivImageの【★コピーを取ってポインタ】として保管<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result != -1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (loadDic.count(FileName) == 1 &amp;&amp; loadDic[FileName] != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 上書き登録のために既存の情報を消す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DivImage* oldHandle = loadDic[FileName];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; delete oldHandle;// 辞書に保管している情報削除<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; loadDic.erase(FileName);// 辞書から索引も削除<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 新たに辞書登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; loadDic[FileName] = new DivImage(divImage);//←★コピーコンストラクタ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result; // ロードした結果を返す<br>
        &nbsp;&nbsp;&nbsp; } // ↓ここまでの↑returnに引っかからずif抜けてきたら【シーン利用しない画像】<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 今回のシーンでは利用しない画像の時はメモリから画像を開放して節約<br>
        &nbsp;&nbsp;&nbsp; if (loadDic.count(FileName) == 1 &amp;&amp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loadDic[FileName] != nullptr &amp;&amp; loadDic[FileName]-&gt;HandleArray != nullptr)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; &nbsp;// メモリから画像開放 https://dxlib.xsrv.jp/function/dxfunc_graph1.html#R3N15<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; loadDic[FileName]-&gt;AllNum; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DeleteGraph(loadDic[FileName]-&gt;HandleArray[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DivImage* oldHandle = loadDic[FileName];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete oldHandle;// 辞書に保管している情報削除<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loadDic.erase(FileName); // 辞書からも索引削除<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; // 今回のシーンでは利用しない画像の時は-2を返す<br>
        &nbsp;&nbsp;&nbsp; return -2; // 画像読込み失敗の-1と区別するため-2を返します</em><br>
      };</p>
    <br>
    <p><code>DivImage.hにコピーコンストラクタをpublic定義にして</code>画像辞書に分割画像のコピーへのポインタを保存できるようにする。<br>
      <a href="https://docs.google.com/presentation/d/1m7LS913CRtCuFAz9-pbyWpka49vUoyqiL_n9h1kG_sY/edit?usp=sharing">スライドで変更理由に目を通しておきましょう(C++の根の深いコピー時の*ポインタとデータ分離問題)。</a></p>
    <p class="source">#ifndef DIVIMAGE_H_<br>
      #define DIVIMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 画像の2のべき乗チェックに使う<br>
      <br>
      // 分割画像を読込むためのデータ構造(画像数や画像ハンドル配列、3Dに使う場合の2のべき乗チェック機能をもつ)<br>
      class DivImage<br>
      {&nbsp; // 2Dの分割画像や3Dに分割Div画像を使うと画像全体が使われてしまうのを回避するための情報<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int XNum = 0;<br>
      &nbsp;&nbsp;&nbsp; int YNum = 0;<br>
      &nbsp;&nbsp;&nbsp; int XSize = 0;<br>
      &nbsp;&nbsp;&nbsp; int YSize = 0;<br>
      &nbsp;&nbsp;&nbsp; int* HandleArray = nullptr;<br>
      &nbsp;&nbsp;&nbsp; int AllNum = 0;<br>
      &nbsp;&nbsp;&nbsp; bool is3DTexture = false;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化 : X方向分割画像数 XNum, Y方向分割画像数 YNum, 画像 横 幅XSizeピクセル, 画像 縦 高さYSizeピクセル<br>
      &nbsp;&nbsp;&nbsp; DivImage(int XNum, int YNum, int XSize, int YSize, bool is3DTexture = false)<br>
      &nbsp;&nbsp;&nbsp; { // 初期化コンストラクタ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;XNum = XNum; // X方向分割画像数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;YNum = YNum; // Y方向分割画像数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;XSize = XSize; // 画像 横 幅XSize(ピクセルドット数)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;YSize = YSize; // 画像 縦 高さYSize(ピクセルドット数)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllNum = XNum * YNum; // トータルの分割画像数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;is3DTexture = is3DTexture; // 3Dテクスチャ分割画像かtrueだと2のべき乗チェックが入る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★div分割画像読込ハンドラ保存用のint配列メモリを確保し-1で初期化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;HandleArray = new int[AllNum]; // 配列を確保し-1で初期化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; AllNum; i++) HandleArray[i] = -1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //↑【演習★】初期化後の動的配列をデバッガで見てみよう[ary,256として再評価ボタン]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // http://visualstudiostudy.blog.fc2.com/blog-entry-17.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int* ary = HandleArray;<br>
      #ifdef _DEBUG // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is3DTexture == true) ImagePowCheck((*this)); // *(this)でthisポインタの示す変数内容を表す<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; ~DivImage()<br>
      &nbsp;&nbsp;&nbsp; { // デストラクタでメモリを解放<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;HandleArray != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] this-&gt;HandleArray;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// コピーコンストラクタ(動的new配列をクラス内に持つ場合にはカスタムが必要)<br>
        &nbsp;&nbsp;&nbsp; // [解説スライド] https://docs.google.com/presentation/d/1m7LS913CRtCuFAz9-pbyWpka49vUoyqiL_n9h1kG_sY/edit?usp=sharing<br>
        &nbsp;&nbsp;&nbsp; DivImage(const DivImage&amp; divImage)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 基本はただのコピー書き移し<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XNum = divImage.XNum; YNum = divImage.YNum;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XSize = divImage.XSize; YSize = divImage.YSize;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AllNum = XNum * YNum;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is3DTexture = divImage.is3DTexture;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↓★この配列だけはデフォルトのコピーコンストラクタではコピーされない！<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HandleArray = new int[AllNum]; //★[勉強]こちらでもnew確保<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; AllNum; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; HandleArray[i] = divImage.HandleArray[i];<br>
        &nbsp;&nbsp;&nbsp; };</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; //【勉強 []添え字演算子を独自に定義】https://programming.pc-note.net/cpp/operator.html<br>
      &nbsp;&nbsp;&nbsp; // 内部のHandleArrayに今までの様にImage::explosion[5]とかで簡単アクセスできるように【あいだに噛ます】<br>
      &nbsp;&nbsp;&nbsp; int const&amp; operator [](int index) const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (index &lt; 0 || AllNum &lt;= index) assert("画像データのアクセス番号がおかしい！" == "");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HandleArray[index];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; int&amp; operator [](int index)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (index &lt; 0 || AllNum &lt;= index) assert("画像データのアクセス番号がおかしい！" == "");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HandleArray[index];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      #ifdef _DEBUG // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;&nbsp; bool is_pow2(unsigned int x) // 2のべき乗か計算<br>
      &nbsp;&nbsp;&nbsp; { // https://programming-place.net/ppp/contents/c/rev_res/math012.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (x != 0) &amp;&amp; (x &amp; (x - 1)) == 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; void ImagePowCheck(DivImage&amp; divImage)<br>
      &nbsp;&nbsp;&nbsp; { // ★3Dに使う画像は2のべき乗でなければ受け付けないようにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://yttm-work.jp/gmpg/gmpg_0031.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://yappy-t.hatenadiary.org/entry/20100110/1263138881<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (divImage.XSize &gt; 0 &amp;&amp; divImage.YSize &gt; 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; is_pow2(divImage.XSize) &amp;&amp; is_pow2(divImage.YSize)) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else assert("3Dに使うなら2のべき乗の画像サイズにしなきゃ" == "");<br>
      &nbsp;&nbsp;&nbsp; }<br>
      #endif<br>
      <br>
      private: // <u>コピーと</u>代入をプライベートにして禁止する<br>
      &nbsp;&nbsp;&nbsp; <u>// コピーコンストラクタの禁止privateオーバーロード<br>
        &nbsp;&nbsp;&nbsp; DivImage(const DivImage&amp; divImage) {};</u><br>
      &nbsp;&nbsp;&nbsp; <em>// いままでコピー禁止してたのはnew,deleteの面倒なデータと*ポインタ分離問題を察知するため</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 代入演算子の禁止privateオーバーロード<br>
      &nbsp;&nbsp;&nbsp; void operator=(const DivImage&amp; divImage) {};<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>TitleScene.hにシーンごとの画像読込みとメモリ開放する処理</code>を追加しましょう。</p>
    <p class="source">(中略)........<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Image::Load("TitleScene"); //画像の読込みとメモリ開放</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 100; // Xの初期位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vx = 10; // ボスの初期速度<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (中略)........</p>
    <br>
    <p><code>PlayScene.hにシーンごとの画像読込みとメモリ開放する処理</code>を追加しましょう。</p>
    <p class="source">(中略)........<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Image::Load("PlayScene"); //画像の読込みとメモリ開放</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ここでプレイヤの初期化などのプレイ開始時の処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.player = std::make_shared&lt;Player&gt;((float)100, (float)(Screen::Height / 2)); // 自機の初期化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 敵の仮生成<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Screen::Width + 90, Screen::Height / 2));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (中略)........</p>
    <br>
    <p><code>GameOverScene.hにシーンごとの画像読込みとメモリ開放する処理</code>を追加します。<br>
      (現状シーンで画像使ってないけどプレイ中画面のメモリを解放する効果が出る)。</p>
    <p class="source">(中略)........<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Image::Load("GameOverScene"); //画像の読込みとメモリ開放</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (中略)........</p>
    <br>
    <p><code>Game.cppでやっていたImageのLoadを削除</code>します。</p>
    <p class="source">#include "Game.h"<br>
      <br>
      #include "MyRandom.h"<br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;&nbsp; <u>Image::Load("PlayScene"); //画像の読込み</u><br>
      &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数シードの初期化<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ゲーム開始して最初はタイトルシーンに遷移<br>
      &nbsp;&nbsp;&nbsp; sm.LoadScene("TitleScene");<br>
      }<br>
      <br>
      (以下略)............</p>
    <br>
    <br>
    <p>これで一応画面ごとにメモリから画像データが開放される構造になりました。<br>
      でも、ほとんどメモリのグラフには変化がないかもしれません(<b>タイトル動画など重いデータあれば威力発揮</b>) </p>
    <br>
    <br>
    <h2><a id="mozTocId40013" class="mozTocH1"></a>サウンドの読込みと再生機能</h2>
    <p>実は画像より音声のほうがメモリ消費が大きかったりします。<br>
      なぜか?画像はアニメしなければ1枚ですよね。<br>
      一方<b>【音声には時間の長さがあります】</b>再生時間が10分など長くなれば数MBになります。<br>
      <b>特に.mp3など圧縮された音声ファイルはメモリ上では非圧縮の.wavになります！</b><br>
      ゲーム開始前は小さいmp3の音声ファイルがゲーム開始すると<b>【メモリ上で数十倍に膨れ上がります】</b><br>
      しかも最悪なことに<b>【圧縮をもとの音声に戻すためロードにめちゃくちゃ時間がかかります】</b><br>
      ゆえにロードが重くなるのを防ぐためLoadSoundMemする<b>音声ファイルは【あらかじめ.wav変換したほうがLoadが早い】</b>です。<br>
      以下リンクの変換ツールで<b>mp3などを.wavの非圧縮の音声ファイルに変換</b>して使いましょう。<br>
      <a href="https://forest.watch.impress.co.jp/library/software/flicaudiocon/">https://forest.watch.impress.co.jp/library/software/flicaudiocon/</a> <br>
      <br>
      今回はまず<b>「webでさがしたBGM素材サイト」</b>から音声ファイルを取ってきてSoundクラスを作成してみましょう。<br>
	    素材サイト例)<br>
	    <a href="https://maou.audio/category/bgm/">https://maou.audio/category/bgm/</a> <br>
	    <a href="https://maou.audio/category/se/">https://maou.audio/category/se/</a> <br>
	<br>
      以下のファイルを作成中のC++のプロジェクト下にImageフォルダの時のように「SEフォルダ」や「BGMフォルダ」を作成してコピーしておきましょう。</p>
    <ul>
      <li>start.ogg&nbsp; スタート時に鳴らす&nbsp;&nbsp; ⇒ SE/start.oggに移動</li>
      <li>bomb.wav&nbsp; 爆発時に鳴らす&nbsp;&nbsp; ⇒ SE/bomb.wavに移動</li>
      <li>title.ogg &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; タイトル画面で流れる&nbsp;&nbsp; ⇒ BGM/title.mp3に移動</li>
      <li>gameplay.ogg プレイ画面で流れる&nbsp;&nbsp; ⇒ BGM/gameplay.mp3に移動</li>
      <li>ending.ogg &nbsp;&nbsp;&nbsp; ゲームオーバ画面で流れる&nbsp;&nbsp; ⇒ BGM/ending.mp3に移動</li>
    </ul>
    <p>まずは簡易版のSoundクラスを作ってみましょう。基本はImage.hと似ています。</p>
    <p><code>Sound.hを新規作成</code>します。</p>
    <p class="source">#ifndef SOUND_H_<br>
      #define SOUND_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 音声読み込みの読込み失敗表示用<br>
      #include &lt;string&gt;<br>
      <br>
      class Sound<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;Sound() {}; // 初期化コンストラクタの定義<br>
      &nbsp;&nbsp; &nbsp;~Sound() {}; // 破棄処理デストラクタの定義<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// メモリ再生音源管理番号<br>
      &nbsp;&nbsp; &nbsp;static int start; // ピロピロリン<br>
      &nbsp;&nbsp; &nbsp;static int bomb; // ボン！<br>
      <br>
      &nbsp;&nbsp; &nbsp;static std::string playingMusic; // 再生中のBGM(同一BGMをPlayMusic指定しても再生し直さない)<br>
      <br>
      &nbsp;&nbsp; &nbsp;static void Load();<br>
      &nbsp;&nbsp; &nbsp;// メモリから音声を再生(個別の音量設定も効かせられる)<br>
      &nbsp;&nbsp; &nbsp;static void Play(int handle, int PlayType = DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp; &nbsp;// ディスク上の音楽を直接再生する(メモリ上に展開しない)<br>
      &nbsp;&nbsp; &nbsp;static void PlayMusic(std::string file, int PlayType = DX_PLAYTYPE_LOOP);<br>
      &nbsp;&nbsp; &nbsp;<br>
      private:<br>
      <br>
      };<br>
      #endif</p>
    <br>
    <br>
    <p><code>Sound.cppを新規作成</code>します。<br>
      <b>すでにプレイ中のBGMは同じBGMをPlayMusicしようとしても再生し直さない工夫をしています。<br>
        これで再生ボタンUpdate連打状態で重くなるストッパーになります</b>。</p>
    <p class="source">#include "Sound.h"<br>
      <br>
      // メモリ再生音源管理番号<br>
      int Sound::start; // ピロピロリン<br>
      int Sound::bomb; // ボン！<br>
      <br>
      std::string Sound::playingMusic; // 再生中のBGM(同一BGMをプレイ指定しても初めから再生しない)<br>
      <br>
      void Sound::Load()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; start = LoadSoundMem("SE/start.ogg");<br>
      &nbsp;&nbsp;&nbsp; assert(start != -1); // 読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; bomb = LoadSoundMem("SE/bomb.wav");<br>
      &nbsp;&nbsp;&nbsp; assert(bomb != -1); // 読込失敗、ファイル名かフォルダ名が間違ってる<br>
      }<br>
      <br>
      // メモリ上の音声を再生する。<br>
      void Sound::Play(int handle, int PlayType)<br>
      {&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // メモリ上から音声再生<br>
      &nbsp;&nbsp;&nbsp; PlaySoundMem(handle, PlayType);<br>
      }<br>
      <br>
      // ディスク上の音楽を直接再生する(メモリ上に展開しない)<br>
      void Sound::PlayMusic(std::string file, int PlayType)<br>
      {&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <b>// プレイ中のBGMを再指定しても再生し直さず即時return<br>
        &nbsp;&nbsp;&nbsp; if (file == playingMusic) return;<br>
        <br>
        &nbsp;&nbsp;&nbsp; playingMusic = file; // プレイ中のBGM名を記録</b><br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::PlayMusic(file.c_str(), PlayType); //ディスクから直接再生(メモリにのせない)<br>
      }<br>
    </p>
    <br>
    <br>
    <p><code>Game.cppにSoundのロード処理を追加</code>します。<br>
    </p>
    <p class="source">#include "Game.h"<br>
      <br>
      #include "MyRandom.h"<br>
      <em>#include "Sound.h"</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数シードの初期化<br>
      &nbsp;&nbsp;&nbsp; <em>Sound::Load(); //音声の読込み</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // ゲーム開始して最初はタイトルシーンに遷移<br>
      &nbsp;&nbsp;&nbsp; sm.LoadScene("TitleScene");<br>
      }<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;&nbsp; // シーンの更新処理<br>
      &nbsp;&nbsp;&nbsp; sm.currentScene-&gt;Update();<br>
      }<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // シーンの描画処理<br>
      &nbsp;&nbsp;&nbsp; sm.currentScene-&gt;Draw();<br>
      }<br>
    </p>
    <br>
    <p><code>TitleScene.hにサウンドの読込みとBGM再生、ゲームスタート時の再生処理と再生終わり待ちで画面遷移する処理</code>を追加します。</p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <em>#include "Sound.h"</em><br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;<em>// スタートボタンを押したら音声再生完了を待って画面移動<br>
        &nbsp;&nbsp; &nbsp;bool isStartPushed = false;</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;int x = 0; //staticじゃないintはここで=0で初期化できる<br>
      &nbsp;&nbsp; &nbsp;int vx = 0;<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;TitleScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "TitleScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Image::Load("TitleScene"); //画像の読込みとメモリ開放<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>Sound::PlayMusic("BGM/title.mp3"); //タイトルBGMを再生<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isStartPushed = false; // ボタンのフラグをリセット</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = 10; // ボスの初期速度<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだが終了時だけやりたいリセットの仕方もあるかも)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;<em>// ボタン入力に応じた処理<br>
        &nbsp;&nbsp; &nbsp;void HandleInput()<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// ボタンを押したらスタート音声を再生<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Sound::Play(Sound::start);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isStartPushed = true; // 画面遷移トリガーON<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;}</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// スタートの効果音の再生が終わるまで画面遷移を待つ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (isStartPushed &amp;&amp; CheckSoundMem(Sound::start) == 0)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// スタート音声再生終了をトリガーとして画面遷移<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sm.LoadScene("PlayScene"); //シーン遷移<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;HandleInput(); // キー入力処理</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = -10; //画面端で移動方向反転<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x += vx; // ボス画像のX位置の更新<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 0, "TitleSceneです。ボタン押下でPlaySceneへ。", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 200, "MAXスコア: " + sm.scoreMax, GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawRotaGraphF((float)x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>PlayScene.hにプレイBGM再生と敵の被弾の効果音の処理</code>を追加します。<br>
      音声のハンドルを<b>辞書管理してメモリから解放したり個別音量調整できるように</b>します。</p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <em>#include "Sound.h"</em><br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Boss.h"<br>
      #include "PlayerBullet.h"<br>
      #include "EnemyBullet.h"<br>
      #include "Explosion.h"<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp;&nbsp; GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; PlayScene() : Scene()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;tag = "PlayScene";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Image::Load("PlayScene"); //画像の読込みとメモリ開放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>Sound::PlayMusic("BGM/gameplay.mp3"); //プレイ画面BGMを再生</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ここでプレイヤの初期化などのプレイ開始時の処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵の仮生成<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (中略)...................<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (中略)...................<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾と敵の衝突判定<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; playerBullet : gm.playerBullets)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾と敵が重なっているか？<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; playerBullet-&gt;position, playerBullet-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; enemy-&gt;position, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; playerBullet-&gt;OnCollisionEnemy(enemy);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>Sound::Play(Sound::bomb); // 効果音の再生</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; break;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (中略)...................<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ゲームオーバー判定と画面チェンジ処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bool isGameover = (gm.player == nullptr);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isGameover &amp;&amp; gm.player-&gt;isDead) isGameover = true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isGameover)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>Sound::PlayMusic("BGM/ending.mp3");</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.LoadScene("GameOverScene"); //シーン遷移<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (中略)...................<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p>ここまでで簡易的なサウンドの再生できるようになります。<br>
      実行してみてうまく音声が再生できるか試してみましょう。<br>
      次は高度なサウンドの機能を作成しますが、難易度が上がりますので<br>
      <b>簡単に再生できるだけでよい人は高度なサウンド機能は一旦後回しでもよいかも</b>しれません。</p>
    <br>
    <br>
    <br>
    <h2><a id="mozTocId40014" class="mozTocH1"></a>【高難度】画面やステージごとにサウンドをメモリ読込み・解放(音量調整機能も追加)</h2>
    <p>さて、一応基本的なサウンド再生機能は実現しました。<br>
      この項では<b>少し高度なサウンドの音量管理とメモリ管理を辞書配列で実現します。</b><br>
      とりあえず再生できればよいや、という人は<b>あとから取り入れる形でもよいかも</b>しれません。</p>
    <p>辞書配列には<b>辞書配列mapの【高速版unordered_map】を使用</b>しました。<br>
      普通の辞書は【あいうえお順に毎度並べ替えに時間かけてる】ですが、<br>
      <b>高速版辞書は【いちいち、あいうえお並び替えしないから高速】</b>と覚えておきましょう。<br>
      <b>並べ替え順のない高速辞書を【ハッシュ】と呼びます。</b><br>
      <b>ハッシュは【辞書のキー⇒順番の必要ないデータへの高速アクセス可】と暗記</b>しておきましょう。<br>
      配列などの中では<b>【条件付きでほぼ最速】</b>という認識で大丈夫です。<br>
      まとめて複数の音声をフェードアウトするときはUpdateで音声辞書を秒間60回連続検索することになるので導入しました。<br>
      ちなみにどれくらい高速かは下記リンク参照(ハッシュはO(1)という最速水準の単位です)<br>
      <a href="https://qiita.com/drken/items/872ebc3a2b5caaa4a0d0">https://qiita.com/drken/items/872ebc3a2b5caaa4a0d0</a><br>
    </p>
    <p><code>Sound.hに辞書配列や音量管理関数の定義を追加</code>します。 </p>
    <p class="source">#ifndef SOUND_H_<br>
      #define SOUND_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 音声読み込みの読込み失敗表示用<br>
      #include &lt;string&gt;<br>
      <em>#include &lt;unordered_map&gt; // 音声の辞書【map高速版】https://qiita.com/sileader/items/a40f9acf90fbda16af51<br>
        #include &lt;vector&gt; // シーンのリストに使う<br>
        #include &lt;algorithm&gt; // シーンのリストからのfindに使う</em><br>
      <br>
      class Sound<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; Sound() {}; // 初期化コンストラクタの定義<br>
      &nbsp;&nbsp;&nbsp; ~Sound() {}; // 破棄処理デストラクタの定義<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // メモリ再生音源管理番号<br>
      &nbsp;&nbsp;&nbsp; static int start; // ピロピロリン<br>
      &nbsp;&nbsp;&nbsp; static int bomb; // ボン！<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// ディスク再生音源管理番号<br>
        &nbsp;&nbsp;&nbsp; static int title; // タイトル画面BGM<br>
        &nbsp;&nbsp;&nbsp; static int gameplay; // プレイ画面BGM<br>
        &nbsp;&nbsp;&nbsp; static int ending; // ゲームオーバ画面BGM</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>static std::unordered_map&lt;std::string, int&gt; loadDic; // ロード済の音声辞書<br>
        &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;int, std::string&gt; SE_Dic; // SEファイル名辞書<br>
        &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;int, std::string&gt; BGM_Dic; // BGMファイル名辞書<br>
        &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;std::string, float&gt; volumeDic; // 【音声ごと】の[音量]辞書</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>static float volumeSE; // 効果音のベース音量(0～100%で指定)<br>
        &nbsp;&nbsp;&nbsp; static float volumeBGM; // 音楽BGMのベース音量(0～100%で指定)</em><br>
      &nbsp;&nbsp;&nbsp; static std::string playingMusic; // 再生中のBGM(同一BGMをPlayMusic指定しても再生し直さない<br>
      &nbsp;&nbsp;&nbsp; <em>static int musicId; // 音楽ID -3,-4,-5..メモリ上にのせないが番号を管理し個別に音量設定できるよう</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; static void Load(<em>std::string scene = ""</em>); <em>// シーンを指定して使うサウンドだけロードもできる</em><br>
      &nbsp;&nbsp;&nbsp; // メモリから音声を再生(個別の音量設定も効かせられる)<br>
      &nbsp;&nbsp;&nbsp; static void Play(int handle, int PlayType = DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp; // ディスク上の音楽を直接再生する(メモリ上に展開しない)<br>
      &nbsp;&nbsp;&nbsp; static void PlayMusic(std::string file, int PlayType = DX_PLAYTYPE_LOOP);<br>
      &nbsp;&nbsp;&nbsp; <em>// IDからディスク上の音楽を直接再生する(メモリ上に展開しない)<br>
        &nbsp;&nbsp;&nbsp; static void PlayMusic(int musicId, int PlayType = DX_PLAYTYPE_LOOP);<br>
        &nbsp;&nbsp;&nbsp; // ファイルを辞書登録しmusicIDで管理する(メモリにはのせずファイル名とIDだけ登録)<br>
        &nbsp;&nbsp;&nbsp; static int SetMusicFile(std::string file, bool isSE = false);<br>
        &nbsp;&nbsp;&nbsp; // 音声ファイルごとのボリューム設定<br>
        &nbsp;&nbsp;&nbsp; static void SetVolume(float VolumeParcent, int SoundHandle);<br>
        &nbsp;&nbsp;&nbsp; // メモリ音源の音量の更新(再生中に減らせばフェードアウト)<br>
        &nbsp;&nbsp;&nbsp; static int UpdateVolume(int SoundHandle = -1);<br>
        &nbsp;&nbsp;&nbsp; // 再生中のディスク音楽の音量の更新<br>
        &nbsp;&nbsp;&nbsp; static int UpdateMusicVolume();<br>
        &nbsp;&nbsp;&nbsp; // 音声をメモリへ読込み番号GET or シーンで使わない場合はメモリから解放<br>
        &nbsp;&nbsp;&nbsp; static int LoadSoundMem(const TCHAR *FileName, std::string scene, std::vector&lt;std::string&gt; useScenes</em><em><em>, bool isBGM=false</em>, int BufferNum = 3);</em><br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>Sound.cppに音声辞書とメモリ開放と音量調節処理を追加</code>します。<br>
      音声のハンドルを<b>辞書管理してメモリから解放したり個別音量調整できるように</b>します。</p>
    <p class="source">#include "Sound.h"<br>
      <br>
      // メモリ再生音源管理番号<br>
      int Sound::start; // ピロピロリン<br>
      int Sound::bomb; // ボン！<br>
      <br>
      <em>// ディスク再生音源管理番号<br>
        int Sound::title; // タイトル画面BGM<br>
        int Sound::gameplay; // プレイ画面BGM<br>
        int Sound::ending; // ゲームオーバ画面BGM<br>
        <br>
        <br>
        std::unordered_map&lt;std::string, int&gt; Sound::loadDic; // ロード済の音声辞書<br>
        std::unordered_map&lt;int, std::string&gt; Sound::SE_Dic; // SEファイル名辞書<br>
        std::unordered_map&lt;int, std::string&gt; Sound::BGM_Dic; // BGMファイル名辞書<br>
        std::unordered_map&lt;std::string, float&gt; Sound::volumeDic; // 【音声ごと】の[音量]辞書<br>
        <br>
        float Sound::volumeSE{ 100 }; // 効果音のベース音量(0～100%で指定)<br>
        float Sound::volumeBGM{ 100 }; // 音楽BGMのベース音量(0～100%で指定)</em><br>
      std::string Sound::playingMusic{ "" }; // 再生中のBGM(同一BGMをPlayMusic指定しても再生し直さない<br>
      <em>int Sound::musicId{ -3 }; // 音楽ID -3,-4,-5..メモリ上にのせないが番号を管理し個別に音量設定できるよう</em><br>
      <br>
      <em>// シーンを指定して使うサウンドだけロードもできる</em><br>
      void Sound::Load(<em>std::string scene</em>)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; start = Sound::LoadSoundMem("SE/start.ogg"<em>, scene, { "TitleScene" }</em>);<br>
      &nbsp;&nbsp;&nbsp; assert(start != -1); // 読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; <em>// オプションで同時[8つ]爆発音再生を可能に(デフォルトは3)falseをtrueにするとBGM扱い</em><br>
      &nbsp;&nbsp;&nbsp; bomb = Sound::LoadSoundMem("SE/bomb.wav"<em>,scene,{"TitleScene","PlayScene"},false, 8);<br>
        &nbsp;&nbsp;&nbsp; </em>assert(bomb != -1); // 読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>title = SetMusicFile("BGM/title.mp3");<br>
        &nbsp;&nbsp;&nbsp; gameplay = SetMusicFile("BGM/gameplay.mp3");<br>
        &nbsp;&nbsp;&nbsp; ending = SetMusicFile("BGM/ending.mp3");</em><br>
      }<br>
      <br>
      // メモリ上の音声を再生する。<br>
      void Sound::Play(int handle, int PlayType)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; <em>assert(handle != -1 &amp;&amp; "プレイする音声がメモリにない?" != "");</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 音量の更新<br>
        &nbsp;&nbsp;&nbsp; UpdateVolume(handle);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // メモリ上から音声再生<br>
      &nbsp;&nbsp;&nbsp; PlaySoundMem(handle, PlayType);<br>
      }<br>
      <br>
      // ディスク上の音楽を直接再生する(メモリ上に展開しない)<br>
      void Sound::PlayMusic(std::string file, int PlayType)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // プレイ中のBGMを再指定しても初めから再生せず即時return<br>
      &nbsp;&nbsp;&nbsp; if (file == playingMusic) return;<br>
      <br>
      &nbsp;&nbsp;&nbsp; playingMusic = file; // プレイ中のBGM名を設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::PlayMusic(file.c_str(), PlayType); //ディスクから直接再生(メモリにのせない)<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>Sound::UpdateMusicVolume(); // // 音量の更新(プレイ【中】の音楽だから↑PlayMusicしてから)</em><br>
      }<br>
      <br>
      <em>// IDからディスク上の音楽を直接再生する(メモリ上に展開しない)<br>
        void Sound::PlayMusic(int musicId, int PlayType)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (musicId &gt; -1) return;//音楽IDはマイナスのID番号を割り振ったはず<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::string file = "";<br>
        &nbsp;&nbsp;&nbsp; // 辞書から対応するファイル名を取得<br>
        &nbsp;&nbsp;&nbsp; if (BGM_Dic.count(musicId) == 1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; file = BGM_Dic[musicId];<br>
        &nbsp;&nbsp;&nbsp; else if (SE_Dic.count(musicId) == 1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; file = SE_Dic[musicId];<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (file == "") return;//対応する音楽ファイルが辞書に未登録<br>
        &nbsp;&nbsp;&nbsp; // ファイル名から音楽ファイルを再生<br>
        &nbsp;&nbsp;&nbsp; Sound::PlayMusic(file, PlayType);<br>
        }<br>
        <br>
        // ファイルを辞書登録しmusicIDで管理する(メモリにはのせずファイル名とIDだけ登録)<br>
        int Sound::SetMusicFile(std::string file, bool isSE)<br>
        {&nbsp;&nbsp;&nbsp; // 既に辞書登録済なら即時return<br>
        &nbsp;&nbsp;&nbsp; if (loadDic.count(file) == 1) return loadDic[file];<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 新規に辞書にファイル登録<br>
        &nbsp;&nbsp;&nbsp; loadDic[file] = musicId; //IDの辞書に登録<br>
        &nbsp;&nbsp;&nbsp; if (isSE) SE_Dic[musicId] = file; //SEの辞書に登録<br>
        &nbsp;&nbsp;&nbsp; else BGM_Dic[musicId] = file; //BGMの辞書に登録<br>
        <br>
        &nbsp;&nbsp;&nbsp; return musicId--; // 後ろに--つけるとカウントダウン前をreturn<br>
        }<br>
        <br>
        // 音声ファイルごとのボリューム設定<br>
        void Sound::SetVolume(float VolumeParcent, int SoundHandle)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (SoundHandle == -1) return;<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (SE_Dic.count(SoundHandle) == 1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ハンドル番号がSEの辞書で見つかれば<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string file = SE_Dic[SoundHandle];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeDic[file] = VolumeParcent;//個別音量を辞書登録<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (BGM_Dic.count(SoundHandle) == 1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ハンドル番号がBGMの辞書で見つかれば<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string file = BGM_Dic[SoundHandle];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeDic[file] = VolumeParcent;//個別音量を辞書登録<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // セットした後の音声には音量が反映されるが<br>
        &nbsp;&nbsp;&nbsp; // すでに再生中の音量は変わらないので↓UpdateVolumeとセットで実行<br>
        }<br>
        <br>
        // メモリ音源の音量の更新(再生中に減らせばフェードアウト)<br>
        int Sound::UpdateVolume(int SoundHandle)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 特に指定がなければすべての音量を更新<br>
        &nbsp;&nbsp;&nbsp; if (SoundHandle == -1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 辞書のfor文はキーとバリューがペアになってる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int result = 0, resultAll = 0;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; kv : loadDic)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 辞書のキーがkv.first,バリューがkv.second<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int handle = kv.second;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 【★勉強】自分自身を呼出す奥の手<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (handle != -1) //↓【再起呼出し】<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; result = Sound::UpdateVolume(handle);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (result == -1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; resultAll += -1; // 失敗した数ぶん-1がカウントされる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return resultAll; // 全音量更新完了【再起呼出しループで】<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 音源指定があるときはhandleを指定して音量を更新<br>
        &nbsp;&nbsp;&nbsp; int handle = SoundHandle;<br>
        <br>
        &nbsp;&nbsp;&nbsp; int volume = 255;<br>
        &nbsp;&nbsp;&nbsp; float volumeParcent = 100;<br>
        &nbsp;&nbsp;&nbsp; std::string file = "";<br>
        &nbsp;&nbsp;&nbsp; if (SE_Dic.count(handle) == 1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // サウンド番号がSE辞書で見つかれば<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; file = SE_Dic[handle];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeParcent = volumeSE; //音量をSEのベース音量に<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (BGM_Dic.count(handle) == 1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // サウンド番号がBGM辞書で見つかれば<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; file = BGM_Dic[handle];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeParcent = volumeBGM; //音量をSEのベース音量に<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (volumeDic.count(file) == 1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 音量辞書をファイル名で検索して<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float fileParcent = volumeDic[file];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeParcent *= fileParcent / 100; //個別音量%割合反映<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (volumeParcent &lt; 100) // 音量に%パーセントを掛ける<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volume = (int)(((float)volume) * volumeParcent / 100);<br>
        &nbsp;&nbsp;&nbsp; // 音量反映<br>
        &nbsp;&nbsp;&nbsp; int result = ChangeVolumeSoundMem(volume, handle);<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result == 0) // 音量変更成功<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return volume;<br>
        &nbsp;&nbsp;&nbsp; else return result; // 音量変更失敗<br>
        }<br>
        <br>
        // 再生中のディスク音楽の音量の更新<br>
        int Sound::UpdateMusicVolume()<br>
        {<br>
        &nbsp;&nbsp;&nbsp; std::string file = playingMusic;<br>
        <br>
        &nbsp;&nbsp;&nbsp; int volume = 255;<br>
        &nbsp;&nbsp;&nbsp; float volumeParcent = volumeBGM;<br>
        &nbsp;&nbsp;&nbsp; if (volumeDic.count(file) == 1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 音量辞書をファイル名で検索して<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float fileParcent = volumeDic[file];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeParcent *= fileParcent / 100; //個別音量%割合反映<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (volumeParcent &lt; 100) // 音量に%パーセントを掛ける<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volume = (int)(((float)volume) * volumeParcent / 100);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 音量反映<br>
        &nbsp;&nbsp;&nbsp; int result = SetVolumeMusic(volume);<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result == 0) // 音量変更成功<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return volume;<br>
        &nbsp;&nbsp;&nbsp; else return result; // 音量変更失敗<br>
        }<br>
        <br>
        // 音声をメモリへ読込み番号GET or シーンで使わない場合はメモリから解放<br>
        int Sound::LoadSoundMem(const TCHAR *FileName, std::string scene, std::vector&lt;std::string&gt; useScenes, bool isBGM, int BufferNum)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; int result = -1;<br>
        &nbsp;&nbsp;&nbsp; // 次のシーンで使う音声かの判別、useScenesリストにあれば使う判定<br>
        &nbsp;&nbsp;&nbsp; bool use = std::find(useScenes.begin(), useScenes.end(), scene) != useScenes.end();<br>
        &nbsp;&nbsp;&nbsp; if (use)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ロード済み辞書に指定したファイルがある(count=1)のとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (loadDic.count(FileName) == 1 &amp;&amp; loadDic[FileName] != -1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ロード済みなら音声ハンドルを返す(ロード時間短縮)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return loadDic[FileName];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // DXライブラリで音声をロード、BufferNumは同時再生可能数<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; result = DxLib::LoadSoundMem(FileName, BufferNum);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (result != -1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 辞書にサウンドハンドル番号を保管<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int handle = result; //ロード結果からハンドル番号取得<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; loadDic[FileName] = handle;//ロード済辞書に登録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isBGM) BGM_Dic[handle] = FileName;//BGMの辞書に登録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else SE_Dic[handle] = FileName;//SEの辞書に登録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return result; // ロードした結果を返す<br>
        &nbsp;&nbsp;&nbsp; } // ↓ここまでの↑returnに引っかからずif抜けてきたら【シーン利用しないサウンド】<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 今回のシーンでは利用しないサウンドの時はメモリからサウンドを開放して節約<br>
        &nbsp;&nbsp;&nbsp; if (loadDic.count(FileName) == 1 &amp;&amp; loadDic[FileName] != -1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // メモリからサウンド開放 https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N8<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int handle = loadDic[FileName];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; result = DxLib::DeleteSoundMem(handle);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(result != -1 &amp;&amp; "音声メモリ開放失敗" != "");<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 辞書からハンドルを削除<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (SE_Dic.count(handle) == 1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SE_Dic.erase(handle);//SEの辞書から削除<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (BGM_Dic.count(handle) == 1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; BGM_Dic.erase(handle);//BGMの辞書から削除<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; loadDic.erase(FileName); // ID辞書からも索引削除<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; // 今回のシーンでは利用しないサウンドの時は-2を返す<br>
        &nbsp;&nbsp;&nbsp; return -2; // サウンド読込み失敗の-1と区別するため-2を返します<br>
        }</em><br>
    </p>
    <br>
    <br>
    <p><code>TitleScene.hにシーンごとのサウンドのロードと音量調節機能を追加</code>します。<br>
      タイトル画面で<b><b>左右</b>キーを押すと音量調整できるようになり</b><b><b>上下</b><b><b></b></b>キーでSE⇔BGM調整モードを切り替え</b>られます。</p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "Sound.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;<em>// 設定モード<br>
        &nbsp;&nbsp; &nbsp;enum class SettingMode<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BGM=0, // BGM設定モード<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SE, // SE設定モード<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NUM // 列挙数[enumの数を得る] https://qiita.com/k-satoda/items/2985e81216b3ee500956<br>
        &nbsp;&nbsp; &nbsp;};<br>
        &nbsp;&nbsp; &nbsp;SettingMode settingMode = SettingMode::BGM; // 現在の設定モード</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// スタートボタンを押したら音声再生完了を待って画面移動<br>
      &nbsp;&nbsp; &nbsp;bool isStartPushed = false;<br>
      <br>
      &nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;int x = 0; //staticじゃないintはここで=0で初期化できる<br>
      &nbsp;&nbsp; &nbsp;int vx = 0;<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;TitleScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "TitleScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Image::Load("TitleScene"); //画像の読込みとメモリ開放<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>Sound::Load("TitleScene"); //音声の読込みとメモリ開放</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Sound::PlayMusic(<em>Sound::title</em>); //タイトルBGMを再生<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isStartPushed = false; // ボタンのフラグをリセット<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x = 100; // Xの初期位置<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = 10; // ボスの初期速度<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだが終了時だけやりたいリセットの仕方もあるかも)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// ボタン入力に応じた処理<br>
      &nbsp;&nbsp; &nbsp;void HandleInput()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// ボタンを押したらスタート音声を再生<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Sound::Play(Sound::start);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isStartPushed = true; // 画面遷移トリガーON<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <em>if (Input::GetButtonDown(PAD_INPUT_UP))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //上を押すと設定モードを-1する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int index = ((int)settingMode - 1);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (index &lt; 0) //↓番号ループ 0→最大数-1<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; index = ((int)SettingMode::NUM) - 1;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; settingMode = (SettingMode)index;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (Input::GetButtonDown(PAD_INPUT_DOWN))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //下を押すと設定モードを+1する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int index = ((int)settingMode + 1);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (index &gt;= ((int)SettingMode::NUM))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; index = 0; //番号ループ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; settingMode = (SettingMode)index;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(PAD_INPUT_RIGHT))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (settingMode == SettingMode::BGM)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM++;//音量をプラス<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeBGM &gt; 100)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM = 100;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (settingMode == SettingMode::SE)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE++;//音量をプラス<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeSE &gt; 100)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE = 100;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::bomb); //効果音を聞きながら調節<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::UpdateMusicVolume(); //再生中の音量の更新<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (Input::GetButton(PAD_INPUT_LEFT))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (settingMode == SettingMode::BGM)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM--;//音量をマイナス<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeBGM &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM = 0;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (settingMode == SettingMode::SE)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE--;//音量をマイナス<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeSE &lt;0)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE = 0;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::bomb); //効果音を聞きながら調節<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::UpdateMusicVolume(); //再生中の音量の更新<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</em><br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スタートの効果音の再生中は遷移を待つ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (isStartPushed &amp;&amp; CheckSoundMem(Sound::start) == 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// スタート音声再生終了をトリガーとして画面遷移<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sm.LoadScene("PlayScene"); //シーン遷移<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;HandleInput(); // キー入力処理<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = 10; //速度の変更<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (x &gt; Screen::Width)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;vx = -10; //画面端で移動方向反転<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x += vx; // ボス画像のX位置の更新<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 0, "TitleSceneです。ボタン押下でPlaySceneへ。", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (sm.scoreMax &gt;= 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawString(0, 200, "MAXスコア: " + sm.scoreMax, GetColor(255, 255, 255));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <em>// 音量設定目盛りの文字列の生成<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string volumeBGM = "　";<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (settingMode == SettingMode::BGM)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeBGM = "⇒"; //[選択中]⇒BGM音量設定モード<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeBGM += "BGM音量設定:" + std::to_string((int)Sound::volumeBGM);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int volBGM_NUM = (int)(Sound::volumeBGM / 10);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (volBGM_NUM != 10) volumeBGM += " ";<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; volBGM_NUM; i++) volumeBGM += "■";//音量目盛り表示<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string volumeSE = "　";<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (settingMode == SettingMode::SE)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeSE = "⇒"; //[選択中]⇒BGM音量設定モード<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; volumeSE += " SE音量設定:" + std::to_string((int)Sound::volumeSE);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int volSE_NUM = (int)(Sound::volumeSE / 10);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (volSE_NUM != 10) volumeSE += " ";<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; volSE_NUM; i++) volumeSE += "■";//音量目盛り表示<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 音量設定の表示<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawString(0, Screen::Height - 60, volumeBGM.c_str(), GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawString(0, Screen::Height - 30, volumeSE.c_str(), GetColor(255, 255, 255));</em><br>
      <br>
      <br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// テスト用のボス画像をタイトルでアニメで左右移動させる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DrawRotaGraphF((float)x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>Game.cppからSoundのロード処理を削除</code>します(シーンごとのロードに変更)。<br>
    </p>
    <p class="source">#include "Game.h"<br>
      <br>
      #include "MyRandom.h"<br>
      <u>#include "Sound.h"</u><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数シードの初期化<br>
      &nbsp;&nbsp;&nbsp; <u>Sound::Load(); //音声の読込み</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; // ゲーム開始して最初はタイトルシーンに遷移<br>
      &nbsp;&nbsp;&nbsp; sm.LoadScene("TitleScene");<br>
      }<br>
      <br>
      void Game::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;&nbsp; // シーンの更新処理<br>
      &nbsp;&nbsp;&nbsp; sm.currentScene-&gt;Update();<br>
      }<br>
      <br>
      void Game::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // シーンの描画処理<br>
      &nbsp;&nbsp;&nbsp; sm.currentScene-&gt;Draw();<br>
      }<br>
    </p>
    <br>
    <p><code>PlayScene.hに画面ごとのサウンドのロード処理を追加しBGM再生をBGM番号経由に変更</code>します。<br>
    </p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "Sound.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Boss.h"<br>
      #include "PlayerBullet.h"<br>
      #include "EnemyBullet.h"<br>
      #include "Explosion.h"<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp;&nbsp; GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; PlayScene() : Scene()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;tag = "PlayScene";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Image::Load("PlayScene"); //画像の読込みとメモリ開放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>Sound::Load("PlayScene"); //音声の読込みとメモリ開放</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::PlayMusic(<em>Sound::gameplay</em>); //プレイ画面BGMを再生<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ここでプレイヤの初期化などのプレイ開始時の処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵の仮生成<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (中略)...................<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (中略)...................<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ゲームオーバー判定と画面チェンジ処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bool isGameover = (gm.player == nullptr);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isGameover &amp;&amp; gm.player-&gt;isDead) isGameover = true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isGameover)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::PlayMusic(<em>Sound::ending</em>);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.LoadScene("GameOverScene"); //シーン遷移<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (中略)...................<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p>いかがでしょうか？これでタイトル画面で音量調整ができ、<br>
      画面が変わるタイミングでシーンで使わない音声のメモリを解放する処理を実現できました。<br>
      一度実行して試してみましょう。</p>
    <br>
    <br>
    <h1><a id="mozTocId4002" class="mozTocH1"></a>CSVを読み込んで敵を生成するプログラム</h1>
	  <a href="https://qiita.com/muzudho1/items/ac3602a29f8536031fe4">https://qiita.com/muzudho1/items/ac3602a29f8536031fe4</a><br>
    <p>Tiledエディタで敵マップを作成して、<br>
      stage1.csvを<br>
      <code>Map/stage1.csv</code>にcsv形式でエクスポートしましょう。<br>
      <br>
      csvファイルの準備ができたらマップの読込みプログラムを作成します。</p>
    <p><code>Map.hを新規作成</code>してマップのCSVファイルの読込みとスクロールを作成しましょう。</p>
    <p class="source">#ifndef MAP_H_<br>
      #define MAP_H_<br>
      <br>
      #include &lt;assert.h&gt; // 読込み失敗表示用<br>
      #include &lt;memory&gt; // 回し読みポインタをザコやボスの生成に使う<br>
      #include &lt;vector&gt; // csvを2次元vector配列に格納<br>
      #include &lt;string&gt; // 文字列に必要<br>
      #include &lt;fstream&gt; // ファイル読み出しifstreamに必要<br>
      #include &lt;sstream&gt; // 文字列ストリームに必要<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "GameManager.h"<br>
      #include "Zako0.h"<br>
      #include "Zako1.h"<br>
      #include "Zako2.h"<br>
      #include "Boss.h"<br>
      <br>
      class Map<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp; &nbsp;int Width = 0; // マップデータの横のマス数<br>
      &nbsp;&nbsp; &nbsp;int Height = 0; // マップデータの縦のマス数<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp; &nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; enemyData;// 敵配置データ<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; float position = 0; // マップ読出し位置のスクロール量<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;// filePath : CSVファイルのパス<br>
      &nbsp;&nbsp; &nbsp;// startPosition : 開始位置（デバッグやリスタート時に、面の途中から開始できるように）<br>
      &nbsp;&nbsp; &nbsp;Map(std::string filePath, float startPosition=0)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position = startPosition;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Load(filePath); // csvファイルをロード<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;//デストラクタ<br>
      &nbsp;&nbsp; &nbsp;~Map()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enemyData.clear();<br>
      <br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// csvファイルの読み込み<br>
      &nbsp;&nbsp; &nbsp;void Load(std::string filePath)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::ifstream ifs_csv_file(filePath);<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string line; //1行単位でcsvファイルから文字列を読み込む<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Width = 0; //初期化<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Height = 0; //初期化<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::vector&lt;int&gt; numlist; // 1行の数字リスト<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::istringstream linestream(line); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string splitted; // カンマで分割された文字列<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int widthCount = 0; //この行の幅をカウント<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (std::getline(linestream, splitted, { ',' }))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::istringstream ss; //文字列ストリームの初期化<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ss = std::istringstream(splitted); //文字列ストリーム<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;numlist.emplace_back(num); // 数字をこの行のリスト(numlist)に追加<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;widthCount++; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 1行の数字の数が記録を更新してMAXになるかチェック<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (widthCount &gt; MaxWidth) MaxWidth = widthCount; //暫定Max幅を更新<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 数字1行分をvectorに追加<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (numlist.size() != 0) enemyData.emplace_back(numlist);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Height++; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Width = MaxWidth; //マップ幅は一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//↓読込んだマップの幅と高さをチェック<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;assert(Width &gt; 0 &amp;&amp;"マップ読込み失敗ファイル名間違いでは?"!="");<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;assert(Height &gt; 0 &amp;&amp;"マップ読込み失敗ファイル名間違いでは?"!="");<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 画面スクロール（位置の更新）<br>
      &nbsp;&nbsp; &nbsp;void Scroll(float delta)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールする前の、画面右端のセルの列番号（x）<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int prevRightCell = (int)(position + Screen::Width) / CellSize;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position += delta; // スクロールする<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールした後の、画面右端のセルの列番号（x）<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int currentRightCell = (int)(position + Screen::Width) / CellSize;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールした後の画面右端のセルがマップの範囲外に出ちゃったら何もしないで終了<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (currentRightCell &gt;= Width)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールする前と後で、画面右端のセルが同じ場合は、何もしないで終了<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (prevRightCell == currentRightCell)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 画面右端のセルの左端のx座標<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float x = currentRightCell * CellSize - position;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 上端のセルから下端のセルまで舐めて、敵データが配置されていたら、敵を生成する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int cellY = 0; cellY &lt; Height; cellY++)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float y = cellY * CellSize;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//【★注意!】2次元vectorではxとyがC#と逆！[行Y][列X]⇒行列の順と覚えよう<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int id = enemyData[cellY][currentRightCell];<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 番号に応じて敵を生成する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (id == -1) continue; // -1は空白なので、何もしない<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (id == 0) gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3(x + 32, y + 32)));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (id == 1) gm.enemies.emplace_back(std::make_shared&lt;Zako1&gt;(Vector3(x + 32, y + 32)));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (id == 2) gm.enemies.emplace_back(std::make_shared&lt;Zako2&gt;(Vector3(x + 32, y + 32)));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (id == 100) gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(x + 90, y + 32))); // ボスは横幅180pxだから90px右に生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else assert("まだ追加してない敵IDがマップCSVにありました。"=="");<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      #endif</p>
    <br>
    <br>
    <p><code>GameManager.hにMapの回し読みポインタの参照リンクを追加</code>します。<br>
    </p>
    <p class="source">#ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      <br>
      #include "Singleton.h"<br>
      <br>
      <em>class Map; //クラス宣言だけでインクルードしないので循環しない(前方宣言)</em><br>
      class Player;<br>
      class PlayerBullet;<br>
      class Enemy;<br>
      class EnemyBullet;<br>
      class Explosion;<br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      <em>&nbsp;&nbsp; &nbsp;std::shared_ptr&lt;Map&gt; map{ nullptr }; // マップ</em><br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機<br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;EnemyBullet&gt;&gt; enemyBullets; // 敵弾のリスト<br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;Explosion&gt;&gt; explosions; // 爆発エフェクトのリスト<br>
      &nbsp;&nbsp;&nbsp; // List↑と同じvector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      <br>
      &nbsp;&nbsp; (中略)..........<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;&nbsp; virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>PlayScene.hにMapの初期化とメモリ参照クリアとスクロール処理を追加</code>します。<b>(シーン分けしていない人はGame.cppで)</b><br>
    </p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <em>#include "Map.h"</em><br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Boss.h"<br>
      #include "PlayerBullet.h"<br>
      #include "EnemyBullet.h"<br>
      #include "Explosion.h"<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp; &nbsp;int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる<br>
      <br>
      &nbsp;&nbsp; &nbsp;<em>float scrollSpeed = 1.5f; // スクロール速度</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;PlayScene() : Scene()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;tag = "PlayScene";<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化処理<br>
      &nbsp;&nbsp; &nbsp;void Initialize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Image::Load("PlayScene"); //画像の読込みとメモリ開放<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Sound::Load("PlayScene"); //音声の読込みとメモリ開放<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Sound::PlayMusic(Sound::gameplay); //プレイ画面BGMを再生<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// マップの初期化<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.map = std::make_shared&lt;Map&gt;("Map/stage1.csv");</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ここでプレイヤの初期化などのプレイ開始時の処理<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player = std::make_shared&lt;Player&gt;(Vector3((float)100, (float)(Screen::Height / 2))); // 自機の初期化<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 敵の仮生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<u>//gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(Screen::Width + 90, Screen::Height / 2)));</u><br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 終了処理(大抵Initializeと同じリセットだが終了時だけやりたいリセットの仕方もあるかも)<br>
      &nbsp;&nbsp; &nbsp;void Finalize() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ここにプレイ終了時のメモリのリセット処理(ゲームクリアやゲームオーバー時など)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>gm.map = nullptr; // マップのメモリからの解放</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player = nullptr; // プレイヤのメモリからの解放<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.enemies.clear(); // 敵のメモリからの解放<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.playerBullets.clear(); // プレイヤの弾のメモリからの解放<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.enemyBullets.clear(); // 敵弾のメモリからの解放<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.explosions.clear(); // 爆発エフェクトのメモリからの解放<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ゲーム終了時のスコアがMAXなら記録して終了<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(score &gt; sm.scoreMax) sm.scoreMax = score;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 更新処理<br>
      &nbsp;&nbsp; &nbsp;void Update() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ここにプレイ中の更新処理を持ってくる<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// マップデータの読出し位置のスクロール<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.map-&gt;Scroll(scrollSpeed);</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; (中略)....................<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 描画処理<br>
      &nbsp;&nbsp; &nbsp;void Draw() override<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; (中略)....................<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <br>
    さて、ここまでで敵が画面の右端から出て来たでしょうか？<br>
    出てこない場合は、大抵以下の原因が多いです。<br>
    <ul>
      <li>【Mapフォルダ】にstage1.csvがありますか？</li>
      <li>【stage1..csv】ドットが多くないですか</li>
      <li>【mapのMが小文字】フォルダ名のMが小文字m</li>
      <li>【別のプロジェクトのMapフォルダに間違って入ってた】</li>
      <li>【敵を開始32マス内に配置してた】開始32マスは読込みしません</li>
    </ul>
    <br>
    <br>
    <br>
    <h2><a id="mozTocId40022" class="mozTocH1"></a>カスタムしたデータ構造DataCsv.hでデータ自身にLoadと幅高さ管理を任せる</h2>
    <p>さて、マップ読込みうまくいきましたか？<br>
      現状のコードは敵のみ読込みですが<b>【地形やその他アイテムなどのデータが増えると面倒です】</b><br>
      いちいち<b>Map.hにint stageWidth, int terrainWidth, int itemWidth...などと定義を増やしますか？</b><br>
      いちいち<b>Map.hにLoadTerrain(),LoadItem()など長いロード処理を個別に書きますか？</b><br>
      そんなの<b>僕は嫌だ！</b><br>
      という人はDataCsv.hを取り入れましょう。<br>
      データは<b>データ自身がLoad処理を持ち、幅Width高さHeightを持つ構造になればよい</b>のです。<br>
      <br>
      コードでは<b>【[]演算子を独自定義】</b>しています。<br>
      これはぜひ勉強してほしいテクニックです。<br>
      DataCsv型のデータは<b>[]演算子を使わないとenemyData.Data[y][x]といったアクセスの仕方</b>になってしまいます。<br>
      すると、DataCsvを導入すると<b>すでに書いたコードすべてに.Data[y][x]の書き足しが必要になっちゃいます</b>よね(めんどくさい)。<br>
      <b>[]演算子を間に噛ますだけで【既存のコードの書き直しがゼロ】</b>になるのです！<br>
      <br>
      どうでしょう？<b>[]演算子の威力を実感できそうですか？</b>(C#でも使えるテクニック)<br>
      <br>
      同じ目的で【関数名かぶらせテクニック】も使っています。<br>
      clear()の定義も同様です。<b>enemyData.Data.clear()と書き直さずenemyData.clear()のままで済む</b>のです。<br>
      size()の定義も同様です。<b>enemyData.Data.size()と書き直さずenemyData.size()のままで済む</b>のです。<br>
      <br>
      どうでしょう？<b>【関数名かぶらせテクニック】を実感できそうですか？</b>(C#でも使えるテクニック)<br>
    </p>
    <p><code>DataCsv.hを新規作成</code>します。</p>
    <p class="source">#ifndef DATACSV_H_<br>
      #define DATACSV_H_<br>
      <br>
      #include &lt;assert.h&gt; // 読込み失敗表示用<br>
      #include &lt;vector&gt; // csvを2次元vector配列に格納<br>
      #include &lt;string&gt; // 文字列に必要<br>
      #include &lt;fstream&gt; // ファイル読み出しifstreamに必要<br>
      #include &lt;sstream&gt; // 文字列ストリームに必要<br>
      <br>
      // CSVファイルを読込み幅や高さとデータ本体を保持するデータ型<br>
      struct DataCsv // ←structはC++ではほぼclassと同じ【違いはデフォルトがpublic】<br>
      {&nbsp;&nbsp; // 読込んだデータファイルの情報<br>
      &nbsp;&nbsp; &nbsp;std::string FilePath = "";<br>
      &nbsp;&nbsp; &nbsp;int Width = 0; // csvファイルの表の幅<br>
      &nbsp;&nbsp; &nbsp;int Height = 0;// csvファイルの表の高さ<br>
      &nbsp;&nbsp; &nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; Data;// csvデータ<br>
      <br>
      &nbsp;&nbsp; &nbsp;<b>// ★スムーズに[][]でアクセスできるように[]演算子を独自定義する<br>
        &nbsp;&nbsp; &nbsp;std::vector&lt;int&gt;&amp; operator[](std::size_t index) { // ★ &amp;参照にしないといちいちデータのコピーを返すので遅くなるよ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return Data[index]; // 書き込み<br>
        &nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;std::vector&lt;int&gt; operator[](std::size_t index) const { // ★constは添え字[]読み取りの処理を定義<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return Data[index]; // 読み取り<br>
        &nbsp;&nbsp; &nbsp;}</b><br>
      <br>
      &nbsp;&nbsp; &nbsp;<b>std::size_t size()<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; // size()関数の名前をvectorと被らせることで使う側はvectorインvectorのままのコードで使える<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return Data.size();<br>
        &nbsp;&nbsp; &nbsp;}</b><br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// 初期化コンストラクタでファイル名を指定して初期化と同時にファイル読込<br>
      &nbsp;&nbsp; &nbsp;DataCsv(std::string FilePath = "") :FilePath{ FilePath }<br>
      &nbsp;&nbsp; &nbsp;{// csvファイルの読込み★【初期化と同時なのでファイルとデータ型が一心同体で使いやすい】<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (FilePath != "") Load(FilePath); // ファイル読込み<br>
      &nbsp;&nbsp; &nbsp;};<br>
      &nbsp;&nbsp; &nbsp;virtual ~DataCsv()<br>
      &nbsp;&nbsp; &nbsp;{// 仮想デストラクタ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Data.clear();// 2次元配列データのお掃除<br>
      &nbsp;&nbsp; &nbsp;};<br>
      <br>
      &nbsp;&nbsp; &nbsp;<b>// データをクリアしてメモリを解放する<br>
        &nbsp;&nbsp; &nbsp;virtual void clear()<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; // データをクリアしてメモリを解放する<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Data.clear();// 2次元配列データのお掃除<br>
        &nbsp;&nbsp; &nbsp;}</b><br>
      <br>
      &nbsp;&nbsp; &nbsp;// csvファイルの読み込み<br>
      &nbsp;&nbsp; &nbsp;void Load(std::string filePath)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (filePath == "") return; //ファイル名がない<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;FilePath = filePath; // ファイル名を保管<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Data.clear(); //データを一旦クリア<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::ifstream ifs_csv_file(filePath);<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string line; //1行単位でcsvファイルから文字列を読み込む<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int readWidth = 0; //読込みデータの幅<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int maxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int readHeight = 0; //初期化<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//↓2重while文でCSVファイルを読み取る<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::vector&lt;int&gt; numlist; // 1行の数字リスト<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::istringstream linestream(line); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string splitted; // カンマで分割された文字列<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int widthCount = 0; //この行の幅をカウント<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (std::getline(linestream, splitted, { ',' }))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::istringstream ss; //文字列ストリームの初期化<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ss = std::istringstream(splitted); //文字列ストリーム<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;numlist.emplace_back(num); // 数字を数字のリスト(numlist)に追加<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;widthCount++; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 1行の幅の数が記録を更新してMAXになるかチェック<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (widthCount &gt; maxWidth) maxWidth = widthCount; //暫定Max幅を更新<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 1行分をvectorに追加<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (numlist.size() != 0) Data.emplace_back(numlist);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;readHeight++; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;readWidth = maxWidth; //マップ幅は一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//↓読込んだマップの幅と高さをチェック<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;assert(readWidth &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違いでは?" != "");<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;assert(readHeight &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違いでは?" != "");<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;Width = readWidth; // 読込み成功したデータの幅を記録<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this-&gt;Height = readHeight; // 読込み成功したデータの高さを記録<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p><code>Map.hで敵データを2次元vectorからDataCsvの使用に変更</code>しましょう。</p>
    <p class="source">#ifndef MAP_H_<br>
      #define MAP_H_<br>
      <br>
      #include &lt;assert.h&gt; // 失敗表示用<br>
      #include &lt;memory&gt; // 回し読みポインタをザコやボスの生成に使う<br>
      <u>#include &lt;vector&gt; // csvを2次元vector配列に格納</u><br>
      #include &lt;string&gt; // 文字列に必要<br>
      <u>#include &lt;fstream&gt; // ファイル読み出しifstreamに必要<br>
        #include &lt;sstream&gt; // 文字列ストリームに必要</u><br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "GameManager.h"<br>
      #include "Zako0.h"<br>
      #include "Zako1.h"<br>
      #include "Zako2.h"<br>
      #include "Boss.h"<br>
      <br>
      <em>#include "DataCsv.h"</em><br>
      <br>
      class Map<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp; &nbsp;<u>int Width = 0; // マップデータの横のマス数<br>
        &nbsp;&nbsp; &nbsp;int Height = 0; // マップデータの縦のマス数</u><br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp; &nbsp;<em>DataCsv</em> enemyData;// 敵配置データ<br>
      &nbsp;&nbsp; &nbsp;float position; // 現在の位置（画面左端の座標）<br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;// filePath : CSVファイルのパス<br>
      &nbsp;&nbsp; &nbsp;// startPosition : 開始位置（デバッグやリスタート時に、面の途中から開始できるように）<br>
      &nbsp;&nbsp; &nbsp;Map(std::string filePath, float startPosition=0)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position = startPosition;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>enemyData.</em>Load(filePath); // csvファイルをロード<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;//デストラクタ<br>
      &nbsp;&nbsp; &nbsp;~Map()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<b>enemyData.clear();</b><br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;<u>// csvファイルの読み込み<br>
        &nbsp;&nbsp; &nbsp;void Load(std::string filePath)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::ifstream ifs_csv_file(filePath);<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string line; //1行単位でcsvファイルから文字列を読み込む<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Width = 0; //初期化<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Height = 0; //初期化<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::vector&lt;int&gt; numlist; // 1行の数字リスト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::istringstream linestream(line); // 各行の文字列ストリーム<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::string splitted; // カンマで分割された文字列<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int widthCount = 0; //この行の幅をカウント<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (std::getline(linestream, splitted, { ',' }))<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::istringstream ss; //文字列ストリームの初期化<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ss = std::istringstream(splitted); //文字列ストリーム<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int num; // 数字単体<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;numlist.emplace_back(num); // 数字をこの行のリスト(numlist)に追加<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;widthCount++; //この行のカンマで区切られた数字の数をカウントアップ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 1行の数字の数が記録を更新してMAXになるかチェック<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (widthCount &gt; MaxWidth) MaxWidth = widthCount; //暫定Max幅を更新<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 数字1行分をvectorに追加<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (numlist.size() != 0) enemyData.emplace_back(numlist);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Height++; //マップの高さをカウントアップ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Width = MaxWidth; //マップ幅は一番数字の個数の多かった行に合わせる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//↓読込んだマップの幅と高さをチェック<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;assert(Width &gt; 0 &amp;&amp;"マップ読込み失敗ファイル名間違いでは?"!="");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;assert(Height &gt; 0 &amp;&amp;"マップ読込み失敗ファイル名間違いでは?"!="");<br>
        &nbsp;&nbsp; &nbsp;}</u><br>
      <br>
      &nbsp;&nbsp; &nbsp;// 画面スクロール（位置の更新）<br>
      &nbsp;&nbsp; &nbsp;void Scroll(float delta)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールする前の、画面右端のセルの列番号（x）<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int prevRightCell = (int)(position + Screen::Width) / CellSize;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position += delta; // スクロールする<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールした後の、画面右端のセルの列番号（x）<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int currentRightCell = (int)(position + Screen::Width) / CellSize;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールした後の画面右端のセルがマップの範囲外に出ちゃったら何もしないで終了<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (currentRightCell &gt;= <em>enemyData.</em>Width)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スクロールする前と後で、画面右端のセルが同じ場合は、何もしないで終了<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (prevRightCell == currentRightCell)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 画面右端のセルの左端のx座標<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float x = currentRightCell * CellSize - position;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 上端のセルから下端のセルまで舐めて、敵データが配置されていたら、敵を生成する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int cellY = 0; cellY &lt; <em>enemyData.</em>Height; cellY++)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float y = cellY * CellSize;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//【★注意!】2次元vectorではxとyがC#と逆！[行Y][列X]⇒行列の順と覚えよう<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int id = <b>enemyData[cellY][currentRightCell];</b><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 番号に応じて敵を生成する<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (id == -1) continue; // -1は空白なので、何もしない<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (id == 0) gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3(x + 32, y + 32)));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (id == 1) gm.enemies.emplace_back(std::make_shared&lt;Zako1&gt;(Vector3(x + 32, y + 32)));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (id == 2) gm.enemies.emplace_back(std::make_shared&lt;Zako2&gt;(Vector3(x + 32, y + 32)));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (id == 100) gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(x + 90, y + 32))); // ボスは横幅180pxだから90px右に生成<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else assert("まだ追加してない敵IDがマップCSVにありました。"=="");<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      #endif</p>
    <br>
    <br>
    <br>
    さて、できるだけ最小限の変更でDataCsvを導入することができたのが実感できましたか？<br>
    これで地形データやアイテムデータなどが増えてきてもすっきりするはずです。<br>
    一度実行してみて、無事に敵が出てくるかは確認してみましょう。<br>
    <br>
    <br>
    <br>
    <h2><a id="mozTocId40023" class="mozTocH1"></a>【3D向け】【高難度】敵データの全方位読出しアルゴリズム</h2>
    <p>さて現状のコードでは縦スクロールの一方向スクロール限定です。<br>
      全方向進めるようなRPGや3Dゲームなどには今のままでは使いづらいです。<br>
      C#のアクションゲームの敵のロードではステージの全敵キャラを開始時に読み込んでます。<br>
      <b>開始時に全敵キャラを読み込むのも一つの手</b>です。<br>
      ある程度<b>敵の数が限られるゲーム</b>であれば有効な策です。<br>
      しかし広大なマップや大量の敵の出るゲームでやると<br>
      <b>【大量の画面にいない敵の当たり判定計算などにより計算が追いつかなくなります】</b><br>
      ゆえにある程度の敵の規模のあるゲームのためには<b>【敵マップの全方向読み出し】</b>が必要です。<br>
      敵の読出しのアルゴリズムについては以下スライドを基本的な考え方としています。<br>
      <a href="https://docs.google.com/presentation/d/11uHlDZGXokjbjiiHduRCHXR7ovXWqQWikwED4D1wk_o/edit?usp=sharing">https://docs.google.com/presentation/d/11uHlDZGXokjbjiiHduRCHXR7ovXWqQWikwED4D1wk_o/edit?usp=sharing</a> </p>
    <p><code>Map.hで敵データを2次元vectorからDataCsvの使用に変更</code>しましょう。</p>
    <p class="source">#ifndef MAP_H_<br>
      #define MAP_H_<br>
      <br>
      #include &lt;assert.h&gt; // 読込み失敗表示用<br>
      #include &lt;memory&gt; // 回し読みポインタをザコやボスの生成に使う<br>
      #include &lt;string&gt; // 文字列に必要<br>
      <em>#include &lt;map&gt; // 連想辞書配列に必要</em><br>
      <em>#include &lt;cmath&gt; // 敵出現楕円射程のsin cos計算に</em><em></em><br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "GameManager.h"<br>
      <em>#include "GameObject.h"</em><br>
      #include "Zako0.h"<br>
      #include "Zako1.h"<br>
      #include "Zako2.h"<br>
      #include "Boss.h"<br>
      <br>
      #include "DataCsv.h"<br>
      <br>
      <em>// マス目のXとYを保持するデータ型<br>
        struct CellXY<br>
        {<br>
        &nbsp;&nbsp;&nbsp; int X = 0;<br>
        &nbsp;&nbsp;&nbsp; int Y = 0;<br>
        &nbsp;&nbsp;&nbsp; CellXY(int X, int Y) : X{ X }, Y{ Y }<br>
        &nbsp;&nbsp;&nbsp; {}; // コンストラクタ<br>
        &nbsp;&nbsp;&nbsp; // ★連想辞書配列で使うため &lt; 比較演算子(連想配列並べ替えのため)をカスタム定義<br>
        &nbsp;&nbsp;&nbsp; // http://programming-tips.info/use_struct_as_key_of_map/cpp/index.html<br>
        &nbsp;&nbsp;&nbsp; bool operator &lt; (const CellXY&amp; otherXY) const {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Y &lt; otherXY.Y) return true; // Y優先並べ替え<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Y &gt; otherXY.Y) return false;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (X &lt; otherXY.X) return true; // Yが同じ時はXを比較<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (X &gt; otherXY.X) return false;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // 完全一致のときはfalse<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // A &lt; B と B &lt; A両方falseなら完全一致(だから==演算子の定義がいらない)<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };</em><br>
      <br>
      <br>
      class Map<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp; &nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>int SpawnRangeX = 0; // 敵出現射程スポーンレンジ【注意！Xの単位はマス目】<br>
        &nbsp;&nbsp;&nbsp; int SpawnRangeY = 0; // 敵出現射程スポーンレンジ【注意！Yの単位はマス目】<br>
        &nbsp;&nbsp;&nbsp; // ★【効率よく柔軟な連想配列】https://qiita.com/_EnumHack/items/f462042ec99a31881a81<br>
        &nbsp;&nbsp;&nbsp; std::map&lt;CellXY, bool&gt; SpawnDic; // 辞書:SpawnDic["10,5"]==trueなら出現範囲</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; DataCsv enemyData;// 敵配置データ<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <em>float positionX = 0; // X位置(マップ読出し位置のXスクロール量）<br>
        &nbsp;&nbsp;&nbsp; float positionY = 0; // Y位置(マップ読出し位置のYスクロール量）</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;// コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;// filePath : CSVファイルのパス<br>
      &nbsp;&nbsp; &nbsp;// startPosition : 開始位置（デバッグやリスタート時に、面の途中から開始できるように）<br>
      &nbsp;&nbsp; &nbsp;Map(std::string filePath, float startPosition<em>X = 0, float startPositionY = 0</em>)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>positionX = startPositionX;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;positionX = startPositionY;</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enemyData.Load(filePath); // csvファイルをロード<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// ★30 = 960/32 マス目のサイズ 960はスクリーンのサイズ！<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SpawnRangeX = 30; // 敵出現射程スポーンレンジ【注意！Xの単位はマス目】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SpawnRangeY = 17; // 敵出現射程スポーンレンジ【注意！Yの単位はマス目】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //【注意！】辞書の初期化をわすれると敵が出てこなくなる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitSpawnDic(SpawnRangeX, SpawnRangeY);</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;//デストラクタ<br>
      &nbsp;&nbsp; &nbsp;~Map()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<b>enemyData.clear();</b><b></b><br>
      &nbsp;&nbsp; &nbsp;}<b></b><br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 敵出現射程の辞書初期化【先に計算して辞書化】すると計算が必要なくなり【高速化する】<br>
        &nbsp;&nbsp;&nbsp; //【注意！XとYの単位はマス目】<br>
        &nbsp;&nbsp;&nbsp; void InitSpawnDic(int rangeCellX, int rangeCellY)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SpawnDic.clear();//一旦辞書をクリアするのでゲーム中の再設定も可(だが処理時間はかかる)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 敵出現射程の辞書初期化<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★ X = A cosθ Y = B sinθ(←楕円の方程式)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★ 楕円の半径 r = √(A×A×cosθ×cosθ + B×B×sinθ×sinθ)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★ xの2乗 + yの2乗 &lt; rならば楕円の内側<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float A2 = (float)(rangeCellX * rangeCellX); // 2乗<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float B2 = (float)(rangeCellY * rangeCellY); // 2乗<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int x = -rangeCellX; x &lt;= rangeCellX; x++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int y = -rangeCellY; y &lt;= rangeCellY; y++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[逆三角関数] https://cpprefjp.github.io/reference/cmath/atan2.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //float theta = (float)std::atan2(y, x); // ★[逆三角関数]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //float cos_t = std::cos(theta);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //float sin_t = std::sin(theta);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //float r2 = A2 * cos_t * cos_t + B2 * sin_t * sin_t;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (x * x + y * y &lt;= r2) // ★ xの2乗 + yの2乗 &lt; rならば楕円の内側<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //{&nbsp;&nbsp; //楕円の内側なら辞書SpawnDic[(x,y)] = true;として登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; //【★楕円にしたいときはこちら】SpawnDic[CellXY(x,y)] = true; //【例】SpawnDic[(3,2)] = true;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //【★四角形にしたいときはこちら】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SpawnDic[CellXY(x, y)] = true;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>float deltaSumX = 0; // deltaXの変化が溜まってマス目が移動が発生するかの判定の計算に使う<br>
        &nbsp;&nbsp;&nbsp; float deltaSumY = 0; // deltaYの変化が溜まってマス目が移動が発生するかの判定の計算に使う</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;<em>// 画面スクロール（位置の更新）<br>
        &nbsp;&nbsp; &nbsp;void Scroll(float deltaX, float deltaY=0, std::shared_ptr&lt;GameObject&gt; baseObj = NULL)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; bool isMoveCell = false; // マス目移動が発生するか？発生しないなら敵出現検索処理を回避したい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 変化量を溜めてマス目移動以外のときは敵出現検索処理を省いて高速化<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaSumX += deltaX;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaSumY += deltaY;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (deltaSumX &lt;= -CellSize || CellSize &lt;= deltaSumX<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || deltaSumY &lt;= -CellSize || CellSize &lt;= deltaSumY)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isMoveCell = true;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マス目移動以外のときは敵出現検索処理を省いて高速化<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isMoveCell)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 移動が1マス幅を超えれば敵新規出現判定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float deltaMoveX = deltaSumX; // 溜まった移動量を移動量deltaMoveXとする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float deltaMoveY = deltaSumY; // 溜まった移動量を移動量deltaMoveYとする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int deltaCellX = (int)deltaMoveX / CellSize; // セル(マス目)単位での移動数(マス数)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int deltaCellY = (int)deltaMoveY / CellSize; // セル(マス目)単位での移動数(マス数)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printfDx("\n%d %d", deltaCellX, deltaCellY);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マス目移動CellSizeぶん移動変化量から差引いて次の移動量計算に備える <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (deltaSumX &lt;= -CellSize) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaSumX += CellSize; // マス目移動CellSizeぶん移動変化量から差引き<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (CellSize &lt;= deltaSumX) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaSumX -= CellSize; // マス目移動CellSizeぶん移動変化量から差引き<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (deltaSumY &lt;= -CellSize) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaSumY += CellSize; // マス目移動CellSizeぶん移動変化量から差引き<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (CellSize &lt;= deltaSumY) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaSumY -= CellSize; // マス目移動CellSizeぶん移動変化量から差引き<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int searchCount = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★連想配列で敵新規出現マスを探す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://qiita.com/_EnumHack/items/f462042ec99a31881a81<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://pyteyon.hatenablog.com/entry/2019/01/01/220850<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto iter = SpawnDic.begin(); iter != SpawnDic.end(); iter++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★例 iter-&gt;firstが"3,1" iter-&gt;secondが[trueかfalse]の射程マスかどうかのペア<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (iter-&gt;second == true)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 例.(3,1)のマス目が出現射程マスか[trueかfalse]か？<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXY xy = iter-&gt;first; // iter-&gt;firstに(x,y)=(3,1)が入っている時<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 例.↑(3,1)のマス目xy.X = 3, xy.Y = 1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 例.deltaCellX = 1 deltaCellY = 2のとき<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int searchX = xy.X + deltaCellX; //例. 3+1 = 4 移動先は4<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int searchY = xy.Y + deltaCellY; //例. 1+2 = 3 移動先は3<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //例.↓もし(4,3)が未登録もしくはfalseなら【新規出現マス！】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXY searchXY(searchX, searchY);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (SpawnDic.count(searchXY) == 1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 例.辞書に↑(4,3)登録があるならcount( (4,3) )は 1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★例.(4,3)がtrueなら↓【被りマス】移動前にすでに敵の出現判定【済】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (SpawnDic[searchXY] == true) continue; // 敵を出現させず別マスの判定を続ける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //↓↓↓↓↓ここより下は敵出現↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapX = 0, mapY = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (baseObj != NULL)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 基準となるオブジェクトがあるならその位置を基準に<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mapX = searchX + (int)(baseObj-&gt;x / CellSize); // セル(マス目)単位でのX位置<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mapY = searchY + (int)(baseObj-&gt;y / CellSize); // セル(マス目)単位でのY位置<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 特に基準オブジェクトの指定がなければ現状ポジションを基準に<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mapX = searchX + (int)(positionX / CellSize); // セル(マス目)単位でのX位置<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mapY = searchY + (int)(positionY / CellSize); // セル(マス目)単位でのY位置<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int objectID = -1;//出現させる敵ID<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0 &lt;= mapY &amp;&amp; 0 &lt;= mapX<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; mapY &lt; enemyData.size() &amp;&amp; mapX &lt; enemyData[mapY].size())<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //データがアクセスできればIDを取得<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objectID = enemyData[mapY][mapX];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★一度出現させたマスはIDを上書きして二重に敵が出現しないように<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enemyData[mapY][mapX] = -1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[コメント外すとテスト表示]if (objectID != -1)printfDx("newID %d (%d,%d)\n", objectID, mapX, mapY);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★(mapX,mapY)の位置のマップデータを読み出し！！<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SpawnObject(mapX, mapY, objectID);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; positionX += deltaX; // 現在の位置を更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; positionY += deltaY; // 現在の位置を更新<br>
        <br>
        &nbsp;&nbsp; &nbsp;}</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// オブジェクトを生成・配置する<br>
        &nbsp;&nbsp;&nbsp; void SpawnObject(int mapX, int mapY, int id)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 生成位置<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x = (float)(mapX * CellSize);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float y = (float)(mapY * CellSize);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 番号に応じて敵を生成する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (id == -1) return; // -1は空白なので、何もしない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (id == 0) gm.enemies.emplace_back(std::make_shared&lt;Zako0&gt;(Vector3(x + 32, y + 32)));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (id == 1) gm.enemies.emplace_back(std::make_shared&lt;Zako1&gt;(Vector3(x + 32, y + 32)));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (id == 2) gm.enemies.emplace_back(std::make_shared&lt;Zako2&gt;(Vector3(x + 32, y + 32)));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (id == 100) gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Vector3(x + 90, y + 32))); // ボスは横幅180pxだから90px右に生成<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else assert("まだ追加してない敵IDがマップCSVにありました。"=="");<br>
        &nbsp;&nbsp; &nbsp;}</em><br>
      };<br>
      #endif</p>
    <br>
    <br>
    <p>うまくいけば、これで全方向のスクロールが可能です。<br>
      Game.cppやPlayScene.hで<b>map-&gt;Scroll(ScrollSpeedX, ScrollSpeedY);</b>でY方向のスクロールもできるようになりました。<br>
      今回はシューティングなのでY方向はデフォルトの0のままで大丈夫です。<br>
    </p>
    <br>
    <br>
    <h1><a id="mozTocId4003" class="mozTocH1"></a>自機狙い弾</h1>
    <h2>点と点を結んだ線の角度を調べる関数</h2>
    <p>C#テキストからの変更はMath関連だけですね。<br>
      インクルードするのは<b>#include &lt;cmath&gt;</b>になります。cmathはスタンダード(<b>ST</b>andar<b>D</b>)ライブラリ所属なので<br>
      つかうときはstd::cos()とか<b>std::atan2()</b>になります。(stdはスタンダードの略)</p>
    <p><code>MyMath.hに逆三角関数でプレイヤへの角度を求める関数を追加</code>しましょう。</p>
    <p class="source">#ifndef _MYMATH_H<br>
      #define _MYMATH_H<br>
      <br>
      <em>#include &lt;cmath&gt;</em><br>
      <br>
      // 数学関連クラス<br>
      class MyMath<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // C ++標準では、静的static定数の【整数型】または【列挙型】のみをクラス内で初期化できます。<br>
      &nbsp;&nbsp;&nbsp; // これが、一部の初期化が許可されているのに他のstatic floatなどが初期化できない理由です。<br>
      <br>
      &nbsp;&nbsp;&nbsp; // float小数を定義するためだけにcppファイルを作成しないと<br>
      &nbsp;&nbsp;&nbsp; //static const float Sqrt2 =【このイコールでエラー】 1.41421356237f;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ルート2(変数名の定義だけ)<br>
      &nbsp;&nbsp;&nbsp; static const float Sqrt2;// = 1.41421356237f;<br>
      &nbsp;&nbsp;&nbsp; static const float PI; // 円周率 3.14159265359f;<br>
      &nbsp;&nbsp;&nbsp; static const float Deg2Rad; // 度からラジアンに変換する定数 PI / 180f;<br>
      <br>
      &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
      &nbsp;&nbsp;&nbsp; /// 円と円が重なっているかを調べる<br>
      &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;param name="pos1"&gt;円1の中心&lt;/param&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;param name="pos2"&gt;円2の中心&lt;/param&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
      &nbsp;&nbsp;&nbsp; static bool CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 pos1, float radius1,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 pos2, float radius2)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((pos1 - pos2).sqrMagnitude()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt; (radius1 + radius2) * (radius1 + radius2));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;<em>/// &lt;summary&gt;<br>
        &nbsp;&nbsp; &nbsp;/// 点から点への角度（ラジアン）を求める。<br>
        &nbsp;&nbsp; &nbsp;/// &lt;/summary&gt;<br>
        &nbsp;&nbsp; &nbsp;/// &lt;param name="fromX"&gt;始点x&lt;/param&gt;<br>
        &nbsp;&nbsp; &nbsp;/// &lt;param name="fromY"&gt;始点y&lt;/param&gt;<br>
        &nbsp;&nbsp; &nbsp;/// &lt;param name="toX"&gt;終点x&lt;/param&gt;<br>
        &nbsp;&nbsp; &nbsp;/// &lt;param name="toY"&gt;終点y&lt;/param&gt;<br>
        &nbsp;&nbsp; &nbsp;/// &lt;returns&gt;&lt;/returns&gt;<br>
        &nbsp;&nbsp; &nbsp;static float PointToPointAngle(float fromX, float fromY, float toX, float toY)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return (float)<b>std::atan2</b>(toY - fromY, toX - fromX);<br>
        &nbsp;&nbsp; &nbsp;}</em><br>
      <br>
      }; // 【注意】セミコロン抜けで【宣言が必要ですエラー】<br>
      <br>
      #endif // 【宣言が必要ですエラーは上のセミコロン抜け】</p>
    <br>
    <br>
    <h2>自機狙い弾を撃たせる</h2>
    <p><code>Zako0</code>を改造して自機狙い弾を撃たせてみます（別に他の敵クラスでも構いません）。<br>
      ついでにZako0の<b>画面外に出たら消す処理も入れましょう【敵が消えないとCPUが当たり判定で激重くなりますよ】</b><br>
      これを機に<b>Zako1,Zako2,Zako3の画面外で消す判定も追加しておいた方がいい</b>ですよ。<br>
      敵がステージに100体出て(撃ち漏らしたら)プレイヤが10発弾を撃つとすると【100×10=1000回の当たり判定】になりますから。</p>
    <p class="source">#ifndef ZAKO_0_H_<br>
      #define ZAKO_0_H_<br>
      <br>
      #include "Enemy.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      <br>
      <em>#include "Player.h" // Player.hでもZako0.hをインクルードすると循環するので注意</em><br>
      <br>
      // ザコ0クラス<br>
      class Zako0 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int coolTime = 0; // クールタイム（冷却時間。0になるまで次の弾が撃てない）<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Zako0(float x, float y, float z = 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Enemy(x, y, z)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Zako0";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x -= 1; // とりあえず左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime--;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (coolTime &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// 自機狙い弾<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float angle = MyMath::PointToPointAngle(x, y, gm.player-&gt;x, gm.player-&gt;y);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(x, y, <em>angle</em>, 8));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime += 10;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// 【重要】画面外の削除処理【CPU処理重くなる原因】<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (x &lt; 0)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 左端の画面外に出たらisDeadしないと<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 画面外の敵の当たり判定で【だんだん処理が重くなるZako1,Zako2..も】<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isDead = true;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(x, y, 1, 0, Image::zako0, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <h2>ばらまき自機狙い弾を撃たせる</h2>
    <p><code>Zako2</code>を改造してばらまき自機狙い弾を撃たせてみます（別に他の敵クラスでも構いません）。<br>
    </p>
    <p class="source">#ifndef ZAKO_2_H_<br>
      #define ZAKO_2_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      #include &lt;cmath&gt; // Sin Cosの計算に使う<br>
      <br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include "MyMath.h"<br>
      #include "MyRandom.h"<br>
      <br>
      <em>#include "Player.h" // Player.hでもZako2.hをインクルードすると循環するので注意</em><br>
      <br>
      // ザコ2クラス<br>
      class Zako2 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int coolTime = 0; // クールタイム（冷却時間。0になるまで次の弾が撃てない）<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Zako2(float x, float y, float z = 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Enemy(x, y, z)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Zako2";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (x &gt; Screen::Width - 200)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { // スクリーンの端から200の位置で止まる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x -= 1; // とりあえず左へ移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime--;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (coolTime &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 自機狙いばらまき弾<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float angle = MyMath::PointToPointAngle(x, y, gm.player-&gt;x, gm.player-&gt;y);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float randomAngle = MyRandom::Range(-15.0f, 15.0f); // ±15度の乱数の角度を取得</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(x, y, <em>angle + randomAngle * MyMath::Deg2Rad</em>, 8));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime += 10;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 200の位置で止まるので左端にこないから削除処理はなくて済む</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(x, y, 1, 0, Image::zako2, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p>さて、ザコ2の場合は画面内の200で止まるので削除処理を入れませんでした。<br>
      そう、<b>削除処理も敵により臨機応変にやるのですね。例えば下から出て上に向かう敵はyが0以下で削除です。</b><br>
      つまり、<b>削除処理も敵の個性の一つの扱いというわけ</b>です。 </p>
    <br>
    <h1><a id="mozTocId4004" class="mozTocH1"></a>自機に向かってくる敵</h1>
    <p>自機に向かってくる敵も基本は追尾弾と同じですね。</p>
    <p><code>Zako1.hにプレイヤへ向かってくる処理を追加</code>しましょう。</p>
    <p class="source">#ifndef ZAKO_1_H_<br>
      #define ZAKO_1_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      #include &lt;cmath&gt; // Sinの計算に使う<br>
      #include "MyMath.h"<br>
      #include "Image.h"<br>
      <br>
      <em>#include "Player.h" // Player.hでもZako1.hをインクルードすると循環するので注意</em><br>
      <br>
      // ザコ1クラス<br>
      class Zako1 : public Enemy<br>
      {<br>
      public:<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Zako1(float x, float y, float z = 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Enemy(x, y, z)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Zako1";//オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life = 5;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// 自機をおいかけてくる処理<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float angleToPlayer = MyMath::PointToPointAngle(x, y, gm.player-&gt;x, gm.player-&gt;y);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float speed = 3;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x += (float)std::cos(angleToPlayer) * speed;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;y += (float)std::sin(angleToPlayer) * speed;</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(x, y, 1, 0, Image::zako1, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <br>
    <p>ゆらゆら向かってくる敵にしてみましょうか。</p>
    <p><code>Zako1.hにSin波動でゆらゆら向かってくる処理を追加</code>しましょう。</p>
    <p class="source">#ifndef ZAKO_1_H_<br>
      #define ZAKO_1_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      #include &lt;cmath&gt; // Sinの計算に使う<br>
      #include "MyMath.h"<br>
      #include "Image.h"<br>
      <br>
      #include "Player.h" // Player.hでもZako1.hをインクルードすると循環するので注意<br>
      <br>
      // ザコ1クラス<br>
      class Zako1 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;<em>float sinMove = 0; // Sinの動きをする際の0～360度<br>
        &nbsp;&nbsp; &nbsp;float sinRadius = 70; // Sinの動きをするときの半径</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Zako1(float x, float y, float z = 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Enemy(x, y, z)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Zako1";//オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life = 5;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機をおいかけてくる処理<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float angleToPlayer = MyMath::PointToPointAngle(x, y, gm.player-&gt;x, gm.player-&gt;y);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float speed = 3;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x += (float)std::cos(angleToPlayer) * speed;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;y += (float)std::sin(angleToPlayer) * speed;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>//ゆらゆらSin波動の動きをy上下方向にプラス<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float prevSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sinMove += 2.5f; // Sinの波運動の角度を進める<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float currentSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// (前の角度でのY) - (今の角度でのY)の差を足すことで【ベースのyの位置 ± sinの動き】になる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;y += currentSinY - prevSinY; // 上下方向のSinの波運動</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(x, y, 1, 0, Image::zako1, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <p>ゆらゆら向かってくるほうが<b>理論上は避けやすいはずなのに、見た目上は逆に怖く見えませんか？</b></p>
    <br>
    <p>あれ？何か2回、<b>2種類の　y += 〜;</b>やってるけどアリなの？と思った人。<br>
      今から数字のマジックを示すので実感してください。<br>
      毎回 y += 〜;されるということは、つまり</p>
    <p class="source"><b>y = (今の角度のY)-(前の角度のY) + (前の角度のY)-(前の前の角度のY) + (前の前の角度のY)-(前の前の前の角度のY)...</b></p>
    となりますよね。<br>
    <p>そしてここで<b>数字のマジックを見てみましょう</b></p>
    <p class="source"> y = (今の角度のY) <u>-(前の角度のY) + (前の角度のY)</u> <u>-(前の前の角度のY) + (前の前の角度のY)</u> <u>- (前の前の前の角度のY)...</u>.....<br>
      <b>y = (今の角度のY) - (一番最初の角度のY=0)←sin 0°=0だから0<br>
      </b></p>
    <p> おお！<b>見事に打ち消しあって(今の角度のY)だけ残りましたね(一番最初の角度0°のYは0になるので)</b><br>
      じゃあ、<b>最初からy += せずにy = (今の角度のY);にすればいいんじゃ？</b>って思う人もいると思います。<br>
      そうするとどうなるか?2つの違う動きの合成が難しくなります。<br>
    </p>
    <p class="source">y += 1; // 【メイン】の動き(少しづつ下に行く)<br>
      <b>y = (今の角度のY); // あ、上書き固定値で y += 1;の効果消えちゃう..</b></p>
    <p>なので<b>【動きを += ～;で表現しつつも毎回打ち消しあう】</b>必要が出てくるのです。<br>
    </p>
    <p class="source">y += 1; // 【メイン】の動き(少しづつ下に行く)<br>
      <b>y += (今の角度のY) - (前の角度のY); // これなら y += 1;の効果が消えない！</b></p>
    <p>これなら色々な動きを<b>【合成した動きなのに】【お互いの動きを消す心配】がなくなります。</b></p>
    <p> これが<b>±プラマイ0で合成テクニック⇒実質微分•積分テクニック</b>です。<br>
      え、<b>微分積分て難しい式なんじゃなかったっけ？</b>って思うでしょうが<br>
      これも<b>まごうことなき積分の式です。</b><br>
      積分は<b>【ちりが積もれば山となる式】</b>です。<br>
      で、この場合<b>【「ちり」が微分です】</b><br>
      今回の例では<b>【yが山です】</b><br>
      そして<b>【「ちり」が(今の角度のY) - (前の角度のY)です】</b><br>
      これを<b>【(今の角度のsin) - (前の角度のsin)の積分がsinθになった】</b><br>
      逆に言うと<b>【sinθを微分すると(今の角度のsin) - (前の角度のsin)になった】</b>とも言えます。<br>
      式で書くと<b>y += 半径×sinθ1(←今の角度のY) - 半径×sinθ2(←前の角度のY)</b>となってます。<br>
      <br>
      どうでしょう意外と微分積分を身近に感じられませんか？<br>
      数学の難しい式、実際使う場合は意外とシンプルなやり方になったりします。<br>
      この【今と前の差】を+= するテクニックはSin以外でも使えるので心に留めておきましょう。<br>
      たとえばxも同じようにすれば、円を描きながら追ってくる敵も作れます。<br>
      <b>x += 半径×cosθ1(←今の角度のX) - 半径×cosθ2(←前の角度のX)</b><br>
      気になった人は試してみてくださいね。<br>
    </p>
    <a id="mozTocId5000" class="mozTocH1"></a>
    <p class="title">[C++]シューティングゲーム 5【応用1】</p>
    <br>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId5001">複数コントローラでプレイ</a><br>
        <a href="#mozTocId50011">Inputクラスの複数プレイ対応</a><br>
        <a href="#mozTocId50012">複数プレイヤの参加処理</a><br>
      </li>
      <br>
      <p>次のテキストは後々。</p>
      <br>
      <a href="#mozTocId6000"></a><br>
    </ol>
    <h1><a id="mozTocId5001" class="mozTocH1"></a>複数コントローラでプレイ</h1>
    <h2><a id="mozTocId50011" class="mozTocH1"></a>Inputクラスの複数プレイ対応</h2>
    <p>複数コントローラーでプレイするためにはまずはInputクラスの改造が必要です。</p>
    <p><code>Input.hのボタン状態を配列</code>にしてゆきましょう。</p>
    <p class="source">#ifndef INPUT_H_<br>
      #define INPUT_H_<br>
      <br>
      #include "DxLib.h"<br>
      <br>
      <em>// コントローラのパッド番号の列挙型enum<br>
        enum class Pad<br>
        {<br>
        &nbsp;&nbsp; &nbsp;None=-1, // パッド割当て無(やられたり待機中のプレイヤに)<br>
        &nbsp;&nbsp; &nbsp;Key=0, // キーボード<br>
        &nbsp;&nbsp; &nbsp;One, // コントローラ1<br>
        &nbsp;&nbsp; &nbsp;Two, // コントローラ2<br>
        &nbsp;&nbsp; &nbsp;Three, // コントローラ3<br>
        &nbsp;&nbsp; &nbsp;Four, // コントローラ4<br>
        &nbsp;&nbsp; &nbsp;NUM, // コントローラの数NUM=5(ちょうど配列の数にもなる)<br>
        };</em><br>
      <br>
      // 入力クラス<br>
      class Input<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; static int prevState<em>s[(int)Pad::NUM]</em>; // 1フレーム前の状態<br>
      &nbsp;&nbsp;&nbsp; static int currentState<em>s[(int)Pad::NUM]</em>; // 現在の状態<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化。タイトルなどキー入力状態リセット時に<br>
      &nbsp;&nbsp;&nbsp; static void Init()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>// キー状態をゼロリセット<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::Key] = currentStates[(int)Pad::Key] = 0;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::One] = currentStates[(int)Pad::One] = 0;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::Two] = currentStates[(int)Pad::Two] = 0;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::Three] = currentStates[(int)Pad::Three] = 0;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::Four] = currentStates[(int)Pad::Four] = 0;</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 最新の入力状況に更新する処理。<br>
      &nbsp;&nbsp;&nbsp; // 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
      &nbsp;&nbsp;&nbsp; static void Update()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>prevStates[(int)Pad::Key] = currentStates[(int)Pad::Key];</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentStates[(int)Pad::Key] = GetJoypadInputState(DX_INPUT_KEY);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::One] = currentStates[(int)Pad::One];<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentStates[(int)Pad::One] = GetJoypadInputState(DX_INPUT_PAD1);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::Two] = currentStates[(int)Pad::Key];<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentStates[(int)Pad::Two] = GetJoypadInputState(DX_INPUT_PAD2);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::Three] = currentStates[(int)Pad::Key];<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentStates[(int)Pad::Three] = GetJoypadInputState(DX_INPUT_PAD3);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;prevStates[(int)Pad::Four] = currentStates[(int)Pad::Key];<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentStates[(int)Pad::Four] = GetJoypadInputState(DX_INPUT_PAD4);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <em>// ↑ちょ！...ちょい待てーい！！待たれ給えよ！！<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // 【こんなのいちいち書いてられるかー！！！！！】</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; }<br>
      (以下略)..................</p>
    <br>
    <p>はい、<b>ダメでござる。こんなのいちいち拙者書きたくないでござる</b>よ！！<br>
      こういう時こそ、<b>for文や辞書配列の出番でござるよ。絶対そのほうが良いでござるよ。</b></p>
    <br>
    <p><code>Input.hの複数プレイのボタン状態を辞書配列とfor文を駆使して書くでござるよ。</code></p>
    <p class="source">#ifndef INPUT_H_<br>
      #define INPUT_H_<br>
      <br>
      <em>#include &lt;unordered_map&gt; // 辞書配列【map高速版】https://qiita.com/sileader/items/a40f9acf90fbda16af51</em><br>
      <br>
      #include "DxLib.h"<br>
      <br>
      // コントローラのパッド番号の列挙型enum<br>
      enum class Pad<br>
      {<br>
      &nbsp;&nbsp; &nbsp;None=-1, // パッド割当て無(やられたり待機中のプレイヤに)<br>
      &nbsp;&nbsp; &nbsp;Key=0, // キーボード<br>
      &nbsp;&nbsp; &nbsp;One, // コントローラ1<br>
      &nbsp;&nbsp; &nbsp;Two, // コントローラ2<br>
      &nbsp;&nbsp; &nbsp;Three, // コントローラ3<br>
      &nbsp;&nbsp; &nbsp;Four, // コントローラ4<br>
      &nbsp;&nbsp; &nbsp;NUM, // コントローラの数NUM=5(ちょうど配列の数にもなる)<br>
      };<br>
      <br>
      // 入力クラス<br>
      class Input<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; static int prevStates[(int)Pad::NUM]; // 1フレーム前の状態<br>
      &nbsp;&nbsp;&nbsp; static int currentStates[(int)Pad::NUM]; // 現在の状態<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>static std::unordered_map&lt;int, int&gt; padDic; // パッド番号からDXの定義への変換辞書</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 辞書配列の初期化<br>
        &nbsp;&nbsp;&nbsp; static void InitPadDictionary()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 辞書配列で対応関係の辞書を作成しておく<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Key] = DX_INPUT_KEY;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::One] = DX_INPUT_PAD1;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Two] = DX_INPUT_PAD2;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Three] = DX_INPUT_PAD3;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Four] = DX_INPUT_PAD4;<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化。タイトルなどキー入力状態リセット時に<br>
      &nbsp;&nbsp;&nbsp; static void Init()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>InitPadDictionary() // パッドの辞書配列の初期化</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // キー状態をゼロリセット<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i] = 0;</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 最新の入力状況に更新する処理。<br>
      &nbsp;&nbsp;&nbsp; // 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
      &nbsp;&nbsp;&nbsp; static void Update()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <em>for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 現在の状態を一つ前の状態として保存してGetJoypad..</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[<em>i</em>] = currentStates[<em>i</em>];<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; currentStates[<em>i</em>] = GetJoypadInputState(<em>padDic[i]</em>);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>}</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが押されているか？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButton(<em>Pad pad, </em>int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if(pad == Pad::None) return false; // Noneなら判別不要</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今ボタンが押されているかどうかを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (currentState<em>s[(int)pad]</em> &amp; buttonId) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが押された瞬間か？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButtonDown(<em>Pad pad, </em>int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if(pad == Pad::None) return false; // Noneなら判別不要</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今は押されていて、かつ1フレーム前は押されていない場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((currentState<em>s[(int)pad]</em> &amp; buttonId) &amp; ~(prevState<em>s[(int)pad]</em> &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが離された瞬間か？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButtonUp(<em>Pad pad, </em>int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if(pad == Pad::None) return false; // Noneなら判別不要</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1フレーム前は押されていて、かつ今は押されている場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((prevState<em>s[(int)pad]</em> &amp; buttonId) &amp; ~(currentState<em>s[(int)pad]</em> &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }; //←【注意】クラス定義の終わりにはコロンが必要だよ！<br>
      <br>
      #endif&nbsp; //ここでエラー出た人は↑【注意】の;コロン忘れ</p>
    <br>
    <p><code>Input.cppの変数定義を変更します。</code></p>
    <p class="source">#include "Input.h"<br>
      <br>
      int Input::prevState<em>s[]</em>; // 1フレーム前の状態<br>
      int Input::currentState<em>s[]</em>; // 現在の状態<br>
      <br>
      <em>std::unordered_map&lt;int, int&gt; Input::padDic; // パッド番号からDXの定義への辞書</em><br>
    </p>
    <br>
    <p> これでボタン判定にはPad番号の指定が必須になりました。<br>
      したがって既存のボタン入力コードにはエラーが出るはずです。<br>
      むしろ出たほうが良いと思い <b>GetButtonDown(int buttonId<em>, Pad pad = Pad::key</em>)</b>みたいな<br>
      <b>デフォルト = Pad::key設定</b>をしませんでした。(デフォルト=があれば省略できたが)<br>
      なぜなら明確にエラーが出ないと<b>複数プレイ対応直し忘れ</b>がでちゃいますからね。<br>
    </p>
    <br>
    <p><code>Player.hにそのプレイヤを操るコントローラpadの定義</code>を追加しましょう。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      #include "GameManager.h"<br>
      <br>
      // 継承するときは↓ : public ～にする。publicをつけ忘れると色々エラー出るので注意<br>
      class Player : public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; <em>Pad pad = Pad::None; // デフォルトは未割当て</em><br>
      &nbsp;&nbsp;&nbsp; const float MoveSpeed = 6; // 移動速度<br>
      &nbsp;&nbsp;&nbsp; int MutekiJikan = 120; // 無敵時間<br>
      <br>
      &nbsp;&nbsp;&nbsp; float collisionRadius = 32; // 当たり判定半径<br>
      <br>
      &nbsp;&nbsp;&nbsp; int life = 3; // ライフ<br>
      &nbsp;&nbsp;&nbsp; int mutekiTimer = 0; // 残り無敵時間。0以下なら無敵じゃないってこと<br>
      <br>
      &nbsp;&nbsp;&nbsp; //【★注意！】ここに【x,yの定義が残ってるとGameObjectと被る】ので<br>
      &nbsp;&nbsp;&nbsp; // 名前の同じ変数が2つ【パラレルワールドに存在してしまう！】<br>
      &nbsp;&nbsp;&nbsp; // Playerからx=13,y=5に変えたつもりでも【ベースのGameObjectはx=0,y=0のままの不思議バグで混乱！】<br>
      <br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; <em>// pad : 対応するコントローラ</em><br>
      &nbsp;&nbsp;&nbsp; // x : 初期位置x<br>
      &nbsp;&nbsp;&nbsp; // y : 初期位置y<br>
      &nbsp;&nbsp;&nbsp; Player(<em>Pad pad, </em>float x, float y, float z = 0) // z=0デフォルトにして2Dのときはzを省略できる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : GameObject() //【忘れると】GameObjectの初期化処理が飛ばされて大混乱！<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>this-&gt;pad = pad;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;y = y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;z = z;//[3D対応]<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 敵にぶつかった時の処理<br>
      &nbsp;&nbsp;&nbsp; void OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 敵弾とぶつかった時の処理<br>
      &nbsp;&nbsp;&nbsp; void OnCollisionEnemyBullet(std::shared_ptr&lt;GameObject&gt; other);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ダメージを受ける処理<br>
      &nbsp;&nbsp;&nbsp; void TakeDamage();<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Player.cppのInput判定にコントローラpadの指定</code>を追加しましょう。<br>
      なおデフォルトの<b>Pad::Noneの状態のままの時は反応しなくなります！</b></p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include "PlayerBullet.h" // ★弾を生成して【使う処理があるのでインクルード必要】<br>
      <br>
      #include "Explosion.h"<br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; vx = 0; // x方向移動速度<br>
      &nbsp;&nbsp;&nbsp; vy = 0; // y方向移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(<em>pad, </em>PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vx = -MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(<em>pad, </em>PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(<em>pad, </em>PAD_INPUT_UP))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(<em>pad, </em>PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 斜め移動も同じ速度になるように調整<br>
      &nbsp;&nbsp;&nbsp; if (vx != 0 &amp;&amp; vy != 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vx /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy /= MyMath::Sqrt2;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      &nbsp;&nbsp;&nbsp; x += vx;<br>
      &nbsp;&nbsp;&nbsp; y += vy;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタン押下で自機弾を発射<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(<em>pad, </em>PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 【C#版】game-&gt;playerBullets.Add(new PlayerBullet(x, y));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // C++ではAddがemplace_backに↓ newがmake_shared↓に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(x, y, 0));//右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(x, y, -15 * MyMath::Deg2Rad));//右上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gm.playerBullets.emplace_back(std::make_shared&lt;PlayerBullet&gt;(x, y, +15 * MyMath::Deg2Rad));//右下<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; mutekiTimer--;// 無敵タイマーは無条件で毎フレームカウントダウン<br>
      }<br>
      <br>
      (以下略)................<br>
    </p>
    <br>
    <p><code>TitleScene.hのInput判定にコントローラpadの指定</code>を書換えましょう。</p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "Sound.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; (中略).....................<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタン入力に応じた処理<br>
      &nbsp;&nbsp;&nbsp; void HandleInput()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// 全部のパッドぶんボタンが押されてるか検査<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(<em>(Pad)i,</em> PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ボタンを押したらスタート音声を再生<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::start);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isStartPushed = true; // 画面遷移トリガーON<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>}</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// いや..ちょ、ちょい待たれよー！いちいちfor文書くの??</em><br>
      <br>
      (以下略)................<br>
    </p>
    <p>はい、来ました！<b>使い勝手の悪さを発見しましたね！</b><br>
      <b>いちいち全部のコントローラ確かめるときはfor文で囲うのがめんどくさい</b>ですよね。<br>
      よいアイデアがあります。Inputの方を改造しましょう。</p>
    <br>
    <br>
    <p><code>Input.hのコントローラpadの種類にAll(すべての内どれか押されたら)を指定できるように</code>改造しましょう。</p>
    <p class="source">#ifndef INPUT_H_<br>
      #define INPUT_H_<br>
      <br>
      #include &lt;unordered_map&gt; // 辞書配列【map高速版】https://qiita.com/sileader/items/a40f9acf90fbda16af51<br>
      <br>
      #include "DxLib.h"<br>
      <br>
      // コントローラのパッド番号定義<br>
      enum class Pad<br>
      {<br>
      &nbsp;&nbsp;&nbsp; <em>All = -2, // すべてのうちどれか1つでも押されたとき</em><br>
      &nbsp;&nbsp;&nbsp; None = -1, // パッド割当て無(やられたり待機中のプレイヤに)<br>
      &nbsp;&nbsp;&nbsp; Key=0, // キーボード<br>
      &nbsp;&nbsp;&nbsp; One, // コントローラ1<br>
      &nbsp;&nbsp;&nbsp; Two, // コントローラ2<br>
      &nbsp;&nbsp;&nbsp; Three, // コントローラ3<br>
      &nbsp;&nbsp;&nbsp; Four, // コントローラ4<br>
      &nbsp;&nbsp;&nbsp; NUM, // コントローラの数=5<br>
      };<br>
      <br>
      // 入力クラス<br>
      class Input<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; static int prevStates[(int)Pad::NUM]; // 1フレーム前の状態<br>
      &nbsp;&nbsp;&nbsp; static int currentStates[(int)Pad::NUM]; // 現在の状態<br>
      <br>
      &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;int, int&gt; padDic; // パッド番号からDXの定義への辞書<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 辞書配列の初期化<br>
      &nbsp;&nbsp;&nbsp; static void InitPadDictionary()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 辞書配列で対応関係を結び付けておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Key] = DX_INPUT_KEY;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::One] = DX_INPUT_PAD1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Two] = DX_INPUT_PAD2;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Three] = DX_INPUT_PAD3;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Four] = DX_INPUT_PAD4;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化。タイトルなどキー入力状態リセット時に<br>
      &nbsp;&nbsp;&nbsp; static void Init()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; InitPadDictionary() // パッドの辞書配列の初期化<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // キー状態をゼロリセット<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i] = 0<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 最新の入力状況に更新する処理。<br>
      &nbsp;&nbsp;&nbsp; // 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
      &nbsp;&nbsp;&nbsp; static void Update()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 現在の状態を一つ前の状態として保存してGetJoypad..<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i];<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; currentStates[i] = GetJoypadInputState(padDic[i]);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが押されているか？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButton(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // GetButtonの中でGetButtonを呼ぶ【再起呼出し】テクニック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetButton((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今ボタンが押されているかどうかを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (currentStates[(int)pad] &amp; buttonId) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが押された瞬間か？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButtonDown(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 再起呼出しテクニック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetButtonDown((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今は押されていて、かつ1フレーム前は押されていない場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((currentStates[(int)pad] &amp; buttonId) &amp; ~(prevStates[(int)pad] &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンが離された瞬間か？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButtonUp(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 再起呼出しテクニック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (GetButtonUp((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1フレーム前は押されていて、かつ今は押されている場合はtrueを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((prevStates[(int)pad] &amp; buttonId) &amp; ~(currentStates[(int)pad] &amp; buttonId)) != 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }; //←【注意】クラス定義の終わりにはコロンが必要だよ！<br>
      <br>
      #endif&nbsp; //ここでエラー出た人は↑【注意】の;コロン忘れ<br>
    </p>
    <p><b>極意【再起呼出し】(自分自身を呼び出すこと)が炸裂しましたね！(再起はきれいにハマると気持ちいいです)</b><br>
      <b>自分自身を呼び出すなんてそんなのアリ!?</b>ですよね。<br>
      でもこのテク便利です。上級者は結構使います<b>【if条件の絞りミスると呼出し無限ループしますがね】</b><br>
      あと、もう一つのテク<b>【enumの種類をAll=-2でマイナス方向に拡張してます】</b><br>
      生真面目な人は0から始めたらプラス方向しかできないと思いがちですよね。<br>
      頭が固いです。<b>柔軟にマイナスの番号も有効活用すればいい</b>んです。<br>
      0から上はコントローラ番号に割り当てることで<b>for(int i=0;i&lt; (int)Pad::NUM; i++)で全チェックのi</b>に使えます。<br>
      <b>0から上の番号にALLとか例外の番号が割り込んでくるとforで回すのに邪魔</b>ですからね。<br>
      だからマイナス番号って便利なんです。<b>普通はマイナス使わないからこそ【マイナス番号は空いてるんです】</b></p>
    <br>
    <br>
    <p>さあ、これで<b>使う側はPad::Allを指定するだけ</b>でコントローラのどれか1つでもボタンが押されたら検知できます。<br>
    </p>
    <p><code>TitleScene.hのInput判定にコントローラpadの指定</code>を書換えましょう。</p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "Sound.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; (中略)....................<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタン入力に応じた処理<br>
      &nbsp;&nbsp;&nbsp; void HandleInput()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(<em>Pad::All, </em>PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ボタンを押したらスタート音声を再生<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::start);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isStartPushed = true; // 画面遷移トリガーON<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(<em>Pad::All, </em>PAD_INPUT_UP))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //上を押すと設定モードを-1する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int index = ((int)settingMode - 1);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (index &lt; 0) //↓番号ループ 0→最大数-1<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; index = ((int)SettingMode::NUM) - 1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; settingMode = (SettingMode)index;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (Input::GetButtonDown(<em>Pad::All, </em>PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //下を押すと設定モードを+1する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int index = ((int)settingMode + 1);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (index &gt;= ((int)SettingMode::NUM))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; index = 0; //番号ループ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; settingMode = (SettingMode)index;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(<em>Pad::All, </em>PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (settingMode == SettingMode::BGM)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM++;//音量をプラス<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeBGM &gt; 100)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM = 100;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (settingMode == SettingMode::SE)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE++;//音量をプラス<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeSE &gt; 100)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE = 100;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::bomb); //効果音を聞きながら調節<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::UpdateMusicVolume(); //再生中の音量の更新<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (Input::GetButton(<em>Pad::All, </em>PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (settingMode == SettingMode::BGM)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM--;//音量をマイナス<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeBGM &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeBGM = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (settingMode == SettingMode::SE)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE--;//音量をマイナス<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Sound::volumeSE &lt;0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::volumeSE = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::bomb); //効果音を聞きながら調節<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::UpdateMusicVolume(); //再生中の音量の更新<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (以下略).....................<br>
    </p>
    <br>
    <p><code>PlayScene.hのプレイヤの生成にパッド番号指定</code>を書き加えましょう。</p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      (中略)...........<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; (中略)............<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (中略)....................<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ここでプレイヤの初期化などのプレイ開始時の処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.player = std::make_shared&lt;Player&gt;(<em>Pad::Key, </em>(float)100, (float)(Screen::Height / 2)); // 自機の初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵の仮生成<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Screen::Width + 90, Screen::Height / 2));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (以下略).....................<br>
    </p>
    <br>
    <p><code>GameOverScene.hのInputボタン判定にPad::Allの指定</code>を書き加えましょう。</p>
    <p class="source">#ifndef GAMEOVERSCENE_H_<br>
      #define GAMEOVERSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      class GameOverScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; <br>
      (中略).....................<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(<em>Pad::All, </em>PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.LoadScene("TitleScene"); //シーン遷移<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawString(0, 0, "GameOver....ボタン押下でPlaySceneへ", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p>さて、これで大丈夫か！...と思いきや反応しなくなりました。<br>
      原因は<b>Input::Init(); // 入力コントローラの初期化</b> 忘れでした！<br>
      逆にいままでなぜ大丈夫だったかというとint型や配列currentStatesの初期値は0だったからです(たまたま実質0初期化になってた)<br>
    </p>
    <p><code>Game.cppに忘れていたInputの初期化</code>を書き加えましょう。</p>
    <p class="source">#include "Game.h"<br>
      <br>
      #include "MyRandom.h"<br>
      <em>#include "Input.h"</em><br>
      <br>
      void Game::Init()<br>
      {// Init処理<br>
      &nbsp;&nbsp;&nbsp; <em>Input::Init(); // コントローラ入力の初期化</em><br>
      &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数シードの初期化<br>
      <br>
      &nbsp;&nbsp;&nbsp; (中略)............<br>
      }<br>
      <br>
      (以下略).....................<br>
    </p>
    <br>
    <p>これでコントローラをつなげばどのコントローラからでもタイトル画面を操作できます。<br>
      なぜ各シーンではなくGame.cppでInput入力とMyRandom乱数はInit初期化するのか？<br>
      それは<b>コントローラ入力と乱数はシーンによらない共通機能</b>だからです。</p>
    <br>
    <br>
    <h2><a id="mozTocId50012" class="mozTocH1"></a>複数プレイヤの参加処理</h2>
    <p>さて、次はプレイヤの参加処理を書いてゆきましょう。<br>
      プレイヤの<b>参加は色んな画面で使うのでInputクラスで共通処理</b>とした方が良さそうです。<br>
      すでに<b>Inputを使い慣れた人も辞書配列の使い道に注目</b>してください。<br>
      <b>辞書配列は【対応関係を結ぶのにめちゃ便利】</b>です。<br>
      <b>辞書配列に慣れると【vector配列が辞書配列の劣化版のようにすら感じるほど】</b>です。<br>
    </p>
    <p><code>Input.hに参加中パッドの辞書と参加チェック処理</code>を書き加えましょう。</p>
    <p class="source">#ifndef INPUT_H_<br>
      #define INPUT_H_<br>
      <br>
      #include &lt;unordered_map&gt; // 辞書配列【map高速版】https://qiita.com/sileader/items/a40f9acf90fbda16af51<br>
      <br>
      #include "DxLib.h"<br>
      <br>
      // コントローラのパッド番号定義<br>
      enum class Pad<br>
      {<br>
      &nbsp;&nbsp;&nbsp; All = -2, // すべてのうちどれか1つでも押されたとき<br>
      &nbsp;&nbsp;&nbsp; None = -1, // パッド割当て無(やられたり待機中のプレイヤに)<br>
      &nbsp;&nbsp;&nbsp; Key=0, // キーボード<br>
      &nbsp;&nbsp;&nbsp; One, // コントローラ1<br>
      &nbsp;&nbsp;&nbsp; Two, // コントローラ2<br>
      &nbsp;&nbsp;&nbsp; Three, // コントローラ3<br>
      &nbsp;&nbsp;&nbsp; Four, // コントローラ4<br>
      &nbsp;&nbsp;&nbsp; NUM, // コントローラの数=5<br>
      };<br>
      <br>
      // 入力クラス<br>
      class Input<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; static int prevStates[(int)Pad::NUM]; // 1フレーム前の状態<br>
      &nbsp;&nbsp;&nbsp; static int currentStates[(int)Pad::NUM]; // 現在の状態<br>
      &nbsp;&nbsp;&nbsp; <em>static std::unordered_map&lt;Pad, bool&gt; isJoin; // 参加中のパッド番号辞書<br>
        &nbsp;&nbsp;&nbsp; // 参加中のパッドかどうか?<br>
        &nbsp;&nbsp;&nbsp; static bool IsJoin(Pad pad) { return isJoin.count(pad) == 1 &amp;&amp; Input::isJoin[pad]; };</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;int, int&gt; padDic; // パッド番号からDXの定義への辞書<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 辞書配列の初期化<br>
      &nbsp;&nbsp;&nbsp; static void InitPadDictionary()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 辞書配列で対応関係を結び付けておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Key] = DX_INPUT_KEY;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::One] = DX_INPUT_PAD1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Two] = DX_INPUT_PAD2;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Three] = DX_INPUT_PAD3;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; padDic[(int)Pad::Four] = DX_INPUT_PAD4;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化。タイトルなどキー入力状態リセット時に<br>
      &nbsp;&nbsp;&nbsp; static void Init()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; InitPadDictionary(); // 辞書配列の初期化<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // キー状態をゼロリセット<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i] = 0;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 最新の入力状況に更新する処理。<br>
      &nbsp;&nbsp;&nbsp; // 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
      &nbsp;&nbsp;&nbsp; static void Update()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 現在の状態を一つ前の状態として保存してGetJoypad..<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i];<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; currentStates[i] = GetJoypadInputState(padDic[i]);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// プレイヤの参加処理(参加辞書登録して参加中の数も返す)<br>
        &nbsp;&nbsp;&nbsp; static int JoinCheck()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int joinCount = 0;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_1))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>isJoin[(Pad)i] = true; // 参加パッド辞書に登録</b><br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (<b>isJoin.count((Pad)i) == 1 &amp;&amp; isJoin[(Pad)i] == true</b>)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; joinCount++; // 参加中の人数をカウント<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return joinCount; // 参加中のコントローラ数を返す<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      (以下略)...............<br>
    </p>
    <p><code>Input.cppに変数定義を追加します。</code></p>
    <p class="source">#include "Input.h"<br>
      <br>
      int Input::prevStates[]; // 1フレーム前の状態<br>
      int Input::currentStates[]; // 現在の状態<br>
      <em>std::unordered_map&lt;Pad, bool&gt; Input::isJoin; // 参加中のパッド番号辞書</em><br>
      <br>
      std::unordered_map&lt;int, int&gt; Input::padDic; // パッド番号からDXの定義への辞書<br>
    </p>
    <br>
    <p>辞書配列、使う際にはvector配列のように<b>isJoin[(Pad)i] = true;</b>と書けば使えるんですね。<br>
      if文の時はあえてcountを間にはさんでます。<b><br>
        直接isJoin[(Pad)i] == trueの判別するとisJoin[(Pad)i]の登録がなかった時に辞書にfalseで登録が増えちゃうんです。</b><br>
      辞書に未登録のものの<b>判定を行うと気を利かせてデフォルトのfalseとか0を勝手に登録してくれちゃう</b>のです。<br>
      勝手に登録してくれて<b>ありがとうとはなりません。辞書の数が増えると検索数も増えるので無駄なん</b>です。<br>
      <b>.count(～)==1のときだけ判定を行えば辞書に無駄なデフォルト登録が発生せずに済みます。</b><br>
      <b>【辞書配列の判定は.count(～)==1の時だけ行えば無駄な項目が増えずエコ】</b>と覚えておきましょう。<br>
    </p>
    <br>
    <br>
    <p>次に現状では、PAD_INPUT_1(Xボタン)にしか反応しないので他のボタンでも参加できるようにします。<br>
      <code>Input.hのボタン判定処理を増やしましょう。</code></p>
    <p class="source">(中略)..............<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの参加処理(参加辞書登録して参加中の数も返す)<br>
      &nbsp;&nbsp;&nbsp; static int JoinCheck()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int joinCount = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 参加ボタンが押されたら<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <em>// 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_2))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_3))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_4))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// ちょ待ち！、あ、これボタンの数だけめっちゃif文増えるやつだ..やだな</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isJoin.count((Pad)i) == 1 &amp;&amp; isJoin[(Pad)i] == true)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; joinCount++; // 参加中の人数をカウント<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return joinCount; // 参加中のコントローラ数を返す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (以下略)...............<br>
    </p>
    <br>
    <br>
    <p>あ、<b>このままだと【if else文がボタンの数だけめっちゃ増えちゃいます】ね。</b><br>
      もっと良い書きかたが実はあります。<br>
      こんな時のために<br>
      PAD_INPUT_1,PAD_INPUT_2,...の定義は2進数に直すと以下のようになってます。</p>
    <p class="source">パッドボタン&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2進数(32ビット32桁)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ← &nbsp; 16進数&nbsp;&nbsp; <br>
      PAD_INPUT_1&nbsp;&nbsp; 000000000000000000000000000<em>1</em>0000 ← 0x00000010<br>
      PAD_INPUT_2&nbsp;&nbsp; 00000000000000000000000000<em>1</em>00000 ← 0x00000020<br>
      PAD_INPUT_3&nbsp;&nbsp; 0000000000000000000000000<em>1</em>000000 ← 0x00000040<br>
      PAD_INPUT_4&nbsp;&nbsp; 000000000000000000000000<em>1</em>0000000 ← 0x00000080<br>
      PAD_INPUT_5&nbsp;&nbsp; 00000000000000000000000<em>1</em>00000000 ← 0x00000100<br>
      PAD_INPUT_6&nbsp;&nbsp; 0000000000000000000000<em>1</em>000000000 ← 0x00000200<br>
      PAD_INPUT_7&nbsp;&nbsp; 000000000000000000000<em>1</em>0000000000 ← 0x00000400<br>
      PAD_INPUT_8&nbsp;&nbsp; 00000000000000000000<em>1</em>00000000000 ← 0x00000800<br>
      PAD_INPUT_9&nbsp;&nbsp; 0000000000000000000<em>1</em>000000000000 ← 0x00001000<br>
      PAD_INPUT_10&nbsp; 000000000000000000<em>1</em>0000000000000 ← 0x00002000<br>
      ............................................................<br>
      PAD_INPUT_28&nbsp; <em>1</em>0000000000000000000000000000000 ← 0x80000000<br>
    </p>
    <p>おお！<b>見事に1が一つずつ左にずれていってますね。</b><br>
      偶然ではありません。<b>人為的にこういう構造になっているのです。</b><br>
      この左ビットシフト構造を<b>【うまくビット論理和で合体させてみましょう】</b><br>
      <b>【ビット論理和「 | 」(または)演算子を使います】(ただの棒 | ではありませんよ！)</b><br>
      ビット論理和<b>「 | 」は「または」の意味になりA | Bで AまたはB どちらかが1の場合に1となる</b>を表します。<br>
      <b>ボタン1とボタン4をビット論理和「 | 」でかけ合わせると</b>以下のようになります！ </p>
    <p class="source">パッドボタン&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2進数(32ビット32桁)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      PAD_INPUT_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000000000000000000000000000<em>1</em>0000<br>
      PAD_INPUT_4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000000000000000000000000<em>1</em>0000000<br>
      ............................................................<br>
      PAD_INPUT_1&nbsp;|&nbsp;PAD_INPUT_4 000000000000000000000000<em>1</em>00<em>1</em>0000<br>
    </p>
    <p>はい、<b>うまいことビットが合成できて0..0<em>1</em>00<em>1</em>0000で1が2か所</b>にできました。 <br>
      この<b>合成したビットの並びをButton::Joinと名付け</b>ましょう。</p>
    <p class="source">パッドボタン&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2進数(32ビット32桁)&nbsp;&nbsp;&nbsp; <br>
      PAD_INPUT_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000000000000000000000000000<em>1</em>0000<br>
      PAD_INPUT_4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000000000000000000000000<em>1</em>0000000<br>
      .................................................<br>
      Button::Join &nbsp; &nbsp; 000000000000000000000000<em>1</em>00<em>1</em>0000<br>
    </p>
    <br>
    <p>そしてこの合成した<b>ビットを判定に使うときは【ビット論理積「 &amp; 」(かつ)演算子を使います】</b><br>
      ビット論理積<b>「 &amp; 」は「かつ」の意味になりA &amp; Bで AかつB 両方が1の場合に1</b>を表します。<br>
      <b>合成したビットPad::Join と PAD_INPUT_1 の【ビット論理積&amp;】をかけ合わせて</b>みましょう。</p>
    <p class="source">パッドボタン&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2進数(32ビット32桁)&nbsp;&nbsp;&nbsp; <br>
      Button::Join &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00000000000000000000000<em>1</em>000<em>1</em>0000<br>
      PAD_INPUT_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000000000000000000000000000<em>1</em>0000<br>
      ...........................................................<br>
      Button::Join &amp; PAD_INPUT_1 000000000000000000000000000<em>1</em>0000 = true<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1つでも1がある)</p>
    <br>
    <p>この<b>【ビット論理積「 &amp; 」(かつ)演算子】どこかで見たと思いませんか？</b><br>
      そう<b>Input.hのGetButtonの中ボタン押し判定のreturnには【ビット論理積「 &amp; 」演算子】を使っていたのです。</b><br>
      <code>Input.hのGetButtonを見てみてください。</code></p>
    <p class="source">&nbsp;&nbsp;&nbsp; // ボタンが押されているか？<br>
      &nbsp;&nbsp;&nbsp; static bool GetButton(Pad pad, int buttonId)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (pad == Pad::None) return false; // Noneなら判別不要<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (pad == Pad::All) // 全てAllの指定だった時は<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// GetButtonの中でGetButtonを呼ぶ再起呼出しテクニック<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (GetButton((Pad)i, buttonId))<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return true; //押されているPadを発見！<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return false; // 一つも押されていなかった<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今ボタンが押されているかどうかを返却<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (currentStates[(int)pad]<em><b> &amp; </b></em>buttonId) != 0;<br>
      &nbsp;&nbsp;&nbsp; }</p>
    <br>
    <p>ただ注意してください。<b>【「 &amp; 」マークは色んな異なる意味がありすぎなので】</b><br>
      ややこしいです<b>【「&amp;&amp;」や「&amp;メモリ参照」など文脈によってビット論理積と勘違いしないように(文脈で判断)しましょう】</b><br>
      まあ普通はあんまりビット演算ばかりやるコードはないので気づけると思います。<br>
    </p>
    <br>
    <p>では【ビット合成】でボタンの種類を合成したButton::Joinを使って<br>
      <code>Input.hのボタン判定処理をすっきり書きましょう。</code></p>
    <p class="source">#ifndef INPUT_H_<br>
      #define INPUT_H_<br>
      <br>
      #include &lt;unordered_map&gt; // 辞書配列【map高速版】https://qiita.com/sileader/items/a40f9acf90fbda16af51<br>
      <br>
      #include "DxLib.h"<br>
      <br>
      // コントローラのパッド番号定義<br>
      enum class Pad<br>
      {<br>
      &nbsp;&nbsp;&nbsp; All = -2, // すべてのうちどれか1つでも押されたとき<br>
      &nbsp;&nbsp;&nbsp; None = -1, // パッド割当て無(やられたり待機中のプレイヤに)<br>
      &nbsp;&nbsp;&nbsp; Key=0, // キーボード<br>
      &nbsp;&nbsp;&nbsp; One, // コントローラ1<br>
      &nbsp;&nbsp;&nbsp; Two, // コントローラ2<br>
      &nbsp;&nbsp;&nbsp; Three, // コントローラ3<br>
      &nbsp;&nbsp;&nbsp; Four, // コントローラ4<br>
      &nbsp;&nbsp;&nbsp; NUM, // コントローラの数=5<br>
      };<br>
      <br>
      <em>// ある動作として反応するボタン一覧(ビット論理和「|または」)<br>
        enum class Button<br>
        {&nbsp;&nbsp;&nbsp; //[反応ボタン一覧定義] https://dixq.net/g/04_05.html<br>
        &nbsp;&nbsp;&nbsp; // 参加ボタン 1=Z 2=X 3=C 4=A 5=S 6=D 7=Q 8=W 9=ESC 10=SPACE<br>
        &nbsp;&nbsp;&nbsp; Join = PAD_INPUT_1 | PAD_INPUT_2 | PAD_INPUT_3 | PAD_INPUT_4<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;| PAD_INPUT_5 | PAD_INPUT_6 | PAD_INPUT_7 | PAD_INPUT_8<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;| PAD_INPUT_9 | PAD_INPUT_10, //1Z～10SPACEキー全て反応<br>
        };</em><br>
      <br>
      // 入力クラス<br>
      class Input<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (中略)..............<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの参加処理(参加辞書登録して参加中の数も返す)<br>
      &nbsp;&nbsp;&nbsp; static int JoinCheck()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int joinCount = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 参加ボタンが押されたら<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i<em>, (int)Button::Join</em>))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <u>// 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_2))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_3))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 参加ボタンが押されたら<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i, PAD_INPUT_4))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ちょ待ち！、あ、これボタンの数だけめっちゃif文増えるやつだ..やだな</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isJoin.count((Pad)i) == 1 &amp;&amp; isJoin[(Pad)i] == true)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; joinCount++; // 参加中の人数をカウント<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return joinCount; // 参加中のコントローラ数を返す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      (以下略)...............<br>
    </p>
    <p>最終的に赤部分を消すと以下のようにすっきりします。<br>
      一目瞭然、見事にすっきりしますね<b>【複数ボタンに反応させるときはビット合成テクニックを使いましょう】</b></p>
    <p class="source"><br>
      &nbsp;&nbsp;&nbsp; // プレイヤの参加処理(参加辞書登録して参加中の数も返す)<br>
      &nbsp;&nbsp;&nbsp; static int JoinCheck()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int joinCount = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 参加ボタンが押されたら<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown((Pad)i<em>, (int)Button::Join</em>))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isJoin[(Pad)i] = true; // 参加パッド辞書に登録<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isJoin.count((Pad)i) == 1 &amp;&amp; isJoin[(Pad)i] == true)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; joinCount++; // 参加中の人数をカウント<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return joinCount; // 参加中のコントローラ数を返す<br>
      &nbsp;&nbsp;&nbsp; }<br>
    </p>
    <br>
    <br>
    <p>今度は<b>プレイヤの数を増やすためにプレイヤをリスト化</b>しましょう。<br>
      今までの敵リストのようにvector配列のリストでもいいですが<b>【使い勝手を考えて辞書配列に挑戦】</b>しましょう。<br>
      <br>
      <code>GameManager.hのプレイヤを複数にできるよう辞書配列に変更</code>します。</p>
    <p class="source">#ifndef GAMEMANAGER_H_<br>
      #define GAMEMANAGER_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      <em>#include &lt;unordered_map&gt; // 辞書配列【map高速版】</em><br>
      <br>
      #include "Singleton.h"<br>
      <br>
      class Map;<br>
      class Player; //クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      class PlayerBullet;<br>
      class Enemy;<br>
      class EnemyBullet;<br>
      class Explosion;<br>
      <br>
      class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Map&gt; map{ nullptr }; // マップ<br>
      &nbsp;&nbsp;&nbsp; <u>std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機の初期化</u><br>
      &nbsp;&nbsp;&nbsp; <em>std::unordered_map&lt;int, std::shared_ptr&lt;Player&gt;&gt; players; // 自機の辞書配列(複数プレイ対応)</em><br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;std::shared_ptr&lt;EnemyBullet&gt;&gt; enemyBullets; // 敵弾のリスト<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;std::shared_ptr&lt;Explosion&gt;&gt; explosions; // 爆発エフェクトのリスト<br>
      &nbsp;&nbsp;&nbsp; // List↑と同じvector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; (中略)....................<br>
      <br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; GameManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;&nbsp; virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><b>playerをplayersに変えたので【つづりの変わった部分は全部エラーになるはず】</b>です。<br>
      逆にいうと<b>【今から変えなきゃいけないとこがエラーになってくれた】</b>のです。<br>
      <b>エラーが出ないと逆に【忘れて謎のバグの原因になりますからね】</b><br>
      変更の必要なところの目印になってくれて逆に方針が立てやすいのです。</p>
    <br>
    <p>今度は<b>プレイヤの数を増やすためにプレイヤをリスト化</b>しましょう。<br>
      今までの敵リストのようにvector配列のリストでもいいですが<b>【使い勝手を考えて辞書配列に挑戦】</b>しましょう。<br>
      <br>
    </p>
    <p>まずはプレイヤをたくさん使ってるだけあってエラーもたくさん出ている<br>
      <code>PlayScene.hのプレイヤを単数から複数に変更</code>するとこから修正始めましょう。</p>
    <p class="source">#ifndef PLAYSCENE_H_<br>
      #define PLAYSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "Map.h"<br>
      <br>
      #include "GameManager.h"<br>
      #include "SceneManager.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Boss.h"<br>
      #include "PlayerBullet.h"<br>
      #include "EnemyBullet.h"<br>
      #include "Explosion.h"<br>
      <br>
      class PlayScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; SceneManager&amp; sm = SceneManager::GetInstance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp;&nbsp; GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる<br>
      <br>
      &nbsp;&nbsp;&nbsp; float scrollSpeed = 1.5f; // スクロール速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; PlayScene() : Scene()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;tag = "PlayScene";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Image::Load("PlayScene"); //画像の読込みとメモリ開放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Load("PlayScene"); //音声の読込みとメモリ開放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::PlayMusic(Sound::gameplay); //プレイ画面BGMを再生<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // マップの初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.map = std::make_shared&lt;Map&gt;("Map/stage1.csv");<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// ここでプレイヤの初期化などのプレイ開始時の処理<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int joinCount = Input::JoinCheck(); // プレイヤの参加検出処理<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(joinCount &gt; 0)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MakePlayer(); // プレイヤの生成処理</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <u>//gm.player = std::make_shared&lt;Player&gt;(Pad::Key, (float)100, (float)(Screen::Height / 2)); // 自機の初期化</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵の仮生成<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //gm.enemies.emplace_back(std::make_shared&lt;Boss&gt;(Screen::Width + 90, Screen::Height / 2));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 終了処理(大抵Initializeと同じリセットだが終了時だけやりたいリセットの仕方もあるかも)<br>
      &nbsp;&nbsp;&nbsp; void Finalize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ここにプレイ終了時のメモリのリセット処理(ゲームクリアやゲームオーバー時など)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.map = nullptr; // マップのメモリからの解放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.<em>players.</em>clear(); // プレイヤのメモリからの解放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.enemies.clear(); // 敵のメモリからの解放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.playerBullets.clear(); // プレイヤの弾のメモリからの解放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.enemyBullets.clear(); // 敵弾のメモリからの解放<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.explosions.clear(); // 爆発エフェクトのメモリからの解放<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ゲーム終了時のスコアがMAXなら記録して終了<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(score &gt; sm.scoreMax) sm.scoreMax = score;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// プレイヤの生成処理<br>
        &nbsp;&nbsp;&nbsp; void MakePlayer()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 参加辞書登録されたプレイヤの自機の生成<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::IsJoin((Pad)i) &amp;&amp; gm.players.count(i) == 0)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.players[i] = std::make_shared&lt;Player&gt;((Pad)i, (float)100, (float)(Screen::Height / 2));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ここにプレイ中の更新処理を持ってくる<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// プレイヤの参加検出処理<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int joinCount = Input::JoinCheck();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (joinCount &gt; 0)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MakePlayer(); // プレイヤの生成処理</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // マップデータの読出し位置のスクロール<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>if(gm.players.size() &gt; 0) //プレイヤ配列0の内はスクロールしない</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.map-&gt;Scroll(scrollSpeed);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // プレイヤの描画処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>for (const auto&amp; pair : gm.players)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto player = pair.second;</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!<em>player</em>-&gt;isDead) // 自機が死んでいなければ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>player</em>-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>}</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾の更新処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp; // autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; b-&gt;Update();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵弾の更新処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.enemyBullets)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; b-&gt;Update();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機と敵弾の衝突判定<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; enemyBullet : gm.enemyBullets)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// 敵弾が死んでたらスキップ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (enemyBullet-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>for (const auto&amp; pair : gm.players)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto player = pair.second;</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機が死んでたらこれ以上判定しない<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (<em>player</em>-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; break;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 円同士の衝突判定で調べる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>player</em>-&gt;x, <em>player</em>-&gt;y, <em>player</em>-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; enemyBullet-&gt;x, enemyBullet-&gt;y, enemyBullet-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>player</em>-&gt;OnCollisionEnemyBullet(enemyBullet);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>}</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵の更新処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; b-&gt;Update();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾と敵の衝突判定<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; playerBullet : gm.playerBullets)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵が死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (enemy-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾と敵が重なっているか？<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; playerBullet-&gt;x, playerBullet-&gt;y, playerBullet-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; enemy-&gt;x, enemy-&gt;y, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; playerBullet-&gt;OnCollisionEnemy(enemy);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::bomb); // 効果音の再生<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (playerBullet-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; break;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機と敵の衝突判定<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; enemy : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// 敵が死んでたらスキップ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (enemy-&gt;isDead)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>for (const auto&amp; pair : gm.players)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto player = pair.second;</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機が死んでたらこれ以上判定しない<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (<em>player</em>-&gt;isDead)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; break;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 円同士の衝突判定で調べる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (MyMath::CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>player</em>-&gt;x, <em>player</em>-&gt;y, <em>player</em>-&gt;collisionRadius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; enemy-&gt;x, enemy-&gt;y, enemy-&gt;collisionRadius))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>player</em>-&gt;OnCollisionEnemy(enemy);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>}</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 爆発エフェクトの更新処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; e : gm.explosions)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; e-&gt;Update();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾の削除処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.EraseRemoveIf(gm.playerBullets,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;PlayerBullet&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.EraseRemoveIf(gm.enemies,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;Enemy&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵弾のリストから死んでるものを除去する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.EraseRemoveIf(gm.enemyBullets,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;EnemyBullet&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //爆発エフェクトのリストから死んでるものを除去する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.EraseRemoveIf(gm.explosions,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;Explosion&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>int aliveCount = 0; // 生きているプレイヤ数のカウント<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; pair : gm.players)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto player = pair.second;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (player-&gt;isDead != true)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; aliveCount++; // 生存プレイヤ数をカウント<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ゲームオーバー判定と画面チェンジ処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// プレイヤの数が0じゃないのに生存数が0ならゲームオーバー</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bool isGameover = (<em>gm.players.size() != 0 &amp;&amp; aliveCount == 0</em>);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isGameover)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::PlayMusic(Sound::ending); //BGMを変更する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.LoadScene("GameOverScene"); //シーン遷移<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ここにプレイ画面の描画処理を持ってくる<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵の描画処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.enemies)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; b-&gt;Draw();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 爆発エフェクトの描画処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; e : gm.explosions)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; e-&gt;Draw();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// プレイヤの描画処理<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; pair : gm.players)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto player = pair.second;</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!<em>player</em>-&gt;isDead) // 自機が死んでいなければ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>player</em>-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 自機弾の描画処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // C#のforeach文と同じく全自機弾を更新できる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.playerBullets)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp; // autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; b-&gt;Draw();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 敵弾の描画処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; b : gm.enemyBullets)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; b-&gt;Draw();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p>さてここで<b>辞書配列のfor文に慣れてしまいましょう。</b><br>
      vector配列との違いは<b>【辞書のキーとバリューを各ループで得られること】</b>です。<br>
      あいうえおの辞書を例にすると<b>【「あ」がキー、「アイス」がバリューですね】</b><br>
      あ、<b>すみません違います！【「アイス」がキー、「アイスとは冷たくておいしいもの(説明)」がバリューです】</b><br>
      ただし<b>一つのキーに複数のバリューのあるタイプの辞書もあり</b><br>
      その場合は<b>【「あ」がキー、「アイス」「愛」..などがバリューですね】</b><br>
      プログラム上では<b>【キーがfirst、バリューがsecondでアクセスできます】</b></p>
    <p class="source">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // プレイヤの描画処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (const auto&amp; <em><b>pair</b></em> : gm.players)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto player = pair.<em><b>second</b></em>;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!player-&gt;isDead) // 自機が死んでいなければ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
    </p>
    <br>
    <p>もう一つ<b>辞書配列に登録する際の形も見ておきましょう。</b><br>
      <b>players[i] = ～;のような配列に代入するような形で登録可能</b>です。<br>
      すでに登録済か未登録かは<b>.count(キー)</b>で判別します。<br>
      この<b>count()でキーがあるか探せるのがvector配列より手軽なところ</b><br>
      <b>5文字ぐらいでさらっと登録済かわかるので。</b></p>
    <p class="source">&nbsp;&nbsp;&nbsp; // プレイヤの生成処理<br>
      &nbsp;&nbsp;&nbsp; void MakePlayer()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 参加辞書登録されたプレイヤの自機の生成<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::IsJoin((Pad)i) &amp;&amp; gm.players<em>.count(i) == 0</em>)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; gm.<em>players[i] = </em>std::make_shared&lt;Player&gt;((Pad)i, (float)100, (float)(Screen::Height / 2));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; } </p>
    <br>
    <br>
    <br>
    <p>さてタイトル画面などにもプレイヤ参加の検出処理を加えておきましょう。<br>
      プレイに移る前に参加辞書Input::isJoinに1人は登録がないとプレイヤのいない空のプレイ画面から始まるので。<br>
      <br>
      <code>TitleScene.hにプレイヤの参加検出処理を追加</code>します。</p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      (中略)..................<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; (中略)..................<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタン入力に応じた処理<br>
      &nbsp;&nbsp;&nbsp; void HandleInput()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>Input::JoinCheck(); // プレイヤの参加検出処理</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(Pad::All, PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ボタンを押したらスタート音声を再生<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sound::Play(Sound::start);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isStartPushed = true; // 画面遷移トリガーON<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp; (中略)..................<br>
      &nbsp;&nbsp;&nbsp; }<br>
      (以下略)..................</p>
    <br>
    <br>
    <p>他にもザコにプレイヤの追撃弾を撃たせている人は単体のプレイヤを複数対応しなければなりません。<br>
      プレイヤを追撃するにも<b>複数いるとどのプレイヤを追撃するかあいまいになるので。</b><br>
      <b>ここからのザコの処理の修正は人それぞれプレイヤを追っかけない独自のザコを作成してる人は不要かもしれません。</b><br>
      <br>
      <br>
    </p>
    <p><code>まずMyMath.hに距離の2乗を求める処理を追加</code>します。 </p>
    <p class="source">#ifndef _MYMATH_H<br>
      #define _MYMATH_H<br>
      <br>
      #include &lt;cmath&gt;<br>
      <br>
      // 数学関連クラス<br>
      class MyMath<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // C ++標準では、静的static定数の【整数型】または【列挙型】のみをクラス内で初期化できます。<br>
      &nbsp;&nbsp;&nbsp; // これが、一部の初期化が許可されているのに他のstatic floatなどが初期化できない理由です。<br>
      <br>
      &nbsp;&nbsp;&nbsp; // float小数を定義するためだけにcppファイルを作成しないと<br>
      &nbsp;&nbsp;&nbsp; //static const float Sqrt2 =【このイコールでエラー】 1.41421356237f;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ルート2(変数名の定義だけ)<br>
      &nbsp;&nbsp;&nbsp; static const float Sqrt2;// = 1.41421356237f;<br>
      &nbsp;&nbsp;&nbsp; static const float PI; // 円周率 3.14159265359f;<br>
      &nbsp;&nbsp;&nbsp; static const float Deg2Rad; // 度からラジアンに変換する定数 PI / 180f;<br>
      <br>
      &nbsp;&nbsp; &nbsp;<em>/// &lt;summary&gt;<br>
        &nbsp;&nbsp; &nbsp;/// 点から点への距離の2乗を求める(最小距離なら2乗のままで√計算省く)<br>
        &nbsp;&nbsp; &nbsp;/// &lt;/summary&gt;<br>
        &nbsp;&nbsp; &nbsp;/// &lt;param name="fromX"&gt;始点x&lt;/param&gt;<br>
        &nbsp;&nbsp; &nbsp;/// &lt;param name="fromY"&gt;始点y&lt;/param&gt;<br>
        &nbsp;&nbsp; &nbsp;/// &lt;param name="toX"&gt;終点x&lt;/param&gt;<br>
        &nbsp;&nbsp; &nbsp;/// &lt;param name="toY"&gt;終点y&lt;/param&gt;<br>
        &nbsp;&nbsp; &nbsp;/// &lt;returns&gt;&lt;/returns&gt;<br>
        &nbsp;&nbsp; &nbsp;static float Distance2(float fromX, float fromY, float toX, float toY)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float distX = toX - fromX;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float distY = toY - fromY;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return distX * distX + distY * distY;<br>
        &nbsp;&nbsp; &nbsp;}</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
      &nbsp;&nbsp;&nbsp; /// 円と円が重なっているかを調べる<br>
      &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;param name="x1"&gt;円1の中心x&lt;/param&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;param name="y1"&gt;円1の中心y&lt;/param&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;param name="x2"&gt;円2の中心x&lt;/param&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;param name="y2"&gt;円2の中心y&lt;/param&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
      &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
      &nbsp;&nbsp;&nbsp; static bool CircleCircleIntersection(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x1, float y1, float radius1,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x2, float y2, float radius2)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt; ((radius1 + radius2) * (radius1 + radius2));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;/// &lt;summary&gt;<br>
      &nbsp;&nbsp; &nbsp;/// 点から点への角度（ラジアン）を求める。<br>
      &nbsp;&nbsp; &nbsp;/// &lt;/summary&gt;<br>
      &nbsp;&nbsp; &nbsp;/// &lt;param name="fromX"&gt;始点x&lt;/param&gt;<br>
      &nbsp;&nbsp; &nbsp;/// &lt;param name="fromY"&gt;始点y&lt;/param&gt;<br>
      &nbsp;&nbsp; &nbsp;/// &lt;param name="toX"&gt;終点x&lt;/param&gt;<br>
      &nbsp;&nbsp; &nbsp;/// &lt;param name="toY"&gt;終点y&lt;/param&gt;<br>
      &nbsp;&nbsp; &nbsp;/// &lt;returns&gt;&lt;/returns&gt;<br>
      &nbsp;&nbsp; &nbsp;static float PointToPointAngle(float fromX, float fromY, float toX, float toY)<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return (float)std::atan2(toY - fromY, toX - fromX);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      }; // 【注意】セミコロン抜けで【宣言が必要ですエラー】<br>
      <br>
      #endif // 【宣言が必要ですエラーは上のセミコロン抜け】</p>
    <br>
    <code>Zako0.hに複数のプレイヤから一番近いプレイヤを追撃する処理を追加</code>します。
    <p></p>
    <p class="source">#ifndef ZAKO_0_H_<br>
      #define ZAKO_0_H_<br>
      <br>
      <em>#include &lt;memory&gt;</em><br>
      <br>
      #include "Enemy.h"<br>
      #include "Image.h"<br>
      #include "MyMath.h"<br>
      <br>
      #include "Player.h" // Player.hでもZako1.hをインクルードすると循環するので注意<br>
      <br>
      // ザコ0クラス<br>
      class Zako0 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int coolTime = 0; // クールタイム（冷却時間。0になるまで次の弾が撃てない）<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Zako0(float x, float y, float z = 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Enemy(x, y, z)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Zako0";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x -= 1; // とりあえず左へ移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime--;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (coolTime &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>float minDistance = 1000000; // 最小の距離の2乗<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::shared_ptr&lt;Player&gt; player = nullptr; // 一番近いプレイヤを探す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; pair : gm.players)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;auto p = pair.second;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float dist2 = MyMath::Distance2(x, y, p-&gt;x, p-&gt;y);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (dist2 &lt; minDistance)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// より小さい距離のプレイヤがいれば記録更新<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;minDistance = dist2;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;player = p;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (player != nullptr)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{</em>&nbsp;&nbsp; &nbsp;// 自機狙い弾<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float angle = MyMath::PointToPointAngle(x, y, <em>player</em>-&gt;x, <em>player</em>-&gt;y);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(x, y, angle, 8));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>}</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;coolTime += 10;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 【重要】画面外の削除処理【CPU処理重くなる原因】<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (x &lt; 0)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 左端の画面外に出たらisDeadしないと<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 画面外の敵の当たり判定で【だんだん処理が重くなるZako1,Zako2..も】<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;isDead = true;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(x, y, 1, 0, Image::zako0, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>Zako1.hに複数のプレイヤから一番近いプレイヤを追撃する処理を追加</code>します。</p>
    <p class="source">#ifndef ZAKO_1_H_<br>
      #define ZAKO_1_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      <em>#include &lt;memory&gt;</em><br>
      #include &lt;cmath&gt; // Sinの計算に使う<br>
      #include "MyMath.h"<br>
      #include "Image.h"<br>
      <br>
      #include "Player.h" // Player.hでもZako1.hをインクルードすると循環するので注意<br>
      <br>
      // ザコ1クラス<br>
      class Zako1 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;float sinMove = 0; // Sinの動きをする際の0～360度<br>
      &nbsp;&nbsp; &nbsp;float sinRadius = 70; // Sinの動きをするときの半径<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Zako1(float x, float y, float z = 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Enemy(x, y, z)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Zako1";//オブジェクトの種類判別タグ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life = 5;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>float minDistance = 1000000; // 最小の距離<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::shared_ptr&lt;Player&gt; player = nullptr; // 一番近いプレイヤを探す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; pair : gm.players)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;auto p = pair.second;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float dist2 = MyMath::Distance2(x, y, p-&gt;x, p-&gt;y);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (dist2 &lt; minDistance)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// より小さい距離のプレイヤがいれば記録更新<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;minDistance = dist2;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;player = p;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (minDistance&gt;300*300+300*300)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{</em><em><em><br>
          &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; </em></em><em><em>x += 1; // 縦Y方向300,横X方向300以上の距離のときは</em><br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else if (player != nullptr)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機をおいかけてくる処理<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float angleToPlayer = MyMath::PointToPointAngle(x, y, <em>player</em>-&gt;x, <em>player</em>-&gt;y);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float speed = 3;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x += (float)std::cos(angleToPlayer) * speed;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;y += (float)std::sin(angleToPlayer) * speed;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//ゆらゆらSin波動の動きをy上下方向にプラス<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float prevSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sinMove += 2.5f; // Sinの波運動の角度を進める<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float currentSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// (前の角度でのY) - (今の角度でのY)の差を足すことで【ベースのyの位置 ± sinの動き】になる<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;y += currentSinY - prevSinY; // 上下方向のSinの波運動<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>}</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(x, y, 1, 0, Image::zako1, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>Zako2.hに複数のプレイヤから一番近いプレイヤを追撃する処理を追加</code>します。</p>
    <p class="source">#ifndef ZAKO_2_H_<br>
      #define ZAKO_2_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      <em>#include &lt;memory&gt;</em><br>
      #include &lt;cmath&gt; // Sin Cosの計算に使う<br>
      <br>
      #include "Image.h"<br>
      #include "Screen.h"<br>
      #include "MyMath.h"<br>
      #include "MyRandom.h"<br>
      <br>
      #include "Player.h" // Player.hでもZako2.hをインクルードすると循環するので注意<br>
      <br>
      // ザコ2クラス<br>
      class Zako2 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int coolTime = 0; // クールタイム（冷却時間。0になるまで次の弾が撃てない）<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Zako2(float x, float y, float z = 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Enemy(x, y, z)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Zako2";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (x &gt; Screen::Width - 200)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { // スクリーンの端から200の位置で止まる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x -= 1; // とりあえず左へ移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coolTime--;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (coolTime &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>float minDistance = 1000000; // 最小の距離<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::shared_ptr&lt;Player&gt; player = nullptr; // 一番近いプレイヤを探す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (const auto&amp; pair : gm.players)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// より小さい距離のプレイヤがいれば記録更新<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;auto p = pair.second;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float dist2 = MyMath::Distance2(x, y, p-&gt;x, p-&gt;y);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (dist2 &lt; minDistance)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;minDistance = dist2;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;player = p;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (player != nullptr)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{</em><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 自機狙いばらまき弾<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float angle = MyMath::PointToPointAngle(x, y, <em>player</em>-&gt;x, <em>player</em>-&gt;y);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;float randomAngle = MyRandom::Range(-15.0f, 15.0f); // ±15度の乱数の角度を取得<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;gm.enemyBullets.emplace_back(std::make_shared&lt;EnemyBullet&gt;(x, y, angle + randomAngle * MyMath::Deg2Rad, 8));<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;coolTime += 10;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 200の位置で止まるので左端にこないから削除処理はなくて済む<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawRotaGraphF(x, y, 1, 0, Image::zako2, TRUE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <br>
    <p>さて、これで独自のザコや弾など単数プレイヤを使用しているコードがなくなれば<br>
      複数プレイヤでプレイできるようになるはずです。<br>
      一度プレイして複数プレイヤでプレイできるか確かめてみましょう。</p>
    <br>
    <br>
    <br>
  </body>
</html>
