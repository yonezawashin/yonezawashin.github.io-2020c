<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>シューティングゲーム 1</title>
    <link rel="stylesheet" href="style.css">
    <style>
      
    </style>
  </head>
  <body>
    <p class="title">[C++移植]シューティングゲーム 1</p>
    <br>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId816363">シューティングのC++移植で目指すところ(意義)</a></li>
      <li><a href="#mozTocId488915">プロジェクトの作成</a></li>
      <li><a href="#mozTocId53452">便利クラスの追加</a></li>
      <li><a href="#mozTocId522169">画像ファイルの追加</a></li>
      <li><a href="#mozTocId848225">Imageクラスの作成</a></li>
      <li><a href="#mozTocId300175">自機の作成</a></li>
      <li><a href="#mozTocId514412">自機弾の作成</a></li>
      <li><a href="#mozTocId668068">敵の作成</a></li>
    </ol>
    <h1><a id="mozTocId816363" class="mozTocH1"></a>シューティングのC++移植で目指すところ(意義)</h1>
    <p>前期でやったシューティングの制作をC++に移植することで以下を作業を通じて【体得しよう】。</p>
    <ul>
      <li>C++でのクラス定義をC#との違いを比較しながら習得</li>
      <li>C++ではないがDXライブラリの公式のサンプルはC++なのでそれを動かせるようになる</li>
      <li>C++でのリストやforeachの使い方の違いを習得</li>
      <li>C++での画像読み込みとそのメモリのお掃除(メモリ開放)</li>
    </ul>
    <p>別途[クラスの基本(C++11).pdf]の解説を参考にしながらC++のクラス定義に慣れてゆきましょう</p>
    <p>最終的には、C++で制作したゲームの提出をしてもらいます（その出来で後期の成績が決まります）。<br>
      頑張ってください！</p>
    <p></p>
    <h1><a id="mozTocId488915" class="mozTocH1"></a>プロジェクトの作成</h1>
    <h2>まずはDXライブラリ公式のC++のライブラリをダウンロード</h2>
    以下のDXライブラリの公式サイトからC++のDXライブラリをダウンロードしてください。<br>
    <a href="https://dxlib.xsrv.jp/dxdload.html">https://dxlib.xsrv.jp/dxdload.html</a>
	<br>ダウンロードできたらzipファイルを【C:ドライブ直下に展開】してください<br>
	<p> <img src="image/img_dxdownload.png" alt=""></p><br><br>
    
    <h2>ダウンロードできたらzipファイルを【C:ドライブ直下に展開】</h2>
    <p> <img src="image/img_dxlibextract_c_drive.png" alt=""></p><br><br>
    
    
    <h2>プロジェクト作成</h2>
    Visual Studio 2019を起動してください。<br>
    <br>
    起動したら、<code>新しいプロジェクトの作成</code>をクリック<br>
    <br>
    <code>C++ 空のプロジェクト</code>を選択して次へ
    <p> <img src="image/making_cpp_prj.png" alt="" style="width: 1156px; height: 853px;"></p>
    <p>今回のプロジェクト名は【1】「自分の作るゲーム名」か【2】毎回C++のプロジェクトを作るのが面倒な人は今回作るプロジェクトをフォルダごと量産するとして「DXLibGameBase」(ゲームの基礎ベース、コピペで量産用プロジェクト)にしましょう。</p></p>
    <p>プロジェクトが作成されたら、まず【main.cpp】作りましょう。</p> <br>
    <p>少なくとも一つ【～.cpp】作らないと出てこない次にやる設定↓で【出てこない項目】があります(【C/C++全般】が出てこない！)</p> <br>
    
    <h2>次にプロジェクトのややこしい設定をしっかりやる</h2>
	プロジェクトの【設定を開く前に】最低限一つだけでもcppファイルがプロジェクトにないと【出てこない設定項目がある】ので新しい項目を追加でC++ソースファイル(.cpp)のファイルを一つ作成しておく。<br>
    <br>
    <p> <img src="image/need_one_cpp.png" alt="" style="width: 1152px; height: 713px;"></p>
    <br>
    一つだけcppファイルを作成した後、プロジェクトを右クリックして<code>プロパティ</code>をクリック<br>
    <br>
    <p> <img src="image/open_setting.png" alt="" style="width: 1128px; height: 642px;"></p>
    <br>    
    
    <h2>【設定】マルチバイト文字セットを使用</h2>
    <br>
    設定画面の【構成プロパティ】→【詳細】の【文字セット】を<code>マルチバイト文字セットを使用</code>に変更<br>
    <p> <img src="image/setting_multibyte_moji.png" alt="" style="width: 982px; height: 682px;"></p>
    <br>


    <h2>【設定】C/C++→全般→追加のインクルードディレクトリにDXライブラリのフォルダ位置(PATH)を追加</h2>
    <br>
    設定画面の【C/C++全般】→【全般】の【追加のインクルードディレクトリ】に<code>DXライブラリのフォルダ位置(PATH)</code>を設定<br>
    <p> <img src="image/setting_cpp_add_include_dir.png" alt="" style="width: 1047px; height: 682px;"></p>
    <br>
    フォルダのパス(位置)文字列は以下のgifアニメのようにコピーして貼り付け<br>
    <p> <img src="image/setting_howto_copy_dir.gif" alt="" style="width: 892px; height: 554px;"></p>
    <br>

    <h2>【設定】リンカ→全般→追加のライブラリディレクトリにDXライブラリのフォルダ位置(PATH)を追加</h2>
    <br>
    設定画面の【リンカー】→【全般】の【追加のライブラリディレクトリ】に<code>DXライブラリのフォルダ位置(PATH)</code>を設定<br>
    <p> <img src="image/setting_linker_add_lib_dir.png" alt="" style="width: 1046px; height: 682px;"></p>
    <br>
    フォルダのパス(位置)文字列は以下のgifアニメのようにコピーしたものを貼り付け<br>
    <p> <img src="image/setting_howto_paste_dir.gif" alt="" style="width: 1075px; height: 805px;"></p>
    <br>

<br>

    
    <h2>【設定】リンカ→システム→サブシステムをウィンドウに(コンソールのままだと黒画面の文字ベースシステムになる)</h2>
    
    <br>
    設定画面の【リンカー】→【システム】の【サブシステム】を<code>Windows(SUBSYSTEM:WINDOWS)</code>に設定<br>
    この設定をするとプログラムの開始位置(エントリポイントという)がWinMainというところから始まるようになる。(Consoleの場合はMain)<br>
    <p> <img src="image/setting_entry_point.png" alt="" style="width: 985px; height: 682px;"></p>
    <br>
    
    <br>
    以上で設定項目は終わり。OKをおして設定を反映しよう<br>

    <br>
<br>
	<h2>設定を反映させたらサンプルプログラムをmain.cppにコピペして動作を確認</h2>
    <p>以下の【ウィンドウを出すだけの最小限サンプル】を動かして設定を確認しましょう</p>
    <p><code>main.cpp【ウィンドウを出すだけの最小限サンプル】</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
<br>
// 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;// 画面モードの設定<br>
&nbsp;&nbsp;SetGraphMode( 960 , 540 , 32 ) ; // 画面サイズ960×540のカラービット数32ビットで起動<br>
&nbsp;&nbsp;SetWindowSize(960, 540);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
&nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
<br>
&nbsp;&nbsp;// ＤＸライブラリの初期化<br>
&nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// エラーが発生したら直ちに終了<br>
&nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
&nbsp;&nbsp;}<br>

&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// この位置にウィンドウの中に画像を描く処理などを書く<br>
&nbsp;&nbsp;// DXライブラリ公式の色々なサンプルを試してみよう！<br>
&nbsp;&nbsp;// https://dxlib.xsrv.jp/dxfunc.html<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>


&nbsp;&nbsp;// キー入力待ちをする<br>
&nbsp;&nbsp;WaitKey();<br>

&nbsp;&nbsp;// ＤＸライブラリの後始末<br>
&nbsp;&nbsp;DxLib_End();<br>

&nbsp;&nbsp;// ソフトの終了<br>
&nbsp;&nbsp;return 0;<br>
}</p>


    
    <h2>解像度の定義</h2>
    <p>【C++で】画面解像度を定義するクラスを作ってみましょう。ソリューションエクスプローラーのプロジェクトを右クリックし、追加＞ヘッダファイル(.h)<br>
      Screen.hという名前でヘッダファイルを生成し、そのファイルにクラスを記述します。</p>
    <p><code>Screen.h</code>を編集します：</p>
    <p class="source">#ifndef _SCREEN_H<br>
#define _SCREEN_H<br>
// ＃ifndefは「_SCREEN_H」がifもしもn(not) def(定義)されていないなら＃endifに挟まれたコードまでを有効化する(だから2度目以降は無効になる)<br>
// 二重定義を防止するために＃から始まる【プリプロセッサ】を使っている<br>
//　【プリプロセッサ】はビルドする段階でコード自体に【前処理】として影響を与える<br>
// たとえば<br>
// ・ファイルの読み込み (including) →＃includeがこれ<br>
// ・マクロの展開（シンボルを、あらかじめ定義された規則に従って置換する）<br>
// ・コンパイル条件によるソースコードの部分的選択→【＃ifndef　～ ＃endifに囲まれた部分】は一度(＃defineで)定義されると無効化<br>
// ・コメントの削除 【&nbsp;//&nbsp;】のコメントの削除も【プリプロセス＝前段階で行われる】<br>
<br>
// 画面解像度<br>
class Screen<br>
{<br>
public: //publicはC＃と違いpublic:以下にまとめて書かれるスタイル<br>
&nbsp;&nbsp;static const int Width = 960; // 幅<br>
&nbsp;&nbsp;static const int Height = 540; // 高さ C＃と違いstaticクラスではなく個々の【すべての変数にstaticをつけて】staticなクラスとする<br>
};// C＃と違ってクラスの定義も;セミコロンで終わる<br>

#endif</p>
<br>
<br>
<br>
    <p><code>main.cpp</code>を編集してScreen.hを読み込ませます：</p>
    <p class="source">#include "DxLib.h"<br>
    <em>#include "Screen.h"</em><br>
// ↑＃includeで別ファイルのヘッダファイル.hをこのコード内に読み込む<br>
<br>
// 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;// 画面モードの設定<br>
&nbsp;&nbsp;SetGraphMode( <em>Screen::Width, Screen::Height,</em> 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;SetWindowSize(<em>Screen::Width, Screen::Height</em>);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
<br>
&nbsp;&nbsp;// ＤＸライブラリの初期化<br>
&nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// エラーが発生したら直ちに終了<br>
&nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
&nbsp;&nbsp;}<br>
<br>

<br>
&nbsp;&nbsp;// (中略).....................................<br>
<br>
&nbsp;&nbsp;// ソフトの終了<br>
&nbsp;&nbsp;return 0;<br>
}</p>



    <h1><a id="mozTocId53452" class="mozTocH1"></a>画像ファイルの追加</h1>
    <p>次は画像ファイルをプロジェクトに追加します。【C#と違い】フォルダは【ウィンドウズ上のエクスプローラで作成】します。<br>
    <br>
    <br>
    <img src="image/open_folder_with_explorer.png" alt="" style="width: 1397px; height: 475px;"><br>
    <br>
    <img src="image/new_image_folder.png" alt="" style="width: 362px; height: 180px;"><br>
	<br>
	<br>
      「素材」フォルダー内の「画像」フォルダーにあるおなじみのボス画像を、【C#と違い】下のアニメようにウィンドウズでImageフォルダーにコピーして貼り付けしてください。</p>
    <img src="image/image_copy_paste.gif" alt=""><br>
    <br>
    <img src="image/image_add_project.gif" alt=""><br>

    <p><br>
    </p>
    
    <h2>試しに表示してみる</h2>
    <p><code>main.cpp</code>にプログラムを追加し、画像が正しく表示できるかテストします。</p>
    <p class="source">#include "DxLib.h"<br>
    <em>#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用</em><br>
    #include "Screen.h"<br>
// ＃includeで別ファイルのヘッダファイル.hをこのコード内に読み込む<br>
<br>
// 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;// 画面モードの設定<br>
&nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
<br>
&nbsp;&nbsp;// ＤＸライブラリの初期化<br>
&nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// エラーが発生したら直ちに終了<br>
&nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
&nbsp;&nbsp;}<br>
<br>
	    
<br>
<em>
&nbsp;&nbsp;//表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;// これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;// これまでInitでやってきてた初期化処理<br>
&nbsp;&nbsp;int bossImage = -1;<br>
&nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
&nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
&nbsp;&nbsp;int x = 100; // Xの初期位置<br>
&nbsp;&nbsp;int vx = 10;<br>
<br>
&nbsp;&nbsp;ScreenFlip();<br>
<br>
&nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;while (ProcessMessage() == 0) <br>
&nbsp;&nbsp;{// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
<br>   
&nbsp;&nbsp;&nbsp;&nbsp;// これまではUpdateでやってきてた更新処理<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;x += vx; // X位置の更新<br>
<br>   
&nbsp;&nbsp;&nbsp;&nbsp;// これまではDrawでやってきてた描画処理<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;}<br></em>
<br>

&nbsp;&nbsp;// キー入力待ちをする<br>
&nbsp;&nbsp;WaitKey();<br>

&nbsp;&nbsp;// ＤＸライブラリの後始末<br>
&nbsp;&nbsp;DxLib_End();<br>

&nbsp;&nbsp;// ソフトの終了<br>
&nbsp;&nbsp;return 0;<br>
}</p>
    <p><br>
    </p>

    
    
    <h1><a id="mozTocId522169" class="mozTocH1"></a>Imageクラスの作成</h1>
    <h2>Imageクラスの作成</h2>
    <p>Imageクラスを作成しましょう。Imageクラスの役割は次の2つです。</p>
    <ul>
      <li>画像の読み込み</li>
      <li>読み込んだ画像ハンドルの保持</li>
    </ul>
    <p><br>
    </p>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「Image」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Image.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef IMAGE_H_<br>
#define IMAGE_H_<br>
<br>
#include "DxLib.h"<br>
#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
<br>
class Image<br>
{<br>
public:<br>
&nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;static void Load();<br>
<br>
&nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
<br>
private:<br>
<br>
};<br>
#endif<br>
</p>
	  
	  
<br>
<p>次に対となるcppファイルを作成します。<br>
ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞cppファイル<br>
      「Image.cpp」という名前でcppファイルを作り、クラスを実装します。<br>
      <br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
<br>
int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
<br>
void Image::Load()<br>
{<br>
&nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
&nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
}</p>

	  <br>
	  <br>
	  
<h2>試しに【Image.hを使って】表示してみる</h2>
    <p><code>main.cpp</code>のプログラムを変更し、画像が正しく表示できるかテストします。</p>
    <p class="source">#include "DxLib.h"<br>
    #include "Screen.h"<br>
    <em>#include "Image.h"&nbsp;// 画像読み込みクラス</em><br>
<br>
<br>
// 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;// 画面モードの設定<br>
&nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
<br>
&nbsp;&nbsp;// ＤＸライブラリの初期化<br>
&nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// エラーが発生したら直ちに終了<br>
&nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;//表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;// これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;// これまでInitでやってきてた初期化処理<br>
&nbsp;&nbsp;<em>Image::Load();</em><br>
&nbsp;&nbsp;int x = 100; // Xの初期位置<br>
&nbsp;&nbsp;int vx = 10;<br>
<br>
&nbsp;&nbsp;ScreenFlip();<br>
<br>
&nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;while (ProcessMessage() == 0) <br>
&nbsp;&nbsp;{// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
<br>   
&nbsp;&nbsp;&nbsp;&nbsp;// これまではUpdateでやってきてた更新処理<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;x += vx; // X位置の更新<br>
<br>   
&nbsp;&nbsp;&nbsp;&nbsp;// これまではDrawでやってきてた描画処理<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, <em>Image::bossImage</em>, TRUE);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;}<br>
<br>

&nbsp;&nbsp;// キー入力待ちをする<br>
&nbsp;&nbsp;WaitKey();<br>

&nbsp;&nbsp;// ＤＸライブラリの後始末<br>
&nbsp;&nbsp;DxLib_End();<br>

&nbsp;&nbsp;// ソフトの終了<br>
&nbsp;&nbsp;return 0;<br>
}</p>
    <p><br>
    </p>

	  <h1><a id="mozTocId522169" class="mozTocH1"></a>前期C#スタイルに近づく一歩！Gameクラスの作成</h1>
    <h2>Gameクラスの作成</h2>
    <p>Gameクラスを作成しましょう。Gameクラスの重要な役割は次の3つ。<br>
    これがあれば前期のようにGameクラスに処理を書いて開発できる！</p>
    <ul>
      <li>初期処理Init()</li>
      <li>更新処理Update()</li>
      <li>描画処理Draw()</li>
    </ul>
    <p><br>
    </p>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「Game」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Game.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef GAME_H_<br>
#define GAME_H_<br>
<br>
#include "Image.h"<br>
#include "Screen.h"<br>
<br>
class Game<br>
{<br>
public :<br>
&nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↓{ 
	}を.hに書くことでcppに分けて書くはずの処理ぶぶんを.hに書いてもよい */<br>
&nbsp;&nbsp;Game() {&nbsp; }; // 初期化コンストラクタ<br>
&nbsp;&nbsp;~Game() {&nbsp; }; // 破棄処理デストラクタ<br>
&nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
&nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
&nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
<br>
&nbsp;&nbsp;int x = 0; //staticじゃないintはここで=0で初期化できる<br>
&nbsp;&nbsp;int vx = 0;<br>
<br>
};<br>

#endif<br></p>
<br>
<p>次に対となるcppファイルを作成します。<br>
ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞cppファイル<br>
      「Game」という名前でcppファイルを作り、クラスの処理を実装します。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Game.h"<br>
<br>
void Game::Init()<br>
{// Init処理<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;x = 100; // Xの初期位置<br>
&nbsp;&nbsp;vx = 10; // ボスの初期速度<br>
}<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -10; //画面端で移動方向反転<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;x += vx; // ボス画像のX位置の更新<br>
	<br>
}<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
}</p>


<h2>では前期に近い【Gameクラスを使って】表示してみる</h2>
    <p><code>main.cpp</code>のプログラムを変更し、画像が正しくGameクラスで表示できるかテストします。</p>
    <p class="source">#include "DxLib.h"<br>
    #include "Screen.h"<br>
    #include "Image.h"&nbsp;// 画像読み込みクラス<br>
    <em>#include "Game.h"&nbsp;</em><br>
<br>
<br>
// 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;// 画面モードの設定<br>
&nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
<br>
&nbsp;&nbsp;// ＤＸライブラリの初期化<br>
&nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// エラーが発生したら直ちに終了<br>
&nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;//表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;// これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;// Init初期化処理<br>
&nbsp;&nbsp;<em>Game game; //Gameの定義と同時にC++ではコンストラクタで初期化される<br>
&nbsp;&nbsp;game.Init(); // gameのInit準備</em><br>
<br>
&nbsp;&nbsp;ScreenFlip();<br>
<br>
&nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;while (ProcessMessage() == 0) <br>
&nbsp;&nbsp;{// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
<br>   
&nbsp;&nbsp;&nbsp;&nbsp;// Update更新処理<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>game.Update(); // gameの更新処理</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;// Draw描画処理<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>game.Draw();</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;}<br>
<br>

&nbsp;&nbsp;// キー入力待ちをする<br>
&nbsp;&nbsp;WaitKey();<br>

&nbsp;&nbsp;// ＤＸライブラリの後始末<br>
&nbsp;&nbsp;DxLib_End();<br>

&nbsp;&nbsp;// ソフトの終了<br>
&nbsp;&nbsp;return 0;<br>
}</p>
    <p><br>
    </p>

	      <h1><a id="mozTocId522169" class="mozTocH1"></a>プレイヤを操作するには便利クラスInputクラスの移植が必須！</h1>
    <h2>Inputクラスの作成</h2>
    <p>Inputクラスを作成しましょう。InputクラスをC#から移植するときの落とし穴に注意。</p>
    <ul>
      <li>static int のstaticタイプの変数は.hだけではシンボリックエラーになるのでこのためだけに最低限.cppファイルを作成する必要がある</li>
    </ul>
	<p>
    </p>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「Input.h」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Input.h</code>にC#のInput.csをコピーし、以下のC++移植の修正をします：</p>
    <p class="source"><em>#ifndef INPUT_H_<br>
#define INPUT_H_<br>
<br>
#include "DxLib.h"</em><br>
<br>
<br>
// 入力クラス<br>
class Input<br>
{<br>
<em>public:</em><br>
&nbsp;<em>&nbsp;</em>static int prevState; // 1フレーム前の状態<br>
&nbsp;<em>&nbsp;</em>static int currentState; // 現在の状態<br>
<br>
&nbsp;&nbsp;// 初期化。最初に1回だけ呼んでください。<br>
&nbsp;<em>&nbsp;</em>static void Init()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;prevState = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;currentState = 0;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 最新の入力状況に更新する処理。<br>
&nbsp;&nbsp;// 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
&nbsp;<em>&nbsp;</em>static void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;prevState = currentState;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;currentState = <em>&nbsp;</em>GetJoypadInputState(<em>&nbsp;</em>DX_INPUT_KEY_PAD1);<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// ボタンが押されているか？<br>
&nbsp;<em>&nbsp;</em>static bool GetButton(int buttonId)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 今ボタンが押されているかどうかを返却<br>
&nbsp;&nbsp;&nbsp;&nbsp;return (currentState &amp; buttonId) != 0;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// ボタンが押された瞬間か？<br>
&nbsp;<em>&nbsp;</em>static bool GetButtonDown(int buttonId)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 今は押されていて、かつ1フレーム前は押されていない場合はtrueを返却<br>
&nbsp;&nbsp;&nbsp;&nbsp;return ((currentState &amp; buttonId) &amp; ~(prevState 
	&amp; buttonId)) != 0;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// ボタンが離された瞬間か？<br>
&nbsp;<em>&nbsp;</em>static bool GetButtonUp(int buttonId)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 1フレーム前は押されていて、かつ今は押されている場合はtrueを返却<br>
&nbsp;&nbsp;&nbsp;&nbsp;return ((prevState &amp; buttonId) &amp; ~(currentState 
	&amp; buttonId)) != 0;<br>
&nbsp;&nbsp;}<br>
}<em>;&nbsp;//←【注意】クラス定義の終わりにはコロンが必要だよ！</em><br>
<br>
#endif<em>&nbsp;&nbsp;//ここでエラー出た人は↑【注意】の;コロン忘れ</em><br></p>
<br>
<p>次に対となるcppファイルを作成します。<br>
ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞cppファイル<br>
      「Input.cpp」という名前でcppファイルを作ります(たった2行の初期化static int変数の初期化のために必須)。<br>
      <br>
      <code>Input.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Input.h"<br>
<br>
int <em>Input::</em>prevState <em>{ 0 }</em>; // 1フレーム前の状態<br>
int <em>Input::</em>currentState <em>{ 0 }</em>; // 現在の状態<br>
<em>// ↑static intのときはこの行書かないとシンボリックエラーになる件(このためだけにcpp書かなきゃならん)</em><br>
<br>
</p>


	  <h1><a id="mozTocId522169" class="mozTocH1"></a>Playerクラスでプレイヤをキー入力(↑↓←→)で動かせるように</h1>
	  <h2>忘れずにプレイヤ画像はImageフォルダにコピー貼り付けしましょう。</h2>
    <p>Playerクラスを作成する前に、忘れずにプレイヤ画像はImageフォルダにコピー貼り付けしましょう。<br>
    Imageフォルダにコピーしたらプロジェクトで</p>
    <p>次は画像ファイルをプロジェクトに追加します。【C#と違いドラッグアンドドロップせず】画像は【プロジェクトを右クリックで「追加」→「既存の項目」で画像を追加】します。<br>
    <img src="image/player_image_add.gif" alt=""><br>

<br>
<code>Image.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef IMAGE_H_<br>
#define IMAGE_H_<br>
<br>
#include "DxLib.h"<br>
#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
<br>
class Image<br>
{<br>
public:<br>
&nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;static void Load();<br>
<br>
&nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
&nbsp;&nbsp;<em>static int player; //プレイヤ画像のハンドラ</em><br>
<br>
private:<br>
<br>
};<br>
#endif<br>
</p>
<br>
<p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
<br>
int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
<em>int Image::player{-1};</em><br>
<br>
void Image::Load()<br>
{<br>
&nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
&nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;<em>player= LoadGraph("Image/player.png");<br>
&nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
}</p>
<br>
<br>


    <h2>Playerクラスの作成</h2>
    <p>Playerクラスを作成しましょう。<br>
    Playerクラスをつくるだけで安心すると【落とし穴】があります。Game.cppでInput.Update();も忘れずに</p>
    <ul>
      <li>【プレイヤ画像が出ない】→Game.cppで【player.Draw();しましたか？】</li>
      <li>【プレイヤ画像が動かない1】→Game.cppで【player.Update();しましたか？】</li>
      <li>【プレイヤ画像が動かない2】→Game.cppで【Input.Update();しましたか？】</li>
    </ul>
    <p><br>
    </p>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「Player.h」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Player.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef PLAYER_H_<br>
#define PLAYER_H_<br>
<br>
#include "DxLib.h"<br>
#include "Input.h"<br>
#include "Image.h"<br>
<br>
class Player<br>
{<br>
public:<br>
&nbsp;<em>&nbsp;</em>const float MoveSpeed = <em>6;</em> // 移動速度<br>
<br>
&nbsp;<em>&nbsp;</em>float x; // x座標<br>
&nbsp;<em>&nbsp;</em>float y; // y座標<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;// x : 初期位置x<br>
&nbsp;&nbsp;// y : 初期位置y<br>
&nbsp;<em>&nbsp;</em>Player(float x, float y)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;x = x</em>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;y = y</em>;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;<em>&nbsp;</em>void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
&nbsp;&nbsp;&nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(<em>&nbsp;</em>PAD_INPUT_LEFT))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;else if (Input<em>::</em>GetButton(<em>&nbsp;</em>PAD_INPUT_RIGHT))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (Input<em>::</em>GetButton(<em>&nbsp;</em>PAD_INPUT_UP))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;else if (Input<em>::</em>GetButton(<em>&nbsp;</em>PAD_INPUT_DOWN))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 実際に位置を動かす<br>
&nbsp;&nbsp;&nbsp;&nbsp;x += vx;<br>
&nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;<em>&nbsp;</em>void Draw()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;<em>&nbsp;</em>DrawRotaGraphF(x, y, 1, 0, <em>Image::</em>player<em>, TRUE</em>);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
#endif<br></p>
<br>

<p><code>Game.h</code>にPlayerを追加します：</p>
    <p class="source">#ifndef GAME_H_<br>
#define GAME_H_<br>
<br>
#include "Image.h"<br>
#include "Screen.h"<br>
<em>#include "Player.h"</em><br>
<br>
class Game<br>
{<br>
public :<br>
&nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↓{ 
	}を.hに書くことでcppに分けて書くはずの処理ぶぶんを.hに書いてもよい */<br>
&nbsp;&nbsp;Game() {&nbsp; }; // 初期化コンストラクタ<br>
&nbsp;&nbsp;~Game() {&nbsp; }; // 破棄処理デストラクタ<br>
&nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
&nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
&nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
<br>
&nbsp;&nbsp;int x = 0; //staticじゃないintはここで=0で初期化できる<br>
&nbsp;&nbsp;int vx = 0;<br>
<br>
&nbsp;&nbsp;<em>Player player{ 100, Screen::Height / 2 }; // 自機の初期化</em><br>
};<br>
#endif</p>

<p>次にGame.cppファイルにUpdateとDraw処理を追加してプレイヤの動作を確認しましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Game.h"<br>
<br>
void Game::Init()<br>
{// Init処理<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;x = 100; // Xの初期位置<br>
&nbsp;&nbsp;vx = 10; // ボスの初期速度<br>
}<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;<em>Input::Update();&nbsp;//【注意】これ忘れるとキー入力押してもキャラ動かない</em><br>
<br>
&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -10; //画面端で移動方向反転<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;x += vx; // ボス画像のX位置の更新<br>
	<br>
&nbsp;&nbsp;<em>player.Update(); // プレイヤの更新【忘れるとプレイヤが動かない】</em><br>
}<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;<em>player.Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】</em><br>
}</p>

<p>さて、無事にプレイヤをキー入力(↑↓←→)で動かせるようになりましたか？？？。</p><br>	  

	  
<h2>√2の定義</h2>
    <p>【C++でも】斜め方向の移動速度を√2で割って補正するために、自分用数学定義クラスを作ってみましょう。ソリューションエクスプローラーのプロジェクトを右クリックし、追加＞ヘッダファイル(.h)<br>
      MyMath.hという名前でヘッダファイルを生成し、そのファイルにクラスを記述します。</p>
    <p><code>MyMath.h</code>を編集します：</p>
    <p class="source">#ifndef _MYMATH_H<br>
	#define _MYMATH_H<br>
	// 数学関連クラス<br>class MyMath<br>{<br>
	public: <br>
&nbsp; // C ++標準では、静的static定数の【整数型】または【列挙型】のみをクラス内で初期化できます。<br>&nbsp; // 
	これが、一部の初期化が許可されているのに他のstatic floatなどが初期化できない理由です。<br><br>&nbsp; // 【OH,ノー】 
	float小数を定義するためだけにcppファイルを作成しないと<br>&nbsp; //static const float Sqrt2 
	=【このイコールでエラー】 1.41421356237f; <br><br>&nbsp; // ルート2(変数名の定義だけ)<br>static 
	const float Sqrt2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	// = 1.41421356237f;<br><br>}; // 【注意】セミコロン抜けで【宣言が必要ですエラー】<br><br>#endif // 
	【宣言が必要ですエラーは上のセミコロン抜け】</p>
<br>
<br>
<br>
    <p><code>MyMath.cpp</code>を編集して変数名に1.41421356237f を 割り当てMath。</p>
    <p class="source">#include "MyMath.h"<br>
	<br>
	const float MyMath::Sqrt2 = 
	1.41421356237f;//(floatは有効桁は実質7桁まで正確だがそれ以降は環境によって誤差出る)<br>
<br>
	// 【ルールとして.hでfloatなどstatic小数などの初期化許さなかった理由】<br>// 一言でいうと 「作った人がそういうルールにした」<br>
	// 以下を一言でまとめると「.hヘッダはマシン環境によって変わるようなことは記述しないようにしたかった」<br>// 
	PCやマシン語翻訳コンパイラによって小数の精度などや数値に誤差が出るから<br>// 
	環境によって変動する可能性のあるfloatなど(int整数は誤差がない)<br>// をstatic 
	const静的定数として.hヘッダで初期化することを許可しなかった(定数といえない) 「マシン依存」<br>// 
	cppで大丈夫なのはcppは実際の処理ベースで動くので【動的な動いてもよい数字となるから】(どの環境でも同じとは限らない)<br>// 
	【勉強】以下サイトにC++のBjarneさんの説明を翻訳したものがある<br>// 
	https://qastack.jp/programming/9656941/why-cant-i-initialize-non-const-static-member-or-static-array-in-class</p>



    <p><br>
      <br>
      定義だけじゃなく、実際にプレイヤを動かしているPlayer.hも編集しなきゃ意味がないよ！お忘れなく！！<br>
      <code>Player.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef PLAYER_H_<br>
#define PLAYER_H_<br>
<br>
#include "DxLib.h"<br>
#include "Input.h"<br>
#include "Image.h"<br>
<em>#include "MyMath.h"</em><br>
<br>
class Player<br>
{<br>
public:<br>
&nbsp;const float MoveSpeed = 6; // 移動速度<br>
<br>
&nbsp;float x; // x座標<br>
&nbsp;float y; // y座標<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;// x : 初期位置x<br>
&nbsp;&nbsp;// y : 初期位置y<br>
&nbsp;Player(float x, float y)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
&nbsp;&nbsp;&nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
&nbsp;&nbsp;&nbsp;&nbsp;}</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>// 斜め移動も同じ速度になるように調整<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (vx != 0 &amp;&amp; vy != 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;// 実際に位置を動かす<br>
&nbsp;&nbsp;&nbsp;&nbsp;x += vx;<br>
&nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
&nbsp;&nbsp;}<br>

<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;void Draw()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::player, TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
#endif<br></p>
<br>
<br>
<br>	  
        <h2>自機弾PlayerBulletクラスの作成</h2>
    <p>PlayerBulletクラスを作成しましょう。<br>
    </p>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「PlayerBullet.h」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>PlayerBullet.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
#define PLAYERBULLET_H_<br>
<br>
#include "DxLib.h"<br>
#include "Image.h"<br>
<br>
// 自機弾クラス<br>
class PlayerBullet<br>
{<br>
public:<br>
&nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
<br>
&nbsp;&nbsp;float x; // x座標<br>
&nbsp;&nbsp;float y; // y座標<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;PlayerBullet(float x, float y)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;x += Speed;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::playerBullet,TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
<br>
#endif<br></p>

<br>
<code>Image.h</code>に自機弾PlayerBullet画像定義を追加します：</p>
    <p class="source">#ifndef IMAGE_H_<br>
#define IMAGE_H_<br>
<br>
#include "DxLib.h"<br>
#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
<br>
class Image<br>
{<br>
public:<br>
&nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;static void Load();<br>
<br>
&nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
&nbsp;&nbsp;static int player; //プレイヤ画像のハンドラ<br>
&nbsp;&nbsp;<em>static int playerBullet; //プレイヤの弾画像のハンドラ</em><br>
<br>
private:<br>
<br>
};<br>
#endif<br>
</p>
<br>
<p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
<br>
int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
int Image::player{-1};<br>
<em>int Image::playerBullet{-1};</em><br>
<br>
void Image::Load()<br>
{<br>
&nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
&nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;player= LoadGraph("Image/player.png");<br>
&nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;<em>playerBullet = LoadGraph("Image/player_bullet.png");<br>
&nbsp;&nbsp;assert(playerBullet!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
}</p>
<br>
<br>

<br>

<p><code>Game.h</code>にPlayerBulletを追加します：</p>
    <p class="source">#ifndef GAME_H_<br>
#define GAME_H_<br>
<br>
<em>#include&nbsp;&lt;vector&gt;//C#のListリストの代わりのC++版<br>
#include&nbsp;&lt;memory&gt;//スマートなポインタを使うのに必要(shared_ptrなど)</em><br>
<br>
#include&nbsp;"Image.h"<br>
#include&nbsp;"Screen.h"<br>
<br>
<em>#include&nbsp;"Player.h"<br>
<br>
class&nbsp;Player;&nbsp;//←【エラー地獄に注意！】ここにPlayerクラスがあるものとして書くことで【循環相互インクルードどうぞどうぞ問題】を回避<br>
class&nbsp;PlayerBullet;</em><br>
<br>
class&nbsp;Game<br>
{<br>
public&nbsp;:<br>
&nbsp;&nbsp;Game()&nbsp;{}; // 初期化コンストラクタ<br>
&nbsp;&nbsp;~Game()&nbsp;{}; // 破棄処理デストラクタ<br>
&nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
&nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
&nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
<br>
&nbsp;&nbsp;int x = 0;<br>
&nbsp;&nbsp;int vx = 0;<br>
<br>
&nbsp;&nbsp;<em>std::shared_ptr&lt;Player&gt;&nbsp;player{ std::make_shared&lt;Player&gt;(100, Screen::Height / 2, this) }; // 自機の初期化</em><br>
&nbsp;&nbsp;<em>//↑プレイヤを回し読みポインタ型に。std::make_shared&lt;Player&gt;でメモリ上に実体を生成<br>
&nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト</em><br>
&nbsp;&nbsp;//&nbsp;List↑と同じvector&nbsp;↑【shared_ptr】<br>
<br>
&nbsp;&nbsp;//&nbsp;★【shared_ptr】とは【データの回し読み(読まれなくなったら廃棄)】<br>
&nbsp;&nbsp;//&nbsp;「兄弟で週刊少年ジャンプを【回し読みする】が<br>
&nbsp;&nbsp;//&nbsp;おかんに【全員読み終わるまでは捨てられないように】する<br>
&nbsp;&nbsp;//&nbsp;【読むつもりの人カウンタ】がゼロになると【おかんに捨てられる(リンク切れ廃棄)】」<br>
<br>
};<br>
<br>
#endif</p>

<p>次にGame.cppファイルにUpdateとDrawに自機弾更新と描画の処理を追加しましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include&nbsp;"Game.h"<br>
<br>
<em>#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;x = 100; // Xの初期位置<br>
&nbsp;&nbsp;vx = 10;<br>
};<br>
<br>
void&nbsp;Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;x += vx; // X位置の更新<br>
<br>
&nbsp;&nbsp;player<em>-&gt;</em>Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
&nbsp;&nbsp;<em>//ポインタ↑になると.から->でのアクセスになる</em><br>
<br>
&nbsp;&nbsp;<em>// 自機弾の更新処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}</em><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<em>//【放置厳禁！！！このままここに弾削除処理書かないとメモリがどんどん減ってくよ(気づかないうちにね..怖)】</em><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;player<em>-&gt;</em>Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
&nbsp;&nbsp;<em>//ポインタ↑になると.から->でのアクセスになる</em><br>
<br>
&nbsp;&nbsp;<em>// 自機弾の描画処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
&nbsp;&nbsp;}</em><br>
};<br>
</p>
<br>
<br>
<br>


<p><code>Player.h</code>にPlayerBulletへの参照を得るため<em>Gameへのポインタ参照を追加</em>します：</p>
    <p class="source">#ifndef&nbsp;PLAYER_H_<br>
#define&nbsp;PLAYER_H_<br>
<br>
#include&nbsp;"DxLib.h"<br>
#include&nbsp;"Input.h"<br>
#include&nbsp;"Image.h"<br>
#include&nbsp;"MyMath.h"<br>
<br>
<em>class&nbsp;Game;&nbsp;//←【エラー地獄に注意！】ここにGameクラスがあるものとして書くことで【循環相互インクルードどうぞどうぞ問題】を回避<br>
<br>
//↑Gameクラス内にPlayer変数を持っているからPlayerの定義が終わらないとGameの定義が完了しない(未定義エラー)<br>
//【なのに】Playerクラス内にGame変数を持っているからPlayerの定義も終わらない！！(未定義エラー)<br>
//【つまりPlayerとGameが互いに定義が終わるのを待つ】【循環相互インクルードどうぞどうぞ状態】になる<br>
//【解決するために】とりあえずclass Game;とだけここに書いてGameは定義完了済と見せかけているわけです！<br>
//[エラー:Playerは未定義です]とか[エラー:Gameは未定義です]とか定義してるはずのものが未定義の場合は大体これ！！</em><br>
<br>
class&nbsp;Player<br>
{<br>
public:<br>
&nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
<br>
&nbsp;&nbsp;float x; // x座標<br>
&nbsp;&nbsp;float y; // y座標<br>
<br>
&nbsp;&nbsp;<em>Game* game { nullptr }; // Gameのインスタンスの参照<br>
&nbsp;&nbsp;//↑ * ポインタ型です！プレイヤの【内部に】ゲームの情報を【メモリ実体として持つ】と<br>
&nbsp;&nbsp;//そのプレイヤを親のゲームがもつと【延々とループで終わりなきメモリ爆発ループ】になるから<br>
&nbsp;&nbsp;//メモリに対しての参照=【レコードの針をGameに指して】【Gameの住所アドレスだけをプレイヤ内部に持つ】</em><br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;// x : 初期位置x<br>
&nbsp;&nbsp;// y : 初期位置y<br>
&nbsp;&nbsp;Player(float x, float y<em>, Game* game</em>)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;game = game;</em><br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;<em>void Update();//【★←Player.cppを新規作成してそちらに処理を書き移す】</em><br>  
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;<em>void Draw();//【★←Player.cppを新規作成してそちらに処理を書き移す】</em><br>
<br>
};<br>
<br>
#endif</p>

<br>
<p><code>↑Player.hにあった上記処理部分を↓Player.cppを新規作成して書き移します</code></p>
<p><code>Player.cpp</code>にPlayerBulletの発射処理を追加します：</p>
    <p class="source">
#include&nbsp;"Player.h"<br>
<br>
<em>#include&nbsp;"Game.h"&nbsp;//&nbsp;★game->playerBulletsなどClass Game;でカバーできない【定義の内部のplayerBulletsにアクセスするのでインクルード必要】<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★弾を生成して【使う処理があるのでインクルード必要】</em><br>
<br>
<br>
<br>
// 更新処理【書き移す際にはPlayer::という形で::所属が必要になります】<br>
void&nbsp;<em>Player::</em>Update()<br>
{<br>
&nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
&nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
<br>
&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
&nbsp;&nbsp;if (vx != 0 &amp;&amp; vy != 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 実際に位置を動かす<br>
&nbsp;&nbsp;x += vx;<br>
&nbsp;&nbsp;y += vy;<br>
<br>
&nbsp;&nbsp;<em>// ボタン押下で自機弾を発射<br>
&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;【C#版→】game-&gt;playerBullets.Add(new PlayerBullet(x, y));<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;C++ではAddがpush_backに↓&nbsp;newがmake_shared↓に<br>
&nbsp;&nbsp;&nbsp;&nbsp;game-&gt;playerBullets.push_back(std::make_shared&lt;PlayerBullet&gt;(x, y));<br>  
&nbsp;&nbsp;}</em><br>
}<br>  
<br>
// 描画処理<br>
void&nbsp;<em>Player::</em>Draw()<br>
{<br>
&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::player, TRUE);<br>
}<br>
<br>
</p>

<br>
<br>
<br>
<p>【確認してみましょう】ここまでで一旦弾が打てるかチェックしてみましょう！【メモリは削除されないバージョンなので要注意！！】</p><br>
<br>
<br>
<br>
	
<p>【さてここで大量のエラーで詰んだ人が多いのでは】おそらくは【Player.hに弾を弾を撃つ処理を書いたのでは】</p>
<p>それにしても【なぜヘッダファイルとcppファイルに書く違いだけで大量のエラー】が出てしまうのでしょう？</p><br>
<p> <img src="image/include_loop_error.png" alt="" style="width: 1277px; height: 982px;"></p>
<br>
<p>原因である【循環参照・循環インクルード】について説明します。<br>
実はインクルードしたPlayer.hやGame.hは【⇒ビルド】した際に【Player.hの中身が#include "Player.h"へとコピペ】されるのです<br>
そして問題は相互に【Player.hで#include "Game.h"】⇔【Game.hで#include "Player.h"】すると<br>
互いへの【コピペがループする】ため【延々とGameかPlayerの定義が完成せず】<br>
結果、邪悪なことに【全然関係ないPlayerBulletが未定義などと、とばっちりエラーが起こる】のです</p>
<p> <img src="image/include_loop.png" alt="" style="width: 1466px; height: 832px;"></p>
<br>
<p>さてこの【循環参照・循環インクルード】への対策をどうするかが問題です。<br>
<br>
【1】 ヘッダ.hでのインクルードを避け.cppファイルでインクルードするのが基本的には有効です(ヘッダ.h同士が相互にコピペしあわないから)<br>
【2】 しかし根本的には【★相互に参照しあう構造の設計自体すっきりさせたい】です。<br>
<br>
今はPlayer⇔Gameの1対1の関係でまだ把握可能ですが、ザコや敵の弾などが他に増えてくると<br>
恐怖の三角関係や四角関係など【どこかで一周回ると無限インクルード発生】が起こってきます。<br>
まだ【1対1の循環なら見抜ける】けど【★三角ループや四角ループは発見が難しすぎ】です。</p>
<p> <img src="image/include_loop_meditator.png" alt="" style="width: 801px; height: 852px;"></p>
<p>そう、相互に行き来する【★矢印を一つへ集中させる】のです。<br>
こういったパターンを【★仲介者(Meditator)パターン】と呼びます。<br>
このパターンは【循環参照問題以外にも色んな利点】があり多用されます。<br>
一点に集中させれば【メモリの状況もここに集中します】し<br>
ここを経由すれば【どこからでもどこへでも連絡でき指令が出せます】<br>
そしていちいち初期化の時に【参照の連絡先の交換が必要なくなります】<br></p>
<p>ついでにもう一つ【★唯一物(シングルトン)パターン】も取り入れておきます。</p>
<p> <img src="image/include_loop_singleton.png" alt="" style="width: 565px; height: 946px;"></p>
<p>こういった先人の生み出したパターンを【デザインパターン】といいます。</p>
<p>有用なデザインパターンは23ほどあり、状況に合わせてうまく取り入れることが上級者への道で<br>
変な構造で作っていると起こる面倒な時間のロスが減り【残業時間が減ります】<br>
案外【ブラックな現場は構造のデザインそのものが悪かった】ことも多いです(なんかいちいちやりづらい環境)<br>
こういう【構造自体に疑問を持てる人が開発のリーダーシップを取れる】と心地よく制作が進むので<br>
時間とスキルに余裕ができたら将来のリーダーに向けて【デザイン構造パターン】を勉強するとよいかもしれません。</p><br>
<br>
<p>さて、ではまず<code>Singleton.h</code>を追加しましょう。<br>
コード中身は難しい文法が多いですが、<br>基本の要点は<br>
<br>
【1】「代入」「コピー」「実体ポインタへの直接アクセス」を★private:として【外部から禁止】<br>
【2】「実体へは★GetInstance()関数経由でしかアクセスできない」よう窓口を絞り<br>
【3】「テンプレ化」★template&lt;class T&gt;して何でも唯一化できるようになっています<br></p>
<br>
<p>難しいコードなので導入するだけでも良いですが、<br>
C++テキスト後半で「代入」「コピー」「テンプレ化」は触れられているので頑張れば6割ほどは理解できる余地ありです。<br>
2,3年後上級者となって読み返して9割ほど理解できるようになるよう成長してゆきましょう。</p>
<p><code>Singleton.h</code></p>
<p class="source">
#ifndef SINGLETON_H_<br>
#define SINGLETON_H_<br>
<br>
// テンプレートT型シングルトンSingleton&lt;～&gt; ～になんでも指定して唯一物にできる<br>
// ★Singleton&lt;T&gt;型は【必ず唯一で複製不可】(使い方:どこからでもアクセスし変数を共有するクラス向き)<br>
// ★ゲーム内の【どこからアクセスしても統一性が保たれる】(唯一だから)「クラス名と実体が一致」<br>
template&lt;class T&gt;<br>
class Singleton<br>
{<br>
public:<br>
&nbsp;&nbsp;// GetInstanceを通して【しか】T型クラスをつくれないうえに、<br>
&nbsp;&nbsp;// ★作ったものは【かならず唯一で複製不可】<br>
&nbsp;&nbsp;// それが【シングルトン型】！<br>
&nbsp;&nbsp;// ゲーム中で唯一で複製不可にしたい【ゲームを一律管理するクラス】などに最適！<br>
&nbsp;&nbsp;// https://teratail.com/questions/17416<br>
&nbsp;&nbsp;// http://rudora7.blog81.fc2.com/blog-entry-393.html<br>
&nbsp;&nbsp;// ②↓同じ関数の定義はプログラム全体で１つだけしか許されません。(static関数名は被らない)<br>
&nbsp;&nbsp;static inline T&amp; GetInstance()<br>
&nbsp;&nbsp;{&nbsp;&nbsp;//①↓関数の中で定義されたstatic変数は、関数の定義毎に１つ領域が確保されます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;static T instance; //メモリ上にstatic変数確保(静かに常に待機するinstance)<br>
&nbsp;&nbsp;&nbsp;&nbsp;return instance; //①=(常駐)②=(唯一) ①と②両方満たすinstanceは【メモリ上に唯一】<br>
&nbsp;&nbsp;}<br>
<br>
protected:<br>
&nbsp;&nbsp;Singleton() {} // 外部でのインスタンス作成は禁止(protected:内部公開、外部禁止)<br>
&nbsp;&nbsp;virtual ~Singleton() {} // 仮想デストラクタ(シングルトンを【継承するためには忘れちゃダメ】)<br>
<br>
private:<br>
&nbsp;&nbsp;void operator=(const Singleton&amp; obj) {} // 代入演算子禁止<br>
&nbsp;&nbsp;Singleton(const Singleton&amp; obj) {} // コピーコンストラクタ禁止(コピーできない【唯一】)<br>
&nbsp;&nbsp;static T* instance; // private:だから外部アクセスできない【GetInstance()経由しか無理】<br>
};<br>
<br>
// いつもcppで書いたstatic変数初期化も★【Tテンプレートクラスだからすべて.hヘッダにまとめて書いた】<br>
template&lt; class T &gt;<br>
T* Singleton&lt; T &gt;::instance = 0; //cppでの定義を.h内に書いた(static変数はclass内で初期化できないから)<br>
<br>
#endif<br>
</p>

<br>

<p>続いて仲介の役割を担当する<code>GameManager.h</code>を作成します。</p>
<p class="source">
#ifndef GAMEMANAGER_H_<br>
#define GAMEMANAGER_H_<br>
<br>
#include &lt;memory&gt;<br>
#include &lt;vector&gt;<br>
<br>
#include&nbsp;"Singleton.h"<br>
<br>
class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
class&nbsp;PlayerBullet;<br>
<br>
class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
{<br>
public:<br>
&nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
<br>
&nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機の初期化<br>
<br>
&nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
&nbsp;&nbsp;// List↑と同じvector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
<br>
protected:<br>
&nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
&nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
};<br>
<br>
#endif<br>
</p>

<p><code>Game.h</code>からGameManager.hに移行した処理を消して代わりにGameMangerへの連絡先gmを確保します。</p>
    <p class="source">#ifndef GAME_H_<br>
#define GAME_H_<br>
<br>
#include&nbsp;&lt;vector&gt;//C#のListリストの代わりのC++版<br>
#include&nbsp;&lt;memory&gt;//スマートなポインタを使うのに必要(shared_ptrなど)<br>
<br>
#include&nbsp;"Image.h"<br>
#include&nbsp;"Screen.h"<br>
<em>#include&nbsp;"Input.h"</em><br>
<br>
<u>#include&nbsp;"Player.h"</u><br>
<br>
<u>class&nbsp;Player;&nbsp;//←【エラー地獄に注意！】ここにPlayerクラスがあるものとして書くことで【循環相互インクルードどうぞどうぞ問題】を回避<br>
class&nbsp;PlayerBullet;</u><br>
<br>
<em>#include&nbsp;"GameManager.h"</em><br>
<br>
class&nbsp;Game<br>
{<br>
public&nbsp;:<br>
&nbsp;&nbsp;Game()&nbsp;{}; // 初期化コンストラクタ<br>
&nbsp;&nbsp;~Game()&nbsp;{}; // 破棄処理デストラクタ<br>
<br>
&nbsp;&nbsp;<em>//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
&nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る</em><br>
<br>
&nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
&nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
&nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
<br>
&nbsp;&nbsp;int x = 0;<br>
&nbsp;&nbsp;int vx = 0;<br>
<br>
&nbsp;&nbsp;<u>std::shared_ptr&lt;Player&gt;&nbsp;player{ std::make_shared&lt;Player&gt;(100, Screen::Height / 2, this) }; // 自機の初期化<br>
&nbsp;&nbsp;//↑プレイヤを回し読みポインタ型に。std::make_shared&lt;Player&gt;でメモリ上に実体を生成<br>
&nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト</u><br>
<br>
};<br>
<br>
#endif</p>

<p>次にGame.cppファイルのPlayerやPlayerBulletのアクセスをGamaManagerのgm経由に書き換えましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のように変更します：</p>
    <p class="source">#include "Game.h"<br>
<br>
<em>#include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;x = 100; // Xの初期位置<br>
&nbsp;&nbsp;vx = 10;<br>
<br>
&nbsp;&nbsp;<em>gm.player = std::make_shared&lt;Player&gt;((float)100, (float)Screen::Height / 2); // 自機の初期化</em><br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;x += vx; // X位置の更新<br>
<br>
&nbsp;&nbsp;<em>gm.</em>player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
&nbsp;&nbsp;//ポインタ↑になると.から->でのアクセスになる<br>
<br>
&nbsp;&nbsp;// 自機弾の更新処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : <em>gm.</em>playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;//【放置厳禁！！！このままここに弾削除処理書かないとメモリがどんどん減ってくよ(気づかないうちにね..怖)】<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;<em>gm.</em>player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
&nbsp;&nbsp;//ポインタ↑になると.から->でのアクセスになる<br>
<br>
&nbsp;&nbsp;// 自機弾の描画処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : <em>gm.</em>playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
&nbsp;&nbsp;}<br>
};<br>
</p>
<br>


<p><code>Player.h</code>もGameManagerのgm経由でのアクセスにするので#include "Game.h"やGame*のポインタはなくなります。</p>
    <p class="source">#ifndef PLAYER_H_<br>
#define PLAYER_H_<br>
<br>
#include "DxLib.h"<br>
#include "Input.h"<br>
#include "Image.h"<br>
#include "MyMath.h"<br>
<br>
<u>class Game;//←【エラー地獄に注意！】ここにGameクラスがあるものとして書くことで【循環相互インクルードどうぞどうぞ問題】を回避</u><br>
<br>
<em>#include&nbsp;"GameManager.h"</em><br>
<br>
class Player<br>
{<br>
public:<br>
&nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
<br>
&nbsp;&nbsp;float x; // x座標<br>
&nbsp;&nbsp;float y; // y座標<br>
<br>
&nbsp;&nbsp;<em>//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
&nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る</em><br>
<br>
&nbsp;&nbsp;<u>Game* game { nullptr }; // Gameのインスタンスの参照<br>
&nbsp;&nbsp;//↑ * ポインタ型です！プレイヤの【内部に】ゲームの情報を【メモリ実体として持つ】と<br>
&nbsp;&nbsp;//そのプレイヤを親のゲームがもつと【延々とループで終わりなきメモリ爆発ループ】になるから<br>
&nbsp;&nbsp;//メモリに対しての参照=【レコードの針をGameに指して】【Gameの住所アドレスだけをプレイヤ内部に持つ】</u><br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;// x : 初期位置x<br>
&nbsp;&nbsp;// y : 初期位置y<br>
&nbsp;&nbsp;Player(float x, float y<u>, Game* game</u>)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<u>this-&gt;game = game;</u><br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理の関数定義<br>
&nbsp;&nbsp;void Update();<br>  
<br>
&nbsp;&nbsp;// 描画処理の関数定義<br>
&nbsp;&nbsp;void Draw();<br>
<br>
};<br>
<br>
#endif</p>

<br>
<p><code>Player.cpp</code>もGameManagerのgm経由でのアクセスに書き換えます</p>
    <p class="source">
#include&nbsp;"Player.h"<br>
<br>
<u>#include "Game.h"</u><br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★弾を生成して【使う処理があるのでインクルード必要】<br>
<br>
// 更新処理【書き移す際にはPlayer::という形で::所属が必要になります】<br>
void Player::Update()<br>
{<br>
&nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
&nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
<br>
&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
&nbsp;&nbsp;if (vx != 0 &amp;&amp; vy != 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 実際に位置を動かす<br>
&nbsp;&nbsp;x += vx;<br>
&nbsp;&nbsp;y += vy;<br>
<br>
&nbsp;&nbsp;// ボタン押下で自機弾を発射<br>
&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;【C#版→】game-&gt;playerBullets.Add(new PlayerBullet(x, y));<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;C++ではAddがpush_backに↓&nbsp;newがmake_shared↓に<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>gm.</em>playerBullets.push_back(std::make_shared&lt;PlayerBullet&gt;(x, y));<br>  
&nbsp;&nbsp;}<br>
}<br>  
<br>
// 描画処理<br>
void Player::Draw()<br>
{<br>
&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::player, TRUE);<br>
}<br>
<br>
</p>


    <h2>【※メモリから弾を削除】自機弾PlayerBulletの削除処理</h2>
    <p>PlayerBulletクラスを改造しましょう。<br>
    </p>
    <p><code>PlayerBullet.h</code>の内容を次のように【改造】します：</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
#define PLAYERBULLET_H_<br>
<br>
#include "DxLib.h"<br>
#include "Image.h"<br>
<br>
// 自機弾クラス<br>
class PlayerBullet<br>
{<br>
public:<br>
&nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
&nbsp;&nbsp;<em>const int VisibleRadius = 16; // 見た目の半径</em><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
&nbsp;&nbsp;//【使用注意】int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ<br>
<br>
&nbsp;&nbsp;float x; // x座標<br>
&nbsp;&nbsp;float y; // y座標<br>
&nbsp;&nbsp;<em>bool isDead = false; // 死亡フラグ</em><br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;PlayerBullet(float x, float y)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;x += Speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>// 画面外に出たら、死亡フラグを立てる<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (x - VisibleRadius &gt; Screen::Width)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br></em>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::playerBullet,TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
<br>
#endif<br></p>

<br>

<p>次にGame.cppファイルに自機弾PlayerBulletの【削除処理】を追加しましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Game.h"<br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;x = 100; // Xの初期位置<br>
&nbsp;&nbsp;vx = 10;<br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;x += vx; // X位置の更新<br>
<br>
&nbsp;&nbsp;player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
<br>
&nbsp;&nbsp;// 自機弾の更新処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<em>//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
&nbsp;&nbsp;// 非常に複雑な式に見えるがこれでisDeadのものを削除<br>
&nbsp;&nbsp;// https://stackoverflow.com/questions/42723205/remove-if-from-a-stdvector-of-shared-pointers-with-a-member-function<br>
&nbsp;&nbsp;gm.playerBullets.erase(<br>
&nbsp;&nbsp;&nbsp;&nbsp;std::remove_if(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int usingCount = -1;//テスト用コード(以下のコメントアウト部分は省略可)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if (ptr-&gt;isDead) usingCount = ptr.use_count();//おかんのコレ捨てるよカウンタ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//弾を捨てるまでの残り↑カウント(1だとisDeadがtrueなら0になり削除へ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),<br>
&nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.end()<br>
&nbsp;&nbsp;);</em><br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
<br>
&nbsp;&nbsp;// 自機弾の描画処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
&nbsp;&nbsp;}<br>
};<br>
</p>
<br>
<p>さて、削除部分の処理が非常に複雑ですね。C#と比較してみましょう。<br>
【C#】<br>
playerBullets.RemoveAll(pb => pb.isDead);<br>
【C++】<br>
<p class="source">
gm.playerBullets.erase(<br>
&nbsp;&nbsp;std::remove_if(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int usingCount = -1;//テスト用コード(以下のコメントアウト部分は省略可)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if (ptr-&gt;isDead) usingCount = ptr.use_count();//おかんのコレ捨てるよカウンタ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//弾を捨てるまでの残り↑カウント(1だとisDeadがtrueなら0になり削除へ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}),<br>
&nbsp;&nbsp;gm.playerBullets.end()<br>
);<br>
</p>
<br>
テスト用のコードを消して読みやすくしてみましょう。<br>
【C++】<br>
<p class="source">
gm.playerBullets.<em>erase</em>(<br>
&nbsp;&nbsp;std::<em>remove_if</em>(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}),<br>
&nbsp;&nbsp;gm.playerBullets.end()<br>
);<br>
</p>
<br>
これでもまだ複雑ですが、なぜ複雑に見えるか？<br>
【実は二つの処理が同時に行われている】ためです。<br>
<br>
【1】erase処理&nbsp;:&nbsp;<a href="https://cpprefjp.github.io/reference/vector/vector/erase.html">指定した配列の要素を削除する処理です。</a><br>
基本構文はvを配列とすると<br>
&nbsp;&nbsp;v.erase(v.begin(), v.begin() + 2);//配列開始begin位置から2個ぶん削除<br>
&nbsp;&nbsp;v.erase(削除開始ポインタ位置, 終了ポインタ位置);<br>
で、プレイヤ弾の削除処理では<br>
<p class="source">
gm.playerBullets.erase(<br>
&nbsp;&nbsp;……<br>
&nbsp;&nbsp;&nbsp;&nbsp;……<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;……<br>
&nbsp;&nbsp;&nbsp;&nbsp;……,<br>
&nbsp;&nbsp;gm.playerBullets.end()<br>
);<br>
</p>
よく見ると実は<br>
gm.playerBullets.erase(複雑な何か&nbsp;&nbsp;,&nbsp;gm.playerBullets.end()&nbsp;);<br>
となっているだけで実は【複雑な何かから ～ end()終了位置】までの削除処理を行っているだけだとわかります。<br>
こういう風にカンマ,や(かっこ)で区切られた構造を読み解く力が身に付けば複雑なコードでも<br>
<br>
【分解ステップを踏んでゆけば読み解けるようになります】<br>
<br>
そして次の「複雑な何か↓」も分解して読み解いてみましょう。<br>
【2】remove_if処理&nbsp;:&nbsp;<a href="https://cpprefjp.github.io/reference/algorithm/remove_if.html">ある条件を①満たすものを【配列の後ろ】に、②満たさないものを【前に】集め①の始まりの位置を返す</a><br>
基本構文はvを配列とすると<br>
&nbsp;&nbsp;std::remove_if(v.begin(), v.end(), 条件);//配列v開始位置から終了位置まで「条件」に従い分離並べ替えし条件を満たす後ろに並べ替えられたものの分離された先頭位置を返す<br>
つまりremove_ifは配列の後ろに条件を満たすものを分離する処理の担当で削除すべきものの先頭の位置をeraseに渡す担当だとわかります。<br>
<br>
要するに【1】と【2】で協力して「削除」と「分離並べ替え」を【分担していただけ】だったわけです。<br>
<br>そしてその条件式が<br>
<p class="source">
[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {&nbsp;<em>return ptr-&gt;isDead;</em>&nbsp;}<br>
</p>
というスタイルでisDeadがtrueかfalseかreturnするという【ちょっとクセの強い条件式の書き方】で書かれていたということです。<br>
<br>
ここは【慣れてゆくしかないです】何度も見て【見慣れる】ことです。<br>
</p>


<p>ただ、この複雑な文が増えてくると【コードが見にくくなる】ので【テンプレート化】に挑戦してみましょう。</p> 


<p><code>GameManager.h</code>に共通の削除機能として【テンプレート機能】として追加してみましょう。</p>
<p class="source">
#ifndef GAMEMANAGER_H_<br>
#define GAMEMANAGER_H_<br>
<br>
#include &lt;memory&gt;<br>
#include &lt;vector&gt;<br>
<br>
#include&nbsp;"Singleton.h"<br>
<br>
class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
class&nbsp;PlayerBullet;<br>
<br>
class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
{<br>
public:<br>
&nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
<br>
&nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機の初期化<br>
<br>
&nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
&nbsp;&nbsp;// List↑と同じvector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
<br>
<br>
<br>
&nbsp;&nbsp;<em>//&nbsp;★削除処理を共通テンプレート関数にする<br>
&nbsp;&nbsp;//&nbsp;[共通テンプレート関数]https://programming-place.net/ppp/contents/cpp/language/009.html#function_template<br>
&nbsp;&nbsp;template&nbsp;&lt;typename&nbsp;T,&nbsp;class&nbsp;T_if&gt;<br>
&nbsp;&nbsp;void&nbsp;EraseRemoveIf(std::vector&lt;T&gt;&nbsp;v,&nbsp;T_if&nbsp;if_condition)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特定のタイプT↑&nbsp;&nbsp;↑配列v&nbsp;&nbsp;&nbsp;↑条件式if_condition<br>
&nbsp;&nbsp;&nbsp;&nbsp;v.erase(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::remove_if(v.begin(),&nbsp;v.end(),if_condition),//←条件で後ろに分離した後方部分の先頭位置<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.end()&nbsp;//&nbsp;&nbsp;↓remove_ifの位置<br>
&nbsp;&nbsp;&nbsp;&nbsp;);//例.[生][生][死][死][死]←&nbsp;v.end()の位置<br>
&nbsp;&nbsp;};</em><br>
<br>
protected:<br>
&nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
&nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
};<br>
<br>
#endif<br>
</p>
<br>
<br>
<p>そして<code>Game.cpp</code>の削除処理をシンプルに書き直します</p>
    <p class="source">#include "Game.h"<br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;x = 100; // Xの初期位置<br>
&nbsp;&nbsp;vx = 10;<br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;x += vx; // X位置の更新<br>
<br>
&nbsp;&nbsp;player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
<br>
&nbsp;&nbsp;// 自機弾の更新処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<u>// 自機弾のリストから死んでるものを除去する<br>
&nbsp;&nbsp;// 非常に複雑な式に見えるがこれでisDeadのものを削除<br>
&nbsp;&nbsp;// https://stackoverflow.com/questions/42723205/remove-if-from-a-stdvector-of-shared-pointers-with-a-member-function<br>
&nbsp;&nbsp;gm.playerBullets.erase(<br>
&nbsp;&nbsp;&nbsp;&nbsp;std::remove_if(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int usingCount = -1;//テスト用コード(以下のコメントアウト部分は省略可)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if (ptr-&gt;isDead) usingCount = ptr.use_count();//おかんのコレ捨てるよカウンタ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//弾を捨てるまでの残り↑カウント(1だとisDeadがtrueなら0になり削除へ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),<br>
&nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.end()<br>
&nbsp;&nbsp;);</u><br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
<br>
&nbsp;&nbsp;// 自機弾の描画処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
&nbsp;&nbsp;}<br>
};<br>
</p>
<h2>とりあえずC++バージョンに変更できたのはここまで</h2>



</body>
</html>
