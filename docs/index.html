<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>シューティングゲーム</title>
    <link rel="stylesheet" href="style.css">
    <style>
      
    </style>
  </head>
  <body>
    <p class="title">[C++移植]シューティングゲーム 1</p>
    <br>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId0001">シューティングのC++移植で目指すところ(意義)</a></li>
      <li><a href="#mozTocId0002">プロジェクトの作成</a></li>
      <li><a href="#mozTocId0003">画像ファイルの追加</a></li>
      <li><a href="#mozTocId0004">Imageクラスの作成</a></li>
      <li><a href="#mozTocId0005">前期C#スタイルに近づく一歩！Gameクラスの作成</a></li>
      <li><a href="#mozTocId0006">自機の作成</a><br>
	      <a href="#mozTocId00061">- Playerクラスの作成</a>
      </li>
      <li><a href="#mozTocId0007">自機弾の作成</a><br>
	<a href="#mozTocId00071">- 循環参照・インクルードの罠</a><br>
	<a href="#mozTocId00072">- シングルトン型:唯一物体タイプの追加</a><br>
	<a href="#mozTocId00073">- 仲介マネージャーGameManagerの追加</a><br>
	<a href="#mozTocId00074">- 【※メモリから弾を削除】自機弾PlayerBulletの削除処理</a><br>
	<a href="#mozTocId00075">- 共通削除機能を【テンプレートとして定義】</a><br>
	<a href="#mozTocId00076">- 【実験】メモリ浪費弾の実験</a>
      </li>
      <li><a href="#mozTocId0008">敵の作成</a><br>
	<a href="#mozTocId00081">- 共通のベースとなるGameObjectを作成する</a><br>
	<a href="#mozTocId00082">- Zako0クラスの作成</a><br>
      </li>
	    <br>
<p>テキスト2もこのファイル内にまとめた。</p>
      <a href="#mozTocId2000">[C++移植]シューティングゲーム 2</a><br>
	    <br>
    </ol>
    <h1><a id="mozTocId0001" class="mozTocH1"></a>シューティングのC++移植で目指すところ(意義)</h1>
    <p>前期でやったシューティングの制作をC++に移植することで以下を作業を通じて【体得しよう】。</p>
    <ul>
      <li>C++でのクラス定義をC#との違いを比較しながら習得</li>
      <li>C++ではないがDXライブラリの公式のサンプルはC++なのでそれを動かせるようになる</li>
      <li>C++でのリストやforeachの使い方の違いを習得</li>
      <li>C++での画像読み込みとそのメモリのお掃除(メモリ開放)</li>
    </ul>
    <p>別途[クラスの基本(C++11).pdf]の解説を参考にしながらC++のクラス定義に慣れてゆきましょう</p>
    <p>最終的には、C++で制作したゲームの提出をしてもらいます（その出来で後期の成績が決まります）。<br>
      頑張ってください！</p>
    <p></p>
    <h1><a id="mozTocId0002" class="mozTocH1"></a>プロジェクトの作成</h1>
    <h2>まずはDXライブラリ公式のC++のライブラリをダウンロード</h2>
    以下のDXライブラリの公式サイトからC++のDXライブラリをダウンロードしてください。<br>
    <a href="https://dxlib.xsrv.jp/dxdload.html">https://dxlib.xsrv.jp/dxdload.html</a>
	<br>ダウンロードできたらzipファイルを【C:ドライブ直下に展開】してください<br>
	<p> <img src="image/img_dxdownload.png" alt=""></p><br><br>
    
    <h2>ダウンロードできたらzipファイルを【C:ドライブ直下に展開】</h2>
    <p> <img src="image/img_dxlibextract_c_drive.png" alt=""></p><br><br>
    
    
    <h2>プロジェクト作成</h2>
    Visual Studio 2019を起動してください。<br>
    <br>
    起動したら、<code>新しいプロジェクトの作成</code>をクリック<br>
    <br>
    <code>C++ 空のプロジェクト</code>を選択して次へ
    <p> <img src="image/making_cpp_prj.png" alt="" style="width: 1156px; height: 853px;"></p>
    <p>今回のプロジェクト名は【1】「自分の作るゲーム名」か【2】毎回C++のプロジェクトを作るのが面倒な人は今回作るプロジェクトをフォルダごと量産するとして「DXLibGameBase」(ゲームの基礎ベース、コピペで量産用プロジェクト)にしましょう。</p></p>
    <p>プロジェクトが作成されたら、まず【main.cpp】作りましょう。</p> <br>
    <p>少なくとも一つ【～.cpp】作らないと出てこない次にやる設定↓で【出てこない項目】があります(【C/C++全般】が出てこない！)</p> <br>
    
    <h2>次にプロジェクトのややこしい設定をしっかりやる</h2>
	プロジェクトの【設定を開く前に】最低限一つだけでもcppファイルがプロジェクトにないと【出てこない設定項目がある】ので新しい項目を追加でC++ソースファイル(.cpp)のファイルを一つ作成しておく。<br>
    <br>
    <p> <img src="image/need_one_cpp.png" alt="" style="width: 1152px; height: 713px;"></p>
    <br>
    一つだけcppファイルを作成した後、プロジェクトを右クリックして<code>プロパティ</code>をクリック<br>
    <br>
    <p> <img src="image/open_setting.png" alt="" style="width: 1128px; height: 642px;"></p>
    <br>    
    
    <h2>【設定】マルチバイト文字セットを使用</h2>
    <br>
    設定画面の【構成プロパティ】→【詳細】の【文字セット】を<code>マルチバイト文字セットを使用</code>に変更<br>
    <p> <img src="image/setting_multibyte_moji.png" alt="" style="width: 982px; height: 682px;"></p>
    <br>


    <h2>【設定】C/C++→全般→追加のインクルードディレクトリにDXライブラリのフォルダ位置(PATH)を追加</h2>
    <br>
    設定画面の【C/C++全般】→【全般】の【追加のインクルードディレクトリ】に<code>DXライブラリのフォルダ位置(PATH)</code>を設定<br>
    <p> <img src="image/setting_cpp_add_include_dir.png" alt="" style="width: 1047px; height: 682px;"></p>
    <br>
    フォルダのパス(位置)文字列は以下のgifアニメのようにコピーして貼り付け<br>
    <p> <img src="image/setting_howto_copy_dir.gif" alt="" style="width: 892px; height: 554px;"></p>
    <br>

    <h2>【設定】リンカ→全般→追加のライブラリディレクトリにDXライブラリのフォルダ位置(PATH)を追加</h2>
    <br>
    設定画面の【リンカー】→【全般】の【追加のライブラリディレクトリ】に<code>DXライブラリのフォルダ位置(PATH)</code>を設定<br>
    <p> <img src="image/setting_linker_add_lib_dir.png" alt="" style="width: 1046px; height: 682px;"></p>
    <br>
    フォルダのパス(位置)文字列は以下のgifアニメのようにコピーしたものを貼り付け<br>
    <p> <img src="image/setting_howto_paste_dir.gif" alt="" style="width: 1075px; height: 805px;"></p>
    <br>

<br>

    
    <h2>【設定】リンカ→システム→サブシステムをウィンドウに(コンソールのままだと黒画面の文字ベースシステムになる)</h2>
    
    <br>
    設定画面の【リンカー】→【システム】の【サブシステム】を<code>Windows(SUBSYSTEM:WINDOWS)</code>に設定<br>
    この設定をするとプログラムの開始位置(エントリポイントという)がWinMainというところから始まるようになる。(Consoleの場合はMain)<br>
    <p> <img src="image/setting_entry_point.png" alt="" style="width: 985px; height: 682px;"></p>
    <br>
    
    <br>
    以上で設定項目は終わり。OKをおして設定を反映しよう<br>

    <br>
<br>
	<h2>設定を反映させたらサンプルプログラムをmain.cppにコピペして動作を確認</h2>
    <p>以下の【ウィンドウを出すだけの最小限サンプル】を動かして設定を確認しましょう</p>
    <p><code>main.cpp【ウィンドウを出すだけの最小限サンプル】</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
<br>
// 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;// 画面モードの設定<br>
&nbsp;&nbsp;SetGraphMode( 960 , 540 , 32 ) ; // 画面サイズ960×540のカラービット数32ビットで起動<br>
&nbsp;&nbsp;SetWindowSize(960, 540);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
&nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
<br>
&nbsp;&nbsp;// ＤＸライブラリの初期化<br>
&nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// エラーが発生したら直ちに終了<br>
&nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
&nbsp;&nbsp;}<br>

&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// この位置にウィンドウの中に画像を描く処理などを書く<br>
&nbsp;&nbsp;// DXライブラリ公式の色々なサンプルを試してみよう！<br>
&nbsp;&nbsp;// https://dxlib.xsrv.jp/dxfunc.html<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>


&nbsp;&nbsp;// キー入力待ちをする<br>
&nbsp;&nbsp;WaitKey();<br>

&nbsp;&nbsp;// ＤＸライブラリの後始末<br>
&nbsp;&nbsp;DxLib_End();<br>

&nbsp;&nbsp;// ソフトの終了<br>
&nbsp;&nbsp;return 0;<br>
}</p>


    
    <h2>解像度の定義</h2>
    <p>【C++で】画面解像度を定義するクラスを作ってみましょう。ソリューションエクスプローラーのプロジェクトを右クリックし、追加＞ヘッダファイル(.h)<br>
      Screen.hという名前でヘッダファイルを生成し、そのファイルにクラスを記述します。</p>
    <p><code>Screen.h</code>を編集します：</p>
    <p class="source">#ifndef _SCREEN_H<br>
#define _SCREEN_H<br>
// ＃ifndefは「_SCREEN_H」がifもしもn(not) def(定義)されていないなら＃endifに挟まれたコードまでを有効化する(だから2度目以降は無効になる)<br>
// 二重定義を防止するために＃から始まる【プリプロセッサ】を使っている<br>
//　【プリプロセッサ】はビルドする段階でコード自体に【前処理】として影響を与える<br>
// たとえば<br>
// ・ファイルの読み込み (including) →＃includeがこれ<br>
// ・マクロの展開（シンボルを、あらかじめ定義された規則に従って置換する）<br>
// ・コンパイル条件によるソースコードの部分的選択→【＃ifndef　～ ＃endifに囲まれた部分】は一度(＃defineで)定義されると無効化<br>
// ・コメントの削除 【&nbsp;//&nbsp;】のコメントの削除も【プリプロセス＝前段階で行われる】<br>
<br>
// 画面解像度<br>
class Screen<br>
{<br>
public: //publicはC＃と違いpublic:以下にまとめて書かれるスタイル<br>
&nbsp;&nbsp;static const int Width = 960; // 幅<br>
&nbsp;&nbsp;static const int Height = 540; // 高さ C＃と違いstaticクラスではなく個々の【すべての変数にstaticをつけて】staticなクラスとする<br>
};// C＃と違ってクラスの定義も;セミコロンで終わる<br>

#endif</p>
<br>
<br>
<br>
    <p><code>main.cpp</code>を編集してScreen.hを読み込ませます：</p>
    <p class="source">#include "DxLib.h"<br>
    <em>#include "Screen.h"</em><br>
// ↑＃includeで別ファイルのヘッダファイル.hをこのコード内に読み込む<br>
<br>
// 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;// 画面モードの設定<br>
&nbsp;&nbsp;SetGraphMode( <em>Screen::Width, Screen::Height,</em> 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;SetWindowSize(<em>Screen::Width, Screen::Height</em>);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
<br>
&nbsp;&nbsp;// ＤＸライブラリの初期化<br>
&nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// エラーが発生したら直ちに終了<br>
&nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
&nbsp;&nbsp;}<br>
<br>

<br>
&nbsp;&nbsp;// (中略).....................................<br>
<br>
&nbsp;&nbsp;// ソフトの終了<br>
&nbsp;&nbsp;return 0;<br>
}</p>



    <h1><a id="mozTocId0003" class="mozTocH1"></a>画像ファイルの追加</h1>
    <p>次は画像ファイルをプロジェクトに追加します。【C#と違い】フォルダは【ウィンドウズ上のエクスプローラで作成】します。<br>
    <br>
    <br>
    <img src="image/open_folder_with_explorer.png" alt="" style="width: 1397px; height: 475px;"><br>
    <br>
    <img src="image/new_image_folder.png" alt="" style="width: 362px; height: 180px;"><br>
	<br>
	<br>
      「素材」フォルダー内の「画像」フォルダーにあるおなじみのボス画像を、【C#と違い】下のアニメようにウィンドウズでImageフォルダーにコピーして貼り付けしてください。</p>
    <img src="image/image_copy_paste.gif" alt=""><br>
    <br>
    <img src="image/image_add_project.gif" alt=""><br>

    <p><br>
    </p>
    
    <h2>試しに表示してみる</h2>
    <p><code>main.cpp</code>にプログラムを追加し、画像が正しく表示できるかテストします。</p>
    <p class="source">#include "DxLib.h"<br>
    <em>#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用</em><br>
    #include "Screen.h"<br>
// ＃includeで別ファイルのヘッダファイル.hをこのコード内に読み込む<br>
<br>
// 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;// 画面モードの設定<br>
&nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
<br>
&nbsp;&nbsp;// ＤＸライブラリの初期化<br>
&nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// エラーが発生したら直ちに終了<br>
&nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
&nbsp;&nbsp;}<br>
<br>
	    
<br>
<em>
&nbsp;&nbsp;//表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;// これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;// これまでInitでやってきてた初期化処理<br>
&nbsp;&nbsp;int bossImage = -1;<br>
&nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
&nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
&nbsp;&nbsp;int x = 100; // Xの初期位置<br>
&nbsp;&nbsp;int vx = 10;<br>
<br>
&nbsp;&nbsp;ScreenFlip();<br>
<br>
&nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;while (ProcessMessage() == 0) <br>
&nbsp;&nbsp;{// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
<br>   
&nbsp;&nbsp;&nbsp;&nbsp;// これまではUpdateでやってきてた更新処理<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;x += vx; // X位置の更新<br>
<br>   
&nbsp;&nbsp;&nbsp;&nbsp;// これまではDrawでやってきてた描画処理<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;}<br></em>
<br>

&nbsp;&nbsp;// キー入力待ちをする<br>
&nbsp;&nbsp;WaitKey();<br>

&nbsp;&nbsp;// ＤＸライブラリの後始末<br>
&nbsp;&nbsp;DxLib_End();<br>

&nbsp;&nbsp;// ソフトの終了<br>
&nbsp;&nbsp;return 0;<br>
}</p>
    <p><br>
    </p>

    
    
    <h1><a id="mozTocId0004" class="mozTocH1"></a>Imageクラスの作成</h1>
    <h2>Imageクラスの作成</h2>
    <p>Imageクラスを作成しましょう。Imageクラスの役割は次の2つです。</p>
    <ul>
      <li>画像の読み込み</li>
      <li>読み込んだ画像ハンドルの保持</li>
    </ul>
    <p><br>
    </p>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「Image」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Image.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef IMAGE_H_<br>
#define IMAGE_H_<br>
<br>
#include "DxLib.h"<br>
#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
<br>
class Image<br>
{<br>
public:<br>
&nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;static void Load();<br>
<br>
&nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
<br>
private:<br>
<br>
};<br>
#endif<br>
</p>
	  
	  
<br>
<p>次に対となるcppファイルを作成します。<br>
ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞cppファイル<br>
      「Image.cpp」という名前でcppファイルを作り、クラスを実装します。<br>
      <br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
<br>
int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
<br>
void Image::Load()<br>
{<br>
&nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
&nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
}</p>

	  <br>
	  <br>
	  
<h2>試しに【Image.hを使って】表示してみる</h2>
    <p><code>main.cpp</code>のプログラムを変更し、画像が正しく表示できるかテストします。</p>
    <p class="source">#include "DxLib.h"<br>
    #include "Screen.h"<br>
    <em>#include "Image.h"&nbsp;// 画像読み込みクラス</em><br>
<br>
<br>
// 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;// 画面モードの設定<br>
&nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
<br>
&nbsp;&nbsp;// ＤＸライブラリの初期化<br>
&nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// エラーが発生したら直ちに終了<br>
&nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;//表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;// これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;// これまでInitでやってきてた初期化処理<br>
&nbsp;&nbsp;<em>Image::Load();</em><br>
&nbsp;&nbsp;int x = 100; // Xの初期位置<br>
&nbsp;&nbsp;int vx = 10;<br>
<br>
&nbsp;&nbsp;ScreenFlip();<br>
<br>
&nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;while (ProcessMessage() == 0) <br>
&nbsp;&nbsp;{// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
<br>   
&nbsp;&nbsp;&nbsp;&nbsp;// これまではUpdateでやってきてた更新処理<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;x += vx; // X位置の更新<br>
<br>   
&nbsp;&nbsp;&nbsp;&nbsp;// これまではDrawでやってきてた描画処理<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, <em>Image::bossImage</em>, TRUE);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;}<br>
<br>

&nbsp;&nbsp;// キー入力待ちをする<br>
&nbsp;&nbsp;WaitKey();<br>

&nbsp;&nbsp;// ＤＸライブラリの後始末<br>
&nbsp;&nbsp;DxLib_End();<br>

&nbsp;&nbsp;// ソフトの終了<br>
&nbsp;&nbsp;return 0;<br>
}</p>
    <p><br>
    </p>

	  <h1><a id="mozTocId0005" class="mozTocH1"></a>前期C#スタイルに近づく一歩！Gameクラスの作成</h1>
    <h2>Gameクラスの作成</h2>
    <p>Gameクラスを作成しましょう。Gameクラスの重要な役割は次の3つ。<br>
    これがあれば前期のようにGameクラスに処理を書いて開発できる！</p>
    <ul>
      <li>初期処理Init()</li>
      <li>更新処理Update()</li>
      <li>描画処理Draw()</li>
    </ul>
    <p><br>
    </p>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「Game」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Game.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef GAME_H_<br>
#define GAME_H_<br>
<br>
#include "Image.h"<br>
#include "Screen.h"<br>
<br>
class Game<br>
{<br>
public :<br>
&nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↓{ 
	}を.hに書くことでcppに分けて書くはずの処理ぶぶんを.hに書いてもよい */<br>
&nbsp;&nbsp;Game() {&nbsp; }; // 初期化コンストラクタ<br>
&nbsp;&nbsp;~Game() {&nbsp; }; // 破棄処理デストラクタ<br>
&nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
&nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
&nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
<br>
&nbsp;&nbsp;int x = 0; //staticじゃないintはここで=0で初期化できる<br>
&nbsp;&nbsp;int vx = 0;<br>
<br>
};<br>

#endif<br></p>
<br>
<p>次に対となるcppファイルを作成します。<br>
ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞cppファイル<br>
      「Game」という名前でcppファイルを作り、クラスの処理を実装します。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Game.h"<br>
<br>
void Game::Init()<br>
{// Init処理<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;x = 100; // Xの初期位置<br>
&nbsp;&nbsp;vx = 10; // ボスの初期速度<br>
}<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -10; //画面端で移動方向反転<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;x += vx; // ボス画像のX位置の更新<br>
	<br>
}<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
}</p>


<h2>では前期に近い【Gameクラスを使って】表示してみる</h2>
    <p><code>main.cpp</code>のプログラムを変更し、画像が正しくGameクラスで表示できるかテストします。</p>
    <p class="source">#include "DxLib.h"<br>
    #include "Screen.h"<br>
    #include "Image.h"&nbsp;// 画像読み込みクラス<br>
    <em>#include "Game.h"&nbsp;</em><br>
<br>
<br>
// 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;// 画面モードの設定<br>
&nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
<br>
&nbsp;&nbsp;// ＤＸライブラリの初期化<br>
&nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// エラーが発生したら直ちに終了<br>
&nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;//表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;// これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;// Init初期化処理<br>
&nbsp;&nbsp;<em>Game game; //Gameの定義と同時にC++ではコンストラクタで初期化される<br>
&nbsp;&nbsp;game.Init(); // gameのInit準備</em><br>
<br>
&nbsp;&nbsp;ScreenFlip();<br>
<br>
&nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;while (ProcessMessage() == 0) <br>
&nbsp;&nbsp;{// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
<br>   
&nbsp;&nbsp;&nbsp;&nbsp;// Update更新処理<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>game.Update(); // gameの更新処理</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;// Draw描画処理<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>game.Draw();</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;}<br>
<br>

&nbsp;&nbsp;// キー入力待ちをする<br>
&nbsp;&nbsp;WaitKey();<br>

&nbsp;&nbsp;// ＤＸライブラリの後始末<br>
&nbsp;&nbsp;DxLib_End();<br>

&nbsp;&nbsp;// ソフトの終了<br>
&nbsp;&nbsp;return 0;<br>
}</p>
    <p><br>
    </p>

	      <h1><a id="mozTocId0006" class="mozTocH1">自機の作成</a></h1>
    <h2>プレイヤを操作するには便利クラスInputクラスの移植が必須！</h2>
    <p>Inputクラスを作成しましょう。InputクラスをC#から移植するときの落とし穴に注意。</p>
    <ul>
      <li>static int のstaticタイプの変数は.hだけではシンボリックエラーになるのでこのためだけに最低限.cppファイルを作成する必要がある</li>
    </ul>
	<p>
    </p>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「Input.h」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Input.h</code>にC#のInput.csをコピーし、以下のC++移植の修正をします：</p>
    <p class="source"><em>#ifndef INPUT_H_<br>
#define INPUT_H_<br>
<br>
#include "DxLib.h"</em><br>
<br>
<br>
// 入力クラス<br>
class Input<br>
{<br>
<em>public:</em><br>
&nbsp;<em>&nbsp;</em>static int prevState; // 1フレーム前の状態<br>
&nbsp;<em>&nbsp;</em>static int currentState; // 現在の状態<br>
<br>
&nbsp;&nbsp;// 初期化。最初に1回だけ呼んでください。<br>
&nbsp;<em>&nbsp;</em>static void Init()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;prevState = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;currentState = 0;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 最新の入力状況に更新する処理。<br>
&nbsp;&nbsp;// 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
&nbsp;<em>&nbsp;</em>static void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;prevState = currentState;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;currentState = <em>&nbsp;</em>GetJoypadInputState(<em>&nbsp;</em>DX_INPUT_KEY_PAD1);<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// ボタンが押されているか？<br>
&nbsp;<em>&nbsp;</em>static bool GetButton(int buttonId)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 今ボタンが押されているかどうかを返却<br>
&nbsp;&nbsp;&nbsp;&nbsp;return (currentState &amp; buttonId) != 0;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// ボタンが押された瞬間か？<br>
&nbsp;<em>&nbsp;</em>static bool GetButtonDown(int buttonId)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 今は押されていて、かつ1フレーム前は押されていない場合はtrueを返却<br>
&nbsp;&nbsp;&nbsp;&nbsp;return ((currentState &amp; buttonId) &amp; ~(prevState 
	&amp; buttonId)) != 0;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// ボタンが離された瞬間か？<br>
&nbsp;<em>&nbsp;</em>static bool GetButtonUp(int buttonId)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 1フレーム前は押されていて、かつ今は押されている場合はtrueを返却<br>
&nbsp;&nbsp;&nbsp;&nbsp;return ((prevState &amp; buttonId) &amp; ~(currentState 
	&amp; buttonId)) != 0;<br>
&nbsp;&nbsp;}<br>
}<em>;&nbsp;//←【注意】クラス定義の終わりにはコロンが必要だよ！</em><br>
<br>
#endif<em>&nbsp;&nbsp;//ここでエラー出た人は↑【注意】の;コロン忘れ</em><br></p>
<br>
<p>次に対となるcppファイルを作成します。<br>
ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞cppファイル<br>
      「Input.cpp」という名前でcppファイルを作ります(たった2行の初期化static int変数の初期化のために必須)。<br>
      <br>
      <code>Input.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Input.h"<br>
<br>
int <em>Input::</em>prevState <em>{ 0 }</em>; // 1フレーム前の状態<br>
int <em>Input::</em>currentState <em>{ 0 }</em>; // 現在の状態<br>
<em>// ↑static intのときはこの行書かないとシンボリックエラーになる件(このためだけにcpp書かなきゃならん)</em><br>
<br>
</p>

    <p>Playerクラスを作成する前に、忘れずにプレイヤ画像はImageフォルダにコピー貼り付けしましょう。<br>
    Imageフォルダにコピーしたらプロジェクトで</p>
    <p>次は画像ファイルをプロジェクトに追加します。【C#と違いドラッグアンドドロップせず】画像は【プロジェクトを右クリックで「追加」→「既存の項目」で画像を追加】します。<br>
    <img src="image/player_image_add.gif" alt=""><br>

<br>
<code>Image.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef IMAGE_H_<br>
#define IMAGE_H_<br>
<br>
#include "DxLib.h"<br>
#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
<br>
class Image<br>
{<br>
public:<br>
&nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;static void Load();<br>
<br>
&nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
&nbsp;&nbsp;<em>static int player; //プレイヤ画像のハンドラ</em><br>
<br>
private:<br>
<br>
};<br>
#endif<br>
</p>
<br>
<p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
<br>
int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
<em>int Image::player{-1};</em><br>
<br>
void Image::Load()<br>
{<br>
&nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
&nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;<em>player= LoadGraph("Image/player.png");<br>
&nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
}</p>
<br>
<br>


    <h2><a id="mozTocId00061" class="mozTocH1"></a>Playerクラスの作成</h2>
    <p>Playerクラスを作成しましょう。<br>
    Playerクラスをつくるだけで安心すると【落とし穴】があります。Game.cppでInput.Update();を忘れるとプレイヤが動きません。</p>
    <p>Update()やDraw()やInput.Update()を忘れないように注意して進めましょう。<br>
    </p>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「Player.h」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>Player.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef PLAYER_H_<br>
#define PLAYER_H_<br>
<br>
#include "DxLib.h"<br>
#include "Input.h"<br>
#include "Image.h"<br>
<br>
class Player<br>
{<br>
public:<br>
&nbsp;<em>&nbsp;</em>const float MoveSpeed = <em>6;</em> // 移動速度<br>
<br>
&nbsp;<em>&nbsp;</em>float x; // x座標<br>
&nbsp;<em>&nbsp;</em>float y; // y座標<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;// x : 初期位置x<br>
&nbsp;&nbsp;// y : 初期位置y<br>
&nbsp;<em>&nbsp;</em>Player(float x, float y)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;x = x</em>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;y = y</em>;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;<em>&nbsp;</em>void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
&nbsp;&nbsp;&nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(<em>&nbsp;</em>PAD_INPUT_LEFT))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;else if (Input<em>::</em>GetButton(<em>&nbsp;</em>PAD_INPUT_RIGHT))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (Input<em>::</em>GetButton(<em>&nbsp;</em>PAD_INPUT_UP))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;else if (Input<em>::</em>GetButton(<em>&nbsp;</em>PAD_INPUT_DOWN))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 実際に位置を動かす<br>
&nbsp;&nbsp;&nbsp;&nbsp;x += vx;<br>
&nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;<em>&nbsp;</em>void Draw()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;<em>&nbsp;</em>DrawRotaGraphF(x, y, 1, 0, <em>Image::</em>player<em>, TRUE</em>);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
#endif<br></p>
<br>

<p><code>Game.h</code>にPlayerを追加します：</p>
    <p class="source">#ifndef GAME_H_<br>
#define GAME_H_<br>
<br>
#include "Image.h"<br>
#include "Screen.h"<br>
<em>#include "Player.h"</em><br>
<br>
class Game<br>
{<br>
public :<br>
&nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↓{ 
	}を.hに書くことでcppに分けて書くはずの処理ぶぶんを.hに書いてもよい */<br>
&nbsp;&nbsp;Game() {&nbsp; }; // 初期化コンストラクタ<br>
&nbsp;&nbsp;~Game() {&nbsp; }; // 破棄処理デストラクタ<br>
&nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
&nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
&nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
<br>
&nbsp;&nbsp;int x = 0; //staticじゃないintはここで=0で初期化できる<br>
&nbsp;&nbsp;int vx = 0;<br>
<br>
&nbsp;&nbsp;<em>Player player{ 100, Screen::Height / 2 }; // 自機の初期化</em><br>
};<br>
#endif</p>

<p>次にGame.cppファイルにUpdateとDraw処理を追加してプレイヤの動作を確認しましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Game.h"<br>
<br>
void Game::Init()<br>
{// Init処理<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;x = 100; // Xの初期位置<br>
&nbsp;&nbsp;vx = 10; // ボスの初期速度<br>
}<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;<em>Input::Update();&nbsp;//【注意】これ忘れるとキー入力押してもキャラ動かない</em><br>
<br>
&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (x &gt; Screen::Width)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -10; //画面端で移動方向反転<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;x += vx; // ボス画像のX位置の更新<br>
	<br>
&nbsp;&nbsp;<em>player.Update(); // プレイヤの更新【忘れるとプレイヤが動かない】</em><br>
}<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;<em>player.Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】</em><br>
}</p>

<p>さて、無事にプレイヤをキー入力(↑↓←→)で動かせるようになりましたか？？？。</p><br>	  

    <ul>
      <li>【プレイヤ画像が出ない】→Game.cppで【player.Draw();しましたか？】</li>
      <li>【プレイヤ画像が動かない1】→Game.cppで【player.Update();しましたか？】</li>
      <li>【プレイヤ画像が動かない2】→Game.cppで【Input.Update();しましたか？】</li>
    </ul><br>
	  
<h2>√2の定義</h2>
    <p>【C++でも】斜め方向の移動速度を√2で割って補正するために、自分用数学定義クラスを作ってみましょう。ソリューションエクスプローラーのプロジェクトを右クリックし、追加＞ヘッダファイル(.h)<br>
      MyMath.hという名前でヘッダファイルを生成し、そのファイルにクラスを記述します。</p>
    <p><code>MyMath.h</code>を編集します：</p>
    <p class="source">#ifndef _MYMATH_H<br>
	#define _MYMATH_H<br>
	// 数学関連クラス<br>class MyMath<br>{<br>
	public: <br>
&nbsp; // C ++標準では、静的static定数の【整数型】または【列挙型】のみをクラス内で初期化できます。<br>&nbsp; // 
	これが、一部の初期化が許可されているのに他のstatic floatなどが初期化できない理由です。<br><br>&nbsp; // 【OH,ノー】 
	float小数を定義するためだけにcppファイルを作成しないと<br>&nbsp; //static const float Sqrt2 
	=【このイコールでエラー】 1.41421356237f; <br><br>&nbsp; // ルート2(変数名の定義だけ)<br>static 
	const float Sqrt2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	// = 1.41421356237f;<br><br>}; // 【注意】セミコロン抜けで【宣言が必要ですエラー】<br><br>#endif // 
	【宣言が必要ですエラーは上のセミコロン抜け】</p>
<br>
<br>
<br>
    <p><code>MyMath.cpp</code>を編集して変数名に1.41421356237f を 割り当てMath。</p>
    <p class="source">#include "MyMath.h"<br>
	<br>
	const float MyMath::Sqrt2 = 
	1.41421356237f;//(floatは有効桁は実質7桁まで正確だがそれ以降は環境によって誤差出る)<br>
<br>
	// 【ルールとして.hでfloatなどstatic小数などの初期化許さなかった理由】<br>// 一言でいうと 「作った人がそういうルールにした」<br>
	// 以下を一言でまとめると「.hヘッダはマシン環境によって変わるようなことは記述しないようにしたかった」<br>// 
	PCやマシン語翻訳コンパイラによって小数の精度などや数値に誤差が出るから<br>// 
	環境によって変動する可能性のあるfloatなど(int整数は誤差がない)<br>// をstatic 
	const静的定数として.hヘッダで初期化することを許可しなかった(定数といえない) 「マシン依存」<br>// 
	cppで大丈夫なのはcppは実際の処理ベースで動くので【動的な動いてもよい数字となるから】(どの環境でも同じとは限らない)<br>// 
	【勉強】以下サイトにC++のBjarneさんの説明を翻訳したものがある<br>// 
	https://qastack.jp/programming/9656941/why-cant-i-initialize-non-const-static-member-or-static-array-in-class</p>



    <p><br>
      <br>
      定義だけじゃなく、実際にプレイヤを動かしているPlayer.hも編集しなきゃ意味がないよ！お忘れなく！！<br>
      <code>Player.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef PLAYER_H_<br>
#define PLAYER_H_<br>
<br>
#include "DxLib.h"<br>
#include "Input.h"<br>
#include "Image.h"<br>
<em>#include "MyMath.h"</em><br>
<br>
class Player<br>
{<br>
public:<br>
&nbsp;const float MoveSpeed = 6; // 移動速度<br>
<br>
&nbsp;float x; // x座標<br>
&nbsp;float y; // y座標<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;// x : 初期位置x<br>
&nbsp;&nbsp;// y : 初期位置y<br>
&nbsp;Player(float x, float y)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
&nbsp;&nbsp;&nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
&nbsp;&nbsp;&nbsp;&nbsp;}</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>// 斜め移動も同じ速度になるように調整<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (vx != 0 &amp;&amp; vy != 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;// 実際に位置を動かす<br>
&nbsp;&nbsp;&nbsp;&nbsp;x += vx;<br>
&nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
&nbsp;&nbsp;}<br>

<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;void Draw()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::player, TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
#endif<br></p>
<br>
<br>
<br>	  
        <h1><a id="mozTocId0007" class="mozTocH1"></a>自機弾PlayerBulletクラスの作成</h1>
    <h2>PlayerBulletクラスを作成しましょう。
    </h2><br>
    <p>ソリューションエクスプローラーからプロジェクトを右クリックし、追加＞ヘッダファイル<br>
      「PlayerBullet.h」という名前でヘッダファイルを作り、クラスを定義します。<br>
      <br>
      <code>PlayerBullet.h</code>の内容を次のようにします：</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
#define PLAYERBULLET_H_<br>
<br>
#include "DxLib.h"<br>
#include "Image.h"<br>
<br>
// 自機弾クラス<br>
class PlayerBullet<br>
{<br>
public:<br>
&nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
<br>
&nbsp;&nbsp;float x; // x座標<br>
&nbsp;&nbsp;float y; // y座標<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;PlayerBullet(float x, float y)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;x += Speed;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::playerBullet,TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
<br>
#endif<br></p>

<br>
<code>Image.h</code>に自機弾PlayerBullet画像定義を追加します：</p>
    <p class="source">#ifndef IMAGE_H_<br>
#define IMAGE_H_<br>
<br>
#include "DxLib.h"<br>
#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
<br>
class Image<br>
{<br>
public:<br>
&nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;static void Load();<br>
<br>
&nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
&nbsp;&nbsp;static int player; //プレイヤ画像のハンドラ<br>
&nbsp;&nbsp;<em>static int playerBullet; //プレイヤの弾画像のハンドラ</em><br>
<br>
private:<br>
<br>
};<br>
#endif<br>
</p>
<br>
<p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
<br>
int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
int Image::player{-1};<br>
<em>int Image::playerBullet{-1};</em><br>
<br>
void Image::Load()<br>
{<br>
&nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
&nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;player= LoadGraph("Image/player.png");<br>
&nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;<em>playerBullet = LoadGraph("Image/player_bullet.png");<br>
&nbsp;&nbsp;assert(playerBullet!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
}</p>
<br>
<br>

<br>

<p><code>Game.h</code>にPlayerBulletを追加します：</p>
    <p class="source">#ifndef GAME_H_<br>
#define GAME_H_<br>
<br>
<em>#include&nbsp;&lt;vector&gt;//C#のListリストの代わりのC++版<br>
#include&nbsp;&lt;memory&gt;//スマートなポインタを使うのに必要(shared_ptrなど)</em><br>
<br>
#include&nbsp;"Image.h"<br>
#include&nbsp;"Screen.h"<br>
<br>
<em>#include&nbsp;"Player.h"<br>
<br>
class&nbsp;Player;&nbsp;//←【エラー地獄に注意！】ここにPlayerクラスがあるものとして書くことで【循環相互インクルードどうぞどうぞ問題】を回避<br>
class&nbsp;PlayerBullet;</em><br>
<br>
class&nbsp;Game<br>
{<br>
public&nbsp;:<br>
&nbsp;&nbsp;Game()&nbsp;{}; // 初期化コンストラクタ<br>
&nbsp;&nbsp;~Game()&nbsp;{}; // 破棄処理デストラクタ<br>
&nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
&nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
&nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
<br>
&nbsp;&nbsp;int x = 0;<br>
&nbsp;&nbsp;int vx = 0;<br>
<br>
&nbsp;&nbsp;<em>std::shared_ptr&lt;Player&gt;&nbsp;player{ std::make_shared&lt;Player&gt;(100, Screen::Height / 2, this) }; // 自機の初期化</em><br>
&nbsp;&nbsp;<em>//↑プレイヤを回し読みポインタ型に。std::make_shared&lt;Player&gt;でメモリ上に実体を生成<br>
&nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト</em><br>
&nbsp;&nbsp;//&nbsp;List↑と同じvector&nbsp;↑【shared_ptr】<br>
<br>
&nbsp;&nbsp;//&nbsp;★【shared_ptr】とは【データの回し読み(読まれなくなったら廃棄)】<br>
&nbsp;&nbsp;//&nbsp;「兄弟で週刊少年ジャンプを【回し読みする】が<br>
&nbsp;&nbsp;//&nbsp;おかんに【全員読み終わるまでは捨てられないように】する<br>
&nbsp;&nbsp;//&nbsp;【読むつもりの人カウンタ】がゼロになると【おかんに捨てられる(リンク切れ廃棄)】」<br>
<br>
};<br>
<br>
#endif</p>

<p>次にGame.cppファイルにUpdateとDrawに自機弾更新と描画の処理を追加しましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include&nbsp;"Game.h"<br>
<br>
<em>#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;x = 100; // Xの初期位置<br>
&nbsp;&nbsp;vx = 10;<br>
};<br>
<br>
void&nbsp;Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;x += vx; // X位置の更新<br>
<br>
&nbsp;&nbsp;player<em>-&gt;</em>Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
&nbsp;&nbsp;<em>//ポインタ↑になると.から->でのアクセスになる</em><br>
<br>
&nbsp;&nbsp;<em>// 自機弾の更新処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}</em><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<em>//【放置厳禁！！！このままここに弾削除処理書かないとメモリがどんどん減ってくよ(気づかないうちにね..怖)】</em><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;player<em>-&gt;</em>Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
&nbsp;&nbsp;<em>//ポインタ↑になると.から->でのアクセスになる</em><br>
<br>
&nbsp;&nbsp;<em>// 自機弾の描画処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
&nbsp;&nbsp;}</em><br>
};<br>
</p>
<br>
<br>
<br>


<p><code>Player.h</code>にPlayerBulletへの参照を得るため<em>Gameへのポインタ参照を追加</em>します：</p>
    <p class="source">#ifndef&nbsp;PLAYER_H_<br>
#define&nbsp;PLAYER_H_<br>
<br>
#include&nbsp;"DxLib.h"<br>
#include&nbsp;"Input.h"<br>
#include&nbsp;"Image.h"<br>
#include&nbsp;"MyMath.h"<br>
<br>
<em>class&nbsp;Game;&nbsp;//←【エラー地獄に注意！】ここにGameクラスがあるものとして書くことで【循環相互インクルードどうぞどうぞ問題】を回避<br>
<br>
//↑Gameクラス内にPlayer変数を持っているからPlayerの定義が終わらないとGameの定義が完了しない(未定義エラー)<br>
//【なのに】Playerクラス内にGame変数を持っているからPlayerの定義も終わらない！！(未定義エラー)<br>
//【つまりPlayerとGameが互いに定義が終わるのを待つ】【循環相互インクルードどうぞどうぞ状態】になる<br>
//【解決するために】とりあえずclass Game;とだけここに書いてGameは定義完了済と見せかけているわけです！<br>
//[エラー:Playerは未定義です]とか[エラー:Gameは未定義です]とか定義してるはずのものが未定義の場合は大体これ！！</em><br>
<br>
class&nbsp;Player<br>
{<br>
public:<br>
&nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
<br>
&nbsp;&nbsp;float x; // x座標<br>
&nbsp;&nbsp;float y; // y座標<br>
<br>
&nbsp;&nbsp;<em>Game* game { nullptr }; // Gameのインスタンスの参照<br>
&nbsp;&nbsp;//↑ * ポインタ型です！プレイヤの【内部に】ゲームの情報を【メモリ実体として持つ】と<br>
&nbsp;&nbsp;//そのプレイヤを親のゲームがもつと【延々とループで終わりなきメモリ爆発ループ】になるから<br>
&nbsp;&nbsp;//メモリに対しての参照=【レコードの針をGameに指して】【Gameの住所アドレスだけをプレイヤ内部に持つ】</em><br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;// x : 初期位置x<br>
&nbsp;&nbsp;// y : 初期位置y<br>
&nbsp;&nbsp;Player(float x, float y<em>, Game* game</em>)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;game = game;</em><br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;<em>void Update();//【★←Player.cppを新規作成してそちらに処理を書き移す】</em><br>  
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;<em>void Draw();//【★←Player.cppを新規作成してそちらに処理を書き移す】</em><br>
<br>
};<br>
<br>
#endif</p>

<br>
<p><code>↑Player.hにあった上記処理部分を↓Player.cppを新規作成して書き移します</code></p>
<p><code>Player.cpp</code>にPlayerBulletの発射処理を追加します：</p>
    <p class="source">
#include&nbsp;"Player.h"<br>
<br>
<em>#include&nbsp;"Game.h"&nbsp;//&nbsp;★game->playerBulletsなどClass Game;でカバーできない【定義の内部のplayerBulletsにアクセスするのでインクルード必要】<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★弾を生成して【使う処理があるのでインクルード必要】</em><br>
<br>
<br>
<br>
// 更新処理【書き移す際にはPlayer::という形で::所属が必要になります】<br>
void&nbsp;<em>Player::</em>Update()<br>
{<br>
&nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
&nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
<br>
&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
&nbsp;&nbsp;if (vx != 0 &amp;&amp; vy != 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 実際に位置を動かす<br>
&nbsp;&nbsp;x += vx;<br>
&nbsp;&nbsp;y += vy;<br>
<br>
&nbsp;&nbsp;<em>// ボタン押下で自機弾を発射<br>
&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;【C#版→】game-&gt;playerBullets.Add(new PlayerBullet(x, y));<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;C++ではAddがpush_backに↓&nbsp;newがmake_shared↓に<br>
&nbsp;&nbsp;&nbsp;&nbsp;game-&gt;playerBullets.push_back(std::make_shared&lt;PlayerBullet&gt;(x, y));<br>  
&nbsp;&nbsp;}</em><br>
}<br>  
<br>
// 描画処理<br>
void&nbsp;<em>Player::</em>Draw()<br>
{<br>
&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::player, TRUE);<br>
}<br>
<br>
</p>

<br>
<br>
<br>
<p>【確認してみましょう】ここまでで一旦弾が打てるかチェックしてみましょう！【メモリは削除されないバージョンなので要注意！！】</p><br>
<br>
<br>
<br>

<h2><a id="mozTocId00071" class="mozTocH1"></a>循環参照・インクルードの罠</h2>
<p>【さてここで大量のエラーで詰んだ人も多いのでは】おそらくは【Player.hに弾を弾を撃つ処理を書いたのでは】</p>
<p>それにしても【なぜヘッダh.ファイルとcppファイルに書く違いだけで大量のエラー】が出てしまうのでしょう？</p><br>
<p> <img src="image/include_loop_error.png" alt="" style="width: 700px; height: 538px;"></p>
<br>
<p>原因である【循環参照・循環インクルード】について説明します。<br>
実はインクルードしたPlayer.hやGame.hは【⇒ビルド】した際に【Player.hの中身が#include "Player.h"へとコピペ】されるのです<br>
そして問題は相互に【Player.hで#include "Game.h"】⇔【Game.hで#include "Player.h"】すると<br>
互いへの【コピペがループする】ため【延々とGameかPlayerの定義が完成せず】<br>
結果、邪悪なことに【全然関係ないPlayerBulletが未定義などと、とばっちりエラーが起こる】のです</p>
<p> <img src="image/include_loop.png" alt="" style="width: 672px; height: 382px;"></p>
<br>
<p>さてこの【循環参照・循環インクルード】への対策をどうするかが問題です。<br>
<br>
【1】 ヘッダ.hでのインクルードを避け.cppファイルでインクルードするのが基本的には有効です(ヘッダ.h同士が相互にコピペしあわないから)<br>
【2】 しかし根本的には【★相互に参照しあう構造の設計自体すっきりさせたい】です。<br>
<br>
今はPlayer⇔Gameの1対1の関係でまだ把握可能ですが、ザコや敵の弾などが他に増えてくると<br>
恐怖の三角関係や四角関係など【どこかで一周回ると無限インクルード発生】が起こってきます。<br>
まだ【1対1の循環なら見抜ける】けど【★三角ループや四角ループは発見が難しすぎ】です。</p>
<p> <img src="image/include_loop_meditator.png" alt="" style="width: 801px; height: 852px;"></p>
<p>そう、相互に行き来する【★矢印を一つへ集中させる】のです。<br>
こういったパターンを【★仲介者(Meditator)パターン】と呼びます。<br>
このパターンは【循環参照問題以外にも色んな利点】があり多用されます。<br>
一点に集中させれば【メモリの状況もここに集中します】し<br>
ここを経由すれば【どこからでもどこへでも連絡でき指令が出せます】<br>
そしていちいち初期化の時に【参照の連絡先の交換が必要なくなります】<br></p>
<p>ついでにもう一つ【★唯一物(シングルトン)パターン】も取り入れておきます。</p>
<p> <img src="image/include_loop_singleton.png" alt="" style="width: 565px; height: 946px;"></p>
<p>こういった先人の生み出したパターンを【デザインパターン】といいます。</p>
<p>有用なデザインパターンは23ほどあり、状況に合わせてうまく取り入れることが上級者への道で<br>
変な構造で作っていると起こる面倒な時間のロスが減り【残業時間が減ります】<br>
案外【ブラックな現場は構造のデザインそのものが悪かった】ことも多いです(なんかいちいちやりづらい環境)<br>
こういう【構造自体に疑問を持てる人が開発のリーダーシップを取れる】と心地よく制作が進むので<br>
時間とスキルに余裕ができたら将来のリーダーに向けて【デザイン構造パターン】を勉強するとよいかもしれません。</p><br>
<br>
<p>さて、ではまず<code>Singleton.h</code>を追加しましょう。<br>
コード中身は難しい文法が多いですが、<br>基本の要点は<br>
<br>
【1】「代入」「コピー」「実体ポインタへの直接アクセス」を★private:として【外部から禁止】<br>
【2】「実体へは★GetInstance()関数経由でしかアクセスできない」よう窓口を絞り<br>
【3】「テンプレ化」★template&lt;class T&gt;して何でも唯一化できるようになっています<br></p>
<br>
<h2><a id="mozTocId00072" class="mozTocH1"></a>シングルトン型:唯一物体タイプの追加</h2>
<p>難しいコードなので導入するだけでも良いですが、<br>
C++テキスト後半で「代入」「コピー」「テンプレ化」は触れられているので頑張れば6割ほどは理解できる余地ありです。<br>
2,3年後上級者となって読み返して9割ほど理解できるようになるよう成長してゆきましょう。</p>
<p><code>Singleton.h</code></p>
<p class="source">
#ifndef SINGLETON_H_<br>
#define SINGLETON_H_<br>
<br>
// テンプレートT型シングルトンSingleton&lt;～&gt; ～になんでも指定して唯一物にできる<br>
// ★Singleton&lt;T&gt;型は【必ず唯一で複製不可】(使い方:どこからでもアクセスし変数を共有するクラス向き)<br>
// ★ゲーム内の【どこからアクセスしても統一性が保たれる】(唯一だから)「クラス名と実体が一致」<br>
template&lt;class T&gt;<br>
class Singleton<br>
{<br>
public:<br>
&nbsp;&nbsp;// GetInstanceを通して【しか】T型クラスをつくれないうえに、<br>
&nbsp;&nbsp;// ★作ったものは【かならず唯一で複製不可】<br>
&nbsp;&nbsp;// それが【シングルトン型】！<br>
&nbsp;&nbsp;// ゲーム中で唯一で複製不可にしたい【ゲームを一律管理するクラス】などに最適！<br>
&nbsp;&nbsp;// https://teratail.com/questions/17416<br>
&nbsp;&nbsp;// http://rudora7.blog81.fc2.com/blog-entry-393.html<br>
&nbsp;&nbsp;// ②↓同じ関数の定義はプログラム全体で１つだけしか許されません。(static関数名は被らない)<br>
&nbsp;&nbsp;static inline T&amp; GetInstance()<br>
&nbsp;&nbsp;{&nbsp;&nbsp;//①↓関数の中で定義されたstatic変数は、関数の定義毎に１つ領域が確保されます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;static T instance; //メモリ上にstatic変数確保(静かに常に待機するinstance)<br>
&nbsp;&nbsp;&nbsp;&nbsp;return instance; //①=(常駐)②=(唯一) ①と②両方満たすinstanceは【メモリ上に唯一】<br>
&nbsp;&nbsp;}<br>
<br>
protected:<br>
&nbsp;&nbsp;Singleton() {} // 外部でのインスタンス作成は禁止(protected:内部公開、外部禁止)<br>
&nbsp;&nbsp;virtual ~Singleton() {} // 仮想デストラクタ(シングルトンを【継承するためには忘れちゃダメ】)<br>
<br>
private:<br>
&nbsp;&nbsp;void operator=(const Singleton&amp; obj) {} // 代入演算子禁止<br>
&nbsp;&nbsp;Singleton(const Singleton&amp; obj) {} // コピーコンストラクタ禁止(コピーできない【唯一】)<br>
&nbsp;&nbsp;static T* instance; // private:だから外部アクセスできない【GetInstance()経由しか無理】<br>
};<br>
<br>
// いつもcppで書いたstatic変数初期化も★【Tテンプレートクラスだからすべて.hヘッダにまとめて書いた】<br>
template&lt; class T &gt;<br>
T* Singleton&lt; T &gt;::instance = 0; //cppでの定義を.h内に書いた(static変数はclass内で初期化できないから)<br>
<br>
#endif<br>
</p>

<br>


<h2><a id="mozTocId00073" class="mozTocH1"></a>仲介マネージャーGameManagerの追加</h2>


<p>続いて仲介の役割を担当する<code>GameManager.h</code>を作成します。</p>
<p class="source">
#ifndef GAMEMANAGER_H_<br>
#define GAMEMANAGER_H_<br>
<br>
#include &lt;memory&gt;<br>
#include &lt;vector&gt;<br>
<br>
#include&nbsp;"Singleton.h"<br>
<br>
class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
class&nbsp;PlayerBullet;<br>
<br>
class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
{<br>
public:<br>
&nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
<br>
&nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機の初期化<br>
<br>
&nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
&nbsp;&nbsp;// List↑と同じvector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
<br>
protected:<br>
&nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
&nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
};<br>
<br>
#endif<br>
</p>

<p><code>Game.h</code>からGameManager.hに移行した処理を消して代わりにGameMangerへの連絡先gmを確保します。</p>
    <p class="source">#ifndef GAME_H_<br>
#define GAME_H_<br>
<br>
#include&nbsp;&lt;vector&gt;//C#のListリストの代わりのC++版<br>
#include&nbsp;&lt;memory&gt;//スマートなポインタを使うのに必要(shared_ptrなど)<br>
<br>
#include&nbsp;"Image.h"<br>
#include&nbsp;"Screen.h"<br>
<em>#include&nbsp;"Input.h"</em><br>
<br>
<u>#include&nbsp;"Player.h"</u><br>
<br>
<u>class&nbsp;Player;&nbsp;//←【エラー地獄に注意！】ここにPlayerクラスがあるものとして書くことで【循環相互インクルードどうぞどうぞ問題】を回避<br>
class&nbsp;PlayerBullet;</u><br>
<br>
<em>#include&nbsp;"GameManager.h"</em><br>
<br>
class&nbsp;Game<br>
{<br>
public&nbsp;:<br>
&nbsp;&nbsp;Game()&nbsp;{}; // 初期化コンストラクタ<br>
&nbsp;&nbsp;~Game()&nbsp;{}; // 破棄処理デストラクタ<br>
<br>
&nbsp;&nbsp;<em>//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
&nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る</em><br>
<br>
&nbsp;&nbsp;void Init(); // Init処理(定義だけ)<br>
&nbsp;&nbsp;void Update(); // 更新処理(定義だけ)<br>
&nbsp;&nbsp;void Draw();// 描画処理(定義だけ)<br>
<br>
&nbsp;&nbsp;int x = 0;<br>
&nbsp;&nbsp;int vx = 0;<br>
<br>
&nbsp;&nbsp;<u>std::shared_ptr&lt;Player&gt;&nbsp;player{ std::make_shared&lt;Player&gt;(100, Screen::Height / 2, this) }; // 自機の初期化<br>
&nbsp;&nbsp;//↑プレイヤを回し読みポインタ型に。std::make_shared&lt;Player&gt;でメモリ上に実体を生成<br>
&nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト</u><br>
<br>
};<br>
<br>
#endif</p>

<p>次にGame.cppファイルのPlayerやPlayerBulletのアクセスをGamaManagerのgm経由に書き換えましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のように変更します：</p>
    <p class="source">#include "Game.h"<br>
<br>
<em>#include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;x = 100; // Xの初期位置<br>
&nbsp;&nbsp;vx = 10;<br>
<br>
&nbsp;&nbsp;<em>gm.player = std::make_shared&lt;Player&gt;((float)100, (float)(Screen::Height / 2)); // 自機の初期化</em><br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;x += vx; // X位置の更新<br>
<br>
&nbsp;&nbsp;<em>gm.</em>player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
&nbsp;&nbsp;//ポインタ↑になると.から->でのアクセスになる<br>
<br>
&nbsp;&nbsp;// 自機弾の更新処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : <em>gm.</em>playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;//【放置厳禁！！！このままここに弾削除処理書かないとメモリがどんどん減ってくよ(気づかないうちにね..怖)】<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;<em>gm.</em>player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
&nbsp;&nbsp;//ポインタ↑になると.から->でのアクセスになる<br>
<br>
&nbsp;&nbsp;// 自機弾の描画処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : <em>gm.</em>playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
&nbsp;&nbsp;}<br>
};<br>
</p>
<br>


<p><code>Player.h</code>もGameManagerのgm経由でのアクセスにするので#include "Game.h"やGame*のポインタはなくなります。</p>
    <p class="source">#ifndef PLAYER_H_<br>
#define PLAYER_H_<br>
<br>
#include "DxLib.h"<br>
#include "Input.h"<br>
#include "Image.h"<br>
#include "MyMath.h"<br>
<br>
<u>class Game;//←【エラー地獄に注意！】ここにGameクラスがあるものとして書くことで【循環相互インクルードどうぞどうぞ問題】を回避</u><br>
<br>
<em>#include&nbsp;"GameManager.h"</em><br>
<br>
class Player<br>
{<br>
public:<br>
&nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
<br>
&nbsp;&nbsp;float x; // x座標<br>
&nbsp;&nbsp;float y; // y座標<br>
<br>
&nbsp;&nbsp;<em>//★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
&nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る</em><br>
<br>
&nbsp;&nbsp;<u>Game* game { nullptr }; // Gameのインスタンスの参照<br>
&nbsp;&nbsp;//↑ * ポインタ型です！プレイヤの【内部に】ゲームの情報を【メモリ実体として持つ】と<br>
&nbsp;&nbsp;//そのプレイヤを親のゲームがもつと【延々とループで終わりなきメモリ爆発ループ】になるから<br>
&nbsp;&nbsp;//メモリに対しての参照=【レコードの針をGameに指して】【Gameの住所アドレスだけをプレイヤ内部に持つ】</u><br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;// x : 初期位置x<br>
&nbsp;&nbsp;// y : 初期位置y<br>
&nbsp;&nbsp;Player(float x, float y<u>, Game* game</u>)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<u>this-&gt;game = game;</u><br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理の関数定義<br>
&nbsp;&nbsp;void Update();<br>  
<br>
&nbsp;&nbsp;// 描画処理の関数定義<br>
&nbsp;&nbsp;void Draw();<br>
<br>
};<br>
<br>
#endif</p>

<br>
<p><code>Player.cpp</code>もGameManagerのgm経由でのアクセスに書き換えます</p>
    <p class="source">
#include&nbsp;"Player.h"<br>
<br>
<u>#include "Game.h"</u><br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★弾を生成して【使う処理があるのでインクルード必要】<br>
<br>
// 更新処理【書き移す際にはPlayer::という形で::所属が必要になります】<br>
void Player::Update()<br>
{<br>
&nbsp;&nbsp;float vx = 0; // x方向移動速度<br>
&nbsp;&nbsp;float vy = 0; // y方向移動速度<br>
<br>
&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
&nbsp;&nbsp;if (vx != 0 &amp;&amp; vy != 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 実際に位置を動かす<br>
&nbsp;&nbsp;x += vx;<br>
&nbsp;&nbsp;y += vy;<br>
<br>
&nbsp;&nbsp;// ボタン押下で自機弾を発射<br>
&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;【C#版→】game-&gt;playerBullets.Add(new PlayerBullet(x, y));<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;C++ではAddがpush_backに↓&nbsp;newがmake_shared↓に<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>gm.</em>playerBullets.push_back(std::make_shared&lt;PlayerBullet&gt;(x, y));<br>  
&nbsp;&nbsp;}<br>
}<br>  
<br>
// 描画処理<br>
void Player::Draw()<br>
{<br>
&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::player, TRUE);<br>
}<br>
<br>
</p>


    <h2><a id="mozTocId00074" class="mozTocH1"></a>【※メモリから弾を削除】自機弾PlayerBulletの削除処理</h2>


    <p>PlayerBulletクラスを改造しましょう。<br>
    </p>
    <p><code>PlayerBullet.h</code>の内容を次のように【改造】します：</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
#define PLAYERBULLET_H_<br>
<br>
#include "DxLib.h"<br>
#include "Image.h"<br>
<em>#include "Screen.h"</em><br>
<br>
// 自機弾クラス<br>
class PlayerBullet<br>
{<br>
public:<br>
&nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
&nbsp;&nbsp;<em>const int VisibleRadius = 16; // 見た目の半径</em><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
&nbsp;&nbsp;//【使用注意】int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ<br>
<br>
&nbsp;&nbsp;float x; // x座標<br>
&nbsp;&nbsp;float y; // y座標<br>
&nbsp;&nbsp;<em>bool isDead = false; // 死亡フラグ</em><br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;PlayerBullet(float x, float y)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;x += Speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>// 画面外に出たら、死亡フラグを立てる<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (x - VisibleRadius &gt; Screen::Width)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br></em>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::playerBullet,TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
<br>
#endif<br></p>

<br>

<p>次にGame.cppファイルに自機弾PlayerBulletの【削除処理】を追加しましょう。<br>
      <br>
      <code>Game.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Game.h"<br>
#include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;x = 100; // Xの初期位置<br>
&nbsp;&nbsp;vx = 10;<br>
<br>
&nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;((float)100, (float)Screen::Height / 2); // 自機の初期化<br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;x += vx; // X位置の更新<br>
<br>
&nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
<br>
&nbsp;&nbsp;// 自機弾の更新処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<em>//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
&nbsp;&nbsp;// 非常に複雑な式に見えるがこれでisDeadのものを削除<br>
&nbsp;&nbsp;// https://stackoverflow.com/questions/42723205/remove-if-from-a-stdvector-of-shared-pointers-with-a-member-function<br>
&nbsp;&nbsp;gm.playerBullets.erase(<br>
&nbsp;&nbsp;&nbsp;&nbsp;std::remove_if(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int usingCount = -1;//テスト用コード(以下のコメントアウト部分は省略可)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if (ptr-&gt;isDead) usingCount = ptr.use_count();//おかんのコレ捨てるよカウンタ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//弾を捨てるまでの残り↑カウント(1だとisDeadがtrueなら0になり削除へ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),<br>
&nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.end()<br>
&nbsp;&nbsp;);</em><br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;gm.player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
<br>
&nbsp;&nbsp;// 自機弾の描画処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
&nbsp;&nbsp;}<br>
};<br>
</p>
<br>
<p>さて、削除部分の処理が非常に複雑ですね。C#と比較してみましょう。<br>
【C#】<br>
playerBullets.RemoveAll(pb => pb.isDead);<br>
【C++】<br>
<p class="source">
gm.playerBullets.erase(<br>
&nbsp;&nbsp;std::remove_if(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int usingCount = -1;//テスト用コード(以下のコメントアウト部分は省略可)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if (ptr-&gt;isDead) usingCount = ptr.use_count();//おかんのコレ捨てるよカウンタ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//弾を捨てるまでの残り↑カウント(1だとisDeadがtrueなら0になり削除へ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}),<br>
&nbsp;&nbsp;gm.playerBullets.end()<br>
);<br>
</p>
<br>
テスト用のコードを消して読みやすくしてみましょう。<br>
【C++】<br>
<p class="source">
gm.playerBullets.<em>erase</em>(<br>
&nbsp;&nbsp;std::<em>remove_if</em>(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}),<br>
&nbsp;&nbsp;gm.playerBullets.end()<br>
);<br>
</p>
<br>
これでもまだ複雑ですが、なぜ複雑に見えるか？<br>
【実は二つの処理が同時に行われている】ためです。<br>
<br>
【1】erase処理&nbsp;:&nbsp;<a href="https://cpprefjp.github.io/reference/vector/vector/erase.html">指定した配列の要素を削除する処理です。</a><br>
基本構文は<br>
&nbsp;&nbsp;v.erase(【削除開始位置】, 【終了位置】);<br>
で、プレイヤ弾の削除処理では<br>
<p class="source">
gm.playerBullets.erase(<br>
&nbsp;&nbsp;……<br>
&nbsp;&nbsp;&nbsp;&nbsp;……<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;……<br>
&nbsp;&nbsp;&nbsp;&nbsp;……,<br>
&nbsp;&nbsp;gm.playerBullets.end()<br>
);<br>
</p>
よく見ると実は<br>
gm.playerBullets.erase(【複雑な何か】,&nbsp;gm.playerBullets.end()&nbsp;);<br>
となっているだけで実は【複雑な何か】 ～ 【end()終了位置】までの削除処理を行っているだけだとわかります。<br>
こういう風にカンマ,や(かっこ)で区切られた構造を読み解く力が身に付けば複雑なコードでも<br>
<br>
【分解ステップを踏んでゆけば読み解けるようになります】<br>
<br>
そして次の「複雑な何か↓」も分解して読み解いてみましょう。<br>
【2】remove_if処理&nbsp;:&nbsp;<a href="https://cpprefjp.github.io/reference/algorithm/remove_if.html">ある条件を①満たすものを【配列の後ろ】に、②満たさないものを【前に】集め①の始まりの位置を返す</a><br>
基本構文はvを配列とすると<br>
&nbsp;&nbsp;std::remove_if(v.begin(), v.end(), 条件);//配列v開始位置から終了位置まで「条件」に従い分離並べ替えし条件を満たす後ろに並べ替えられたものの分離された先頭位置を返す<br>
つまりremove_ifは配列の後ろに条件を満たすものを分離する処理の担当で削除すべきものの先頭の位置をeraseに渡す担当だとわかります。<br>
<br>
要するに【1】と【2】で協力して「削除」と「分離並べ替え」を【分担していただけ】だったわけです。<br>
<br>そしてその条件式が<br>
<p class="source">
[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {&nbsp;<em>return ptr-&gt;isDead;</em>&nbsp;}<br>
</p>
というスタイルでisDeadがtrueかfalseかreturnするという【ちょっとクセの強い条件式の書き方】で書かれていたということです。<br>
<br>
ここは【慣れてゆくしかないです】何度も見て【見慣れる】ことです。<br>
</p>
<p>しかし、なぜ【わざわざeraseとremove_ifを組合わせる必要があるのか】<br>
それは【erase単体だけだと削除処理が遅い】からです。<br>
vectorはメモリ上にデータが【隙間なく詰まってます】ゆえに【通常性能は速いです】<br>
ただ引き換えに【あいだのデータを1個消す】だけで【隙間を埋める座席移動が発生】します。<br>
100万のデータが座ってる中、中央付近のデータを1個消すだけで【50万回ぶん一つずつ隙間を埋める座席移動が発生】します。<br>
これがeraseだけ異様に遅い理由です。<br>
逆に映画館の座席で通路付近に座ってる人を思い浮かべてください。<br>
映画が終わると通路付近の座席の人はすぐに立って横に出れば最初に通路への出られますよね。<br>
ゆえに配列の【後ろから】一つ削除する【pop_back処理は速い】です。<br>
したがって【後ろに消したいものを先に集めてしまえばよいのです】<br>
これが【remove_if】処理です。remove_ifは条件を指定して【削除候補を後ろに並べ替えます】<br>
ゆえに【2】remove_ifで先に後ろに並べ替えて【1】eraseでまとめて削除の【1】【2】のハイブリッドが必要なのです。<br>
<br></p>
<p> <img src="image/erase_remove_if_fast.png" alt="" style="width: 620px; height: 701px;"></p>

<p>ただ、毎回この複雑なコードを書くと【コードが見にくくなる】ので【テンプレート化】に挑戦してみましょう。</p> 


<h2><a id="mozTocId00075" class="mozTocH1"></a>共通削除機能を【テンプレートとして定義】</h2>
    

<p><code>GameManager.h</code>に共通の削除機能として【テンプレート機能】として追加してみましょう。</p>
<p class="source">
#ifndef GAMEMANAGER_H_<br>
#define GAMEMANAGER_H_<br>
<br>
#include &lt;memory&gt;<br>
#include &lt;vector&gt;<br>
<br>
#include&nbsp;"Singleton.h"<br>
<br>
class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
class&nbsp;PlayerBullet;<br>
<br>
class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
{<br>
public:<br>
&nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
<br>
&nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機の初期化<br>
<br>
&nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
&nbsp;&nbsp;// List↑と同じvector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
<br>
<br>
<br>
&nbsp;&nbsp;<em>//&nbsp;★削除処理を共通テンプレート関数にする<br>
&nbsp;&nbsp;//&nbsp;[共通テンプレート関数]https://programming-place.net/ppp/contents/cpp/language/009.html#function_template<br>
&nbsp;&nbsp;template&nbsp;&lt;typename&nbsp;T,&nbsp;class&nbsp;T_if&gt;<br>
&nbsp;&nbsp;void&nbsp;EraseRemoveIf(std::vector&lt;T&gt;&nbsp;&amp;v,&nbsp;T_if&nbsp;if_condition)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特定のタイプT↑&nbsp;&nbsp;↑配列v&nbsp;&nbsp;&nbsp;↑条件式if_condition<br>
&nbsp;&nbsp;&nbsp;&nbsp;v.erase(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::remove_if(v.begin(),&nbsp;v.end(),if_condition),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.end()&nbsp;//&nbsp;&nbsp;↓remove_ifの位置<br>
&nbsp;&nbsp;&nbsp;&nbsp;);//例.[生][生][死][死][死]←&nbsp;v.end()の位置<br>
&nbsp;&nbsp;};</em><br>
<br>
protected:<br>
&nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
&nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
};<br>
<br>
#endif<br>
</p>
<br>
<br>
<p>そして<code>Game.cpp</code>の削除処理をシンプルに書き直します</p>
    <p class="source">#include "Game.h"<br>
#include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;x = 100; // Xの初期位置<br>
&nbsp;&nbsp;vx = 10;<br>
<br>
&nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;((float)100, (float)Screen::Height / 2); // 自機の初期化<br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;x += vx; // X位置の更新<br>
<br>
&nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
<br>
&nbsp;&nbsp;// 自機弾の更新処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<em>// 自機弾の削除処理<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<u>// 自機弾のリストから死んでるものを除去する<br>
&nbsp;&nbsp;// 非常に複雑な式に見えるがこれでisDeadのものを削除<br>
&nbsp;&nbsp;// https://stackoverflow.com/questions/42723205/remove-if-from-a-stdvector-of-shared-pointers-with-a-member-function<br>
&nbsp;&nbsp;gm.playerBullets.erase(<br>
&nbsp;&nbsp;&nbsp;&nbsp;std::remove_if(gm.playerBullets.begin(), gm.playerBullets.end(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt; &amp;ptr) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//int usingCount = -1;//テスト用コード(以下のコメントアウト部分は省略可)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if (ptr-&gt;isDead) usingCount = ptr.use_count();//おかんのコレ捨てるよカウンタ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//弾を捨てるまでの残り↑カウント(1だとisDeadがtrueなら0になり削除へ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ptr-&gt;isDead;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),<br>
&nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.end()<br>
&nbsp;&nbsp;);</u><br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;gm.player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
<br>
&nbsp;&nbsp;// 自機弾の描画処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
&nbsp;&nbsp;}<br>
};<br>
</p>
<p>さて、使う側はすっきり2行にまとまりました。<br>
これなら削除するリストがenemiesやenemyBulletsなど増えてきても書きやすいです。</p>
<p>テンプレート化template&nbsp;&lt;typename&nbsp;T&gt;を習得することは上級者への第一歩です。<br>
C++だけでなく【C#でもテンプレート化ができます】ぜひ練習して習得してゆきましょう。<br>
逆の目線で言うと【実は今まではテンプレート化された使いやすい機能を使わせてもらっていた】のです。意識せずに。<br>
使う側が意識しなくていいほど【使いやすいテンプレート】を自力で作れることが理想形です。トライしてゆきましょう。<br>
</p>
<br>


<h2><a id="mozTocId00076" class="mozTocH1"></a>【実験】メモリ浪費弾の実験</h2>


<p>
ここまでで一応弾の削除処理は書けました。しかし本当に弾が削除されているか実感がありません。<br>
弾1個は現状では【かなり微小なメモリしか】使用しません。<br>
実行して【メモリのグラフを見ても増えているか減っているか見えないほど微小です】<br>
そこで【人為的に弾1個のメモリを大きくする】実験をしてみましょう。<br>
注意が必要です【危険な実験】です(ほったらかすと)。【実験コードは必ず元に戻してください！！】<br>
では実験を始めてみましょう。<br>
</p>
<p><code>PlayerBullet.h</code>の内容を次のように【改造】します：</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
#define PLAYERBULLET_H_<br>
<br>
#include "DxLib.h"<br>
#include "Image.h"<br>
#include "Screen.h"<br>
<br>
// 自機弾クラス<br>
class PlayerBullet<br>
{<br>
public:<br>
&nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
&nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
&nbsp;&nbsp;<em>int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ</em><br>
<br>
&nbsp;&nbsp;float x; // x座標<br>
&nbsp;&nbsp;float y; // y座標<br>
&nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;PlayerBullet(float x, float y)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;x += Speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 画面外に出たら、死亡フラグを立てる<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (x - VisibleRadius &gt; Screen::Width)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::playerBullet,TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
<br>
#endif<br></p>
<br>
<p>無駄メモリをあえて人為的に定義して弾を撃ってみましょう。<br>
メモリの【グラフがうなぎ上りに上昇しなければ】プレイヤの弾に関してはメモリの削除と開放が成功している証拠です。<br>
<br>
<p> <img src="image/memory_valance_and.png" alt="" style="width: 773px; height: 467px;"></p>

<p>試しに<code>Game.cpp</code>で削除処理をわすれた場合の実験をしてみましょう。</p>
    <p class="source">#include "Game.h"<br>
#include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;x = 100; // Xの初期位置<br>
&nbsp;&nbsp;vx = 10;<br>
<br>
&nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;((float)100, (float)Screen::Height / 2); // 自機の初期化<br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;x += vx; // X位置の更新<br>
<br>
&nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
<br>
&nbsp;&nbsp;// 自機弾の更新処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<em>return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験</em><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<em>// 自機弾の削除処理<br>
&nbsp;&nbsp;//gm.EraseRemoveIf(gm.playerBullets,<br>
&nbsp;&nbsp;//&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
&nbsp;&nbsp;<br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
<br>
&nbsp;&nbsp;// 自機弾の描画処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
&nbsp;&nbsp;}<br>
};<br>
</p>


<p> <img src="image/memory_leak.png" alt="" style="width: 728px; height: 433px;"></p>
<p>実験が終わったら実験コードをもとに戻しましょう<code>PlayerBullet.h</code>の内容を次のようにします</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
#define PLAYERBULLET_H_<br>
<br>
#include "DxLib.h"<br>
#include "Image.h"<br>
#include "Screen.h"<br>
<br>
// 自機弾クラス<br>
class PlayerBullet<br>
{<br>
public:<br>
&nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
&nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
&nbsp;&nbsp;<em>//【実験コード】int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ</em><br>
<br>
&nbsp;&nbsp;float x; // x座標<br>
&nbsp;&nbsp;float y; // y座標<br>
&nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;PlayerBullet(float x, float y)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;x += Speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 画面外に出たら、死亡フラグを立てる<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (x - VisibleRadius &gt; Screen::Width)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::playerBullet,TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
<br>
#endif<br></p>
<br>

<p><code>Game.cpp</code>の削除処理ももとに戻しましょう。</p>
    <p class="source">#include "Game.h"<br>
#include&nbsp;"Player.h"&nbsp;//&nbsp;★初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;★Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;x = 100; // Xの初期位置<br>
&nbsp;&nbsp;vx = 10;<br>
<br>
&nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;((float)100, (float)Screen::Height / 2); // 自機の初期化<br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;x += vx; // X位置の更新<br>
<br>
&nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
<br>
&nbsp;&nbsp;// 自機弾の更新処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<em>//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験</em><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<em>// 自機弾の削除処理<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
&nbsp;&nbsp;<br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
<br>
&nbsp;&nbsp;// 自機弾の描画処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
&nbsp;&nbsp;}<br>
};<br>
</p>
<br>


<h2>自機弾の角度を変えられるようにする</h2>
<p><code>PlayerBullet.h</code>に角度をつけられるようにします</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
#define PLAYERBULLET_H_<br>
<br>
<em>#include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要</em><br>
<br>
#include "DxLib.h"<br>
#include "Image.h"<br>
#include "Screen.h"<br>
<br>
// 自機弾クラス<br>
class PlayerBullet<br>
{<br>
public:<br>
&nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
&nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
&nbsp;&nbsp;//【実験コード】int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ<br>
<br>
&nbsp;&nbsp;float x; // x座標<br>
&nbsp;&nbsp;float y; // y座標<br>
&nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
<br>
&nbsp;&nbsp;<em>float vx; // x方向移動速度</em><br>
&nbsp;&nbsp;<em>float vy; // y方向移動速度</em><br>
&nbsp;&nbsp;<em>float angle; // 移動角度</em><br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;PlayerBullet(float x, float y<em>, float angle</em>)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;angle = angle;</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>vx = (float)std::cos(angle) * Speed;</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>vy = (float)std::sin(angle) * Speed;</em><br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>x += vx;</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>y += vy;</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 画面外に出たら、死亡フラグを立てる<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (<em>x + VisibleRadius &lt; 0 || x - VisibleRadius &gt; Screen::Width || <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y + VisibleRadius &lt; 0 || y - VisibleRadius &gt; Screen::Height</em>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, <em>angle</em>, Image::playerBullet,TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
<br>
#endif<br></p>
<br>


<p><code>MyMath.h</code>を編集します：</p>
    <p class="source">#ifndef _MYMATH_H<br>
#define _MYMATH_H<br>
// 数学関連クラス<br>class MyMath<br>{<br>
public: <br>
&nbsp;&nbsp;static const float Sqrt2;&nbsp;&nbsp;// = 1.41421356237f;<br>
&nbsp;&nbsp;<em>static const float PI; // 円周率 3.14159265359f;</em><br>
&nbsp;&nbsp;<em>static const float Deg2Rad; // 度からラジアンに変換する定数 PI / 180f;</em><br>
<br>
}; // 【注意】セミコロン抜けで【宣言が必要ですエラー】<br>
<br>
#endif //【宣言が必要ですエラーは上のセミコロン抜け】</p>
<br>
    <p><code>MyMath.cpp</code>を編集して変数に数値を割り当て。</p>
    <p class="source">#include "MyMath.h"<br>
	<br>
	const float MyMath::Sqrt2 = 
	1.41421356237f;//(floatは有効桁は実質7桁まで正確だがそれ以降は環境によって誤差出る)<br>
	<em>const float MyMath::PI = 3.14159265359f; // 円周率<br>
	const float MyMath::Deg2Rad = MyMath::PI / 180; // 度からラジアンに変換する定数</em><br>
<br>
</p>
		
		
<p><code>Player.cpp</code>のプレイヤの弾の生成を改修します。</p>
    <p class="source">#include "Player.h"<br>
<em>#include "MyMath.h"<br></em>
<br>
(前略)...................................<br>
<br>
&nbsp;&nbsp;// ボタン押下で自機弾を発射<br>
&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;C++ではAddがpush_backに↓&nbsp;newがmake_shared↓に<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>gm.playerBullets.push_back(std::make_shared&lt;PlayerBullet&gt;(x, y, 0));//右</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>gm.playerBullets.push_back(std::make_shared&lt;PlayerBullet&gt;(x, y, -15 * MyMath::Deg2Rad));//右上</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>gm.playerBullets.push_back(std::make_shared&lt;PlayerBullet&gt;(x, y, +15 * MyMath::Deg2Rad));//右下</em><br>
&nbsp;&nbsp;}<br>
}<br>  
<br>
(以下略)
</p>
 
<h1><a id="mozTocId0008" class="mozTocH1"></a>敵の作成【共通のGameObjectを継承する】</h1>
 
<h2>Enemyクラスを作成するにあたってアクションゲームのGameObjectを導入する</h2>
<p>前期はEnemyクラスを継承する形でZako0をつくりましたが<br>
この構造のままで作り進めると循環参照インクルードが起こってしまいます。<br>
なぜなら、衝突判定で【PlayerBullet⇔Enemy⇔Playerの相互の矢印の参照が生まれざる負えません】<br>
そこでアクションゲームのGameObject、すなわち全てのものが継承する【ベースとなる継承元】を導入します。<br>
これで矢印はGameObjectにまとまりオブジェクト同士の参照をせずに済みます。<br>
</p>
<p> <img src="image/include_base_gameobject.png" alt="" style="width: 702px; height: 758px;"></p>


<h2><a id="mozTocId00081" class="mozTocH1"></a>共通のベースとなるGameObjectを作成する</h2>
<p><code>GameObject.h</code>を作成します(拡張も見越して3DのZ座標も導入しておきます)。</p>
<p class="source">#ifndef GAMEOBJECT_H_<br>
#define GAMEOBJECT_H_<br>
<br>
#include "DxLib.h"<br>
#include &lt;string&gt; //文字タグのため<br>
#include &lt;memory&gt; //回し読みポインタの定義のため<br>
<br>
// ゲーム上に表示される物体の基底クラス。<br>
// プレイヤーや敵、アイテムなどはこのクラスを継承して作る。<br>
class GameObject<br>
{<br>
public:<br>
&nbsp;&nbsp;std::string tag = ""; // Zako0やBossやPlayerなど小カテゴリ<br>
&nbsp;&nbsp;std::string typeTag = ""; // EnemyやPlayerなど大カテゴリ<br>
&nbsp;&nbsp;std::string statusTag = ""; // 爆発状態やアイテムゲット状態など自由に使えばよい<br>
&nbsp;&nbsp;float x = 0; // x座標<br>
&nbsp;&nbsp;float y = 0; // y座標<br>
&nbsp;&nbsp;float z = 0; //【3D】z座標<br>
&nbsp;&nbsp;float vx = 0; // x方向の速度<br>
&nbsp;&nbsp;float vy = 0; // y方向の速度<br>
&nbsp;&nbsp;float vz = 0; //【3D】z方向の速度<br>
<br>
&nbsp;&nbsp;bool isDead = false; // 死んだ（削除対象）フラグ<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;GameObject()<br>
&nbsp;&nbsp;{<br>
<br>
&nbsp;&nbsp;}
<br>
&nbsp;&nbsp;//★仮想デストラクタ【忘れるとメモリがヤバいダメ絶対】<br>
&nbsp;&nbsp;//【注意！】ベースの基底では必ず定義しないとstringなどが浪費され極悪なメモリ被害に発展<br>
&nbsp;&nbsp;virtual ~GameObject()<br>
&nbsp;&nbsp;{<br>
<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;//★純粋仮想関数=0は継承したZakoやPlayerなどの必須機能(継承したら絶対override必須縛り)<br>	
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;virtual void Update() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;virtual void Draw() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
<br>
&nbsp;&nbsp;//★virtual仮想関数は共通カスタマイズ機能(継承してもoverride必須ではないご自由にカスタマイズ)<br>
&nbsp;&nbsp;// 衝突したときの関数(仮のvirtual関数←純粋仮想関数と違い継承してもoverride必須ではない)<br>
&nbsp;&nbsp;virtual void OnCollision(std::shared_ptr&lt;GameObject&gt; other)<br>
&nbsp;&nbsp;{<br>
<br>
&nbsp;&nbsp;}<br>
<br>
};<br>
<br>
#endif<br>
</p>
<p><code>Enemy.h</code>を作成します。</p>
<p class="source">#ifndef ENEMY_H_<br>
#define ENEMY_H_<br>
<br>
#include "GameObject.h"<br>
<br>
#include "GameManager.h"<br>
<br>
// 敵の基底クラス。<br>
// 全ての敵は、このクラスを継承して作る。<br>
// ★【勉強】abstract型はC++にない!!【純粋仮想関数】を使って作る<br>
// クラスの基本(C++11).pdfの17ページの下のほう(クラスの基本④)<br>
class Enemy : public GameObject<br>
{<br>
public:<br><br>
&nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
&nbsp;&nbsp;GameManager& gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&)を得る<br>
<br>
&nbsp;&nbsp;float collisionRadius = 32; // 当たり判定の半径<br>
&nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
&nbsp;&nbsp;float life = 1; // 耐久力<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;Enemy(float x, float y, float z=0)//★z=0をデフォルトとすることでx,yだけでも初期化でき2Dと3D両立<br>
&nbsp;&nbsp;&nbsp;&nbsp;: GameObject() // GameObjectをベースとして初期化処理を継承する<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;typeTag = "Enemy";<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z = z;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理。派生クラスでオーバーライドして使う<br>
&nbsp;&nbsp;virtual void Update() = 0;//virtual ～ = 0;で【純粋仮想関数に】これで【C#のabstract型に】<br>
<br>
&nbsp;&nbsp;// 描画処理。派生クラスでオーバーライドして使う<br>
&nbsp;&nbsp;virtual void Draw() = 0; //virtual ～ = 0;で【純粋仮想関数に】【関数 = 0で未定義状態を表現】<br>
<br>
&nbsp;&nbsp;//【勉強】関数 = 0って何?と思った人は【関数もメモリ上では住所アドレスに過ぎない】ことを知ろう<br>
&nbsp;&nbsp;// ★関数 = 0はつまり関数の住所ポインタの針が【メモリ上の何かを針で参照してない(住所不定無処理)】<br>
&nbsp;&nbsp;// つまり【関数が未定義ってこと】＝【あいまい部分があるabstractクラスってこと】<br>
&nbsp;&nbsp;//http://etc2myday.jugem.jp/?eid=204<br>
&nbsp;&nbsp;//http://wisdom.sakura.ne.jp/programming/c/c54.html<br>
&nbsp;&nbsp;//逆にいうと【関数を配列】にするっていうトリッキーなこともできる!<br>
&nbsp;&nbsp;//http://www.ced.is.utsunomiya-u.ac.jp/lecture/2012/prog/p3/kadai3/virtualfunc2.php<br>
<br>
&nbsp;&nbsp;// 自機弾に当たったときの処理<br>
&nbsp;&nbsp;virtual void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;life -= 1; // ライフを減らす<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ライフが無くなったら、死亡<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (life &lt;= 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
#endif<br>
</p>


<p><code>Player.h</code>も共通のベースとなるGameObjectを継承するように書き換えます。</p>
    <p class="source">#ifndef PLAYER_H_<br>
#define PLAYER_H_<br>
<br>
#include "DxLib.h"<br>
#include "Input.h"<br>
#include "Image.h"<br>
#include "MyMath.h"<br>
<br>
<em>#include&nbsp;"GameObject.h"</em><br>
<br>
#include&nbsp;"GameManager.h"<br>
<br>
<em>// 継承するときは↓ : public ～にする。publicをつけ忘れると色々エラー出るので注意</em><br>
class Player <em>: public GameObject</em><br>
{<br>
public:<br>
&nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
<br>
&nbsp;&nbsp;<em>//【★注意！】ここに【x,yの定義が残ってるとGameObjectと被る】ので<br>
&nbsp;&nbsp;// 名前の同じ変数が2つ【パラレルワールドに存在してしまう！】<br>
&nbsp;&nbsp;// Playerからx=13,y=5に変えたつもりでも【ベースのGameObjectはx=0,y=0のままの不思議バグで混乱！】</em><br>
&nbsp;&nbsp;<u>float x; // x座標<br>
&nbsp;&nbsp;float y; // y座標</u><br>
<br>
&nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
&nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;// x : 初期位置x<br>
&nbsp;&nbsp;// y : 初期位置y<br>
&nbsp;&nbsp;Player(float x, float y<em>, float z=0</em>) <em>// z=0デフォルトにして2Dのときはzを省略できる</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>: GameObject() //【忘れると】GameObjectの初期化処理が飛ばされて大混乱！</em><br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;z = z;//[3D対応]</em><br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理の関数定義<br>
&nbsp;&nbsp;void Update();<br>  
<br>
&nbsp;&nbsp;// 描画処理の関数定義<br>
&nbsp;&nbsp;void Draw();<br>
<br>
};<br>
<br>
#endif</p>

<p><code>PlayerBullet.h</code>もGameObjectを継承する形に書き換えます。</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
#define PLAYERBULLET_H_<br>
<br>
#include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要<br>
<br>
#include "DxLib.h"<br>
#include "Image.h"<br>
#include "Screen.h"<br>
<br>
<em>#include "GameObject.h"</em><br>
<br>
// 自機弾クラス<br>
<em>// 継承するときは↓ : public ～にする。publicをつけ忘れると色々エラー出るので注意</em><br>
class PlayerBullet<em>: public GameObject</em><br>
{<br>
public:<br>
&nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
&nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
&nbsp;&nbsp;//【実験コード】int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ<br>
<br>
&nbsp;&nbsp;<em>//【★注意！GameObjectと被る変数は全部消す】</em><br>
&nbsp;&nbsp;<u>float x; // x座標<br>
&nbsp;&nbsp;float y; // y座標<br>
&nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
<br>
&nbsp;&nbsp;float vx; // x方向移動速度<br>
&nbsp;&nbsp;float vy; // y方向移動速度</u><br>
&nbsp;&nbsp;float angle; // 移動角度<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;PlayerBullet(float x, float y, float angle)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>: GameObject()</em><br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>this-&gt;tag = "PlayerBullet";</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angle = angle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = (float)std::cos(angle) * Speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy = (float)std::sin(angle) * Speed;<br>
&nbsp;&nbsp;}<br>
<br><br>
&nbsp;&nbsp;<em>//【★勉強】初期化は何種類も【別窓口を】用意できる<br>
&nbsp;&nbsp;//マニアックな初期設定は【①別窓口】【②デフォルト=0で省略可にする】<br>
&nbsp;&nbsp;// [3D用]コンストラクタ(引数4つの別窓口の初期化を用意)<br>
&nbsp;&nbsp;PlayerBullet(float x, float y, float z, float angle)<br>
&nbsp;&nbsp;&nbsp;&nbsp;: GameObject()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z = z;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angle = angle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = (float)std::cos(angle) * Speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vz = (float)std::sin(angle) * Speed;//Y平面固定で弾を撃つ<br>
&nbsp;&nbsp;}</em><br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;(中略)....................<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, angle, Image::playerBullet,TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
<br>
#endif<br></p>


<h2><a id="mozTocId00082" class="mozTocH1"></a>Zako0クラスの作成</h2>


<p><code>Zako0.h</code>を作成します。</p>
<p class="source">#ifndef ZAKO_0_H_<br>
#define ZAKO_0_H_<br>
<br>
#include "Enemy.h"<br>
#include "Image.h"<br>
<br>
// ザコ0クラス<br>
class Zako0 : public Enemy<br>
{<br>
public:<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;Zako0(float x, float y, float z=0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;: Enemy(x, y, z)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako0";<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update() override<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;x -= 1; // とりあえず左へ移動<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw() override<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::zako0, TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
#endif<br>
</p>
<p><code>Image.h</code>にザコ0,1,2,3と敵弾の画像定義を追加します：</p>
    <p class="source">#ifndef IMAGE_H_<br>
#define IMAGE_H_<br>
<br>
#include "DxLib.h"<br>
#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
<br>
class Image<br>
{<br>
public:<br>
&nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;static void Load();<br>
<br>
&nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
&nbsp;&nbsp;static int player; //プレイヤ画像のハンドラ<br>
&nbsp;&nbsp;static int playerBullet; //プレイヤの弾画像のハンドラ<br>
&nbsp;&nbsp;<em>static int enemyBullet16; //敵弾 画像のハンドラ(読込画像番号)</em><br>
&nbsp;&nbsp;<em>static int zako0; //ザコ0 画像のハンドラ(読込画像番号)</em><br>
&nbsp;&nbsp;<em>static int zako1; //ザコ1 画像のハンドラ(読込画像番号)</em><br>
&nbsp;&nbsp;<em>static int zako2; //ザコ2 画像のハンドラ(読込画像番号)</em><br>
&nbsp;&nbsp;<em>static int zako3; //ザコ3 画像のハンドラ(読込画像番号)</em><br>
<br>
private:<br>
<br>
};<br>
#endif<br>
</p>
<br>
<p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
<br>
int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
int Image::player{-1};<br>
int Image::playerBullet{-1};<br>
<em>int Image::enemyBullet16{-1};</em><br>
<em>int Image::zako0{-1};</em><br>
<em>int Image::zako1{-1};</em><br>
<em>int Image::zako2{-1};</em><br>
<em>int Image::zako3{-1};</em><br>
<br>
void Image::Load()<br>
{<br>
&nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
&nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;player= LoadGraph("Image/player.png");<br>
&nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;playerBullet = LoadGraph("Image/player_bullet.png");<br>
&nbsp;&nbsp;assert(playerBullet!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;<em>enemyBullet16 = LoadGraph("Image/enemy_bullet_16.png");<br>
&nbsp;&nbsp;assert(enemyBullet16!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
<br>
&nbsp;&nbsp;<em>zako0 = LoadGraph("Image/zako0.png");<br>
&nbsp;&nbsp;assert(zako0!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
<br>
&nbsp;&nbsp;<em>zako1 = LoadGraph("Image/zako1.png");<br>
&nbsp;&nbsp;assert(zako1!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
<br>
&nbsp;&nbsp;<em>zako2 = LoadGraph("Image/zako2.png");<br>
&nbsp;&nbsp;assert(zako2!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
<br>
&nbsp;&nbsp;<em>zako3 = LoadGraph("Image/zako3.png");<br>
&nbsp;&nbsp;assert(zako3!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
}<br>
</p>
<h2>敵を管理する仕組みの作成</h2>
<p><code>GameManager.h</code>に敵のリストを追加しましょう。</p>
<p class="source">
#ifndef GAMEMANAGER_H_<br>
#define GAMEMANAGER_H_<br>
<br>
#include &lt;memory&gt;<br>
#include &lt;vector&gt;<br>
<br>
#include&nbsp;"Singleton.h"<br>
<br>
class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
class&nbsp;PlayerBullet;<br>
<em>class&nbsp;Enemy;</em><br>
<br>
class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
{<br>
public:<br>
&nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
<br>
&nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機のポインタ<br>
&nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
&nbsp;&nbsp;<em>std::vector&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト</em><br>
&nbsp;&nbsp;// List↑と同じvector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
<br>
<br>
(中略)..............
<br>
protected:<br>
&nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
&nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
};<br>
<br>
#endif<br>
</p>


<p><code>Game.cpp</code>に敵の生成と更新と描画処理を追加しましょう。</p>
    <p class="source">#include "Game.h"<br>
#include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<em>#include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;x = 100; // Xの初期位置<br>
&nbsp;&nbsp;vx = 10;<br>
<br>
&nbsp;&nbsp;gm.player = std::make_shared&lt;Player&gt;((float)100, (float)Screen::Height / 2); // 自機の初期化<br>
&nbsp;&nbsp;<em>// とりあえず適当に敵を生成</em><br>
&nbsp;&nbsp;<em>gm.enemies.push_back(std::make_shared&lt;Zako0&gt;((float)600, (float)100));</em><br>
&nbsp;&nbsp;<em>gm.enemies.push_back(std::make_shared&lt;Zako0&gt;((float)1000, (float)500));</em><br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;if (x &lt; 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = 10; //速度の変更<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (x &lt; Screen::Width)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -10;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;x += vx; // X位置の更新<br>
<br>
&nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
<br>
&nbsp;&nbsp;// 自機弾の更新処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<em>// 敵の更新処理<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.enemies)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}</em><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
&nbsp;&nbsp;<br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;<em>// 敵の描画処理<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.enemies)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
&nbsp;&nbsp;}</em><br>
<br>
&nbsp;&nbsp;gm.player-&gt;Draw(); // プレイヤの更新【忘れるとプレイヤ表示されない】<br>
<br>
&nbsp;&nbsp;// 自機弾の描画処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
&nbsp;&nbsp;}<br>
};<br>
</p>
<br>
<br>
<br>

<a id="mozTocId2000" class="mozTocH1"></a>
</body>
<body>
    <p class="title">[C++移植]シューティングゲーム 2</p>
    <br>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId2001">敵と自機弾の当たり判定の作成</a></li>
      <li><a href="#mozTocId2002">敵に耐久力を持たせる(おまけでSinの波運動のコード例も)</a></li>
      <li><a href="#mozTocId2003">自機と敵の当たり判定</a></li>
      <li><a href="#mozTocId2004">自機のライフの作成</a></li>
      <li><a href="#mozTocId2005">敵弾の作成</a><br>
      	<a href="#mozTocId20052">- 練習問題(MyRandomで±15度に散乱弾を撃つ敵キャラ)</a><br>
      	<a href="#mozTocId20053">- 練習問題(やられると点滅後自爆する敵キャラ)</a>
      </li>
	    <br>
	    <p>次のテキスト3はこちら。</p><br>
	    <a href="#mozTocId3000">[C++移植]シューティングゲーム 3</a><br>
    </ol>
    <h1><a id="mozTocId2001" class="mozTocH1"></a>敵と自機弾の当たり判定の作成</h1>
    <p>当たり判定を移植してゆきます。</p>
	
<p><code>MyMath.h</code>を編集します：</p>
    <p class="source">#ifndef _MYMATH_H<br>
#define _MYMATH_H<br>
// 数学関連クラス<br>class MyMath<br>{<br>
public: <br>
&nbsp;&nbsp;static const float Sqrt2;&nbsp;&nbsp;// = 1.41421356237f;<br>
&nbsp;&nbsp;static const float PI; // 円周率 3.14159265359f;<br>
&nbsp;&nbsp;static const float Deg2Rad; // 度からラジアンに変換する定数 PI / 180f;<br>
<br>
&nbsp;&nbsp;<em>/// &lt;summary&gt;<br>
&nbsp;&nbsp;/// 円と円が重なっているかを調べる<br>
&nbsp;&nbsp;/// &lt;/summary&gt;<br>
&nbsp;&nbsp;/// &lt;param name="x1"&gt;円1の中心x&lt;/param&gt;<br>
&nbsp;&nbsp;/// &lt;param name="y1"&gt;円1の中心y&lt;/param&gt;<br>
&nbsp;&nbsp;/// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
&nbsp;&nbsp;/// &lt;param name="x2"&gt;円2の中心x&lt;/param&gt;<br>
&nbsp;&nbsp;/// &lt;param name="y2"&gt;円2の中心y&lt;/param&gt;<br>
&nbsp;&nbsp;/// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
&nbsp;&nbsp;/// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
&nbsp;&nbsp;static bool CircleCircleIntersection(<br>
&nbsp;&nbsp;&nbsp;&nbsp;float x1, float y1, float radius1,<br>
&nbsp;&nbsp;&nbsp;&nbsp;float x2, float y2, float radius2)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt; ((radius1 + radius2) * (radius1 + radius2));<br>
&nbsp;&nbsp;}</em><br>
}; // 【注意】セミコロン抜けで【宣言が必要ですエラー】<br>
<br>
#endif //【宣言が必要ですエラーは上のセミコロン抜け】</p>
<br>
	
	
<p><code>Enemy.h</code>を改修します。当たり判定の半径を表す変数と、死亡フラグ、被弾時の処理を追加します。</p>
<p class="source">#ifndef ENEMY_H_<br>
#define ENEMY_H_<br>
<br>
#include "GameObject.h"<br>
<br>
#include "GameManager.h"<br>
<br>
// 敵の基底クラス。<br>
// 全ての敵は、このクラスを継承して作る。<br>
// ★【勉強】abstract型はC++にない!!【純粋仮想関数】を使って作る<br>
// クラスの基本(C++11).pdfの17ページの下のほう(クラスの基本④)<br>
class Enemy : public GameObject<br>
{<br>
public:<br><br>
&nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
&nbsp;&nbsp;GameManager& gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&)を得る<br>
<br>
&nbsp;&nbsp;<em>float collisionRadius = 32; // 当たり判定の半径</em><br>
&nbsp;&nbsp;<em>float life = 1; // 耐久力</em><br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;Enemy(float x, float y, float z=0)//★z=0をデフォルトとすることでx,yだけでも初期化でき2Dと3D両立<br>
&nbsp;&nbsp;&nbsp;&nbsp;: GameObject() // GameObjectをベースとして初期化処理を継承する<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;typeTag = "Enemy";<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z = z;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理。派生クラスでオーバーライドして使う<br>
&nbsp;&nbsp;virtual void Update() = 0;//virtual ～ = 0;で【純粋仮想関数に】これで【C#のabstract型に】<br>
<br>
&nbsp;&nbsp;// 描画処理。派生クラスでオーバーライドして使う<br>
&nbsp;&nbsp;virtual void Draw() = 0; //virtual ～ = 0;で【純粋仮想関数に】【関数 = 0で未定義状態を表現】<br>
<br>
&nbsp;&nbsp;//【勉強】関数 = 0って何?と思った人は【関数もメモリ上では住所アドレスに過ぎない】ことを知ろう<br>
&nbsp;&nbsp;// ★関数 = 0はつまり関数の住所ポインタの針が【メモリ上の何かを針で参照してない(住所不定無処理)】<br>
&nbsp;&nbsp;// つまり【関数が未定義ってこと】＝【あいまい部分があるabstractクラスってこと】<br>
&nbsp;&nbsp;//http://etc2myday.jugem.jp/?eid=204<br>
&nbsp;&nbsp;//http://wisdom.sakura.ne.jp/programming/c/c54.html<br>
&nbsp;&nbsp;//逆にいうと【関数を配列】にするっていうトリッキーなこともできる!<br>
&nbsp;&nbsp;//http://www.ced.is.utsunomiya-u.ac.jp/lecture/2012/prog/p3/kadai3/virtualfunc2.php<br>
<br>
&nbsp;&nbsp;<em>// 自機弾に当たったときの処理 関数の【★引数をGameObject型↓にすることで循環インクルード抑止】<br>
&nbsp;&nbsp;virtual void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;life -= 1; // ライフを減らす<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ライフが無くなったら、死亡<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (life &lt;= 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}</em><br>
};<br>
<br>
#endif<br>
</p>
	
	
	<p><code>PlayerBullet.h</code>を改修します。当たり判定を表す変数を追加します。</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
#define PLAYERBULLET_H_<br>
<br>
#include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要<br>
<br>
#include "DxLib.h"<br>
#include "Image.h"<br>
#include "Screen.h"<br>
<br>
#include "GameObject.h"<br>
<br>
// 自機弾クラス<br>
// 継承するときは↓ : public ～にする。publicをつけ忘れると色々エラー出るので注意<br>
class PlayerBullet: public GameObject<br>
{<br>
public:<br>
&nbsp;&nbsp;const float Speed = 25; // 移動速度<br>
&nbsp;&nbsp;const int VisibleRadius = 16; // 見た目の半径<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
&nbsp;&nbsp;//【実験コード】int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ<br>
<br>
&nbsp;&nbsp;<em>float collisionRadius = 16; // 当たり判定の半径</em><br>
&nbsp;&nbsp;float angle; // 移動角度<br>
<br>
<br>
&nbsp;&nbsp;(中略)....................<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;(中略)....................<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, angle, Image::playerBullet,TRUE);<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;<em>// 敵にぶつかった時の処理<br>
&nbsp;&nbsp;void OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
&nbsp;&nbsp;}</em><br>
};<br>
<br>
#endif<br></p>

	<p><code>Game.cpp</code>を改修します。自機弾と敵が当たっているか調べる処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
#include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
<br>
&nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
<br>
&nbsp;&nbsp;// 自機弾の更新処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 敵の更新処理<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.enemies)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<em>// 自機弾と敵の衝突判定<br>
&nbsp;&nbsp;for(const auto&amp; playerBullet : gm.playerBullets)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾が死んでたらスキップする<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾と敵が重なっているか？<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;x, playerBullet-&gt;y, playerBullet-&gt;collisionRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;x, enemy-&gt;y, enemy-&gt;collisionRadius))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;OnCollisionEnemy(enemy);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}</em><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
<br>
&nbsp;&nbsp;<em>// 敵のリストから死んでるものを除去する<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
&nbsp;&nbsp;<br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
(以下略)............<br>
</p>

	<h1><a id="mozTocId2002" class="mozTocH1"></a>敵に耐久力を持たせる(おまけでSinの波運動のコード例も)</h1>
	
<p><code>Zako1.h</code>のlifeを5にすることでZako1を硬くしてみましょう。<br>
ついでにsinの波運動も試してみましょう。</p>
<p class="source">#ifndef ZAKO_1_H_<br>
#define ZAKO_1_H_<br>
<br>
#include "Enemy.h"<br>
<br>
<em>#include &lt;cmath&gt; // Sinの計算に使う<br>
#include "MyMath.h"</em><br>
#include "Image.h"<br>
<br>
// ザコ1クラス<br>
class Zako1 : public Enemy<br>
{<br>
public:<br>
&nbsp;&nbsp;<em>float sinMove = 0; // Sinの動きをする際の0～360度</em><br>
&nbsp;&nbsp;<em>float sinRadius = 70; // Sinの動きをするときの半径</em><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;Zako1(float x, float y, float z=0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;: Enemy(x, y, z)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako1";//オブジェクトの種類判別タグ<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>life = 5;</em><br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update() override<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;x -= 1; // 左へ移動<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>float prevSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>sinMove += 2.5f; // Sinの波運動の角度を進める</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>float currentSinY = std::sin(sinMove * MyMath::Deg2Rad) * sinRadius;</em><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>// (前の角度でのY) - (今の角度でのY)の差を足すことで【ベースのyの位置 ± sinの動き】になる</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>y += currentSinY - prevSinY; // 上下方向のSinの波運動</em><br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw() override<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::zako1, TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
#endif<br>
</p>
	
	<p><code>Game.cpp</code>にZako1の生成処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
#include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<em>#include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
<br>
&nbsp;&nbsp;// とりあえず適当に敵を生成<br>
&nbsp;&nbsp;gm.enemies.push_back(std::make_shared&lt;Zako0&gt;((float)600, (float)100));<br>
&nbsp;&nbsp;gm.enemies.push_back(std::make_shared&lt;Zako0&gt;((float)1000, (float)500));<br>
&nbsp;&nbsp;<em>gm.enemies.push_back(std::make_shared&lt;Zako1&gt;((float)1000, (float)150));</em><br>
};<br>
<br>
	    
	<h1><a id="mozTocId2003" class="mozTocH1"></a>自機と敵の当たり判定</h1>
	

<p><code>Player.h</code>に当たり判定半径を定義します。</p>
    <p class="source">#ifndef PLAYER_H_<br>
#define PLAYER_H_<br>
<br>
#include "DxLib.h"<br>
#include "Input.h"<br>
#include "Image.h"<br>
#include "MyMath.h"<br>
<br>
#include&nbsp;"GameObject.h"<br>
<br>
#include&nbsp;"GameManager.h"<br>
<br>
// 継承するときは↓ : public ～にする。publicをつけ忘れると色々エラー出るので注意<br>
class Player : public GameObject<br>
{<br>
public:<br>
&nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
<br>
&nbsp;&nbsp;<em>float collisionRadius = 32; // 当たり判定半径</em><br>
<br>
&nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
&nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;// x : 初期位置x<br>
&nbsp;&nbsp;// y : 初期位置y<br>
&nbsp;&nbsp;Player(float x, float y, float z=0) // z=0デフォルトにして2Dのときはzを省略できる<br>
&nbsp;&nbsp;&nbsp;&nbsp;: GameObject() //【忘れると】GameObjectの初期化処理が飛ばされて大混乱！<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z = z;//[3D対応]<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理の関数定義<br>
&nbsp;&nbsp;void Update();<br>  
<br>
&nbsp;&nbsp;// 描画処理の関数定義<br>
&nbsp;&nbsp;void Draw();<br>
<br>
&nbsp;&nbsp;<em>// 敵にぶつかった時の処理<br>
&nbsp;&nbsp;void OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other);</em><br>
};<br>
<br>
#endif</p>
	
	<p><code>Player.cpp</code>に敵との当たり判定処理を追加します。</p>
    <p class="source">
#include&nbsp;"Player.h"<br>
<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;弾を生成して【使う処理があるのでインクルード必要】<br>
<br>
// 更新処理<br>
void Player::Update()<br>
{<br>
&nbsp;&nbsp;// 継承したGameObjectにvx,vyがあるのでvx,vyをfloatで定義し直さないように注意<br>
&nbsp;&nbsp;vx = 0; // x方向移動速度<br>
&nbsp;&nbsp;vy = 0; // y方向移動速度<br>
<br>
&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
&nbsp;&nbsp;if (vx != 0 &amp;&amp; vy != 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 実際に位置を動かす<br>
&nbsp;&nbsp;x += vx;<br>
&nbsp;&nbsp;y += vy;<br>
<br>
&nbsp;&nbsp;// ボタン押下で自機弾を発射<br>
&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;C++ではAddがpush_backに↓&nbsp;newがmake_shared↓に<br>
&nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.push_back(std::make_shared&lt;PlayerBullet&gt;x, y, 0));//右<br>  
&nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.push_back(std::make_shared&lt;PlayerBullet&gt;(x, y, -15 * MyMath::Deg2Rad));//右上<br>  
&nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.push_back(std::make_shared&lt;PlayerBullet&gt;(x, y, +15 * MyMath::Deg2Rad));//右下<br>  
&nbsp;&nbsp;}<br>
}<br>  
<br>
// 描画処理<br>
void Player::Draw()<br>
{<br>
&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::player, TRUE);<br>
}<br>
<br>
<em>// 敵にぶつかった時の処理<br>
void Player::OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other)<br>
{<br>
&nbsp;&nbsp;isDead = true;<br>
}</em><br>
</p>
	
	<p><code>Game.cpp</code>を改修します。自機が死んだとき消す処理と自機と敵の衝突判定を追加します。</p>
    <p class="source">#include "Game.h"<br>
#include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
<br>
&nbsp;&nbsp;<em>if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
&nbsp;&nbsp;&nbsp;&nbsp;</em>gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
<br>
&nbsp;&nbsp;// 自機弾の更新処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 敵の更新処理<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.enemies)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 自機弾と敵の衝突判定<br>
&nbsp;&nbsp;for(const auto&amp; playerBullet : gm.playerBullets)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾が死んでたらスキップする<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾と敵が重なっているか？<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;x, playerBullet-&gt;y, playerBullet-&gt;collisionRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;x, enemy-&gt;y, enemy-&gt;collisionRadius))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;OnCollisionEnemy(enemy);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<em>// 自機と敵の衝突判定<br>
&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップ<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;x, gm.player-&gt;y, gm.player-&gt;collisionRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;x, enemy-&gt;y, enemy-&gt;collisionRadius))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;OnCollisionEnemy(enemy);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}</em><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
<br>
&nbsp;&nbsp;// 敵のリストから死んでるものを除去する<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
&nbsp;&nbsp;<br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;// 敵の描画処理<br>
&nbsp;&nbsp;for (const auto&amp; e : gm.enemies)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Draw();<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;<em>if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
&nbsp;&nbsp;&nbsp;&nbsp;</em>gm.player-&gt;Draw(); // プレイヤの描画【忘れるとプレイヤ表示されない】<br>
<br>
&nbsp;&nbsp;// 自機弾の描画処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
&nbsp;&nbsp;}<br>
};<br>
</p>
	
	<h1><a id="mozTocId2004" class="mozTocH1"></a>自機のライフの作成</h1>
	
	<p><code>Player.h</code>にライフと無敵時間を定義します。</p>
    <p class="source">#ifndef PLAYER_H_<br>
#define PLAYER_H_<br>
<br>
#include "DxLib.h"<br>
#include "Input.h"<br>
#include "Image.h"<br>
#include "MyMath.h"<br>
<br>
#include&nbsp;"GameObject.h"<br>
<br>
#include&nbsp;"GameManager.h"<br>
<br>
// 継承するときは↓ : public ～にする。publicをつけ忘れると色々エラー出るので注意<br>
class Player : public GameObject<br>
{<br>
public:<br>
&nbsp;&nbsp;const float MoveSpeed = 6; // 移動速度<br>
&nbsp;&nbsp;<em>int MutekiJikan = 120; // 無敵時間</em><br>
<br>
&nbsp;&nbsp;float collisionRadius = 32; // 当たり判定半径<br>
<br>
&nbsp;&nbsp;<em>int life = 3; // ライフ</em><br>
&nbsp;&nbsp;<em>int mutekiTimer = 0; // 残り無敵時間。0以下なら無敵じゃないってこと</em><br>
<br>
&nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
&nbsp;&nbsp;GameManager&amp; gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&amp;)を得る<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;// x : 初期位置x<br>
&nbsp;&nbsp;// y : 初期位置y<br>
&nbsp;&nbsp;Player(float x, float y, float z=0) // z=0デフォルトにして2Dのときはzを省略できる<br>
&nbsp;&nbsp;&nbsp;&nbsp;: GameObject() //【忘れると】GameObjectの初期化処理が飛ばされて大混乱！<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z = z;//[3D対応]<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理の関数定義<br>
&nbsp;&nbsp;void Update();<br>  
<br>
&nbsp;&nbsp;// 描画処理の関数定義<br>
&nbsp;&nbsp;void Draw();<br>
<br>
&nbsp;&nbsp;// 敵にぶつかった時の処理<br>
&nbsp;&nbsp;void OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other);<br>
<br>	    
&nbsp;&nbsp;<em>// ダメージを受ける処理<br>
&nbsp;&nbsp;void TakeDamage();</em><br>
};<br>
<br>
#endif</p>
	
	<p><code>Player.cpp</code>に敵との当たり判定処理を追加します。</p>
    <p class="source">
#include&nbsp;"Player.h"<br>
<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;弾を生成して【使う処理があるのでインクルード必要】<br>
<br>
// 更新処理<br>
void Player::Update()<br>
{<br>
&nbsp;&nbsp;// 継承したGameObjectにvx,vyがあるのでvx,vyをfloatで定義し直さないように修正<br>
&nbsp;&nbsp;<u>float </u>vx = 0; // x方向移動速度<br>
&nbsp;&nbsp;<u>float </u>vy = 0; // y方向移動速度<br>
<br>
&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = -MoveSpeed; // 左<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_RIGHT))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = MoveSpeed; // 右<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy = -MoveSpeed; // 上<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else if (Input::GetButton(PAD_INPUT_DOWN))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy = MoveSpeed; // 下<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 斜め移動も同じ速度になるように調整<br>
&nbsp;&nbsp;if (vx != 0 &amp;&amp; vy != 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy /= MyMath::Sqrt2;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 実際に位置を動かす<br>
&nbsp;&nbsp;x += vx;<br>
&nbsp;&nbsp;y += vy;<br>
<br>
&nbsp;&nbsp;// ボタン押下で自機弾を発射<br>
&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_1))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;C++ではAddがpush_backに↓&nbsp;newがmake_shared↓に<br>
&nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.push_back(std::make_shared&lt;PlayerBullet&gt;x, y, 0));//右<br>  
&nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.push_back(std::make_shared&lt;PlayerBullet&gt;(x, y, -15 * MyMath::Deg2Rad));//右上<br>  
&nbsp;&nbsp;&nbsp;&nbsp;gm.playerBullets.push_back(std::make_shared&lt;PlayerBullet&gt;(x, y, +15 * MyMath::Deg2Rad));//右下<br>  
&nbsp;&nbsp;}<br>
<br>    
&nbsp;&nbsp;<em>mutekiTimer--; // 無敵タイマーは無条件で毎フレームカウントダウン</em><br>
}<br>  
<br>
// 描画処理<br>
void Player::Draw()<br>
{<br>
&nbsp;&nbsp;<em>// 無敵ではない場合は描画<br>
&nbsp;&nbsp;// 無敵中は2フレームに1回描画（点滅）<br>
&nbsp;&nbsp;if (mutekiTimer &lt;= 0 || mutekiTimer % 2 == 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;</em>DrawRotaGraphF(x, y, 1, 0, Image::player, TRUE);<br>
}<br>
<br>
// 敵にぶつかった時の処理<br>
void Player::OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other)<br>
{<br>
&nbsp;&nbsp;<em>// 無敵じゃなければダメージを受ける<br>
&nbsp;&nbsp;if (mutekiTimer &lt;= 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;TakeDamage();<br>
&nbsp;&nbsp;}</em><br>
}<br>
<br>
<em>// ダメージを受ける処理<br>
void Player::TakeDamage()<br>
{<br>
&nbsp;&nbsp;life -= 1; // ライフ減少<br>
<br>
&nbsp;&nbsp;if (life &lt;= 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ライフが無くなったら死亡<br>
&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 無敵時間発動<br>
&nbsp;&nbsp;&nbsp;&nbsp;mutekiTimer = MutekiJikan;<br>
&nbsp;&nbsp;}<br>
}</em><br>
</p>

<h1><a id="mozTocId2005" class="mozTocH1"></a>敵弾の作成</h1>	
	<h2><a id="mozTocId20051" class="mozTocH1"></a>敵弾の作成(発射間隔を空けて撃つ方法を学ぶ)</h2>

		<p><code>EnemyBullet.h</code>を新規作成します。</p>
    <p class="source">#ifndef ENEMYBULLET_H_<br>
#define ENEMYBULLET_H_<br>
<br>
#include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要<br>
<br>
#include "DxLib.h"<br>
#include "Image.h"<br>
#include "Screen.h"<br>
<br>
#include "GameObject.h"<br>
<br>
// 敵弾クラス<br>
class EnemyBullet: public GameObject<br>
{<br>
public:<br>
&nbsp;&nbsp;const int VisibleRadius = 8; // 見た目の半径<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// ↓【使用要注意！(テスト用！！)】メモリ消費弾(4MB)撃つたびに4MB消費(下の行のコメント外すと)<br>
&nbsp;&nbsp;//【実験コード】int memMUDA[1000000]; // 4バイト×1000000= 4MBの無駄メモリ<br>
<br>
&nbsp;&nbsp;float angle; // 移動角度(垂直Vertical)<br>
&nbsp;&nbsp;float angleH=0; // 移動角度(水平Horizontal)<br>
<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;EnemyBullet(float x, float y, float angle, float speed)<br>
&nbsp;&nbsp;&nbsp;&nbsp;: GameObject()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angle = angle;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 角度からx方向の移動速度を算出<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = (float)std::cos(angle) * speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 角度からy方向の移動速度を算出<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy = (float)std::sin(angle) * speed;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// [3D版]コンストラクタ<br>
&nbsp;&nbsp;EnemyBullet(float x, float y, float z, float angleV, float angleH, float speed)<br>
&nbsp;&nbsp;&nbsp;&nbsp;: GameObject()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z = z; // [3D版]<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angle = angleV;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;angleH = angleH;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// [3Dの角度は水平・垂直に分割]https://teratail.com/questions/126004<br>
&nbsp;&nbsp;&nbsp;&nbsp;float cosAngleV = (float)std::cos(angle);<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 角度からx方向の移動速度を算出<br>
&nbsp;&nbsp;&nbsp;&nbsp;vx = cosAngleV * (float)std::sin(angleH) * speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 角度からy方向の移動速度を算出<br>
&nbsp;&nbsp;&nbsp;&nbsp;vy = (float)std::sin(angle) * speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 角度からz方向の移動速度を算出<br>
&nbsp;&nbsp;&nbsp;&nbsp;vz = cosAngleV * (float)std::cos(angleH) * speed;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 速度の分だけ移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;x += vx;<br>
&nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 画面外に出たら死亡フラグを立てる<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (y + VisibleRadius &lt; 0 || y - VisibleRadius > Screen::Height ||<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x + VisibleRadius &lt; 0 || x - VisibleRadius > Screen::Width)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, angle, Image::enemyBullet16,TRUE);<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// プレイヤにぶつかった時の処理<br>
&nbsp;&nbsp;void OnCollisionPlayer(std::shared_ptr&lt;GameObject&gt; other)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
#endif<br></p>
	
<p><code>GameManager.h</code>にEnemyBulletを管理するリストの定義を追加します。</p>
<p class="source">
#ifndef GAMEMANAGER_H_<br>
#define GAMEMANAGER_H_<br>
<br>
#include &lt;memory&gt;<br>
#include &lt;vector&gt;<br>
<br>
#include&nbsp;"Singleton.h"<br>
<br>
class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
class&nbsp;PlayerBullet;<br>
class&nbsp;Enemy;<br>
<em>class&nbsp;EnemyBullet;</em><br>
<br>
class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
{<br>
public:<br>
&nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
<br>
&nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機のポインタ<br>
&nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
&nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
&nbsp;&nbsp;<em>std::vector&lt;std::shared_ptr&lt;EnemyBullet&gt;&gt; enemyBullets; // 敵弾のリスト</em><br>
&nbsp;&nbsp;// List↑と同じvector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
<br>
<br>
(中略)..............
<br>
protected:<br>
&nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
&nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
};<br>
<br>
#endif<br>
</p>
	
<p><code>Game.cpp</code>にEnemyBulletの更新Updateと削除Remove、描画Drawの処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
#include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<em>#include&nbsp;"EnemyBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
#include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
<br>
&nbsp;&nbsp;if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
<br>
&nbsp;&nbsp;// 自機弾の更新処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;<em>// 敵弾の更新処理<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.enemyBullets)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}</em><br>
<br>
&nbsp;&nbsp;// 敵の更新処理<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.enemies)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 自機弾と敵の衝突判定<br>
&nbsp;&nbsp;for(const auto&amp; playerBullet : gm.playerBullets)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾が死んでたらスキップする<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾と敵が重なっているか？<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;x, playerBullet-&gt;y, playerBullet-&gt;collisionRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;x, enemy-&gt;y, enemy-&gt;collisionRadius))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;OnCollisionEnemy(enemy);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 自機と敵の衝突判定<br>
&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップ<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;x, gm.player-&gt;y, gm.player-&gt;collisionRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;x, enemy-&gt;y, enemy-&gt;collisionRadius))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;OnCollisionEnemy(enemy);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
&nbsp;&nbsp;// 敵のリストから死んでるものを除去する<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
&nbsp;&nbsp;// 敵弾のリストから死んでるものを除去する<br>
&nbsp;&nbsp;<em>gm.EraseRemoveIf(gm.enemyBullets,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;EnemyBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
&nbsp;&nbsp;<br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;DrawRotaGraphF(x, 200, 0.9f, 0, Image::bossImage, TRUE);<br>
<br>
&nbsp;&nbsp;// 敵の描画処理<br>
&nbsp;&nbsp;for (const auto&amp; e : gm.enemies)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Draw();<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;Draw(); // プレイヤの描画【忘れるとプレイヤ表示されない】<br>
<br>
&nbsp;&nbsp;// 自機弾の描画処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 敵の描画処理<br>
&nbsp;&nbsp;for (const auto&amp; e : gm.enemyBullets)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Draw();<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;<em>// 敵弾の描画処理<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.enemyBullets)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Draw();<br>
&nbsp;&nbsp;}</em><br>
};<br>
</p>	

<p><code>Zako0.h</code>に弾を発射間隔を開けながら撃たせます。</p>
<p class="source">#ifndef ZAKO_0_H_<br>
#define ZAKO_0_H_<br>
<br>
#include "Enemy.h"<br>
#include "Image.h"<br>
<em>#include "MyMath.h"</em><br>
<br>
// ザコ0クラス<br>
class Zako0 : public Enemy<br>
{<br>
public:<br>
&nbsp;&nbsp;<em>int counter = 0;</em><br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;Zako0(float x, float y, float z=0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;: Enemy(x, y, z)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako0";<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update() override<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;x -= 1; // とりあえず左へ移動<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>counter++;</em><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>if (counter % 10 == 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.enemyBullets.push_back(std::make_shared&lt;EnemyBullet&gt;(x, y, 180 * MyMath::Deg2Rad, 8));<br>
&nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw() override<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::zako0, TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
#endif<br>
</p>

	<p><code>Zako0.h</code>の弾の発射間隔を開ける方法は別のやり方もあります。</p>
<p class="source">#ifndef ZAKO_0_H_<br>
#define ZAKO_0_H_<br>
<br>
#include "Enemy.h"<br>
#include "Image.h"<br>
<em>#include "MyMath.h"</em><br>
<br>
// ザコ0クラス<br>
class Zako0 : public Enemy<br>
{<br>
public:<br>
&nbsp;&nbsp;<em>int coolTime = 0; // クールタイム（冷却時間。0になるまで次の弾が撃てない）</em><br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;Zako0(float x, float y, float z=0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;: Enemy(x, y, z)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako0";<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update() override<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;x -= 1; // とりあえず左へ移動<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>coolTime--;</em><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<em>if (coolTime &lt;= 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.enemyBullets.push_back(std::make_shared&lt;EnemyBullet&gt;(x, y, 180 * MyMath::Deg2Rad, 8));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coolTime += 10;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw() override<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::zako0, TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
#endif<br>
</p>
	
	<h2><a id="mozTocId20052" class="mozTocH1"></a>練習問題(色んな弾の撃ち方を試す)</h2>
	
<p>弾の発射角度の方向を180度 + (-15度～+15度)にすることで散乱弾を実現します。</p>
<p>まず、乱数生成に必要な乱数クラス<code>MyRandom.h</code>を作成します。</p>
	
	<p class="source">#ifndef MYRANDOM_H_<br>
#define MYRANDOM_H_<br>
<br>
#include &lt;random&gt;<br>
<br>
class MyRandom<br>
{<br>
public:<br>
&nbsp;&nbsp;// ゲーム中で唯一のインスタンス<br>
&nbsp;&nbsp;static std::random_device rnd;// 非決定的な乱数生成器<br>
&nbsp;&nbsp;static std::mt19937 random; // メルセンヌ・ツイスタの32ビット版<br>
<br>
&nbsp;&nbsp;// 初期化（シード指定無し）<br>
&nbsp;&nbsp;static void Init()<br>
&nbsp;&nbsp;{   // https://cpprefjp.github.io/reference/random/random_device.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;random.seed(rnd()); // 乱数をシードにすることで毎回ランダムにする<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 初期化（シードを指定）<br>
&nbsp;&nbsp;static void Init(int seed)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;random.seed(seed);<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 指定した範囲の整数の乱数を取得する（maxは出ないので注意）<br>
&nbsp;&nbsp;static int Range(int min, int max)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;std::uniform_int_distribution<> randRange(min, max); // [0, 99] 範囲の一様乱数<br>
&nbsp;&nbsp;&nbsp;&nbsp;return randRange(random);<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 指定した範囲の小数の乱数を取得する（maxは出ないので注意）<br>
&nbsp;&nbsp;static float Range(float min, float max)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;std::uniform_real_distribution<> randRange(min, max); // [0, 99] 範囲の一様乱数<br>
&nbsp;&nbsp;&nbsp;&nbsp;return (float)randRange(random);<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 指定した確率（％）でtrueになる<br>
&nbsp;&nbsp;static bool Percent(float probability)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return Range(0.0f, 1.0f) * 100 &lt;= probability;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 指定した範囲で乱数を返却する。<br>
&nbsp;&nbsp;// 例えば1.5fを指定すると、-1.5～+1.5の範囲の値を返却する。<br>
&nbsp;&nbsp;static float PlusMinus(float value)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return Range(-value, value);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
#endif<br></p>

	<p>staticなクラスなので<code>MyRandom.cpp</code>を作成して変数をcppで定義初期化します。</p>
<p class="source">#include "MyRandom.h"<br>
<br>
std::random_device MyRandom::rnd;// 非決定的な乱数生成器<br>
std::mt19937 MyRandom::random; // メルセンヌ・ツイスタの32ビット版 https://qiita.com/angel_p_57/items/971d0208186f81d5d044<br>
</p>
	
<p><code>Zako2.h</code>を作成して弾の発射方向を-15度～+15度までランダムに散らすようにしてみます。</p>
<p class="source">#ifndef ZAKO_2_H_<br>
#define ZAKO_2_H_<br>
<br>
#include "Enemy.h"<br>
#include "Image.h"<br>
#include "Screen.h"<br>
#include &lt;cmath&gt; // Sin Cosの計算に使う<br>
#include "MyMath.h"<br>
#include "MyRandom.h"<br>
<br>
// ザコ2クラス<br>
class Zako2 : public Enemy<br>
{<br>
public:<br>
&nbsp;&nbsp;int coolTime = 0; // クールタイム（冷却時間。0になるまで次の弾が撃てない）<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;Zako2(float x, float y, float z=0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;: Enemy(x, y, z)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako2";<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update() override<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if(x &gt; Screen::Width - 200)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{  // スクリーンの端から200の位置で止まる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x -= 1; // とりあえず左へ移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;coolTime--;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (coolTime &lt;= 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float bulletAngle = MyRandom::Range(-15.0f,15.0f); // ±15度の乱数の角度を取得<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.enemyBullets.push_back(std::make_shared&lt;EnemyBullet&gt;(x, y, (180 + bulletAngle) * MyMath::Deg2Rad, 8));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coolTime += 10;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw() override<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::zako2, TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
#endif<br>
</p>

<p><code>Game.cpp</code>にMyRandom乱数とザコ2の初期化を追加します。</p>
    <p class="source">#include "Game.h"<br>
#include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"EnemyBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<em>#include&nbsp;"Zako2.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
<br>
void Game::Init()<br>
{// Init処理<br>
&nbsp;&nbsp;Image::Load(); //画像の読込み<br>
&nbsp;&nbsp;<em>MyRandom::Init(); // 乱数シードの初期化</em><br>
<br>
&nbsp;&nbsp;(中略)..................<br>
<br>
&nbsp;&nbsp;// とりあえず適当に敵を生成<br>
&nbsp;&nbsp;gm.enemies.push_back(std::make_shared&lt;Zako0&gt;((float)600, (float)100));<br>
&nbsp;&nbsp;gm.enemies.push_back(std::make_shared&lt;Zako0&gt;((float)1000, (float)500));<br>
&nbsp;&nbsp;gm.enemies.push_back(std::make_shared&lt;Zako1&gt;((float)1000, (float)150));<br>
&nbsp;&nbsp;<em>gm.enemies.push_back(std::make_shared&lt;Zako2&gt;((float)1200, (float)250));</em><br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
<br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
};<br>
</p>
<br>	
	<p>どうでしょうか(-15度～+15度)の散乱弾を撃つ敵キャラを作れましたか？</p>
	<p>まずはザコ2を試してみましょう。うまくいったら次のザコ3を試してみましょう。</p>
	<p> <img src="image/gif01.gif" alt=""></p>
<br>
	<p><a id="mozTocId20053" class="mozTocH1"></a>こんどは<code>Zako3.h</code>を作成して10ダメージ受けると点滅状態(5秒=5×60=300フレーム)になり、isDeadと同時に弾を全方向に0度～360度に散らすようにしてみます。</p>
	<p>勉強になるテクニックとして【共通処理の上書きオーバーライド】や【点滅処理の条件式】や【ド・モルガンの定理】を使っているので上級者も1度は試してみましょう。</p>
<p class="source">#ifndef ZAKO_3_H_<br>
#define ZAKO_3_H_<br>
<br>
#include "Enemy.h"<br>
#include "Image.h"<br>
#include "Screen.h"<br>
#include &lt;cmath&gt; // Sin Cosの計算に使う<br>
#include "MyMath.h"<br>
#include "MyRandom.h"<br>
<br>
// ザコ3クラス(自爆型機雷タイプの敵キャラ)<br>
class Zako3 : public Enemy<br>
{<br>
public:<br>
&nbsp;&nbsp;int bombCounter = -1; // やられたときのisDeadまでのカウントダウン<br>
&nbsp;&nbsp;int BombTime = 300; // 爆発までのカウント時間<br>
&nbsp;&nbsp;int life = 10; // 敵ライフ<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;Zako3(float x, float y, float z=0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;: Enemy(x, y, z)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Zako3";<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update() override<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if(x &gt; Screen::Width - 350)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{  // スクリーンの端から350の位置で止まる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x -= 1; // とりあえず左へ移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;{  // スクリーン端から350の位置で自爆モードに入る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;life = 0; // 画面中央付近で勝手にlife=0で自爆モードに入る<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;bombCounter--; // 爆発カウンタは常にカウントダウン(-1から始まるときは0を通過しないので爆発しない)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if(life &lt;= 0 && bombCounter &lt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bombCounter = BombTime; // 爆発モードに入る(bombCounterがプラス値になり0になると爆発)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (bombCounter == 0) // 初期状態は-1からカウントダウン-1,-2,-3..するからここには入らずに済む<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i=0; i &lt; 360; i = i+10) //【勉強】for文は1ずつプラスじゃなくてもよい<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.enemyBullets.push_back(std::make_shared&lt;EnemyBullet&gt;(x, y, (180 + i) * MyMath::Deg2Rad, 6));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // 爆発カウンタ==0で初めてisDead状態に<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 【勉強】共通処理を上書きオーバーライドで上塗りして共通処理を無効化・乗っ取るテクニック<br>
&nbsp;&nbsp;// 自機弾との衝突処理を★【上書きオーバーライド】して死亡フラグが立たないように<br>
&nbsp;&nbsp;void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet) override<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;life -= 1; // ライフを減らす<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 死亡フラグはこのザコ3だけ特別に衝突ではONにしない<br>
&nbsp;&nbsp;}<br>
<br>	
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw() override<br>
&nbsp;&nbsp;{&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;//【ド・モルガンの定理を学ぼう】||と&&の逆の関係性の法則<br>
&nbsp;&nbsp;&nbsp;&nbsp;//【勉強】条件【または||】は条件【かつ&&】の(life &lt;= 0 && bombCounter &gt; 0)のちょうど逆条件！<br>
&nbsp;&nbsp;&nbsp;&nbsp;if(life &gt; 0 || bombCounter &lt;= 0<br>
&nbsp;&nbsp;&nbsp;&nbsp; || (bombCounter % 8 &lt; 4) ) //[点滅]パラパラ8枚の周期で余り4以下の時だけ描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::zako3, TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
#endif<br>
</p>

	<p><code>Game.cpp</code>にザコ3の生成処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
#include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"EnemyBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako2.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<em>#include&nbsp;"Zako3.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
<br>
&nbsp;&nbsp;// とりあえず適当に敵を生成<br>
&nbsp;&nbsp;gm.enemies.push_back(std::make_shared&lt;Zako0&gt;((float)600, (float)100));<br>
&nbsp;&nbsp;gm.enemies.push_back(std::make_shared&lt;Zako0&gt;((float)1000, (float)500));<br>
&nbsp;&nbsp;gm.enemies.push_back(std::make_shared&lt;Zako1&gt;((float)1000, (float)150));<br>
&nbsp;&nbsp;gm.enemies.push_back(std::make_shared&lt;Zako2&gt;((float)1200, (float)250));<br>
&nbsp;&nbsp;<em>gm.enemies.push_back(std::make_shared&lt;Zako3&gt;((float)1300, (float)400));</em><br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
<br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
};<br>
</p>	
<br>
	<p>どうでしょうか爆弾っぽい自爆タイプの敵キャラが作れましたか？</p>
	<p> <img src="image/zako3_selfbomb.gif" alt=""></p></p>
	
<br>	
	
<a id="mozTocId3000" class="mozTocH1"></a>
</body>
<body>
    <p class="title">[C++移植]シューティングゲーム 3</p>
    <br>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId3001">自機と敵弾の当たり判定</a></li>
      <li><a href="#mozTocId3002">爆発エフェクトの作成(分割画像DivImage型の定義)</a></li>
      <li><a href="#mozTocId3003">ボスの作成</a></li>
	    <br>
	    <p>次のテキスト4はこちら。</p><br>
	    <a href="#mozTocId4000">[C++移植]シューティングゲーム 4</a><br>
    </ol>
    <h1><a id="mozTocId3001" class="mozTocH1"></a>自機と敵弾の当たり判定</h1>
	
    <p>自機と敵弾がぶつかったら、自機がダメージを受けるようにしましょう。</p>
	
	<p><code>EnemyBullet.h</code>に当たり判定の大きさを表す変数を追加します。</p>
    <p class="source">#ifndef ENEMYBULLET_H_<br>
#define ENEMYBULLET_H_<br>
<br>
#include &lt;cmath&gt;&nbsp;//sin,cosを使うのに必要<br>
<br>
#include "DxLib.h"<br>
#include "Image.h"<br>
#include "Screen.h"<br>
<br>
#include "GameObject.h"<br>
<br>
// 敵弾クラス<br>
class EnemyBullet: public GameObject<br>
{<br>
public:<br>
&nbsp;&nbsp;const int VisibleRadius = 8; // 見た目の半径<br>
&nbsp;&nbsp;<em>float collisionRadius = 8; // 当たり判定半径</em><br>
<br>
&nbsp;&nbsp;(以下略)........................<br>
</p>
	
	<p><code>Player.h</code>に敵弾とぶつかったときの処理の定義を追加します。</p>
    <p class="source">#ifndef PLAYER_H_<br>
#define PLAYER_H_<br>
<br>
#include "DxLib.h"<br>
#include "Input.h"<br>
#include "Image.h"<br>
#include "MyMath.h"<br>
<br>
#include&nbsp;"GameObject.h"<br>
<br>
#include&nbsp;"GameManager.h"<br>
<br>
// 継承するときは↓ : public ～にする。publicをつけ忘れると色々エラー出るので注意<br>
class Player : public GameObject<br>
{<br>
public:<br>
<br>
&nbsp;&nbsp;(中略)...........<br>
<br>
&nbsp;&nbsp;// 敵にぶつかった時の処理<br>
&nbsp;&nbsp;void OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other);<br>
<br>
&nbsp;&nbsp;<em>// 敵弾とぶつかった時の処理<br>
&nbsp;&nbsp;void OnCollisionEnemyBullet(std::shared_ptr&lt;GameObject&gt; other);</em><br>
<br>
&nbsp;&nbsp;// ダメージを受ける処理<br>
&nbsp;&nbsp;void TakeDamage();<br>
};<br>
<br>
#endif</p>
	
	<p><code>Player.cpp</code>に敵弾とぶつかったときの処理を追加します。</p>
    <p class="source">
#include&nbsp;"Player.h"<br>
<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;弾を生成して【使う処理があるのでインクルード必要】<br>
<br>
// 更新処理<br>
void Player::Update()<br>
{<br>
&nbsp;&nbsp;(中略).........<br>
}<br>  
<br>
// 描画処理<br>
void Player::Draw()<br>
{<br>
&nbsp;&nbsp;(中略).........<br>
}<br>
<br>
// 敵にぶつかった時の処理<br>
void Player::OnCollisionEnemy(std::shared_ptr&lt;GameObject&gt; other)<br>
{<br>
&nbsp;&nbsp;<em>// 無敵じゃなければダメージを受ける<br>
&nbsp;&nbsp;if (mutekiTimer &lt;= 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;TakeDamage();<br>
&nbsp;&nbsp;}</em><br>
}<br>
<br>
<em>// 敵弾とぶつかった時の処理<br>
void Player::OnCollisionEnemyBullet(std::shared_ptr&lt;GameObject&gt; other)<br>
{<br>
&nbsp;&nbsp;// 無敵じゃなければダメージを受ける<br>
&nbsp;&nbsp;if (mutekiTimer &lt;= 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;TakeDamage();<br>
&nbsp;&nbsp;}<br>
}</em><br>
<br>
// ダメージを受ける処理<br>
void Player::TakeDamage()<br>
{<br>
&nbsp;&nbsp;life -= 1; // ライフ減少<br>
<br>
&nbsp;&nbsp;if (life &lt;= 0)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ライフが無くなったら死亡<br>
&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 無敵時間発動<br>
&nbsp;&nbsp;&nbsp;&nbsp;mutekiTimer = MutekiJikan;<br>
&nbsp;&nbsp;}<br>
}<br>
</p>
	
		<p><code>Game.cpp</code>に当たり判定の処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
#include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"EnemyBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako2.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako3.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
<br>
&nbsp;&nbsp;if (!gm.player-&gt;isDead) // 自機が死んでいなければ<br>
&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
<br>
&nbsp;&nbsp;// 自機弾の更新処理<br>
&nbsp;&nbsp;// C#のforeach文と同じく全自機弾を更新できる<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.playerBullets)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;// autoキーワードはビルドのコンパイル機械語翻訳の時に型を自動推論してくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 敵弾の更新処理<br>
&nbsp;&nbsp;for (const auto&amp; b : gm.enemyBullets)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<em>// 自機と敵弾の衝突判定<br>
&nbsp;&nbsp;foreach (const auto&amp; enemyBullet : gm.enemyBullets)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 敵弾が死んでたらスキップ<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (enemyBullet-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;x, gm.player-&gt;y, gm.player-&gt;collisionRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemyBullet-&gt;x, enemyBullet-&gt;y, enemyBullet-&gt;collisionRadius))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;OnCollisionEnemyBullet(enemyBullet);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}</em><br>
<br>
&nbsp;&nbsp;// 敵の更新処理<br>
&nbsp;&nbsp;for (const auto&amp; e : gm.enemies)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Update();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 自機弾と敵の衝突判定<br>
&nbsp;&nbsp;for(const auto&amp; playerBullet : gm.playerBullets)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾が死んでたらスキップする<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 自機弾と敵が重なっているか？<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;x, playerBullet-&gt;y, playerBullet-&gt;collisionRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;x, enemy-&gt;y, enemy-&gt;collisionRadius))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 重なっていたら、それぞれのぶつかったときの処理を呼び出す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;OnCollisionPlayerBullet(playerBullet);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerBullet-&gt;OnCollisionEnemy(enemy);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 衝突の結果、自機弾が死んだら、この弾のループはおしまい<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (playerBullet-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 自機と敵の衝突判定<br>
&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップ<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;x, gm.player-&gt;y, gm.player-&gt;collisionRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;x, enemy-&gt;y, enemy-&gt;collisionRadius))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;OnCollisionEnemy(enemy);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
<br>
&nbsp;&nbsp;// 敵のリストから死んでるものを除去する<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
&nbsp;&nbsp;<br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;(中略)......<br>
};<br>
</p>
	
	<h1><a id="mozTocId3002" class="mozTocH1"></a>爆発エフェクトの作成(分割画像DivImage型の定義)</h1>
	
<p><code>DivImage.h</code>を新規作成して、カスタムしたデータタイプ【DivImage型】を定義して縦2×横8の分割された爆発画像を読込みましょう。</p>
    <p class="source">#ifndef DIVIMAGE_H_<br>
#define DIVIMAGE_H_<br>
<br>
#include "DxLib.h"<br>
#include &lt;assert.h&gt; // 画像の2のべき乗チェックに使う<br>
<br>
// 分割画像を読込むためのデータ構造(画像数や画像ハンドル配列、3Dに使う場合の2のべき乗チェック機能をもつ)<br>
class DivImage<br>
{&nbsp;&nbsp;// 2Dの分割画像や3Dに分割Div画像を使うと画像全体が使われてしまうのを回避するための情報<br>
public:<br>
&nbsp;&nbsp;int XNum = 0;<br>
&nbsp;&nbsp;int YNum = 0;<br>
&nbsp;&nbsp;int XSize = 0;<br>
&nbsp;&nbsp;int YSize = 0;<br>
&nbsp;&nbsp;int* HandleArray = NULL;<br>
&nbsp;&nbsp;int AllNum = 0;<br>
&nbsp;&nbsp;bool is3DTexture = false;<br>
<br>
// 初期化 : X方向分割画像数 XNum, Y方向分割画像数 YNum, 画像 横 幅XSizeピクセル, 画像 縦 高さYSizeピクセル<br>
&nbsp;&nbsp;DivImage(int XNum, int YNum, int XSize, int YSize, bool is3DTexture=false)<br>
&nbsp;&nbsp;{   // 初期化コンストラクタ<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;XNum = XNum; // X方向分割画像数<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;YNum = YNum; // Y方向分割画像数<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;XSize = XSize; // 画像 横 幅XSize(ピクセルドット数)<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;YSize = YSize; // 画像 縦 高さYSize(ピクセルドット数)<br>
&nbsp;&nbsp;&nbsp;&nbsp;AllNum = XNum * YNum; // トータルの分割画像数<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;is3DTexture = is3DTexture; // 3Dテクスチャ分割画像かtrueだと2のべき乗チェックが入る<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ★div分割画像読込ハンドラ保存用のint配列メモリを確保し-1で初期化<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;HandleArray = new int[AllNum]; // 配列を確保し-1で初期化<br>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; AllNum; i++) HandleArray[i] = -1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;//↑【演習★】初期化後の動的配列をデバッガで見てみよう[ary,256として再評価ボタン]<br>
&nbsp;&nbsp;&nbsp;&nbsp;// http://visualstudiostudy.blog.fc2.com/blog-entry-17.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;int* ary = HandleArray;<br>
#ifdef _DEBUG // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if(is3DTexture==true) ImagePowCheck((*this)); // *(this)でthisポインタの示す変数内容を表す<br>
#endif<br>
&nbsp;&nbsp;};<br>
<br>
&nbsp;&nbsp;~DivImage()<br>
&nbsp;&nbsp;{   // デストラクタでメモリを解放<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (this-&gt;HandleArray != NULL)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete[] this-&gt;HandleArray;<br>
&nbsp;&nbsp;};<br>
<br>
&nbsp;&nbsp;//【勉強 []添え字演算子を独自に定義】https://programming.pc-note.net/cpp/operator.html<br>
&nbsp;&nbsp;// 内部のHandleArrayに今までの様にImage::explosion[5]とかで簡単アクセスできるように【あいだに噛ます】<br>	    
&nbsp;&nbsp;int const& operator [](int index) const<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if(index&lt;0 || AllNum<=index) assert("画像データのアクセス番号がおかしい！" == "");<br>
&nbsp;&nbsp;&nbsp;&nbsp;return HandleArray[index];<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;int& operator [](int index)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if(index&lt;0 || AllNum<=index) assert("画像データのアクセス番号がおかしい！" == "");<br>
&nbsp;&nbsp;&nbsp;&nbsp;return HandleArray[index];<br>
&nbsp;&nbsp;}<br>
<br>
#ifdef _DEBUG // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
&nbsp;&nbsp;bool is_pow2(unsigned int x) // 2のべき乗か計算<br>
&nbsp;&nbsp;{   // https://programming-place.net/ppp/contents/c/rev_res/math012.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;return (x != 0) && (x & (x - 1)) == 0;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;void ImagePowCheck(DivImage& divImage)<br>
&nbsp;&nbsp;{   // ★3Dに使う画像は2のべき乗でなければ受け付けないようにする<br>
&nbsp;&nbsp;&nbsp;&nbsp;// https://yttm-work.jp/gmpg/gmpg_0031.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;// https://yappy-t.hatenadiary.org/entry/20100110/1263138881<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (divImage.XSize &gt; 0 && divImage.YSize > 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&& is_pow2(divImage.XSize) && is_pow2(divImage.YSize)) return;<br>
&nbsp;&nbsp;&nbsp;&nbsp;else assert("3Dに使うなら2のべき乗の画像サイズにしなきゃ" == "");<br>
&nbsp;&nbsp;}<br>
#endif<br>
<br>
private: // コピーと代入をプライベートにして禁止する<br>
&nbsp;&nbsp;//コピーコンストラクタ<br>
&nbsp;&nbsp;DivImage(const DivImage& divImage) {};<br>
<br>
&nbsp;&nbsp;//代入演算子のオーバーロード<br>
&nbsp;&nbsp;DivImage& operator=(const DivImage& divImage) {};<br>
};<br>
<br>
#endif<br></p>
		
	<p><code>Image.h</code>でカスタムしたデータタイプ【DivImage型】で縦2×横8の分割された爆発画像を読込みましょう。</p>
    <p class="source">#ifndef IMAGE_H_<br>
#define IMAGE_H_<br>
<br>
#include "DxLib.h"<br>
#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
<em>#include "DivImage.h" // 分割画像の読込みに使う</em><br>
<br>
class Image<br>
{<br>
public:<br>
&nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
&nbsp;&nbsp;static void Load();<br>
&nbsp;&nbsp;<em>static int LoadDivGraph(const TCHAR* FileName, DivImage& divImage);</em><br>    
<br>
&nbsp;&nbsp;static int bossImage; //ボス画像のハンドラ(読込画像番号)<br>
&nbsp;&nbsp;static int player; //プレイヤ画像のハンドラ<br>
&nbsp;&nbsp;static int playerBullet; //プレイヤの弾画像のハンドラ<br>
&nbsp;&nbsp;static int enemyBullet16; //敵弾 画像のハンドラ(読込画像番号)<br>
&nbsp;&nbsp;static int zako0; //ザコ0 画像のハンドラ(読込画像番号)<br>
&nbsp;&nbsp;static int zako1; //ザコ1 画像のハンドラ(読込画像番号)<br>
&nbsp;&nbsp;static int zako2; //ザコ2 画像のハンドラ(読込画像番号)<br>
&nbsp;&nbsp;static int zako3; //ザコ3 画像のハンドラ(読込画像番号)<br>
&nbsp;&nbsp;<em>static DivImage explosion; // [分割画像]爆発エフェクト</em><br>
<br>
private:<br>
<br>
};<br>
#endif<br>
</p>
<br>
<p>次に対となるcppファイルも変更します。<br>
      <code>Image.cpp</code>の内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
<br>
int Image::bossImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
int Image::player{-1};<br>
int Image::playerBullet{-1};<br>
int Image::enemyBullet16{-1};<br>
int Image::zako0{-1};<br>
int Image::zako1{-1};<br>
int Image::zako2{-1};<br>
int Image::zako3{-1};<br>
<em>// ★分割画像は初期化のときに{X方向画像数, Y方向画像数, 画像横幅XSize,画像縦幅YSize}を指定</em><br> 
<em>DivImage Image::explosion{ 8, 2, 64, 64 };</em><br>
<br>
<em>// DXライブラリのLoadDivGraphを使いやすくラッピング<br>
// ★関数に参照渡しを行う<br>
// 関数の引数に参照渡しを行うことでdivImageの中身を書き換えることができる(値渡しでは書換不可)<br>
//　https://qiita.com/agate-pris/items/05948b7d33f3e88b8967<br>
//  https://qiita.com/RuthTaro/items/f35c3a26779c0ca1a41a<br>
int Image::LoadDivGraph(const TCHAR* FileName, DivImage& divImage)<br>
{<br>
&nbsp;&nbsp;return DxLib::LoadDivGraph(FileName, divImage.XNum * divImage.YNum,<br>
&nbsp;&nbsp;&nbsp;&nbsp;divImage.XNum, divImage.YNum, divImage.XSize, divImage.YSize, divImage.HandleArray);<br>
};</em><br>
<br>	    
void Image::Load()<br>
{<br>
&nbsp;&nbsp;bossImage = LoadGraph("Image/boss1.png");<br>
&nbsp;&nbsp;assert(bossImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;player= LoadGraph("Image/player.png");<br>
&nbsp;&nbsp;assert(player!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;playerBullet = LoadGraph("Image/player_bullet.png");<br>
&nbsp;&nbsp;assert(playerBullet!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;enemyBullet16 = LoadGraph("Image/enemy_bullet_16.png");<br>
&nbsp;&nbsp;assert(enemyBullet16!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;zako0 = LoadGraph("Image/zako0.png");<br>
&nbsp;&nbsp;assert(zako0!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;zako1 = LoadGraph("Image/zako1.png");<br>
&nbsp;&nbsp;assert(zako1!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;zako2 = LoadGraph("Image/zako2.png");<br>
&nbsp;&nbsp;assert(zako2!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;zako3 = LoadGraph("Image/zako3.png");<br>
&nbsp;&nbsp;assert(zako3!= -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
<br>
&nbsp;&nbsp;<em>Image::LoadDivGraph("Image/explosion.png", explosion); // div分割画像をロード<br>
&nbsp;&nbsp;for (int i = 0; i &lt; explosion.AllNum; i++)<br>
&nbsp;&nbsp;{   // 画像読込失敗<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (explosion.HandleArray[i] == -1) assert("爆発分割画像読込失敗" == "");<br>
&nbsp;&nbsp;}</em><br>
}<br>
</p>

		<p><code>Explosion.h</code>を新規作成して爆発エフェクトを表示するクラスを作ります。</p>
<p class="source">#ifndef EXPLOSION_H_<br>
#define EXPLOSION_H_<br>
<br>
#include "Image.h"<br>
<br>
#include "GameObject.h"<br>
<br>
// 爆発エフェクトクラス<br>
class Explosion : public GameObject<br>
{<br>
public:<br>
&nbsp;&nbsp;int counter = 0; // 時間を計るための変数<br>
&nbsp;&nbsp;int imageIndex  = 0; // 表示すべき画像の番号<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;Explosion(float x, float y, float z=0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;: GameObject()<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;tag = "Explosion";<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理<br>
&nbsp;&nbsp;void Update() override<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;counter++;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;imageIndex = counter / 3; // そのままだと速すぎるので、3で割る<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 絵は16枚しかない（0～15）ので、<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 16番目を表示しようとしたら終了。<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (imageIndex &gt;= 16)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 描画処理<br>
&nbsp;&nbsp;void Draw() override<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;// Image.explosionは配列であり、<br>
&nbsp;&nbsp;// 分割して読み込んだ絵のハンドルが各要素に格納されているので、<br>
&nbsp;&nbsp;// 要素番号を指定してハンドルを取り出して使う。<br>
&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1, 0, Image::explosion[imageIndex], TRUE);<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
#endif<br>
</p>

		
<p><code>GameManager.h</code>にExplosionを管理するリストの定義を追加します。</p>
<p class="source">
#ifndef GAMEMANAGER_H_<br>
#define GAMEMANAGER_H_<br>
<br>
#include &lt;memory&gt;<br>
#include &lt;vector&gt;<br>
<br>
#include&nbsp;"Singleton.h"<br>
<br>
class&nbsp;Player;&nbsp;//&nbsp;クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
class&nbsp;PlayerBullet;<br>
class&nbsp;Enemy;<br>
class&nbsp;EnemyBullet;<br>
<em>class&nbsp;Explosion;</em><br>
<br>
class GameManager : public Singleton&lt;GameManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
{<br>
public:<br>
&nbsp;&nbsp;friend class Singleton&lt;GameManager&gt;; // Singleton でのインスタンス作成は許可<br>
<br>
&nbsp;&nbsp;std::shared_ptr&lt;Player&gt; player{ nullptr }; // 自機のポインタ<br>
&nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト<br>
&nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
&nbsp;&nbsp;std::vector&lt;std::shared_ptr&lt;EnemyBullet&gt;&gt; enemyBullets; // 敵弾のリスト<br>
&nbsp;&nbsp;<em>std::vector&lt;std::shared_ptr&lt;Explosion&gt;&gt; explosions; // 爆発エフェクトのリスト</em><br>
&nbsp;&nbsp;// List↑と同じvector ↑【shared_ptr】回し読みポインタ:メモリにデータを回し読み状態として確保できる<br>
<br>
<br>
(中略)..............
<br>
protected:<br>
&nbsp;&nbsp;GameManager() {}; // 外部からのインスタンス作成は禁止<br>
&nbsp;&nbsp;virtual ~GameManager() {}; //外部からのインスタンス破棄も禁止<br>
};<br>
<br>
#endif<br>
</p>
	
	<p><code>Game.cpp</code>に当たり判定の処理を追加します。</p>
    <p class="source">#include "Game.h"<br>
#include&nbsp;"Player.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"PlayerBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"EnemyBullet.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<em>#include&nbsp;"Explosion.h"&nbsp;//&nbsp;Update(),Draw()など【実際の処理を行うのでインクルード必要】</em><br>
#include&nbsp;"Zako0.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako1.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako2.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
#include&nbsp;"Zako3.h"&nbsp;//&nbsp;初期化やUpdate(),Draw()など【実際の処理を行うのでインクルード必要】<br>
<br>
void Game::Init()<br>
{// Init処理<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
};<br>
<br>
void Game::Update()<br>
{// 更新処理<br>
<br>
&nbsp;&nbsp;Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
<br>
&nbsp;&nbsp;(中略)..................<br>
<br>
&nbsp;&nbsp;// 自機と敵の衝突判定<br>
&nbsp;&nbsp;for(const auto&amp; enemy : gm.enemies)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 自機が死んでたらこれ以上判定しない<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (gm.player-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 敵が死んでたらスキップ<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (enemy-&gt;isDead)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 円同士の衝突判定で調べる<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (MyMath::CircleCircleIntersection(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;x, gm.player-&gt;y, gm.player-&gt;collisionRadius,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enemy-&gt;x, enemy-&gt;y, enemy-&gt;collisionRadius))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.player-&gt;OnCollisionEnemy(enemy);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<em>// 爆発エフェクトの更新処理<br>
&nbsp;&nbsp;for (const auto&amp; e : gm.explosions)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Update();<br>
&nbsp;&nbsp;}</em><br>
&nbsp;&nbsp;<br>
<br>
&nbsp;&nbsp;//return; //【★実験】ここでreturnで処理を終わると弾のメモリを解放しない！下のerase前でそこまで処理が行かないからメモリ解放せずに終わる実験<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 自機弾のリストから死んでるものを除去する<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.playerBullets,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;PlayerBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
&nbsp;&nbsp;// 敵のリストから死んでるものを除去する<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.enemies,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Enemy&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
&nbsp;&nbsp;// 敵弾のリストから死んでるものを除去する<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.enemyBullets,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;EnemyBullet&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<em>//爆発エフェクトのリストから死んでるものを除去する<br>
&nbsp;&nbsp;gm.EraseRemoveIf(gm.explosions,<br>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::shared_ptr&lt;Exploions&gt;&amp;&nbsp;ptr)&nbsp;{&nbsp;return ptr-&gt;isDead;&nbsp;});//isDead==trueの条件のものを削除</em><br>
&nbsp;&nbsp;<br>
};<br>
<br>
void Game::Draw()<br>
{// 描画処理<br>
&nbsp;&nbsp;(中略)......<br>
<br>
&nbsp;&nbsp;// 敵の描画処理<br>
&nbsp;&nbsp;for (const auto&amp; e : gm.enemies)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Draw();<br>
&nbsp;&nbsp;}</em><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;// 爆発エフェクトの描画処理<br>
&nbsp;&nbsp;for (const auto&amp; e : gm.explosions)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;e-&gt;Draw();<br>
&nbsp;&nbsp;}</em><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;(中略)......<br>
<br>
};<br>
</p>

<p><code>Enemy.h</code>を改修して、敵が死んだときに爆発エフェクトを出すようにしましょう。</p>
<p class="source">#ifndef ENEMY_H_<br>
#define ENEMY_H_<br>
<br>
#include "GameObject.h"<br>
<br>
#include "GameManager.h"<br>
<br>
// 敵の基底クラス。<br>
// 全ての敵は、このクラスを継承して作る。<br>
// ★【勉強】abstract型はC++にない!!【純粋仮想関数】を使って作る<br>
// クラスの基本(C++11).pdfの17ページの下のほう(クラスの基本④)<br>
class Enemy : public GameObject<br>
{<br>
public:<br><br>
&nbsp;&nbsp;//【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
&nbsp;&nbsp;GameManager& gm = GameManager::GetInstance(); //唯一のゲームマネージャへの参照(&)を得る<br>
<br>
&nbsp;&nbsp;float collisionRadius = 32; // 当たり判定の半径<br>
&nbsp;&nbsp;bool isDead = false; // 死亡フラグ<br>
&nbsp;&nbsp;float life = 1; // 耐久力<br>
<br>
&nbsp;&nbsp;// コンストラクタ<br>
&nbsp;&nbsp;Enemy(float x, float y, float z=0)//★z=0をデフォルトとすることでx,yだけでも初期化でき2Dと3D両立<br>
&nbsp;&nbsp;&nbsp;&nbsp;: GameObject() // GameObjectをベースとして初期化処理を継承する<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;typeTag = "Enemy";<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;z = z;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// 更新処理。派生クラスでオーバーライドして使う<br>
&nbsp;&nbsp;virtual void Update() = 0;//virtual ～ = 0;で【純粋仮想関数に】これで【C#のabstract型に】<br>
<br>
&nbsp;&nbsp;// 描画処理。派生クラスでオーバーライドして使う<br>
&nbsp;&nbsp;virtual void Draw() = 0; //virtual ～ = 0;で【純粋仮想関数に】【関数 = 0で未定義状態を表現】<br>
<br>
&nbsp;&nbsp;//【勉強】関数 = 0って何?と思った人は【関数もメモリ上では住所アドレスに過ぎない】ことを知ろう<br>
&nbsp;&nbsp;// ★関数 = 0はつまり関数の住所ポインタの針が【メモリ上の何かを針で参照してない(住所不定無処理)】<br>
&nbsp;&nbsp;// つまり【関数が未定義ってこと】＝【あいまい部分があるabstractクラスってこと】<br>
&nbsp;&nbsp;//http://etc2myday.jugem.jp/?eid=204<br>
&nbsp;&nbsp;//http://wisdom.sakura.ne.jp/programming/c/c54.html<br>
&nbsp;&nbsp;//逆にいうと【関数を配列】にするっていうトリッキーなこともできる!<br>
&nbsp;&nbsp;//http://www.ced.is.utsunomiya-u.ac.jp/lecture/2012/prog/p3/kadai3/virtualfunc2.php<br>
<br>
&nbsp;&nbsp;// 自機弾に当たったときの処理<br>
&nbsp;&nbsp;virtual void OnCollisionPlayerBullet(std::shared_ptr&lt;GameObject&gt; playerBullet)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;life -= 1; // ライフを減らす<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// ライフが無くなったら、死亡<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (life &lt;= 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>// 爆発を出す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gm.explosions.push_back(std::make_shared<Explosion>(x, y);</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
};<br>
<br>
#endif<br>
</p>

		
</body>
</html>
