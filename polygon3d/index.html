<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>[C++]3D描画エンジン</title>
    <link rel="stylesheet" href="../style.css">
    <style>
      
    </style>
  </head>
  <body>
    <p class="title">[C++]3D描画エンジン1</p>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId0001">試しにポリゴンを表示してみる</a></li>
      <li><a href="#mozTocId0002">ポリゴンの光の色表示の基礎となっている「拡散反射光:ディフューズ値」の値を変更してみる</a></li>
      <li><a href="#mozTocId0003">シンプルな.ply形式の3Dデータフォーマットを読み取ってポリゴン表示してみる</a></li>
      <li><a href="#mozTocId0004">Blenderをインストールして3Dのサイコロとテクスチャ画像を書き出してXYZ軸を見極める</a></li>
      <li><a href="#mozTocId0005">別の描画スクリーンを作って、Windowsみたいなサブのウィンドウを描く</a></li>
      <li><a href="#mozTocId0006">エディタを自作して視点カメラを動かせるようにする</a></li>
      <li><a href="#mozTocId0007">キーボードのWSキーでカメラ視点を手前や奥に移動できるようにする</a></li>
      <li><a href="#mozTocId0008">キーボードのDAキーとEQキーでカメラ視点を左右や上下に移動できるようにする</a></li>
      <li><a href="#mozTocId0009">Unityのアセットストアからとってきたテクスチャ1枚のシンプルな3DモデルをDXのモデルビューアで.mv1形式に変換して表示させてみる</a></li>
      <li><a href="#mozTocId0010">MV1形式の3Dモデルをアニメーション描画する</a></li>
      <li><a href="#mozTocId0011">複数の3DモデルやアニメをResourceクラスで2重ロードしないよう読み込んで複数アニメを切替えする</a></li>
      <li><a href="#mozTocId0012">.ply形式の3DモデルデータをResourceクラスを継承したDataPly構造体で読み込む</a></li>
      <li><a href="#mozTocId0013">Vector3に色々な関数を用意して3D空間の当たり判定をする</a></li>
      <li><a href="#mozTocId0014">ドラッグできるオブジェクトのコントロール点を用意して当たり判定の球やカプセルなどの幅や高さを調整できるようにする</a></li>
      <li><a href="#mozTocId0015">3Dモデルをクオータニオンで安定して回転できるようにする</a></li>
      <li><a href="#mozTocId0016">自作したシェーダー言語をコンパイルしてGPU上で動くプログラムを実感する</a></li>
    </ol>
    <br>
    <a id="mozTocId0001" class="mozTocH1">
      <h1>試しにポリゴンを表示してみる</h1>
    </a>
    <p><a id="mozTocId0001" class="mozTocH1"><code>main.cpp</code>にプログラムを追加し、ポリゴン画像が正しく表示できるかテストします。<br>
        (DXの</a><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId0002">プロジェクトとScreen.hはシューティングの別記事を参考</a>に作っておいてください、<br>
      画像ファイルは<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId0003">シュー ティングの別記事を参考</a>にImage/boss1.pngで保管されている前提で進めます)</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
      &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
      &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
      &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0; keyControlXYZ.y = Screen::Height; keyControlXYZ.z = 0;<br>
      &nbsp;&nbsp;&nbsp; float keyControlAngle = 0.0f; // 回転<br>
      &nbsp;&nbsp;&nbsp; int animTime = 0; // アニメーションの時刻カウンタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0) <br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x = keyControlXYZ.x; float y = keyControlXYZ.y; float z = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float scaleX = 0.5f; float scaleY = 0.5f; // 拡大縮小スケール<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)でz軸(画面奥方向)まわりに画像を回転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlAngle += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_B) keyControlAngle -= speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = 0 * Deg2Rad;&nbsp; const float yRotate = 0 * Deg2Rad; const float zRotate = keyControlAngle * Deg2Rad;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u0 = 0.0f; const float v0 = 0.0f; // テクスチャのUV切り出し起点(u:0～1.0, v:0～1.0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u1 = 1.0f; const float v1 = 1.0f; // テクスチャのUV切り出し終点 1.0は画像の右下を表す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerX = x + width * scaleX / 2; // 四角形の中心(x+width/2,y-height/2,z)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerY = y - height * scaleY / 2;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityのxyz方向と回転] https://gametukurikata.com/basic/xyzaxis<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityの回転ZXYの順で適用したもの] https://light11.hatenadiary.com/entry/2019/01/24/223705<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX TransformMatrix = MGetTranslate(VGet(-centerX, -centerY, -z)); // 四角形の中心を 原点(0,0,0)に一旦移動させてから回転させる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotZ(zRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotX(xRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotY(yRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetTranslate(VGet(centerX, centerY, z))); // 四角形の中心ぶんだけ平行移動させて戻す<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 四角ポリゴンのインデックス順<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(時計回りが表面)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↓(x,y)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 0-1 4 ←(x + width * scale, y)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; |/ /|<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 2 3-5 ←(x + width * scale, y - height * scale)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↑(x, y - height * scale)&nbsp;&nbsp;&nbsp;&nbsp; ↑[UIのy方向は下だが3D空間上は上が+方向なのでheightを-1方向に]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; rectVertex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex.resize(4);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;unsigned int&gt; rectIndex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex.resize(6);&nbsp; // 4頂点のうち 右上(1と4)と左下(2と3)は同位置に2つ頂点を使う(三角形2つぶんのため) 4頂点 + 2被り = 6<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4頂点分のデータをセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左上(0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].pos = VTransform(VGet(x, y, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].norm = VGet(0.0f, 0.0f, -1.0f); // 法線ベクトル(面の反射方向:z方向-1.0のベクトルなら光がzマイナス方向に反射)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].dif = GetColorU8(255, 255, 255, 255); // 拡散反射光の色<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].spc = GetColorU8(255, 255, 255, 255); // 鏡面反射光の色<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].u = u0; // テクスチャ切り出し点 U(横方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].v = v0; // テクスチャ切り出し点 V(縦方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].su = 0.0f; // 補助テクスチャのUV(いまはない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右上(1と4)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].pos = VTransform(VGet(x + width * scaleX, y, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].norm = VGet(0.0f, 0.0f, -1.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].u = u1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].v = v0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].su = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左下(2と3)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].pos = VTransform(VGet(x, y - height * scaleY, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].norm = VGet(0.0f, 0.0f, -1.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].u = u0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].v = v1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].su = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右下(5)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].pos = VTransform(VGet(x + width * scaleX, y - height * scaleY, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].norm = VGet(0.0f, 0.0f, -1.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].u = u1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].v = v1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].su = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2ポリゴン分のインデックス順データをセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[0] = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[1] = 1; // 0-1 4<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[2] = 2; // |/ /|&nbsp;&nbsp; 0,1,2で左上ポリゴンを 3,4,5で右下ポリゴンを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[3] = 2; // 2 3-5<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[4] = 1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[5] = 3;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++animTime;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isDrawPolygon = animTime % 60 &gt; 30; // 30フレームに1回三角ポリゴン(1個)と四角(2個)を描くのを切り替える↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::<span style="font-weight: bold;">DrawPolygon32bitIndexed3D</span>(rectVertex.data(), rectVertex.size(), rectIndex.data(), (isDrawPolygon) ? 1 : 2, texImage, FALSE); // 三角形ポリゴン2枚を描画<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(VGet(x, y, z), 4.0f, 8, GetColor(255, 255, 0), GetColor(255, 255, 0),TRUE); // 左上に黄色の3D球を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f", x, y, keyControlAngle);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <p><code>main.cpp</code>のプログラムを変更し、ポリゴンのインデックスの順番がポリゴンの表(時計回 り)と裏(反時計回り)に 影響を与えることを確認しましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      // ＃includeで別ファイルのヘッダファイル.hをこのコード内に読み込む<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
      &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
      &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
      &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0; keyControlXYZ.y = Screen::Height; keyControlXYZ.z = 0;<br>
      &nbsp;&nbsp;&nbsp; float keyControlAngle = 0.0f; // 回転<br>
      &nbsp;&nbsp;&nbsp; int animTime = 0; // アニメーションの時刻カウンタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0) <br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x = keyControlXYZ.x; float y = keyControlXYZ.y; float z = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float scaleX = 0.5f; float scaleY = 0.5f; // 拡大縮小スケール<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)でz軸(画面奥方向)まわりに画像を回転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlAngle += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_B) keyControlAngle -= speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = 0 * Deg2Rad;&nbsp; const float yRotate = <em>keyControlAngle</em> * Deg2Rad; const float zRotate = <em>0</em> * Deg2Rad;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u0 = 0.0f; const float v0 = 0.0f; // テクスチャのUV切り出し起点(u:0～1.0, v:0～1.0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u1 = 1.0f; const float v1 = 1.0f; // テクスチャのUV切り出し終点 1.0は画像の右下を表す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerX = x + width * scaleX / 2; // 四角形の中心(x+width/2,y-height/2,z)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerY = y - height * scaleY / 2;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityのxyz方向と回転] https://gametukurikata.com/basic/xyzaxis<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityの回転ZXYの順で適用したもの] https://light11.hatenadiary.com/entry/2019/01/24/223705<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX TransformMatrix = MGetTranslate(VGet(-centerX, -centerY, -z)); // 四角形の中心を 原点(0,0,0)に一旦移動させてから回転させる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotZ(zRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotX(xRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotY(yRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetTranslate(VGet(centerX, centerY, z))); // 四角形の中心ぶんだけ平行移動させて戻す<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 四角ポリゴンのインデックス順<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(時計回りが表面)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↓(x,y)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 0-1 4 ←(x + width * scale, y)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; |/ /|<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 2 3-5 ←(x + width * scale, y - height * scale)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↑(x, y - height * scale)&nbsp;&nbsp;&nbsp;&nbsp; ↑[UIのy方向は下だが3D空間上は上が+方向なのでheightを-1方向に]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; rectVertex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex.resize(4);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;unsigned int&gt; rectIndex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex.resize(6);&nbsp; // 4頂点のうち 右上(1と4)と左下(2と3)は同位置に2つ頂点を使う(三角形2つぶんのため) 4頂点 + 2被り = 6<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4頂点分のデータをセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左上(0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].pos = VTransform(VGet(x, y, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].norm = VGet(0.0f, 0.0f, -1.0f); // 法線ベクトル(面の反射方向:z方向-1.0のベクトルなら光がzマイナス方向に反射)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].dif = GetColorU8(255, 255, 255, 255); // 拡散反射光の色<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].spc = GetColorU8(255, 255, 255, 255); // 鏡面反射光の色<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].u = u0; // テクスチャ切り出し点 U(横方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].v = v0; // テクスチャ切り出し点 V(縦方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].su = 0.0f; // 補助テクスチャのUV(いまはない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右上(1と4)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].pos = VTransform(VGet(x + width * scaleX, y, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].norm = VGet(0.0f, 0.0f, -1.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].u = u1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].v = v0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].su = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左下(2と3)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].pos = VTransform(VGet(x, y - height * scaleY, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].norm = VGet(0.0f, 0.0f, -1.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].u = u0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].v = v1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].su = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右下(5)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].pos = VTransform(VGet(x + width * scaleX, y - height * scaleY, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].norm = VGet(0.0f, 0.0f, -1.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].u = u1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].v = v1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].su = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2ポリゴン分のインデックス順データをセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[0] = <em>2</em>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[1] = 1; // 0-1 4<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[2] = <em>0</em>; // |/ /|&nbsp;&nbsp; 0,1,2で左上ポリゴンを 3,4,5で右下ポリゴンを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[3] = 2; // 2 3-5<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[4] = 1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[5] = 3;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++animTime;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isDrawPolygon = animTime % 60 &gt; 30; // 30フレームに1回三角ポリゴン(1個)と四角(2個)を描くのを切り替える↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(rectVertex.data(), rectVertex.size(), rectIndex.data(), (isDrawPolygon) ? 1 : 2, texImage, FALSE); // 三角形ポリゴン2枚を描画<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(VGet(x, y, z), 4.0f, 8, GetColor(255, 255, 0), GetColor(255, 255, 0),TRUE); // 左上に黄色の3D球を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f", x, y, keyControlAngle);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <p>いかがですか？キーボードのzキーとxキーでポリゴンをまわしてみ てポリゴンを裏から見ると表示されることが確認できましたか?<br>
    </p>
    <br>
    <br>
    <br>
    <a id="mozTocId0002" class="mozTocH1">
      <h1>ポリゴンの光の色表示の基礎となっている「拡散反射光: ディ フューズ値」の値を変更してみる</h1>
      <p><code>main.cpp</code>のプログラムを変更し、ポリゴンの<span style="text-decoration: underline;">difの値(拡散反射光:ディフューズ値)</span>がポリゴンの反射 する色に影響を与えることを確認しましょう。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
        #include "Screen.h"<br>
        // ＃includeで別ファイルのヘッダファイル.hをこのコード内に読み込む<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
        &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/boss1.png");<br>
        &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
        &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0; keyControlXYZ.y = Screen::Height; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; float keyControlAngle = 0.0f; // 回転<br>
        &nbsp;&nbsp;&nbsp; int animTime = 0; // アニメーションの時刻カウンタ<br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0) <br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x = keyControlXYZ.x; float y = keyControlXYZ.y; float z = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float scaleX = 0.5f; float scaleY = 0.5f; // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)でz軸(画面奥方向)まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlAngle += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_B) keyControlAngle -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = 0 * Deg2Rad;&nbsp; const float yRotate = <em>0</em> * Deg2Rad; const float zRotate = <em>keyControlAngle</em><em></em> * Deg2Rad;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u0 = 0.0f; const float v0 = 0.0f; // テクスチャのUV切り出し起点(u:0～1.0, v:0～1.0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u1 = 1.0f; const float v1 = 1.0f; // テクスチャのUV切り出し終点 1.0は画像の右下を表す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerX = x + width * scaleX / 2; // 四角形の中心(x+width/2,y-height/2,z)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerY = y - height * scaleY / 2;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityのxyz方向と回転] https://gametukurikata.com/basic/xyzaxis<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityの回転ZXYの順で適用したもの] https://light11.hatenadiary.com/entry/2019/01/24/223705<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX TransformMatrix = MGetTranslate(VGet(-centerX, -centerY, -z)); // 四角形の中心を 原点(0,0,0)に一旦移動させてから回転させる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetTranslate(VGet(centerX, centerY, z))); // 四角形の中心ぶんだけ平行移動させて戻す<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 四角ポリゴンのインデックス順<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(時計回りが表面)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↓(x,y)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 0-1 4 ←(x + width * scale, y)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; |/ /|<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 2 3-5 ←(x + width * scale, y - height * scale)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↑(x, y - height * scale)&nbsp;&nbsp;&nbsp;&nbsp; ↑[UIのy方向は下だが3D空間上は上が+方向なのでheightを-1方向に]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; rectVertex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex.resize(4);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;unsigned int&gt; rectIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex.resize(6);&nbsp; // 4頂点のうち 右上(1と4)と左下(2と3)は同位置に2つ頂点を使う(三角形2つぶんのため) 4頂点 + 2被り = 6<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4頂点分のデータをセット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左上(0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].pos = VTransform(VGet(x, y, z), TransformMatrix);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].norm = VGet(0.0f, 0.0f, -1.0f); // 法線ベクトル(面の反射方向:z方向-1.0のベクトルなら光がzマイナス方向に反射)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].dif = GetColorU8(255, <em>0</em>, <em>0</em>, 255); // 拡散反射光の色<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].spc = GetColorU8(255, 255, 255, 255); // 鏡面反射光の色<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].u = u0; // テクスチャ切り出し点 U(横方向)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].v = v0; // テクスチャ切り出し点 V(縦方向)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].su = 0.0f; // 補助テクスチャのUV(いまはない)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].sv = 0.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右上(1と4)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].pos = VTransform(VGet(x + width * scaleX, y, z), TransformMatrix);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].norm = VGet(0.0f, 0.0f, -1.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].dif = GetColorU8(<em>0</em>, <em>0</em>, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].u = u1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].v = v0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].su = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].sv = 0.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左下(2と3)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].pos = VTransform(VGet(x, y - height * scaleY, z), TransformMatrix);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].norm = VGet(0.0f, 0.0f, -1.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].dif = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].u = u0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].v = v1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].su = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].sv = 0.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右下(5)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].pos = VTransform(VGet(x + width * scaleX, y - height * scaleY, z), TransformMatrix);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].norm = VGet(0.0f, 0.0f, -1.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].dif = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].u = u1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].v = v1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].su = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].sv = 0.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2ポリゴン分のインデックス順データをセット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[0] = <em>0</em>;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[1] = 1; // 0-1 4<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[2] = <em>2</em>; // |/ /|&nbsp;&nbsp; 0,1,2で左上ポリゴンを 3,4,5で右下ポリゴンを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[3] = 2; // 2 3-5<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[4] = 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[5] = 3;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++animTime;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isDrawPolygon = animTime % 60 &gt; 30; // 30フレームに1回三角ポリゴン(1個)と四角(2個)を描くのを切り替える↓<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(rectVertex.data(), rectVertex.size(), rectIndex.data(), (isDrawPolygon) ? 1 : 2, texImage, FALSE); // 三角形ポリゴン2枚を描画<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(VGet(x, y, z), 4.0f, 8, GetColor(255, 255, 0), GetColor(255, 255, 0),TRUE); // 左上に黄色の3D球を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f", x, y, keyControlAngle);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      <br>
      <br>
    </a><a id="mozTocId0003" class="mozTocH1">
      <h1>シンプルな.ply形式の3Dデータフォーマットを読み取ってポリゴン表示してみる</h1>
      <p><code>メモ帳を開いて下記データをコピペして dicetest.plyという名前でImageフォルダに保存</code>しましょう。</p>
      <p class="source">ply<br>
        format ascii 1.0<br>
        comment Created by Blender 3.5.1 - www.blender.org<br>
        element vertex 14<br>
        property float x<br>
        property float y<br>
        property float z<br>
        property float nx<br>
        property float ny<br>
        property float nz<br>
        property float s<br>
        property float t<br>
        element face 12<br>
        property list uchar uint vertex_indices<br>
        end_header<br>
        -1.000000 1.000000 1.000000 0.000000 0.000000 1.000000 0.875000 0.500000<br>
        1.000000 -1.000000 1.000000 0.577350 -0.577350 0.577350 0.625000 0.750000<br>
        1.000000 1.000000 1.000000 0.577350 0.577350 0.577350 0.625000 0.500000<br>
        -1.000000 -1.000000 -1.000000 0.000000 -1.000000 0.000000 0.375000 1.000000<br>
        1.000000 -1.000000 -1.000000 0.577350 -0.577350 -0.577350 0.375000 0.750000<br>
        -1.000000 -1.000000 1.000000 -1.000000 0.000000 0.000000 0.625000 0.000000<br>
        -1.000000 1.000000 -1.000000 -0.707107 0.707107 0.000000 0.375000 0.250000<br>
        -1.000000 -1.000000 -1.000000 -1.000000 0.000000 0.000000 0.375000 0.000000<br>
        1.000000 1.000000 -1.000000 0.577350 0.577350 -0.577350 0.375000 0.500000<br>
        -1.000000 -1.000000 -1.000000 0.000000 0.000000 -1.000000 0.125000 0.750000<br>
        -1.000000 1.000000 -1.000000 0.000000 0.000000 -1.000000 0.125000 0.500000<br>
        -1.000000 1.000000 1.000000 -0.707107 0.707107 0.000000 0.625000 0.250000<br>
        -1.000000 -1.000000 1.000000 0.000000 0.000000 1.000000 0.875000 0.750000<br>
        -1.000000 -1.000000 1.000000 0.000000 -1.000000 0.000000 0.625000 1.000000<br>
        3 0 1 2<br>
        3 1 3 4<br>
        3 5 6 7<br>
        3 8 9 10<br>
        3 2 4 8<br>
        3 8 11 2<br>
        3 0 12 1<br>
        3 1 13 3<br>
        3 5 11 6<br>
        3 8 4 9<br>
        3 2 1 4<br>
        3 8 6 11<br>
      </p>
      <br>
      <p><code>Ply.hを新規作成</code>して、ファイルから.ply形式の3Dフォーマットを読み取るための処理を準 備しましょう。</p>
      <p class="source">#ifndef PLY_H_<br>
        #define PLY_H_<br>
        <br>
        #include &lt;assert.h&gt; // 読込み失敗表示用<br>
        #include &lt;string&gt;<br>
        #include &lt;vector&gt;<br>
        #include &lt;memory&gt;<br>
        #include &lt;utility&gt; // ペア型std::pairを使う<br>
        #include &lt;typeindex&gt; // std::type_indexを使えばunordered_mapの辞書のキーにfloatなどのタイプの型を指定できるようになる<br>
        #include &lt;unordered_map&gt;<br>
        #include &lt;fstream&gt; // ファイル読み出しifstreamに必要<br>
        #include &lt;sstream&gt; // 文字列ストリームに必要<br>
        #include &lt;functional&gt; // std::functionでラムダ式を関数の引数にできる<br>
        <br>
        namespace Ply //[.ply形式の3Dデータを読みだす]https://ja.wikipedia.org/wiki/PLY_(%E3%83%95%E3%82 %A1%E3%82%A4%E3%83%AB%E5%BD%A2%E5%BC%8F)<br>
        {<br>
        &nbsp;&nbsp; &nbsp;enum class FileFormat { ASCII, BINARY };<br>
        <br>
        &nbsp;&nbsp; &nbsp;const std::type_index CHAR = std::type_index(typeid(int8_t));<br>
        &nbsp;&nbsp; &nbsp;const std::type_index UCHAR = std::type_index(typeid(uint8_t));<br>
        &nbsp;&nbsp; &nbsp;const std::type_index SHORT = std::type_index(typeid(int16_t));<br>
        &nbsp;&nbsp; &nbsp;const std::type_index USHORT = std::type_index(typeid(uint16_t));<br>
        &nbsp;&nbsp; &nbsp;const std::type_index INT = std::type_index(typeid(int32_t));<br>
        &nbsp;&nbsp; &nbsp;const std::type_index UINT = std::type_index(typeid(uint32_t));<br>
        &nbsp;&nbsp; &nbsp;const std::type_index FLOAT = std::type_index(typeid(float));<br>
        &nbsp;&nbsp; &nbsp;const std::type_index DOUBLE = std::type_index(typeid(double));<br>
        <br>
        &nbsp;&nbsp; &nbsp;// ビックエンディアン方式でメモリに数値が格納される環境かチェック https://qiita.com/nia_tn1012/items/340a1f0ad71bf6085f7f<br>
        &nbsp;&nbsp; &nbsp;static bool isBigEndian()<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 0x01020304 という 4バイト数値 が メモリ上に 0x01 0x02 0x03 0x04 と上位バイトから順に格納する方式ならビッグエンディアンと判定<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const uint32_t i = 0x01020304; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↑<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return reinterpret_cast&lt;const uint8_t*&gt;(&amp;i)[0] == 1;<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;const std::unordered_map&lt;std::type_index, int&gt; dataTypeByteSize // データタイプFLOATなど から そのステップサイズ(データ量)=4バイト への変換辞書<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { CHAR, sizeof(char) }, // sizeof(char) = 1バイト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { UCHAR, sizeof(unsigned char) }, // sizeof(unsigned char) = 1バイト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { SHORT, sizeof(int16_t) }, // sizeof(int16_t) = 2バイト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { USHORT, sizeof(uint16_t) }, // sizeof(uint16_t) = 2バイト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { INT, sizeof(int32_t) }, // sizeof(int32_t) = 4バイト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { UINT, sizeof(uint32_t) }, // sizeof(uint32_t) = 4バイト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { FLOAT, sizeof(float) }, // sizeof(float) = 4バイト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { DOUBLE, sizeof(double) } // sizeof(double) = 8バイト<br>
        &nbsp;&nbsp; &nbsp;};<br>
        <br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(char) == 1, "sizeof(char) = 1バイトじゃないので何かおかしい");<br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(unsigned char) == 1, "sizeof(unsigned char) = 1バイトじゃないので何かおかしい");<br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(int16_t) == 2, "sizeof(int16_t) = 2バイトじゃないので何かおかしい");<br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(uint16_t) == 2, "sizeof(uint16_t) = 2バイトじゃないので何かおかしい");<br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(int32_t) == 4, "sizeof(int32_t) = 4バイトじゃないので何かおかしい");<br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(uint32_t) == 4, "sizeof(uint32_t) = 4バイトじゃないので何かおかしい");<br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(float) == 4, "sizeof(float) = 4バイトじゃないので何かおかしい");<br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(double) == 8, "sizeof(double) = 8バイトじゃないので何かおかしい");<br>
        <br>
        &nbsp;&nbsp; &nbsp;const std::unordered_map&lt;std::string, std::type_index&gt; strToDataType // "int32"などの文字列 → INTなどそのタイプ(std::type_index)への変換辞書<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { "char", CHAR }, { "uchar", UCHAR }, { "uint8", UCHAR },<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { "short", SHORT }, { "ushort", USHORT }, { "uint16", USHORT },<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { "int", INT }, { "int32", INT }, { "uint", UINT }, { "uint32", UINT },<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { "float", FLOAT }, { "float32", FLOAT },<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { "double", DOUBLE }, { "float64", DOUBLE }<br>
        &nbsp;&nbsp; &nbsp;};<br>
        <br>
        &nbsp;&nbsp; &nbsp;const std::unordered_map&lt;std::type_index, std::string&gt; dataTypeToStr // INTなどそのタイプ から "int32"など文字列への変換辞書<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { CHAR, "char" }, { UCHAR, "uchar" },<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { SHORT, "short" }, { USHORT, "ushort" },<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { INT, "int" }, { UINT, "uint" },<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { FLOAT, "float" }, { DOUBLE, "double" },<br>
        &nbsp;&nbsp; &nbsp;};<br>
        <br>
        &nbsp;&nbsp; &nbsp;// std::type_index(typeid(float)) などのタイプから そのステップバイト数=4バイト に変換<br>
        &nbsp;&nbsp; &nbsp;static size_t dataTypeToStepSize(const std::type_index&amp; type)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; auto it = dataTypeByteSize.find(type);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; assert(it != dataTypeByteSize.end() &amp;&amp; "指定された type は plyのヘッダで未定義です");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return it-&gt;second;<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;// "int" や "float32"などを std::type_index(typeid(float)) など std::type_index型に変換<br>
        &nbsp;&nbsp; &nbsp;static std::type_index parseDataType(const std::string&amp; type_name)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const auto&amp; it = strToDataType.find(type_name);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (it != strToDataType.end()) return it-&gt;second;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else throw std::exception(std::string("よくわからん定義してないタイプ名が来た:" + type_name).c_str());<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;template&lt;typename Key, typename Value&gt;<br>
        &nbsp;&nbsp; &nbsp;struct IndexList<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;private:<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; typedef typename std::pair&lt;Key, std::shared_ptr&lt;Value&gt;&gt; KeyValue;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;KeyValue&gt; data; // data配列にはキー"x" "y"などとバリュー(PropertyやElementなど)の"x"の型の情報(Property)が入る<br>
        &nbsp;&nbsp; &nbsp;public:<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Value&gt; operator[] (const Key&amp; key)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto it = std::find_if(begin(), end(), [&amp;key](const KeyValue&amp; keyVal) { return keyVal.first == key; });<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(it != end() &amp;&amp; "未登録のキーに[]でアクセスしようとしました");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return it-&gt;second;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // ["x"] や ["vertex"]のようにプロパティやエレメントに[]オペレータでアクセスできる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const std::shared_ptr&lt;const Value&gt; operator[] (const Key&amp; key) const<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; &nbsp;// keyに "x" が入ってきたらdata配列のbegin()からend()までkeyが "x"になるKeyValueを探す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto it = std::find_if(begin(), end(), [&amp;key](const KeyValue&amp; keyVal) { return keyVal.first == key; });<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(it != end() &amp;&amp; "未登録のキーに[]でアクセスしようとしました");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return it-&gt;second; // "x" のsecondがfloat型ならばfloat型のデータへの共有ポインタのアクセスを返す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; bool has_key(const Key&amp; key) // xやredなどキーが.plyのヘッダで例.property float x などのように宣言されているか<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto it = std::find_if(begin(), end(), [&amp;key](const KeyValue&amp; keyVal) { return keyVal.first == key; });<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (it != end()) return true;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; return false;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; void emplace_back(const Key&amp; key, const std::shared_ptr&lt;Value&gt;&amp; value)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; data.emplace_back(key, value);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; void clear() { data.clear(); }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; typedef typename std::vector&lt;std::pair&lt;Key, std::shared_ptr&lt;Value&gt;&gt;&gt;::iterator iterator;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; typedef typename std::vector&lt;std::pair&lt;Key, std::shared_ptr&lt;Value&gt;&gt;&gt;::const_iterator const_iterator;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // 範囲for文のためのイテレータの先頭beginと終端endを定義<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; iterator begin() { return data.begin(); };<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const_iterator begin() const { return data.begin(); };<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; iterator end() { return data.end(); };<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const_iterator end() const { return data.end(); };<br>
        &nbsp;&nbsp; &nbsp;};<br>
        <br>
        &nbsp;&nbsp; &nbsp;class Property // プロパティの例. property float x なら "x" は std::vector&lt;unsigned char&gt; dataにfloat型4バイト枠data[][][][]にまたがって保管<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;public:<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // ※unsigned char型の1バイト配列として定義してあるが実際に格納されるデータは2バイトなら箱2つ[ ][ ]で[ ]をまたいで格納される<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;unsigned char&gt; data; // 読みだしたプロパティのデータの書き込み先配列<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const std::type_index type; // プロパティのタイプ 例. property float x なら floatのstd::type_index<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const unsigned int stepSize; // プロパティのデータのステップサイズ数 例. floatやint = 4バイト stepSize = 4<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const bool isList = false; // 例. property list uchar uint vertex_indices なら isList = true<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const size_t elementSize = 0; // エレメントのサイズ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //std::vector&lt;unsigned char&gt; listCounts;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Property(const std::type_index type, const size_t size, const bool isList = false, const size_t elementSize = 0)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : type{ type }, isList{ isList }, stepSize{ (unsigned int)Ply::dataTypeToStepSize(type) }, elementSize{ elementSize }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;data.resize(size * this-&gt;stepSize); // データの書き込み先配列のメモリを事前確保しておく<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; template&lt;typename T&gt; // TがPropertyのタイプと一致するか判定<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; bool isType() const { return (type == std::type_index(typeid(T))); }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; template&lt;typename T&gt; // T型としてdata配列の先頭への T型のポインタを得る(const不変縛り)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const T* ptr() const { assert(isType&lt;T&gt;()); return reinterpret_cast&lt;const T*&gt;(&amp;data[0]); }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; template&lt;typename T&gt; // T型としてdata配列の先頭への T型のポインタを得る<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; T* ptr() { assert(isType&lt;T&gt;()); return reinterpret_cast&lt;T*&gt;(data.data()); }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // data配列のサイズをPropertyのステップサイズで割ることで配列の要素数を得られる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const size_t size() const { assert(data.size() % stepSize == 0); return data.size() / stepSize; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; template&lt;typename T&gt;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const T&amp; at(const size_t i) const<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(isType&lt;T&gt;());<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert((i + 1) * stepSize &lt;= data.size()); //↓ [ ]をまたいで格納しているぶん i * stepSizeで<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return&nbsp; *reinterpret_cast&lt;const T*&gt;(&amp;data[i * stepSize]); // 2バイトなら箱2つ[ ][ ] i×2ぶんずらしたアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; template&lt;typename T&gt;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; T&amp; at(const size_t i)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(isType&lt;T&gt;());<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert((i + 1) * stepSize &lt;= data.size()); //↓ [ ]をまたいで格納しているぶん i * stepSizeで<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return&nbsp; *reinterpret_cast&lt;T*&gt;(&amp;data[i * stepSize]); // 2バイトなら箱2つ[ ][ ] i×2ぶんずらしたアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;};<br>
        <br>
        &nbsp;&nbsp; &nbsp;class Elements // .plyの各elementを表す 例. element face 12 = ポリゴンが size = 12面ぶんありdata["face"]でアクセスできる<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; size_t size_;<br>
        &nbsp;&nbsp; &nbsp;public:<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Elements(const size_t size) : size_(size) {}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; IndexList&lt;std::string, Property&gt; properties; // elementにぶらさがっている property float x などのリスト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; size_t size() const { return size_; }<br>
        &nbsp;&nbsp; &nbsp;};<br>
        <br>
        <br>
        &nbsp;&nbsp; &nbsp;typedef IndexList&lt;std::string, Elements&gt; Data; //　["x"] や["vertex"]のようにプロパティやエレメントに[]オペレータでアクセスして使う<br>
        <br>
        &nbsp;&nbsp; &nbsp;// Windowsで作成されたファイルは改行コード \n に \r がついたcarrige return形式になっているので除去してstd::getlineできる関数<br>
        &nbsp;&nbsp; &nbsp;inline void getline_carriage_return(std::ifstream&amp; inputfile, std::string&amp; line)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::getline(inputfile, line); // ファイルから1行をstd::getlineで取得<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // Windowsで作成されたファイルは改行コード \n に \r がついたcarrige return形式になっているので除去<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (!line.empty() &amp;&amp; line.back() == '\r')<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; line.pop_back();<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;// " "スペース区切りでresult配列に出力する<br>
        &nbsp;&nbsp; &nbsp;inline void split_space(const std::string&amp; input, std::vector&lt;std::string&gt;&amp; result)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; result.clear();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::stringstream ss(input);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; while (true)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string elem;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ss &gt;&gt; elem; // ssで&gt;&gt;するたびに" "スペースで区切られてelemに文字列が読みだされていく<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (ss.fail()) break;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; result.push_back(elem);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;inline size_t str_to_size_t(const std::string&amp; input) // 文字列をstd::stringstreamの &gt;&gt; でsize_t型の数値に変換<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::stringstream ss(input);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; size_t val; // size_t型はunsigned long long型64bit<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; ss &gt;&gt; val; // 文字列を &gt;&gt; で 数値型に変換<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (ss.fail()) throw std::exception("std::stringstream で 数値型(size_t型)に変換できない文字列がありました");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return val;<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;// テキストASCII形式のデータを読みだしてpWriteAddressへ書き込んで保管する<br>
        &nbsp;&nbsp; &nbsp;inline void readASCIIValue(std::ifstream&amp; fin, unsigned char* const pWriteAddress, const std::type_index&amp; type)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (type == Ply::CHAR)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int temp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fin &gt;&gt; temp; // 一旦 int型に変換してから8ビットにキャストして書き込む必要がある<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *reinterpret_cast&lt;int8_t*&gt;(pWriteAddress) = static_cast&lt;int8_t&gt;(temp);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::UCHAR)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int temp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fin &gt;&gt; temp; // 一旦 int型に変換してから8ビットにキャストして書き込む必要がある<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *reinterpret_cast&lt;uint8_t*&gt;(pWriteAddress) = static_cast&lt;uint8_t&gt;(temp);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::SHORT)&nbsp; fin &gt;&gt; *reinterpret_cast&lt;int16_t*&gt;(pWriteAddress);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::USHORT) fin &gt;&gt; *reinterpret_cast&lt;uint16_t*&gt;(pWriteAddress);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::INT)&nbsp;&nbsp;&nbsp; fin &gt;&gt; *reinterpret_cast&lt;int32_t*&gt;(pWriteAddress);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::UINT)&nbsp;&nbsp; fin &gt;&gt; *reinterpret_cast&lt;uint32_t*&gt;(pWriteAddress);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::FLOAT)&nbsp; fin &gt;&gt; *reinterpret_cast&lt;float*&gt;(pWriteAddress);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::DOUBLE) fin &gt;&gt; *reinterpret_cast&lt;double*&gt;(pWriteAddress);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else throw std::exception("なんか知らない未知のtype型が来たのでおかしい");<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;// .plyデータのヘッダではなく本体データをヘッダのプロパティのステップサイズに沿って読みだす<br>
        &nbsp;&nbsp; &nbsp;template &lt;Ply::FileFormat format&gt;<br>
        &nbsp;&nbsp; &nbsp;void readDataContent(std::ifstream&amp; fin, Ply::Data&amp; loadingData)//, std::function&lt;void()&gt; onVetexFunc, std::function&lt;void()&gt; onIndexFunc)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //Property型の内部のstd::vector&lt;unsigned char&gt; data;の配列の先頭アドレスへの辞書を作ってデータ書き込み先へのリンクを保持しておく<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::unordered_map&lt;Property*, unsigned char*&gt; writingPlace; // データ書込先の配列先頭アドレスを表す辞書<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; elementsKeyVal : loadingData) // elementsのキー("vertex"など)とバリュー(elements自体)のペアをループ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (auto&amp; propertyKeyVal : elementsKeyVal.second-&gt;properties) // propertyのキー("x"や"red"など)とバリュー(property自体)のペアをループ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; pProperty = propertyKeyVal.second;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; writingPlace[pProperty.get()] = pProperty-&gt;data.data(); // std::vector型のdata()を呼び出すと配列の先頭アドレスが得られる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //uint8_t max_count = 3; //property list uchar uint vertex_indices のインデックスの数は3固定だが4とかに対応するなら工夫が必要<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; elementsKeyVal : loadingData) // 各エレメントをループ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; pElements = elementsKeyVal.second;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const size_t elementsSize = pElements-&gt;size();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (size_t i = 0; i &lt; elementsSize; ++i) // 各エレメントのサイズぶんだけループ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (auto&amp; propertyKeyVal : pElements-&gt;properties) // 各エレメントの全プロパティをループ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; pProperty = propertyKeyVal.second;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!pProperty-&gt;isList) // リストじゃないとき 例. property float x など<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; pWriteAddress = writingPlace[pProperty.get()]; // 読み込んだデータの書き込み先アドレスを得る<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(pWriteAddress &gt;= pProperty-&gt;data.data() &amp;&amp; "書き込み先アドレスが事前確保したプロパティの内部配列の書き込み可能位置ではない");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //assert(ptData + prop-&gt;stepSize &lt;= prop-&gt;data.data() + prop-&gt;data.size());<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (format == FileFormat::ASCII)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; readASCIIValue(fin, pWriteAddress, pProperty-&gt;type); // テキストASCII形式をstd::ifstreamの &gt;&gt; 演算子で変換して読取<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fin.read(reinterpret_cast&lt;char*&gt;(pWriteAddress), pProperty-&gt;stepSize); // バイナリ形式をstd::ifstreamのreadで読取<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pWriteAddress += pProperty-&gt;stepSize; // 読取先アドレスをプロパティのステップサイズぶん先に進める<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else // リストのとき 例. property list uchar uint vertex_indices など<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Read count<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; uint8_t indexCount;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (format == FileFormat::ASCII)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int temp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fin &gt;&gt; temp; // 一旦 int型に変換してから8ビットunsigned charにキャストして読み込む必要がある<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; indexCount = static_cast&lt;unsigned char&gt;(temp);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else fin.read(reinterpret_cast&lt;char*&gt;(&amp;indexCount), sizeof(indexCount));<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (fin.fail()) throw std::exception("property listは 3(三角ポリゴンインデックス) か 6(テクスチャ3点×uv 2値 = 6)のみサポート");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //property list uchar uint vertex_indices のインデックスの数は3固定だが4とかに対応するなら工夫が必要<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /*if (count &gt; max_count &amp;&amp; count != 3 &amp;&amp; count != 6)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; max_count = count;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; size_t newSize = count * prop-&gt;elementSize * prop-&gt;stepSize;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prop-&gt;data.size() &lt; newSize)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prop-&gt;data.resize(newSize);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }*/<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //prop-&gt;listCounts.push_back(count); // save each counts<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Read data<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; pWriteAddress = writingPlace[pProperty.get()]; // 読み込んだデータの書き込み先アドレスを得る<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const size_t chunkSize = indexCount * pProperty-&gt;stepSize; // 読み出すチャンクの塊のサイズ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(pWriteAddress &gt;= pProperty-&gt;data.data() &amp;&amp; "書き込み先アドレスが事前確保したプロパティの内部配列の書き込み可能位置ではない");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //assert(ptData + chunkSize &lt;= prop-&gt;data.data() + prop-&gt;data.size());<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (format == Ply::FileFormat::ASCII)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (size_t n = 0; n &lt; indexCount; ++n) // インデックスの数だけループ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; readASCIIValue(fin, pWriteAddress, pProperty-&gt;type);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pWriteAddress += pProperty-&gt;stepSize; // 読取先アドレスをステップサイズぶん先に進める<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; &nbsp;// バイナリ形式ならチャンクの塊サイズ = chunkSize ぶんまとめて高速読み出し<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fin.read(reinterpret_cast&lt;char*&gt;(pWriteAddress), chunkSize);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pWriteAddress += chunkSize; // 読取先アドレスをチャンクのサイズぶん先に進める<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;// PLY形式のデータをロードする<br>
        &nbsp;&nbsp; &nbsp;inline void load(const std::string&amp; filepath, Ply::Data&amp; loadingData)//, std::function&lt;void()&gt; onVetexFunc, std::function&lt;void()&gt; onIndexFunc)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::string format; // .plyファイルのヘッダの format<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::string version; // .plyファイルのヘッダの version<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::ifstream fin(filepath, std::ios::binary); // バイナリ形式で読み込み<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (!fin.is_open())<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw std::exception((std::string("指定された ply ファイルが開けませんでした") + filepath).c_str());<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::string line; // 読み出し1行ライン<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Ply::getline_carriage_return(fin, line);<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Ply::Elements&gt; currentElement = nullptr;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (line != "ply") throw std::exception(".plyファイルヘッダの先頭に ""ply"" がなかったのでフォーマットがおかしいです");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; while (line != "end_header") // .plyファイルのヘッダーの終わりを表す end_header になるまでwhileループで読取<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Ply::getline_carriage_return(fin, line);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (fin.fail()) throw std::exception(".plyファイルヘッダーの読取に失敗");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; lineContent;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Ply::split_space(line, lineContent);<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (lineContent.size() == 3 &amp;&amp; lineContent[0] == "format")<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; format = lineContent[1]; // スペース区切りの2つめ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; version = lineContent[2]; // スペース区切りの3つめ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (lineContent.size() == 3 &amp;&amp; lineContent[0] == "element")<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const std::string&amp; name = lineContent[1]; // elementの名前 例.element vertex 14 なら"vertex"<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const size_t elementSize = Ply::str_to_size_t(lineContent[2]); // elementの数 ↑14 つまり3Dのvertex(点)が14個<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; currentElement.reset(new Ply::Elements(elementSize)); // 今から読みだすエレメントのステップするサイズが確定<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; loadingData.emplace_back(name, currentElement); // elementをデータ構造に登録<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (lineContent.size() == 3 &amp;&amp; lineContent[0] == "property") //例. property float x などの行を受け取る<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!currentElement)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw std::exception("elementが読まれてないのにpropertyが先に来ちゃったら何バイト飛ばしのステップで読みだして良いかわか らない");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const std::type_index dataType = Ply::parseDataType(lineContent[1]); // "int" "char"や"float32"などのデータタイプがlineContent[1]に入ってる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const std::string&amp; name = lineContent[2]; // x y z や red green blue など↑のintやfloatが表す数値の名前(使われ方)が入っている<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Ply::Property&gt; newProperty(new Ply::Property(dataType, currentElement-&gt;size()));<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; currentElement-&gt;properties.emplace_back(name, newProperty); // currentElementに property float x などのプロパティ情報(name="x" float)を登録<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (lineContent.size() == 5 &amp;&amp; lineContent[0] == "property" &amp;&amp; lineContent[1] == "list") //例.property list uchar uint vertex_indices などの行<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!currentElement)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw std::exception("elementが読まれてないのにpropertyが先に来ちゃったら何バイト飛ばしのステップで読みだして良いかわか らない");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const std::type_index indexCountType = Ply::parseDataType(lineContent[2]); // "uchar"などのインデックスの数を表す型がlineContent[2]に入ってる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const std::type_index dataType = Ply::parseDataType(lineContent[3]); // "int" "char"や"float32"などのデータタイプがlineContent[3]に入ってる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const std::string&amp; name = lineContent[4]; // vertex_indices や texcoord などのインデックス数値の名前(使われ方)が入っている<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (indexCountType != Ply::UCHAR)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw std::exception("property listでは uchar 型しか インデックスの数を表す型にはつかえない 例. property list uchar uint vertex_indices");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ポリゴンindexの数は 3 固定で決め打ちしている↓のでblenderなどで「メッシュの三角面化」にチェックを入れてエクスポートする必要がある<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; size_t lineDataNum = (name == "texcoord") ? 6 : 3; // テクスチャUV(st)座標 は 6つ 点1(u,v),点2(u,v),点3(u,v) = 6つの u v<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Ply::Property&gt; newProperty(new Ply::Property(dataType, lineDataNum * currentElement-&gt;size(), true, currentElement-&gt;size()));<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; currentElement-&gt;properties.emplace_back(name, newProperty); // currentElementに 登 録&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isList = true↑<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (fin.fail()) throw std::exception(".plyファイルのヘッダを読み取ったあとの本データを読取る前にファイルエラーが出た");<br>
        <br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // ヘッダのプロパティ形式を元に本データを読み取る<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (format == "ascii") // テキストのASCII形式の場合<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // .plyデータの本体データをヘッダのプロパティのステップサイスに沿って読みだす<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Ply::readDataContent&lt;Ply::FileFormat::ASCII&gt;(fin, loadingData);//, onVetexFunc, onIndexFunc);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (fin.fail()) throw std::exception(".plyのアスキー形式のデータ読み出しに失敗しました");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else // 本体データがバイナリ形式の場合<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const bool isBigEndian = Ply::isBigEndian();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (format != "binary_little_endian" &amp;&amp; format != "binary_big_endian")<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw std::exception(".plyのヘッダのformat部分が binary_little_endian でも binary_big_endian でもない");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((isBigEndian &amp;&amp; format != "binary_big_endian") || (!isBigEndian &amp;&amp; format != "binary_little_endian"))<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw std::exception(".plyのformat と お使いのPC環境のビックエンディアンorリトルエンディアン環境が合致していない");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // .plyデータの本体データをヘッダのプロパティのステップサイスに沿って読みだす<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Ply::readDataContent&lt;Ply::FileFormat::BINARY&gt;(fin, loadingData);//, onVetexFunc, onIndexFunc);<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (fin.fail()) throw std::exception(".plyのバイナリ形式のデータ読み出しに失敗しました");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; char endOfFileCheck; // ファイルの終わりにchar1バイト余分に読みだしてみてちゃんとファイルの終わりまでロードできたかチェック<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fin.read(&amp;endOfFileCheck, 1);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!fin.eof()) throw std::exception("ファイルの終わりに1バイト余分に読みだしたけどファイルに続きがあるのでちゃんと完全に読みだせてない");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;}<br>
        }<br>
        <br>
        #endif</p>
      <br>
      <p><code>main.cppを一旦まっさらにリセットしてから</code>下記のプログラムで、.ply形式のファイルをロードしてポリゴンで サイコロ型の3Dモデルが表示できるかテストします。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Screen.h"<br>
        <span style="font-weight: bold;">#include "Ply.h"</span><br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
        &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/boss1.png");<br>
        &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
        &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
        &nbsp;&nbsp;&nbsp; Ply::load("Image/<span style="font-weight: bold;">dicetest.ply</span>", Data); // .plyデータをロード<br>
        <br>
        &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
        <br>
        &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
        &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
        &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
        <br>
        &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
        &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
        &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
        &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        <br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
        &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 200.0f; keyControlXYZ.y = 200.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(100.0f, 100.0f, 100.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); // 三角形ポリゴンを描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      <br>
      <br>
    </a><a id="mozTocId0004" class="mozTocH1">
      <h1>Blenderをインストールして3Dのサイコロとテク スチャ画 像を書き出してXYZ軸を見極める</h1>
    </a>
    <p><a id="mozTocId0004" class="mozTocH1">Blenderを下記サイトを参考にインストールしましょう。<br>
      </a><a href="https://www.blender.jp/install">https://www.blender.jp/install</a> <br>
    </p>
    Blenderを開いて、上部のメニューバーから[テクスチャペイント]をクリックし[+新規]をクリックしてdiceと名前をつけてテクスチャ画像を生 成します。<br>
    <p> <img src="image/blender_dice1.png" alt=""></p>
    テクスチャ画像が生成されたら黒地に白で筆の半径50pxほどのサイコロの目を描いてみましょう。<br>
    <p> <img src="image/blender_dice2.png" alt=""></p>
    上部のメニューバーから[シェーディング]をクリックして下画面のノード画面で右クリックして[+追加]→[テクスチャ]→[画像テ クスチャ]のノードを生成
    <p> <img src="image/blender_dice3.png" alt=""></p>
    画像テクスチャノードの画像として先ほどペイントしたdiceを選びます<br>
    <p> <img src="image/blender_dice4.png" alt=""></p>
    画像テクスチャノードの[カラー]からプリンシプルBSDFノードの[ベースカラー]へと線を引っ張ってつなげるとサイコロのテクスチャ画像がでます<br>
    <p> <img src="image/blender_dice5.png" alt=""></p>
    [テクスチャペイント]をクリックして、[画像]から[名前をつけて保存]を選び、テクスチャ画像をDXのプロジェクトのImageフォルダに dice.pngとして保存<br>
    <p> <img src="image/blender_dice6.png" alt=""></p>
    メニューバーの[ファイル]→[エクスポート]→[Stanford PLY(.ply)]を選び、DXのプロジェクトのImageフォルダにdice.plyとしてエクスポート保存します。
    <p> <img src="image/blender_dice7.png" alt=""></p>
    エクスポートする際の[前方の軸][上向きの軸]はDXのmain.cppで読み取る際に対応関係があるので色んな軸の設定の仕方で実験してみましょう<br>
    <p> <img src="image/blender_dice8.png" alt=""></p>
    <p><code>main.cpp</code>のコードで読み込む.plyファイルをBlenderで作成したファイルに変えて、書き出す際のxyz 軸を変えながら試行錯誤してみましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Ply.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
      &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/<span style="font-weight: bold;">dice.png</span>");<br>
      &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
      &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
      &nbsp;&nbsp;&nbsp; Ply::load("Image/<span style="font-weight: bold;">dice.ply</span>", Data); // .plyデータをロード <span

        style="font-weight: bold;">軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう</span><br>
      <br>
      &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
      &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
      &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
      <br>
      &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
      &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
      &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
      &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      <br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(<em>-(p_y[i]), p_z[i], p_x[i]</em>);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(<em>-p_ny[i], p_nz[i], p_nx[i]</em>)) : VGet(0.0f, 0.0f, 0.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
      &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
      &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 200.0f; keyControlXYZ.y = 200.0f; keyControlXYZ.z = 0;<br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
      <br>
      &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(<em>50.0f, 50.0f, 50.0f</em>); // 拡大縮小スケール<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    <br>
    <br>
    <a id="mozTocId0005" class="mozTocH1">
      <h1>別の描画スクリーンを作って、Windowsみたいなサブのウィ ンドウを描く</h1>
      <br>
      <p><code>main.cpp</code>のコードにMakeScreen関数を使って別の描画先スクリーンを作って描画先スクリーンをスイッチする方法をテストしてみましょう。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
        &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
        &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
        &nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply", Data); // .plyデータをロード 軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう<br>
        <br>
        &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
        <br>
        &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
        &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
        &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
        <br>
        &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
        &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
        &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
        &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        <br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
        &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 200.0f; keyControlXYZ.y = 200.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>float subscreenX = 0, subscreenY = 0; // 別描画スクリーンを描く位置<br>
          &nbsp;&nbsp;&nbsp; int subscreenWidth = 600, subscreenHeight = 100;<br>
          &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE); // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドル作成を TRUE:許可<br>
          &nbsp;&nbsp;&nbsp; // [別の描画スクリーンを用意] https://dxlib.xsrv.jp/function/dxfunc_graph1.html#R3N25<br>
          &nbsp;&nbsp;&nbsp; int subscreen = DxLib::MakeScreen(subscreenWidth, subscreenHeight, FALSE);<br>
          &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE); // FLASE:通常のグラフィックハンドルを作成するモードに戻す</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>int MouseX, MouseY;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マウスの位置を取得<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetMousePoint(&amp;MouseX, &amp;MouseY);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreenX = MouseX; subscreenY = MouseY; // マウスのポインタの位置を起点にサブのスクリーンを描く</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(50.0f, 50.0f, 50.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>int tmpResetSetting = DxLib::GetUseSetDrawScreenSettingReset(); // 設定を一旦tmpに退避<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseSetDrawScreenSettingReset(FALSE); // SetDrawScreen切り替え時に設定をリセットしない(FALSE)(これをやらないとカメラ視点などがリセットされるから)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpDrawScreen = DxLib::GetDrawScreen(); // 一旦変更前のスクリーンのハンドルを退避<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawScreen(subscreen);// ゲームを描く先を用意しておいたサブスクリーンに設定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // (0,0)位置を起点に</em><em>別 スクリーン</em><em>へ文字列を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawScreen((tmpDrawScreen == -1) ? DX_SCREEN_BACK : tmpDrawScreen); // 描く先をもとのデフォルトのスクリーンに戻しておく<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseSetDrawScreenSettingReset((tmpResetSetting == -1) ? TRUE : tmpResetSetting); // 設定を元に戻す<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 画面に別スクリーンの内容を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawRectExtendGraph((int)subscreenX, (int)subscreenY, (int)(subscreenX + subscreenWidth), (int)(subscreenY + subscreenHeight), 0, 0, subscreenWidth, subscreenHeight, subscreen, FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 別スクリーンの枠を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox( (int)((int)subscreenX - 1 + 0.5f),(int)((int)subscreenY - 1 + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(subscreenX + subscreenWidth + 1) + 0.5f), (int)((int)(subscreenY + subscreenHeight + 1) + 0.5f), GetColor(255,255,255), FALSE);</em><br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <p>このサブのスクリーンの機能をこてこてに魔改造するとウィンドウズ のようなドラッグできるウィンドウをつくることもできます。<br>
      </p>
      <p><code>Input.hを新規作成</code>してドラッグや複数のスクリーンがあるときの一番上のレイヤーを保管する変数やマウスのドラッグを取れるようにしましょう。</p>
      <p class="source">#ifndef INPUT_H_<br>
        #define INPUT_H_<br>
        <br>
        #include &lt;climits&gt; //int型の最大値2147483647につかう<br>
        #include &lt;unordered_map&gt; //【高速辞書配列】<br>
        #include &lt;string&gt; // キーボード押下の文字列出力につかう<br>
        <br>
        #include "DxLib.h"<br>
        <br>
        // パッド番号<br>
        enum class Pad<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Keyboard = -3, // キーボード入力を得る<br>
        &nbsp;&nbsp;&nbsp; All = -2, // すべてのうちどれか1つでも押されたとき(マウス除く)<br>
        &nbsp;&nbsp;&nbsp; None = -1, // パッド割当て無(やられたり待機中のプレイヤに)<br>
        &nbsp;&nbsp;&nbsp; Key = 0,<br>
        &nbsp;&nbsp;&nbsp; One,<br>
        &nbsp;&nbsp;&nbsp; Two,<br>
        &nbsp;&nbsp;&nbsp; Three,<br>
        &nbsp;&nbsp;&nbsp; Four,<br>
        &nbsp;&nbsp;&nbsp; Mouse, // マウスのボタン判定に<br>
        &nbsp;&nbsp;&nbsp; NUM,&nbsp; // コントローラの数=6(マウス込み)<br>
        };<br>
        <br>
        enum class Mouse<br>
        {<br>
        &nbsp;&nbsp;&nbsp; All = -2, // すべてのうちどれか1つでも押されたとき<br>
        &nbsp;&nbsp;&nbsp; None = -1,<br>
        &nbsp;&nbsp;&nbsp; DownL, //[左クリック押した瞬間=1]<br>
        &nbsp;&nbsp;&nbsp; DragL, //[左ドラッグ中=1]<br>
        &nbsp;&nbsp;&nbsp; UpL, //[左クリック離した瞬間=1]<br>
        &nbsp;&nbsp;&nbsp; DownR, //[右クリック押した瞬間=1]<br>
        &nbsp;&nbsp;&nbsp; DragR, //[右ドラッグ中=1]<br>
        &nbsp;&nbsp;&nbsp; UpR, //[右クリック離した瞬間=1]<br>
        &nbsp;&nbsp;&nbsp; X, // 現在のマウス位置<br>
        &nbsp;&nbsp;&nbsp; ReleaseX, // 離した状態のマウス位置(ドラッグ中は開始前位置)<br>
        &nbsp;&nbsp;&nbsp; DownLX, //[左] 押した位置<br>
        &nbsp;&nbsp;&nbsp; DragLX, //[左] ドラッグ中の位置<br>
        &nbsp;&nbsp;&nbsp; UpLX, //[左] 離した位置<br>
        &nbsp;&nbsp;&nbsp; DownRX,//[右] 押した位置<br>
        &nbsp;&nbsp;&nbsp; DragRX, //[右] ドラッグ中の位置<br>
        &nbsp;&nbsp;&nbsp; UpRX, //[右] 離した位置<br>
        &nbsp;&nbsp;&nbsp; Y, // 現在のマウス位置<br>
        &nbsp;&nbsp;&nbsp; ReleaseY, // 離した状態のマウス位置(ドラッグ中は開始前位置)<br>
        &nbsp;&nbsp;&nbsp; DownLY, //[左] 押した位置<br>
        &nbsp;&nbsp;&nbsp; DragLY, //[左] ドラッグ中の位置<br>
        &nbsp;&nbsp;&nbsp; UpLY, //[左] 離した位置<br>
        &nbsp;&nbsp;&nbsp; DownRY,//[右] 押した位置<br>
        &nbsp;&nbsp;&nbsp; DragRY, //[右] ドラッグ中の位置<br>
        &nbsp;&nbsp;&nbsp; UpRY, //[右] 離した位置<br>
        &nbsp;&nbsp;&nbsp; NUM<br>
        };<br>
        <br>
        // 入力クラス<br>
        class Input<br>
        {<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; // ある動作として反応するボタン一覧(ビット論理和「|または」)<br>
        &nbsp;&nbsp;&nbsp; enum Button<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //[反応ボタン一覧定義] https://dixq.net/g/04_05.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 参加ボタン 1=Z 2=X 3=C 4=A 5=S 6=D 7=Q 8=W 9=ESC 10=SPACE<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Join = PAD_INPUT_1 | PAD_INPUT_2 | PAD_INPUT_3 | PAD_INPUT_4<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | PAD_INPUT_5 | PAD_INPUT_6 | PAD_INPUT_7 | PAD_INPUT_8<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | PAD_INPUT_9 | PAD_INPUT_10, //1Z～10SPACEキー全て反応<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; const int MaxPadNum = (int)Pad::Four + 1; // 最大パッド数(Keyぶん+1)<br>
        <br>
        &nbsp;&nbsp;&nbsp; static int prevStates[(int)Pad::NUM]; // 1フレーム前の状態<br>
        &nbsp;&nbsp;&nbsp; static int currentStates[(int)Pad::NUM]; // 現在の状態<br>
        &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;Pad, bool&gt; isJoin; // 参加中のパッド番号辞書<br>
        &nbsp;&nbsp;&nbsp; // 参加中のパッドかどうか?<br>
        &nbsp;&nbsp;&nbsp; static bool IsJoin(Pad pad) { return isJoin.count(pad) &amp;&amp; Input::isJoin[pad]; }<br>
        &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;int, int&gt; padDic; // パッド番号からDXの定義への辞書<br>
        <br>
        &nbsp;&nbsp;&nbsp; static int prevMouse; // 1フレーム前のマウス状態<br>
        &nbsp;&nbsp;&nbsp; static int currentMouse; // 現在のマウス状態<br>
        &nbsp;&nbsp;&nbsp; static int MouseX, MouseY; // 現在のマウス位置<br>
        &nbsp;&nbsp;&nbsp; static int <span style="font-weight: bold;">TopLayerMouseX</span>, <span

          style="font-weight: bold;">TopLayerMouseY</span>; // Subsreenの一番上のレイヤのマウス位置XY(Subscreenクラスで更新)<br>
        &nbsp;&nbsp;&nbsp; static int ClickX, ClickY, MButton, LogType;<br>
        &nbsp;&nbsp;&nbsp; static float MouseWheel; // マウスのホイールの回転<br>
        &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;Mouse, int&gt; Click;//&lt;Mouse⇒int&gt; マウスのクリックXY位置辞書<br>
        <br>
        &nbsp;&nbsp;&nbsp; //[キーボード入力]https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
        &nbsp;&nbsp;&nbsp; static char prevKey[256]; // 1フレーム前のキーボード状態<br>
        &nbsp;&nbsp;&nbsp; static char currentKey[256]; // 現在のキーボード状態<br>
        &nbsp;&nbsp;&nbsp; static std::string KeyString[256];//&lt;キーコード⇒キー文字列&gt;の辞書<br>
        &nbsp;&nbsp;&nbsp; static std::string CapsString[256];//&lt;Caps状態キーコード⇒キー文字列&gt;の辞書<br>
        &nbsp;&nbsp;&nbsp; static bool isCapsLocked;// CapsLock状態か?<br>
        &nbsp;&nbsp;&nbsp; static bool isShifted;// Shiftが押された状態か?<br>
        <br>
        &nbsp;&nbsp;&nbsp; //★【DXコントローラバグ検知】初回プッシュが被ればDXバグで同一コントローラ<br>
        &nbsp;&nbsp;&nbsp; static int firstPushTiming[(int)Pad::NUM - 1]; // マウスのぶんの配列はいらないから-1<br>
        &nbsp;&nbsp;&nbsp; static int timing;// = 0;<br>
        &nbsp;&nbsp;&nbsp; static bool isBugCheckMode;// = false; //バグチェックを開始するか<br>
        <br>
        private:<br>
        &nbsp;&nbsp;&nbsp; // 辞書配列の初期化<br>
        &nbsp;&nbsp;&nbsp; static void InitPadDictionary()<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 辞書配列で対応関係を結び付けておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padDic[(int)Pad::Key] = DX_INPUT_KEY_PAD1; // DX_INPUT_KEY<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padDic[(int)Pad::One] = DX_INPUT_PAD1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padDic[(int)Pad::Two] = DX_INPUT_PAD2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padDic[(int)Pad::Three] = DX_INPUT_PAD3;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padDic[(int)Pad::Four] = DX_INPUT_PAD4;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        public:<br>
        &nbsp;&nbsp;&nbsp; // 初期化。最初に1回だけ呼んでください。<br>
        &nbsp;&nbsp;&nbsp; static void Init()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitPadDictionary(); // 辞書配列の初期化<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitKeyString(); // キーボード辞書配列の初期化<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キー状態をゼロリセット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i] = 0;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitMouse(); // マウスの状態初期化<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitKeyboard(); // キーボードの状態初期化<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timing = 0, isBugCheckMode = false; //バグチェックを開始するか<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; // マウスの状態初期化<br>
        &nbsp;&nbsp;&nbsp; static void InitMouse()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MouseX = -1, MouseY = -1; // 現在のマウス位置を-1で初期状態では画面外として初期化<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClickX = -1, ClickY = -1, MButton = 0, LogType = 0;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::ReleaseX] = -1; Click[Mouse::ReleaseY] = -1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpLX] = -1;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpLY] = -1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpRX] = -1;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpRY] = -1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DownLX] = -1;&nbsp;&nbsp; Click[Mouse::DownLY] = -1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DownRX] = -1;&nbsp;&nbsp; Click[Mouse::DownRY] = -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; // キーボードの状態初期化<br>
        &nbsp;&nbsp;&nbsp; static void InitKeyboard()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キー状態をゼロリセット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 256; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevKey[i] = currentKey[i] = 0;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 最新の入力状況に更新する処理。<br>
        &nbsp;&nbsp;&nbsp; // 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
        &nbsp;&nbsp;&nbsp; static void Update()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::Mouse; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 現在の状態を一つ前の状態として保存してGetJoypad..<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentStates[i] = GetJoypadInputState(padDic[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateMouse(); // マウス状態を更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateKeyboard(); // キーボード状態を更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isBugCheckMode = true;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timing++; //タイミングのカウントを+1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (timing == INT_MAX) timing = 0; // long型最大値になったら0に戻す<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キーボードの状態を更新する<br>
        &nbsp;&nbsp;&nbsp; static void UpdateKeyboard()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy(prevKey, currentKey, sizeof(prevKey));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードの状態配列を更新する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetHitKeyStateAll(currentKey); // https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetButtonUp(Pad::Keyboard, KEY_INPUT_CAPSLOCK))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCapsLocked = !isCapsLocked; // CapsLock状態を反転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // シフトが押された状態かを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isShifted = (GetButton(Pad::Keyboard, KEY_INPUT_LSHIFT) || GetButton(Pad::Keyboard, KEY_INPUT_RSHIFT));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // マウスの状態を更新する<br>
        &nbsp;&nbsp;&nbsp; static void UpdateMouse()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DownL] = 0; Click[Mouse::DownR] = 0; //Click[Mouse.UpL] = 0; Click[Mouse.UpR] = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::All] = 0; // 状態辞書の0リセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevMouse = currentMouse; // 前フレームの最新のマウス情報を1つ前の情報とする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevStates[(int)Pad::Mouse] = currentMouse;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MouseWheel = GetMouseWheelRotVolF(); // マウスのホイール回転量を更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マウスの位置を取得<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetMousePoint(&amp;MouseX, &amp;MouseY);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TopLayerMouseX = MouseX; TopLayerMouseY = MouseY;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::X] = MouseX; Click[Mouse::Y] = MouseY;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentMouse = GetMouseInput(); // マウス状態を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentStates[(int)Pad::Mouse] = currentMouse; // マウス状態をパッド状態にも併合<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 押してない離した状態のマウス位置を更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (currentMouse == 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::ReleaseX] = MouseX; Click[Mouse::ReleaseY] = MouseY;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else Click[Mouse::All] = 1; // マウスのいずれかのボタンが押されている<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">// 左マウスドラッグ中のXY位置を更新</span><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetButton(Pad::Mouse, MOUSE_INPUT_LEFT) &amp;&amp; !GetButtonDown(Pad::Mouse, MOUSE_INPUT_LEFT))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DragLX] = MouseX; Click[Mouse::DragLY] = MouseY; Click[Mouse::DragL] = 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DragL] = 0;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">// 右マウスドラッグ中のXY位置を更新</span><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetButton(Pad::Mouse, MOUSE_INPUT_RIGHT) &amp;&amp; !GetButtonDown(Pad::Mouse, MOUSE_INPUT_RIGHT))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DragRX] = MouseX; Click[Mouse::DragRY] = MouseY; Click[Mouse::DragR] = 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DragR] = 0;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[マウスクリック検知] https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N40<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マウスのボタンが押されたり離されたりしたかどうかの情報を取得する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetMouseInputLog2(&amp;MButton, &amp;ClickX, &amp;ClickY, &amp;LogType, TRUE) == 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // [左ボタン]が押されたり離されたりしていた<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((MButton &amp; MOUSE_INPUT_LEFT) != 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // クリックされた瞬間と離された瞬間のマウス位置を記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LogType == MOUSE_INPUT_LOG_DOWN)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DownLX] = ClickX; Click[Mouse::DownLY] = ClickY; Click[Mouse::DownL] = 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (LogType == MOUSE_INPUT_LOG_UP)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpLX] = ClickX; Click[Mouse::UpLY] = ClickY; Click[Mouse::UpL] = 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }// [右ボタン]が押されたり離されたりしていた<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((MButton &amp; MOUSE_INPUT_RIGHT) != 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // クリックされた瞬間と離された瞬間のマウス位置を記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LogType == MOUSE_INPUT_LOG_DOWN)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DownRX] = ClickX; Click[Mouse::DownRY] = ClickY; Click[Mouse::DownR] = 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (LogType == MOUSE_INPUT_LOG_UP)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpRX] = ClickX; Click[Mouse::UpRY] = ClickY; Click[Mouse::UpR] = 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ボタンが押されているか？<br>
        &nbsp;&nbsp;&nbsp; static bool GetButton(int buttonId) { return GetButton(Pad::Key, buttonId); }<br>
        &nbsp;&nbsp;&nbsp; static bool GetButton(Pad pad, int buttonId)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //コントローラバグチェック<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ControllerBugCheck(pad, buttonId)) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // GetButtonの中でGetButtonを呼ぶ【再起呼出し】テクニック<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetButton((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::Keyboard) // 今ボタンが押されているかどうかを返却<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (currentKey[buttonId] == 1); //https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今ボタンが押されているかどうかを返却<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (currentStates[(int)pad] &amp; buttonId) != 0;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ボタンが押された瞬間か？<br>
        &nbsp;&nbsp;&nbsp; static bool GetButtonDown(int buttonId) { return GetButtonDown(Pad::Key, buttonId); }<br>
        &nbsp;&nbsp;&nbsp; static bool GetButtonDown(Pad pad, int buttonId)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //コントローラバグチェック<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ControllerBugCheck(pad, buttonId)) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 再起呼出しテクニック<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetButtonDown((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::Keyboard) //https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (currentKey[buttonId] == 1) &amp;&amp; (prevKey[buttonId] != 1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今は押されていて、かつ1フレーム前は押されていない場合はtrueを返却<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((currentStates[(int)pad] &amp; buttonId) &amp; ~(prevStates[(int)pad] &amp; buttonId)) != 0;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ボタンが離された瞬間か？<br>
        &nbsp;&nbsp;&nbsp; static bool GetButtonUp(int buttonId) { return GetButtonDown(Pad::Key, buttonId); }<br>
        &nbsp;&nbsp;&nbsp; static bool GetButtonUp(Pad pad, int buttonId)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //コントローラバグチェック<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ControllerBugCheck(pad, buttonId)) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 再起呼出しテクニック<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetButtonUp((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::Keyboard) //https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (prevKey[buttonId] == 1) &amp;&amp; (currentKey[buttonId] != 1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1フレーム前は押されていて、かつ今は押されている場合はtrueを返却<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((prevStates[(int)pad] &amp; buttonId) &amp; ~(currentStates[(int)pad] &amp; buttonId)) != 0;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; //コントローラのボタンの初回プッシュを検知し<br>
        &nbsp;&nbsp;&nbsp; //他コントローラと初回タイミングが完全被りかチェック<br>
        &nbsp;&nbsp;&nbsp; //★初回タイミングが完全被りなら【怪しい】重複コントローラとみなし判定処理スルー<br>
        &nbsp;&nbsp;&nbsp; static bool ControllerBugCheck(Pad pad, int buttonId)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::Mouse) return false; // マウスはバグチェック不要<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (pad == Pad::Keyboard) return false; // キーボードはバグチェック不要<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今は押されていて、かつ1フレーム前は押されていない場合<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool buttonDown = ((currentStates[(int)pad] &amp; buttonId) &amp; ~(prevStates[(int)pad] &amp; buttonId)) != 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (isBugCheckMode == false) return false; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //コントローラの初回ボタンプッシュを検知<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (buttonDown &amp;&amp; firstPushTiming[(int)pad] == 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM - 1; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //全コントローラ初回プッシュ被りがないかチェック完全同時は怪しいので-1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isDown = ((currentStates[i] &amp; buttonId) &amp; ~(prevStates[i] &amp; buttonId)) != 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((Pad)i != pad &amp;&amp; isDown ////初回プッシュ被り検出<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (timing == firstPushTiming[i] || firstPushTiming[i] == 0))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //初回プッシュのタイミング被りは-1フラグを記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstPushTiming[i] = -1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (firstPushTiming[(int)pad] != -1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstPushTiming[(int)pad] = timing;//初回プッシュを記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (firstPushTiming[(int)pad] == -1) return true; //DXのコントローラ被りバグ！<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else return false; //コントローラ被りOK!<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キーボードのキーと文字列の対応関係配列の初期化 https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N2<br>
        &nbsp;&nbsp;&nbsp; static void InitKeyString()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 辞書配列で対応関係を結び付けておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_BACK] = "BackSpace";//"\b";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_TAB] = "\t";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RETURN] = "\n";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LSHIFT] = "ShiftL";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RSHIFT] = "ShiftR";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LCONTROL] = "CtrlL";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RCONTROL] = "CtrlR";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SPACE] = " ";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PGUP] = "PgUp";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PGDN] = "PgDn";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_END] = "End";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_HOME] = "Home";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LEFT] = "Left";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_UP] = "Up";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RIGHT] = "Right";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DOWN] = "Down";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_INSERT] = "Insert";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DELETE] = "Delete";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_MINUS] = "-"; CapsString[KEY_INPUT_MINUS] = "=";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_YEN] = "\\"; CapsString[KEY_INPUT_YEN] = "|";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PREVTRACK] = "^"; CapsString[KEY_INPUT_PREVTRACK] = "~";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PERIOD] = "."; CapsString[KEY_INPUT_PERIOD] = "&gt;";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SLASH] = "/"; CapsString[KEY_INPUT_SLASH] = "?";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LALT] = "AltL";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RALT] = "AltR";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SCROLL] = "Scroll";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SEMICOLON] = ";"; CapsString[KEY_INPUT_SEMICOLON] = "+";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_COLON] = ":"; CapsString[KEY_INPUT_COLON] = "*";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LBRACKET] = "["; CapsString[KEY_INPUT_LBRACKET] = "{";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RBRACKET] = "]"; CapsString[KEY_INPUT_RBRACKET] = "}";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_AT] = "@"; CapsString[KEY_INPUT_AT] = "`";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_BACKSLASH] = "\\"; CapsString[KEY_INPUT_BACKSLASH] = "_";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_COMMA] = ","; CapsString[KEY_INPUT_COMMA] = "&lt;";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_CAPSLOCK] = "CapsLock";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PAUSE] = "Pause";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD0] = "0";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD1] = "1";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD2] = "2";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD3] = "3";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD4] = "4";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD5] = "5";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD6] = "6";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD7] = "7";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD8] = "8";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD9] = "9";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_MULTIPLY] = "*";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_ADD] = "+";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SUBTRACT] = "-";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DECIMAL] = ".";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DIVIDE] = "/";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPADENTER] = "\n";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F1] = "F1";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F2] = "F2";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F3] = "F3";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F4] = "F4";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F5] = "F5";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F6] = "F6";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F7] = "F7";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F8] = "F8";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F9] = "F9";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F10] = "F10";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F11] = "F11";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F12] = "F12";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_A] = "a"; CapsString[KEY_INPUT_A] = "A";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_B] = "b"; CapsString[KEY_INPUT_B] = "B";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_C] = "c"; CapsString[KEY_INPUT_C] = "C";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_D] = "d"; CapsString[KEY_INPUT_D] = "D";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_E] = "e"; CapsString[KEY_INPUT_E] = "E";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F] = "f"; CapsString[KEY_INPUT_F] = "F";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_G] = "g"; CapsString[KEY_INPUT_G] = "G";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_H] = "h"; CapsString[KEY_INPUT_H] = "H";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_I] = "i"; CapsString[KEY_INPUT_I] = "I";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_J] = "j"; CapsString[KEY_INPUT_J] = "J";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_K] = "k"; CapsString[KEY_INPUT_K] = "K";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_L] = "l"; CapsString[KEY_INPUT_L] = "L";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_M] = "m"; CapsString[KEY_INPUT_M] = "M";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_N] = "n"; CapsString[KEY_INPUT_N] = "N";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_O] = "o"; CapsString[KEY_INPUT_O] = "O";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_P] = "p"; CapsString[KEY_INPUT_P] = "P";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_Q] = "q"; CapsString[KEY_INPUT_Q] = "Q";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_R] = "r"; CapsString[KEY_INPUT_R] = "R";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_S] = "s"; CapsString[KEY_INPUT_S] = "S";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_T] = "t"; CapsString[KEY_INPUT_T] = "T";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_U] = "u"; CapsString[KEY_INPUT_U] = "U";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_V] = "v"; CapsString[KEY_INPUT_V] = "V";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_W] = "w"; CapsString[KEY_INPUT_W] = "W";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_X] = "x"; CapsString[KEY_INPUT_X] = "X";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_Y] = "y"; CapsString[KEY_INPUT_Y] = "Y";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_Z] = "z"; CapsString[KEY_INPUT_Z] = "Z";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_0] = "0";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_1] = "1"; CapsString[KEY_INPUT_1] = "!";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_2] = "2"; CapsString[KEY_INPUT_2] = "\"";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_3] = "3"; CapsString[KEY_INPUT_3] = "#";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_4] = "4"; CapsString[KEY_INPUT_4] = "$";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_5] = "5"; CapsString[KEY_INPUT_5] = "%";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_6] = "6"; CapsString[KEY_INPUT_6] = "&amp;";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_7] = "7"; CapsString[KEY_INPUT_7] = "'";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_8] = "8"; CapsString[KEY_INPUT_8] = "(";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_9] = "9"; CapsString[KEY_INPUT_9] = ")";<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        #endif</p>
      <p>&lt;<br>
      </p>
      <p><code>Input.cppを新規作成</code>してドラッグや複数のスクリーンがあるときの一番上のレイヤーを保管する変数 などの static変数を定義しましょう。</p>
      <p class="source">#include "Input.h"<br>
        <br>
        int Input::prevStates[]; // 1フレーム前の状態<br>
        int Input::currentStates[]; // 現在の状態<br>
        // ↑static intのときはこの行書かないとシンボリックエラーになる件(このためだけにcpp書かなきゃならん)<br>
        <br>
        std::unordered_map&lt;Pad, bool&gt; Input::isJoin; // 参加中のパッド番号辞書<br>
        // 参加中のパッドかどうか?<br>
        std::unordered_map&lt;int, int&gt; Input::padDic; // パッド番号からDXの定義への辞書<br>
        <br>
        int Input::prevMouse; // 1フレーム前のマウス状態<br>
        int Input::currentMouse; // 現在のマウス状態<br>
        int Input::MouseX{ -1 }, Input::MouseY{ -1 }; // 現在のマウス位置<br>
        int Input::TopLayerMouseX{ -1 }, Input::TopLayerMouseY{ -1 }; // 現在のマウス位置<br>
        float Input::MouseWheel{ 0 };<br>
        int Input::ClickX{ -1 }, Input::ClickY{ -1 }, Input::MButton{ 0 }, Input::LogType{ 0 };<br>
        std::unordered_map&lt;Mouse, int&gt; Input::Click;//&lt;Mouse⇒int&gt; マウスのクリックXY位置辞書<br>
        <br>
        //[キーボード入力]https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
        char Input::prevKey[256]; // 1フレーム前のキーボード状態<br>
        char Input::currentKey[256]; // 現在のキーボード状態<br>
        std::string Input::KeyString[256];//&lt;キーコード⇒キー文字列&gt;の辞書<br>
        std::string Input::CapsString[256];//&lt;Caps状態キーコード⇒キー文字列&gt;の辞書<br>
        bool Input::isCapsLocked{ false };// CapsLock状態か?<br>
        bool Input::isShifted{ false };// Shiftが押された状態か?<br>
        <br>
        <br>
        //★【DXコントローラバグ検知】初回プッシュが被ればDXバグで同一コントローラ<br>
        int Input::firstPushTiming[(int)Pad::NUM - 1]; // マウスのぶんの配列はいらないから-1<br>
        int Input::timing{ 0 };<br>
        bool Input::isBugCheckMode = false; //バグチェックを開始するか<br>
        <br>
      </p>
      <p><code>Screen.h</code>にWindowsのウィンドウみたいにドラッグできるSubScreenクラスを追加しましょう。</p>
      <p class="source">#ifndef _SCREEN_H<br>
        #define _SCREEN_H<br>
        <br>
        <em>#include &lt;string&gt;<br>
          #include &lt;set&gt; // サブスクリーンをDepth順に並べ替えるのに使う [multisetを使用するのに必要]<br>
          #include &lt;unordered_map&gt; // サブスクリーンをidをキーに保管するのに使う<br>
          #include &lt;memory&gt; // std::shared_ptrに使う</em><br>
        #include "DxLib.h"<br>
        <em><br>
          #include &lt;assert.h&gt; // アサート警告表示用</em><br>
        <br>
        <em>#include "Input.h"</em><br>
        <br>
        // 画面解像度<br>
        class Screen<br>
        {<br>
        public: //publicはC＃と違いpublic:以下にまとめて書かれるスタイル<br>
        &nbsp;&nbsp;&nbsp; static const int Width = 1280; // 幅<br>
        &nbsp;&nbsp;&nbsp; static const int Height = 720; // 高さ C＃と違いstaticクラスではなく個々の【すべての変数にstaticをつけて】staticなクラスとする<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>// X,Yがウィンドウの中にあるか<br>
          &nbsp;&nbsp;&nbsp; static bool IsInsideWindow(int screenX = Input::MouseX, int screenY = Input::MouseY) { return (0 &lt;= screenX &amp;&amp; screenX &lt; Width) &amp;&amp; (0 &lt;= screenY &amp;&amp; screenY &lt; Height); }</em><br>
        };// C＃と違ってクラスの定義も;セミコロンで終わる<br>
        <br>
        <br>
        <em>class SubScreen : public std::enable_shared_from_this&lt;SubScreen&gt;<br>
          {&nbsp;&nbsp;&nbsp; // [std::shared_ptrでthisポインタをつかうためには]↑ https://www.kabuku.co.jp/developers/cpp_enable_shared_from_this<br>
          protected:<br>
          &nbsp;&nbsp;&nbsp; int id; //サブスクリーンの管理ID<br>
          &nbsp;&nbsp;&nbsp; int handle = -1; //サブスクリーンへのハンドル<br>
          &nbsp;&nbsp;&nbsp; int tmpDrawScreen = -1; // DrawStartとDrawEndのあいだDrawStart前のhandleを一時保管する<br>
          &nbsp;&nbsp;&nbsp; int tmpResetSetting = -1; // DrawStartとDrawEndのあいだDrawStart前の設定を一時保管する<br>
          <br>
          &nbsp;&nbsp;&nbsp; static int serialDivID; //= 0 サブスクリーンを新たに生成するときの通し番号(シリアルID)<br>
          <br>
          public:<br>
          &nbsp;&nbsp;&nbsp; int frameWidth = 2;//サブスクリーンの枠の幅<br>
          &nbsp;&nbsp;&nbsp; unsigned int frameColor = DxLib::GetColor(255, 255, 255); //サブスクリーンの枠の色<br>
          &nbsp;&nbsp;&nbsp; float x = 0, y = 0; //サブスクリーンの描画位置<br>
          &nbsp;&nbsp;&nbsp; float zoomRate = 1.0f; // スクリーンに描くズーム率<br>
          &nbsp;&nbsp;&nbsp; float LocalX(float mainScreenX) { return (mainScreenX - x) / zoomRate; } // メインのスクリーンのXからサブスクリーンのローカルなXへ変換<br>
          &nbsp;&nbsp;&nbsp; float LocalY(float mainScreenY) { return (mainScreenY - y) / zoomRate; } // メインのスクリーンのYからサブスクリーンのローカルなYへ変換<br>
          &nbsp;&nbsp;&nbsp; bool IsInside(float mainScreenX, float mainScreenY) { return (x &lt; mainScreenX &amp;&amp; mainScreenX &lt; x + Width * zoomRate) &amp;&amp; (y &lt; mainScreenY &amp;&amp; mainScreenY &lt; y + Height * zoomRate); } // メインのスクリーン上のXとYがサブスクリーンの内側にあるか<br>
          &nbsp;&nbsp;&nbsp; bool IsOnBarFrame(float mainScreenX, float mainScreenY) { return (x - frameWidth - 1 &lt; mainScreenX &amp;&amp; mainScreenX &lt; x + Width * zoomRate + frameWidth + 1) &amp;&amp; (y - frameWidth - 1 - barFrameHeight &lt; mainScreenY &amp;&amp; mainScreenY &lt; y + frameWidth + 1 + Height * zoomRate); } // バーを含むウィンドウの内側にあるか<br>
          &nbsp;&nbsp;&nbsp; bool IsOnBar(float mainScreenX, float mainScreenY) { return (x - frameWidth - 1 &lt; mainScreenX &amp;&amp; mainScreenX &lt; x + Width * zoomRate + frameWidth + 1) &amp;&amp; (y - frameWidth - 1 - barFrameHeight &lt; mainScreenY &amp;&amp; mainScreenY &lt; y + frameWidth + 1); } // バーを含むウィンドウの内側にあるか<br>
          <br>
          &nbsp;&nbsp;&nbsp; float Width = 0, Height = 0; // サブスクリーンの幅と高さ<br>
          &nbsp;&nbsp;&nbsp; int Alpha = 255; // デフォルトは透明じゃない(アルファ不透明度=255)<br>
          &nbsp;&nbsp;&nbsp; float renderX = 0, renderY = 0; //描画オフセット位置(一部だけを抜き出してスクリーンにレンダリングするときに設定)<br>
          &nbsp;&nbsp;&nbsp; float renderWidth = 0; float renderHeight = 0; // 抜き出してスクリーンに描く部位の幅と高さ<br>
          <br>
          &nbsp;&nbsp;&nbsp; int Depth = 0; //[この値が大きいほど手前に割り込んで描かれる] [Unityの描画順を参考に] https://tama-lab.net/2017/07/unity%E3%81%A7%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E6%8F%8F%E7%94%BB%E9%A0%86%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95/<br>
          &nbsp;&nbsp;&nbsp; static bool isDepthLayerChanged; //= false 新しいレイヤが追加されり変更があった時だけ並べ替えるためのフラグ<br>
          <br>
          &nbsp;&nbsp;&nbsp; bool isInitAgain = false; // WidthやHeightやAlphaが変わったらDxLib::MakeScreenのやり直し<br>
          &nbsp;&nbsp;&nbsp; bool isFrameShow = false; // ウィンドウのフレームを描くか<br>
          &nbsp;&nbsp;&nbsp; bool isBarShow = false; // ウィンドウズみたいなウィンドウのバーを描くか<br>
          &nbsp;&nbsp;&nbsp; int barFrameHeight = 15; // ウィンドウのバーの高さ<br>
          &nbsp;&nbsp;&nbsp; int barFrameFontSize = 14; // ウィンドウのバーのnameのフォントサイズ<br>
          &nbsp;&nbsp;&nbsp; unsigned int barColor = DxLib::GetColor(0, 0, 0); //バーの色<br>
          <br>
          &nbsp;&nbsp;&nbsp; unsigned int stringColor = DxLib::GetColor(255, 255, 255); //サブスクリーンの枠の色<br>
          &nbsp;&nbsp;&nbsp; std::string drawString = ""; // デバッグなどのためにスクリーンの左上に表示する文字列(サブスクリーン番号など)<br>
          &nbsp;&nbsp;&nbsp; std::string tag = "";<br>
          &nbsp;&nbsp;&nbsp; std::string name = ""; //サブスクリーン名<br>
          <br>
          &nbsp;&nbsp;&nbsp; int GetID() { return id; } // サブスクリーンの管理ID<br>
          &nbsp;&nbsp;&nbsp; inline static int NewID() { return ++serialDivID; } //スクリーンの通し番号を+1(先に+1するので0はなく1からID割り振り)<br>
          <br>
          &nbsp;&nbsp;&nbsp; static std::shared_ptr&lt;SubScreen&gt; Get(int id) { // ★constは添え字[]読み取りの処理を定義<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (SubScreen::layers.count(id) == 0)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert("指定したIDの分割スクリーンはまだ未生成！Make()関数で新規生成してください" == "");<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return layers[id]; // 読み取り<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          protected:<br>
          &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ペア&lt;Depth, id&gt;<br>
          &nbsp;&nbsp;&nbsp; typedef std::pair&lt;int, int&gt; depth_id_pair;<br>
          &nbsp;&nbsp;&nbsp; static std::multiset&lt;depth_id_pair&gt; depth_id_ordered; // std::multiset[キーの無い版のstd::map(マルチでキーかぶりOK版)] http://alctail.sakura.ne.jp/tip/cplus_kannrenn/cplusplus/stl.shtml#stl2-7<br>
          public:<br>
          &nbsp;&nbsp;&nbsp; // オーダー(並べ替えられた)IDを返す<br>
          &nbsp;&nbsp;&nbsp; static std::vector&lt;int&gt; GetOrderedIDs(bool isDesc = false) { // Desc(降順) 4 3 2 2 1 みたいな降りるid順<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; orderedIDs;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::multiset&lt;depth_id_pair&gt;::iterator ite = depth_id_ordered.begin();<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (ite != depth_id_ordered.end())<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id = ite-&gt;second;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orderedIDs.emplace_back(id); // depth順に追加<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ite++;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isDesc) return orderedIDs;<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[逆順の範囲for文] https://koturn.hatenablog.com/entry/2018/07/21/190000<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; descIDs;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto itr = std::rbegin(orderedIDs); itr != std::rend(orderedIDs); ++itr)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; descIDs.emplace_back(*itr); // 逆順に<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return descIDs;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; class Greater_Depth<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; public: // Depthでソートするために比較用オペレータを定義<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool operator() (SubScreen* left, SubScreen* right) const<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (left-&gt;Depth &gt; right-&gt;Depth); // 不等号 &gt; で比較<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; };<br>
          &nbsp;&nbsp;&nbsp; // Depthでソートするためにオペレータをオーバーロード<br>
          &nbsp;&nbsp;&nbsp; bool operator &lt; (const SubScreen&amp; another) const {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this-&gt;Depth &gt; another.Depth;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; //[protectedなコンストラクタでもstd::make_sharedで呼ぶテク] https://gintenlabo.hatenablog.com/entry/20131211/1386771626<br>
          &nbsp;&nbsp;&nbsp; template&lt;typename ProtectedT&gt;<br>
          &nbsp;&nbsp;&nbsp; struct ProtectedCall : public ProtectedT // ProtectedTをpublicで継承することで ProtectedCallから見てProtectedTのコンストラクタはpublicになるテク<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class... ArgsT&gt; // std::make_sharedはprotectedな継承クラスは呼べないのでそれを回避するテクニック<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; explicit ProtectedCall(ArgsT&amp;&amp;... args)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : ProtectedT(std::forward&lt;ArgsT&gt;(args)...) { } //std::forwardで複数引数を完全転送で引き渡し https://proc-cpuinfo.fixstars.com/2016/03/c-html/<br>
          &nbsp;&nbsp;&nbsp; };<br>
          <br>
          &nbsp;&nbsp;&nbsp; struct Layers : public std::unordered_map&lt;int, std::shared_ptr&lt;SubScreen&gt;&gt; // std::unordered_mapを継承してmake_sharedの機能も追加する<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class TypeT&gt;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;TypeT&gt; make_shared() // この関数経由で新規生成すればNewIDで新しいIDで辞書にemplaceで登録もいっしょにしてくれる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int newID = SubScreen::NewID(); //スクリーンの通し番号を+1(先に+1するので0はなく1からID割り振り)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pNewObj = std::make_shared&lt;ProtectedCall&lt;TypeT&gt;&gt;(); // std::make_sharedで共有状態で新規生成 (ProtectedCall経由でprotectedなコンストラクタも呼べる)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;emplace(newID, pNewObj); //★idはかぶらないはずだからそれをキーに辞書に登録<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::dynamic_pointer_cast&lt;TypeT&gt;(this-&gt;at(newID));// std::shared_ptrのキャスト https://chiku2gonzalez.hatenablog.com/entry/2014/10/23/230011<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; };<br>
          &nbsp;&nbsp;&nbsp; static Layers layers; // 生成したサブスクリーンの高速辞書配列&lt;id,サブスクリーンの共有ポインタ&gt;<br>
          <br>
          protected:<br>
          &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:(外部読み取り不可)にしておくのでCreate()関数で生成してCreate().Set(～)で初期設定して ください<br>
          &nbsp;&nbsp;&nbsp; // [Factoryパターン:生成経路限定工場] https://qiita.com/shoheiyokoyama/items/d752834a6a2e208b90ca<br>
          &nbsp;&nbsp;&nbsp; // Factoryパターンの本質はクラスのユーザーに勝手にnewやmake_sharedで自由にコンストラクタを呼ばせないこと<br>
          &nbsp;&nbsp;&nbsp; // newのかわりにCreate関数を経由して生成を強制することでCreateと同時にIDを振ったり辞書に登録して勝手にnewされて一貫性が崩れるの を防ぐ<br>
          &nbsp;&nbsp;&nbsp; SubScreen() //float x = 0, float y = 0, float Width = 0, float Height = 0, int Alpha = 255, int Depth = 0, std::string name = "")<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // std::enable_shared_from_thisを継承するとコンストラクタ内ではまだthisは未確定なので shared_from_this()を使う関数(例.Set関数)は呼べなくなる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set(x, y, Width, Height, Alpha, Depth, name);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;id = SubScreen::serialDivID; // 通し番号割り振り(ゲーム中は被らない【通し】番号)<br>
          &nbsp;&nbsp;&nbsp; }<br>
          public:<br>
          &nbsp;&nbsp;&nbsp; // 新しくサブスクリーンを生成してそれへの共有ポインタを返す<br>
          &nbsp;&nbsp;&nbsp; static std::shared_ptr&lt;SubScreen&gt; Create()<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isDepthLayerChanged = true; // 新しいレイヤーが増えたので再並べ替えフラグをオンに<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return SubScreen::layers.make_shared&lt;SubScreen&gt;();<br>
          &nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; // サブスクリーンを削除<br>
          &nbsp;&nbsp;&nbsp; static void Erase(int id) { SubScreen::layers.erase(id); isDepthLayerChanged = true; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; virtual ~SubScreen() { if (handle &gt;= 0) DxLib::DeleteGraph(handle); } // 仮想デストラクタ<br>
          <br>
          &nbsp;&nbsp;&nbsp; virtual void InitScreen()<br>
          &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 分割画面を描くためのスクリーンの描画ハンドルを得る<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★複数プレイヤ画面や複数カメラ視点に使える[敵目線カメラサブ画面など]<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (renderWidth &gt;= 1 &amp;&amp; renderHeight &gt;= 1)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [描画スクリーンの紙を用意] https://dxlib.xsrv.jp/function/dxfunc_graph1.html#R3N25<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle = DxLib::MakeScreen((int)renderWidth, (int)renderHeight, (Alpha == 255 ? FALSE : TRUE));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↑[半透明スクリーンも可] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=3650<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitAgain = false; // 再びInitが必要かのフラグをオフに<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetX(float x) { this-&gt;x = x; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetY(float y) { this-&gt;y = y; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetZoomRate(float zoomRate) { this-&gt;zoomRate = (zoomRate &lt; 0.1f) ? 0.1f : zoomRate; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetWidth(float width) { this-&gt;Width = width;&nbsp; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetHeight(float height) { this-&gt;Height = height; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetRenderX(float renderX) { this-&gt;renderX = renderX; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetRenderY(float renderY) { this-&gt;renderY = renderY; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetRenderWidth(float renderWidth) { if (((int)this-&gt;renderWidth) != (int)renderWidth)&nbsp; isInitAgain = true; this-&gt;renderWidth = renderWidth;&nbsp;&nbsp; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetRenderHeight(float renderHeight) { if (((int)this-&gt;renderHeight) != (int)renderHeight) isInitAgain = true; this-&gt;renderHeight = renderHeight; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetAlpha(int alpha) { if (((int)this-&gt;Alpha) != (int)alpha)&nbsp; isInitAgain = true;&nbsp; this-&gt;Alpha = alpha;&nbsp; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetDepth(int depth) { if (this-&gt;Depth != depth) isDepthLayerChanged = true; this-&gt;Depth = depth; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレームに表示出力する文字の設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetDrawString(std::string drawString = "") { this-&gt;drawString = drawString; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレーム枠の幅の設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetFrameWidth(int frameWidth) { this-&gt;frameWidth = frameWidth; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレーム枠の色の設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetFrameColor(unsigned int frameColor) { this-&gt;frameColor = frameColor; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレームとバーを見せるかの設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetIsBarFrameShow(bool isBarShow, bool isFrameShow = true) { this-&gt;isBarShow = isBarShow; this-&gt;isFrameShow = isFrameShow; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレームのバーの高さの設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetBarFrameHeight(int barFrameHeight) { this-&gt;barFrameHeight = barFrameHeight; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレームのバーのnameのフォントのサイズ設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetBarFrameFontSize(int barFrameFontSize) { this-&gt;barFrameFontSize = barFrameFontSize; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレームのバーの背景色設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetBarColor(unsigned int barColor) { this-&gt;barColor = barColor; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレームの設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetFrame(int frameWidth, unsigned int frameColor, bool isBarShow = false, int barFrameHeight = 15) { this-&gt;frameWidth = frameWidth; this-&gt;isFrameShow = (frameWidth&gt;0)?true:false; this-&gt;frameColor = frameColor; this-&gt;isBarShow = isBarShow; this-&gt;barFrameHeight = barFrameHeight; return shared_from_this(); }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 色々セッティングして初回と設定変更があった時だけサブ画面を描くためのスクリーンの描画ハンドルを得る<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; Set(float x = 0, float y = 0, float width = 0, float height = 0, int alpha = 255, int depth = 0, std::string name = "")<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x = x; this-&gt;y = y;<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWidth(width); SetHeight(height); SetRenderWidth(width); SetRenderHeight(height); SetAlpha(alpha);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isInitAgain) InitScreen(); // 変更があるか確認してある時だけInitし直すようにすると早くなる<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;Depth != depth) isDepthLayerChanged = true; // Depthに変更があれば再並べ替えフラグをオンに<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;Depth = depth; this-&gt;name = name;<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return shared_from_this(); // 設定した後の自分自身を返す<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; virtual void Update()<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // なにかUpdateしたいことがあれば処理を追加<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; virtual void Draw()<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawScreen(); // スクリーンをDrawRectExtendGraphを使って描く(ズームやアルファ透明度も反映させる)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawFrame(); // スクリーンのまわりにフレームを描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawBarFrame(); // スクリーンの上にWindowsみたいなバーを描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // デバッグ用の文字表示<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpFontSize = GetFontSize();// 元のフォントサイズを保管<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetFontSize(barFrameFontSize); // 描画する文字列のサイズを設定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString((int)x, (int)y, drawString.c_str(), stringColor); // デバッグ用の文字列をスクリーンの左上(0,0)に描画<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetFontSize(tmpFontSize); // 元のフォントサイズ設定にすぐ戻す<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; virtual void DrawScreen() // スクリーンをDrawRectExtendGraphを使って描く(ズームやアルファ透明度も反映させる)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpBlendMode, tmpBlendParam;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetDrawBlendMode(&amp;tmpBlendMode, &amp;tmpBlendParam); // 現在の描画ブレンドモードを取得しておく<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Alpha != 255) DxLib::SetDrawBlendMode(DX_BLENDMODE_ALPHA, Alpha); // 半透明のスクリーンも描ける https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4978<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 画面ウィンドウに描画されたスクリーン内容を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawRectExtendGraph((int)x, (int)y, (int)(x + Width * zoomRate), (int)(y + Height * zoomRate), renderX, renderY, renderWidth, renderHeight, handle, (Alpha == 255 ? FALSE : TRUE));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Alpha != 255) DxLib::SetDrawBlendMode(tmpBlendMode, tmpBlendParam); // もとのブレンドモードに戻しておく<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; virtual void DrawFrame() // スクリーンのまわりにフレームを描く<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isFrameShow) return; // フレームを描かない設定の場合<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //サブスクリーンの枠の表示<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int f = 1; f &lt;= frameWidth; f++)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)x - f + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)y - 1 + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(x + Width * zoomRate + f) + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(y + Height * zoomRate + f) + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameColor, FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; virtual void DrawBarFrame() // スクリーンの上にWindowsみたいなバーを描く<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isBarShow) return; // バーのフレームを描かない設定の場合<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // バーの背景の地を塗りつぶす<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)x + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)y - barFrameHeight + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(x + Width * zoomRate) + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(y - 1) + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; barColor, TRUE);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マウスが上に乗った時の色はGetColor(255, 0, 0)で赤枠にしている<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int mouseOverColor = (this-&gt;id == topMouseOverID) ? GetColor(255, 0, 0) : frameColor;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int barFrameWidth = (1 &lt; frameWidth) ? 2 : 1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for文でフレームの枠=frameWidthの大きさぶんBoxを複数描いて枠を太くする<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int f = frameWidth - barFrameWidth; f &lt;= frameWidth; f++)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)x - f + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)y - barFrameHeight - f + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(x + Width * zoomRate + f) + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(y + Height * zoomRate + f) + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (f == frameWidth) ? mouseOverColor : frameColor, FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // バーにウィンドウの名前表示(バーの高さがフォントのサイズ以下なら文字サイズをバーの大きさに合わせる)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpFontSize = GetFontSize();// 元のフォントサイズを保管<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetFontSize((barFrameHeight &gt; barFrameFontSize) ? barFrameFontSize : barFrameHeight); // 描画する文字列のサイズを設定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString((int)x, (int)y - barFrameHeight, name.c_str(), frameColor); // バーにnameの文字列を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetFontSize(tmpFontSize); // 元のフォントサイズ設定にすぐ戻す<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          <br>
          &nbsp;&nbsp;&nbsp; static void UpdateScreens() // スクリーンの状態の更新(ドラッグ移動など)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; subScreen : layers)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subScreen.second-&gt;Update();<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //OrderByLayerDepth(); // レイヤーのDepth順に並べ替え→FocusOnClickScreen関数でやる<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FocusOnClickScreen(); // クリックしたスクリーンを一番上にするように並べ替え<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DragScreen();// サブスクリーンをドラッグで移動できるように<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZoomScreens(); // サブスクリーンをマウスホイールでズームインズームアウトできるように<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; static void DrawScreens() // サブスクリーンを全部まとめて描く<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderByLayerDepth(); // レイヤーのDepth順に並べ替え<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //↓並べ変わった順を使ってDepth順にサブスクリーンをDraw<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::multiset&lt;depth_id_pair&gt;::iterator ite = depth_id_ordered.begin();<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (ite != depth_id_ordered.end())<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id = ite-&gt;second;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (layers.count(id) &gt; 0)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; layers[id]-&gt;Draw(); // depth順にDrawでサブスクリーンを複数レイヤーで描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ite++;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // サブスクリーンの描画内容をきれいにクリア<br>
          &nbsp;&nbsp;&nbsp; void ClearDrawScreen()<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (handle &lt; 0) return;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawStart(); // 設定先をサブスクリーンとする<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen(); // 一旦 サブスクリーンをきれいにクリア<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawEnd();<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // ★このStartとEndのあいだの描画処理はサブスクリーンに描かれるようになる<br>
          &nbsp;&nbsp;&nbsp; void DrawStart()<br>
          &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブスクリーンが描画可能状態なら<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (handle &lt; 0) return;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isInitAgain) InitScreen();// 変更があるか確認してある時だけInitでDxLib::MakeScreenをし直す<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpResetSetting = GetUseSetDrawScreenSettingReset(); // 設定を一旦tmpに退避<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetUseSetDrawScreenSettingReset(FALSE); // SetDrawScreen切り替え時に設定をリセットしない(FALSE)(これをやらないとカメラ視点などがリセットされるから)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpDrawScreen = DxLib::GetDrawScreen(); // Endまでのあいだ一旦変更前のhandleを退避<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ゲームを描く先を用意しておいたサブスクリーンに設定(キャンバスを指定する)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawScreen(handle);<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // ★このStartとEndのあいだの描画処理はサブスクリーンに描かれるようになる<br>
          &nbsp;&nbsp;&nbsp; void DrawEnd()<br>
          &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブスクリーンが描画可能状態なら<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (handle &lt; 0) return;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ゲームを描く先をもとのデフォルトに戻しておく<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawScreen((tmpDrawScreen == -1) ? DX_SCREEN_BACK : tmpDrawScreen);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetUseSetDrawScreenSettingReset((tmpResetSetting == -1) ? TRUE : tmpResetSetting); // 設定をすぐに元に戻す<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          <br>
          <br>
          &nbsp;&nbsp;&nbsp; // スタティック機能群(サブスクリーンの辞書やマウスでのドラッグ移動など)<br>
          public:<br>
          &nbsp;&nbsp;&nbsp; static bool isMouseOvered; //= false マウスオーバーしてるレイヤがあるか<br>
          &nbsp;&nbsp;&nbsp; static int topMouseOverID; //= -1 一番上のマウスオーバーしてるレイヤのID<br>
          &nbsp;&nbsp;&nbsp; static int topDepthID; //= -1 一番上のレイヤのID<br>
          &nbsp;&nbsp;&nbsp; static int topDepth; //= -1 一番上のレイヤのDepth<br>
          protected:<br>
          &nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp; static void OrderByLayerDepth() // レイヤーのDepth順に並べ替え<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isDepthLayerChanged) return; // レイヤーのDepthに変化がなければ並べ替えは不要<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; depth_id_ordered.clear(); // 並べ替え前に既存の順序データを一度クリア<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; subScreen : layers)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id = subScreen.first;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int depth = subScreen.second-&gt;Depth;//ペア(左,右)だと左の数字の順に自動で並ぶ<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; depth_id_ordered.insert(std::make_pair(depth, id)); // https://qiita.com/izmktr/items/17e3009041b841b26a34<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } //全部マルチセットに↑入れると自動でdepth順に並べ変わってる<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CheckLayerOrder(); // マウスオーバーしてるレイヤや一番上のレイヤも再び調べる<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; static void CheckLayerOrder() // 一番上のマウスオーバーしてるレイヤを調べる<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::TopLayerMouseX = Input::MouseX; Input::TopLayerMouseY = Input::MouseY; // 一番上のレイヤのTopLayerMouseマウス座標をリセット<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isMouseOvered = false; // ループを回す前にfalseで初期化<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; topMouseOverID = -1; // -1ならマウスオーバーしているレイヤはない<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //↓並べ変わった順を使ってDepth順に調べ、一番上のマウスオーバーしてるレイヤを調べる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::multiset&lt;depth_id_pair&gt;::iterator ite = depth_id_ordered.begin();<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; topDepth = -1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (ite != depth_id_ordered.end())<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id = ite-&gt;second;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto subscreen = layers[id];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool _isMouseOvered = subscreen-&gt;IsOnBarFrame((float)Input::MouseX, (float)Input::MouseY);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_isMouseOvered &amp;&amp; id &gt;= 0) // depth順で一番上のマウスオーバーしてるレイヤを調べる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; topMouseOverID = id; // idが0以上のレイヤしか検知しない<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_isMouseOvered)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isMouseOvered |= _isMouseOvered; // | で[または]のビット演算(1つでもtrueがあれば最終的にtrueに)<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ite-&gt;first &gt;= topDepth)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; topDepthID = id; // マウスが乗ってるかと関係なしに最大Depthも記録<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; topDepth = ite-&gt;first;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ite++;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ite == depth_id_ordered.end() &amp;&amp; topMouseOverID != -1)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto topLayerScreen = layers[topMouseOverID];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 一番上のレイヤーのマウスの「ローカルな」座標を登録しておけば「そのウィンドウ内のマウス位置」を得られる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::TopLayerMouseX = topLayerScreen-&gt;LocalX(Input::MouseX);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::TopLayerMouseY = topLayerScreen-&gt;LocalY(Input::MouseY); // LocalXYならそのウィンドウの左上を(0,0)とした「ウィンドウ内のマウス位置」が求まる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          public:<br>
          &nbsp;&nbsp;&nbsp; static int clickDownID; //= -1 クリックした瞬間のマウスが乗ってるサブウィンドウの番号(マウスを話した瞬間のIDと比べて同じならそのウィンドウにフォーカスする)<br>
          &nbsp;&nbsp;&nbsp; static void FocusOnClickScreen() // クリックしたスクリーンを一番上にするように並べ替え<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderByLayerDepth(); // レイヤーのDepth順に並べ替え<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (topMouseOverID == -1) return;<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(Pad::Mouse, MOUSE_INPUT_LEFT)) // マウスの右ボタンが押された瞬間か？(ドラッグ開始)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // clickDownID = クリックした瞬間(ドラッグ開始時)のマウスが乗ってる一番上のサブウィンドウのID番号<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clickDownID = topMouseOverID;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (Input::GetButtonUp(Pad::Mouse, MOUSE_INPUT_LEFT)) // マウスの右ボタンが離された瞬間か？<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int clickUpID = topMouseOverID; // マウスのクリックを離した瞬間のスクリーンIDは基本はマウスが乗っている一番上のスクリーン<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (topMouseOverID != clickDownID // ↑例外的に、clickDownIDがマウスを離した瞬間のtopMouseOverIDと違うとき<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; layers.count(clickDownID) &gt; 0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; layers[clickDownID]-&gt;Depth &lt; layers[topMouseOverID]-&gt;Depth) // clickDownIDのDepthがマウスを離した瞬間に一番上にあるウィンドウのDepthより小さい<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clickUpID = clickDownID; // clickUpIDをドラッグ中の後ろに隠れているウィンドウに変える<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ドラッグを離した瞬間のスクリーンを一番上のDepthへと書き換えたい<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (layers.count(topDepthID) &gt; 0)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto clickUpScreen = layers[clickUpID]; // マウスを離した瞬間のドラッグ中の一番上のレイヤにしたいスクリーン<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto topDepthScreen = layers[topDepthID]; // Depthが一番大きいスクリーン<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (clickUpScreen-&gt;Depth &lt;= topDepthScreen-&gt;Depth) // Depthが一番大きいスクリーンよりクリックを離したスクリーンのDepthが小さいなら<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int newTopDepth = topDepthScreen-&gt;Depth;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (clickUpScreen-&gt;Depth == newTopDepth &amp;&amp; clickUpID != topDepthID)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newTopDepth++; //&nbsp; マウスを離した瞬間のマウスが乗ってる一番上のレイヤのスクリーンのDepthをtopDepthScreenより+1大きくする<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (clickUpScreen-&gt;Depth != topDepthScreen-&gt;Depth)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; topDepthScreen-&gt;SetDepth(clickUpScreen-&gt;Depth); // 現在の一番上のレイヤのスクリーンとクリックを離したスクリーンのDepthを入れ替え<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clickUpScreen-&gt;SetDepth(newTopDepth); // +1大きくしたDepthをSetする<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderByLayerDepth(); // [再び並べ替え]レイヤーのDepth順に<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; /*static void FocusOnScreen(int id)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 特定のidへフォーカスさせたければ関数を自作してもよいかも<br>
          &nbsp;&nbsp;&nbsp; }*/<br>
          <br>
          &nbsp;&nbsp;&nbsp; static int prevDragX; //= -1 直前のドラッグ中のマウスの位置<br>
          &nbsp;&nbsp;&nbsp; static int prevDragY; //= -1 直前のドラッグ中のマウスの位置<br>
          &nbsp;&nbsp;&nbsp; static bool isDraging() { return (dragingID != -1); }<br>
          &nbsp;&nbsp;&nbsp; static int dragingID; //= -1 ドラッグ中のサブスクリーンのID<br>
          <br>
          &nbsp;&nbsp;&nbsp; static bool DragScreen() // サブスクリーンをドラッグで移動できるように<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int dragID = -1; // ドラッグ移動する一番上のサブスクリーンのID<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dragingID == -1 &amp;&amp; isMouseOvered)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dragID = topMouseOverID;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dragingID != -1)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dragID = dragingID;<br>
          <br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dragID != -1 &amp;&amp; Input::Click[Mouse::DragL] &amp;&amp; Screen::IsInsideWindow())<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto dragScreen = layers[dragID];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dragingID = dragID;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (prevDragX != -1 &amp;&amp; prevDragY != -1)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ★前の位置prevと現在の位置に移動があれば、その差ぶんだけ+=することでドラッグ移動を実現<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragLX])<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dragScreen-&gt;x += (float)(Input::Click[Mouse::DragLX] - prevDragX);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (prevDragY != Input::Click[Mouse::DragLY])<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dragScreen-&gt;y += (float)(Input::Click[Mouse::DragLY] - prevDragY);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevDragX = Input::Click[Mouse::DragLX];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevDragY = Input::Click[Mouse::DragLY];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevDragX = -1; prevDragY = -1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dragingID = -1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // サブスクリーンをバーの上てマウスホイールグリグリするとズームインズームアウトできるように<br>
          &nbsp;&nbsp;&nbsp; static void ZoomScreens(bool isZoomByBar = true)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isMouseOvered) return;<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto zoomScreen = layers[topMouseOverID];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isZoomByBar &amp;&amp; !zoomScreen-&gt;IsOnBar((float)Input::MouseX, (float)Input::MouseY))<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return; // バーの上にカーソルがない<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zoomScreen-&gt;SetZoomRate(zoomScreen-&gt;zoomRate + 0.1f * (Input::MouseWheel));<br>
          &nbsp;&nbsp;&nbsp; }<br>
          };<br>
        </em><br>
        <br>
        #endif<br>
      </p>
      <p><code>Screen.cppを新規作成</code>して static変数を定義しましょう。</p>
      <p class="source">#include "Screen.h"<br>
        <br>
        int SubScreen::serialDivID{ 0 }; // サブスクリーンを新たに生成するときの通し番号(シリアルID)<br>
        bool SubScreen::isDepthLayerChanged{ false }; // 新しいレイヤが追加されり変更があった時だけ並べ替えるためのフラグ<br>
        <br>
        std::multiset&lt;SubScreen::depth_id_pair&gt; SubScreen::depth_id_ordered; // std::multiset[キーの無い版のstd::map(マルチでキーかぶりOK版)]<br>
        <br>
        bool SubScreen::isMouseOvered{ false }; // マウスオーバーしてるレイヤがあるか<br>
        int SubScreen::topMouseOverID{ -1 }; // 一番上のマウスオーバーしてるレイヤのID<br>
        int SubScreen::topDepthID{ -1 }; // 一番上のレイヤのID<br>
        int SubScreen::topDepth{ -1 }; // 一番上のレイヤのDepth<br>
        <br>
        <br>
        SubScreen::Layers SubScreen::layers; // 生成したサブスクリーンの高速辞書配列&lt;id,サブスクリーンの共有ポインタ&gt;<br>
        <br>
        int SubScreen::clickDownID{ -1 }; // クリックした瞬間のマウスが乗ってるサブウィンドウの番号(マウスを話した瞬間のIDと比べて同じならそのウィンドウにフォーカスする)<br>
        <br>
        int SubScreen::prevDragX{ -1 }; // 直前のドラッグ中のマウスの位置<br>
        int SubScreen::prevDragY{ -1 }; // 直前のドラッグ中のマウスの位置<br>
        int SubScreen::dragingID{ -1 }; // ドラッグ中のサブスクリーンのID<br>
      </p>
      <p>ウィンドウのドラッグってどうやってるのって、シンプルにいうなら<br>
        <span style="font-weight: bold; text-decoration: underline;">前の瞬間(prev)と 現在の位置に移動があれば、その差ぶんだけ+=する</span>、というだけなのでベースとなっているアイデア自体は実はシンプルなものです<br>
        (ただレイヤーの並べ替えとか一番上じゃないレイヤーをクリックしたときにフォーカスして一番上にするとか考え出すと結構たいへんですが)<br>
        <br>
      </p>
      <p><code>main.cpp</code>のコードにSubScreenクラスを使ってドラッグできるウィンドウズみたいなサブのスクリーンを表 示させてみましょう。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        <em>#include "Input.h"</em><br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
        &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
        &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
        &nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply", Data); // .plyデータをロード 軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう<br>
        <br>
        &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
        <br>
        &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
        &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
        &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
        <br>
        &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
        &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
        &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
        &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        <br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
        &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 200.0f; keyControlXYZ.y = 200.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
          &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
          &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
          &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; <u>float subscreenX = 0, subscreenY = 0; // 別描画スクリーンを描く位置<br>
          &nbsp;&nbsp;&nbsp; int subscreenWidth = 600, subscreenHeight = 100;<br>
          &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE); // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドル作成を TRUE:許可<br>
          &nbsp;&nbsp;&nbsp; // [別の描画スクリーンを用意] https://dxlib.xsrv.jp/function/dxfunc_graph1.html#R3N25<br>
          &nbsp;&nbsp;&nbsp; int subscreen = DxLib::MakeScreen(subscreenWidth, subscreenHeight, FALSE);<br>
          &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE); // FLASE:通常のグラフィックハンドルを作成するモードに戻す</u><br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Input::Update(); // マウスのドラッグなどを更新<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens(); // スクリーンの位置やドラッグによる移動を更新する</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>int MouseX, MouseY;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マウスの位置を取得<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetMousePoint(&amp;MouseX, &amp;MouseY);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreenX = MouseX; subscreenY = MouseY; // マウスのポインタの位置を起点にサブのスクリーンを描く</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(50.0f, 50.0f, 50.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>int tmpResetSetting = DxLib::GetUseSetDrawScreenSettingReset(); // 設定を一旦tmpに退避<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseSetDrawScreenSettingReset(FALSE); // SetDrawScreen切り替え時に設定をリセットしない(FALSE)(これをやらないとカメラ視点などがリセットされるから)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpDrawScreen = DxLib::GetDrawScreen(); // 一旦変更前のスクリーンのハンドルを退避<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawScreen(subscreen);// ゲームを描く先を用意しておいたサブスクリーンに設定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // (0,0)位置を起点に別 スクリーンへ文字列を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawScreen((tmpDrawScreen == -1) ? DX_SCREEN_BACK : tmpDrawScreen); // 描く先をもとのデフォルトのスクリーンに戻しておく<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseSetDrawScreenSettingReset((tmpResetSetting == -1) ? TRUE : tmpResetSetting); // 設定を元に戻す<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 画面に別スクリーンの内容を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawRectExtendGraph((int)subscreenX, (int)subscreenY, (int)(subscreenX + subscreenWidth), (int)(subscreenY + subscreenHeight), 0, 0, subscreenWidth, subscreenHeight, subscreen, FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 別スクリーンの枠を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox( (int)((int)subscreenX - 1 + 0.5f),(int)((int)subscreenY - 1 + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(subscreenX + subscreenWidth + 1) + 0.5f), (int)((int)(subscreenY + subscreenHeight + 1) + 0.5f), GetColor(255,255,255), FALSE);</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 半透明のスクリーンも描ける<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height, GetColor(0, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();</em><br>
        <em><br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); // サブのスクリーンを全部描く</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <p>いかがですか?ウィンドウズっぽいものが自作できたでしょうか?<br>
        ドラッグだけじゃなくバーの上でマウスのホイールをグリグリするとウィンドウがズームできる機能もおまけでついてます<br>
      </p>
      <br>
      <br>
      <br>
    </a><a id="mozTocId0006" class="mozTocH1">
      <h1>エディタを自作して視点カメラを動かせるようにする</h1>
      <br>
      <p><code>Singleton.hを新規作成</code>して Editorクラスが唯一のシングルトンを継承できるように準備する。</p>
      <p class="source">#ifndef SINGLETON_H_<br>
        #define SINGLETON_H_<br>
        <br>
        // テンプレートT型シングルトンSingleton&lt;～&gt; ～になんでも指定して唯一物にできる<br>
        // ★Singleton&lt;T&gt;型は【必ず唯一で複製不可】(使い方:どこからでもアクセスし変数を共有するクラス向き)<br>
        // ★ゲーム内の【どこからアクセスしても統一性が保たれる】(唯一だから)「クラス名と実体が一致」<br>
        template&lt;class T&gt;<br>
        class Singleton<br>
        {<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; // GetInstanceを通して【しか】T型クラスをつくれないうえに、<br>
        &nbsp;&nbsp;&nbsp; // ★作ったものは【かならず唯一で複製不可】<br>
        &nbsp;&nbsp;&nbsp; // それが【シングルトン型】！<br>
        &nbsp;&nbsp;&nbsp; // ゲーム中で唯一で複製不可にしたい【ゲームを一律管理するクラス】などに最適！<br>
        &nbsp;&nbsp;&nbsp; // https://teratail.com/questions/17416<br>
        &nbsp;&nbsp;&nbsp; // http://rudora7.blog81.fc2.com/blog-entry-393.html<br>
        &nbsp;&nbsp;&nbsp; // ②↓同じ関数の定義はプログラム全体で１つだけしか許されません。(static関数名は被らない)<br>
        &nbsp;&nbsp;&nbsp; static inline T&amp; GetInstance()<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //①↓関数の中で定義されたstatic変数は、関数の定義毎に１つ領域が確保されます。<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static T instance; //メモリ上にstatic変数確保(静かに常に待機するinstance)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return instance; //①=(常駐)②=(唯一) ①と②両方満たすinstanceは【メモリ上に唯一】<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        protected:<br>
        &nbsp;&nbsp;&nbsp; Singleton() {} // 外部でのインスタンス作成は禁止(protected:内部公開、外部禁止)<br>
        &nbsp;&nbsp;&nbsp; virtual ~Singleton() {} // 仮想デストラクタ(シングルトンを【継承するためには忘れちゃダメ】)<br>
        <br>
        private:<br>
        &nbsp;&nbsp;&nbsp; void operator=(const Singleton&amp; obj) {} // 代入演算子禁止<br>
        &nbsp;&nbsp;&nbsp; Singleton(const Singleton&amp; obj) {} // コピーコンストラクタ禁止(コピーできない【唯一】)<br>
        &nbsp;&nbsp;&nbsp; static T* instance; // private:だから外部アクセスできない【GetInstance()経由しか無理】<br>
        };<br>
        <br>
        // ふだんcppで書くstatic変数初期化も★【Tテンプレートクラスだからすべて.hヘッダにまとめて書いた】<br>
        template&lt; class T &gt;<br>
        T* Singleton&lt; T &gt;::instance = 0; // static変数はclass内で初期化できないが、class外では = 0できる<br>
        <br>
        #endif<br>
      </p>
      <br>
      <p><code>Editor.hを新規作成</code>して マウスの右ドラッグでカメラを回転、左ドラッグでカメラの視点を移動、<br>
        キーボードのT,Yキーでカメラz軸回転、キーボードのH,Jキーでカメラy軸回転、キーボードのV,Bキーでカメラx軸回転できるようにする。</p>
      <p class="source">#ifndef EDITOR_H_<br>
        #define EDITOR_H_<br>
        <br>
        #include "DxLib.h"<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        <br>
        #include "Singleton.h"<br>
        <br>
        class Editor : public Singleton&lt;Editor&gt;<br>
        {<br>
        public:<br>
        <br>
        &nbsp;&nbsp;&nbsp; struct Camera<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x = 0.f, y = 0.0f, z = -10.0f; // カメラはz軸マイナス位置からz軸プラス向きに原点を見る形で初期化される<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float VRotate = 0.0f, HRotate = 0.0f, TRotate = 0.0f; // X軸 V,Y軸 H,Z軸 T まわりのカメラのオイラー回転の角度<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; inline Camera&amp; operator +=(VECTOR move) { x += move.x; y += move.y; z += move.z; return *this; } // VECTOR型を足したときはカメラを移動させる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float wheelSpeed = 1.0f; // マウスのホイールと連動した際のカメラのスピード<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR GetCameraWorldDirByScreenXY(float screenX = (float)Input::MouseX, float screenY = (float)Input::MouseY)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // スクリーン(X,Y)からマウスの指すワールド座標(X,Y,Z)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR currentPos = DxLib::ConvScreenPosToWorldPos(VGet(screenX, screenY, 0.0f));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラからマウスの指す位置への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return DxLib::VNorm(DxLib::VGet(currentPos.x - x, currentPos.y - y, currentPos.z - z));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; };<br>
        &nbsp;&nbsp;&nbsp; Camera camera;<br>
        <br>
        &nbsp;&nbsp;&nbsp; int prevDragX = -1, prevDragY = -1; // 前フレームでのスクリーン上でのドラッグXY位置<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; bool isInitFinished = false; // 一回でもInitされたかのフラグ<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; void Init()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isInitFinished) return; // 最初の一回だけInit処理をするためのフラグ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitFinished = true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateKeyInput()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_V))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_B))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_H))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_J))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_T))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_Y))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateMouseInput()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!SubScreen::isMouseOvered) // マウスオーバーしているSubscreenがないとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::MouseWheel != 0.0f) // マウスのホイールをグリグリしたとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界の奥への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR camNorm = camera.GetCameraWorldDirByScreenXY((float)Input::MouseX, (float)Input::MouseY);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camSpeed = camera.wheelSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.wheelSpeed *= (camera.wheelSpeed &lt; 100.0f) ? 1.5f : 1.0f; // カメラのズーム速度を加速する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 求めた単位ベクトル×カメラのスピードぶんカメラの位置を移動<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.x += camNorm.x * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.y += camNorm.y * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.z += camNorm.z * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (camera.wheelSpeed &gt; 0.1f) camera.wheelSpeed *= 0.9f; // カメラのズーム速度を減衰する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else camera.wheelSpeed = 0.1f; // カメラのズーム速度を減衰して最小0.1にすることで繊細なズーム調整もできるようにする<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((Input::Click[Mouse::DragL] || Input::Click[Mouse::DragR]) &amp;&amp; Screen::IsInsideWindow())<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != -1 &amp;&amp; prevDragY != -1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 前の位置prevと現在の位置に移動があれば、その差ぶんだけ+=することでドラッグ移動を実現<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragL]) // マウス左クリック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragLX] || prevDragY != Input::Click[Mouse::DragLY])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // マウスポインタがある画面上の座標に該当する３Ｄ空間上の座標を取得 https://dxlib.xsrv.jp/function/dxfunc_3d_camera.html#R12N11<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float positionRatio = 0.9f;// 奥行の位置 Near 面 0.0f ～ 1.0f Far 面<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR start = DxLib::ConvScreenPosToWorldPos(VGet((float)prevDragX, (float)prevDragY, positionRatio));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR end = DxLib::ConvScreenPosToWorldPos(VGet((float)Input::Click[Mouse::DragLX], (float)Input::Click[Mouse::DragLY], positionRatio));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camSpeed = 400; // ドラッグに対するカメラの移動速度<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.x -= (end.x - start.x) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.y -= (end.y - start.y) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.z -= (end.z - start.z) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragR]) // マウス右クリック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // カメラの角度を変更<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragRX])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate += (float)(Input::Click[Mouse::DragRX] - prevDragX);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragY != Input::Click[Mouse::DragRY])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate += (float)(Input::Click[Mouse::DragRY] - prevDragY);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ±360度を超えたら割り算の余りを設定して 例.365度 → 5度に戻してやる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (camera.HRotate &gt; 360.0f || camera.HRotate &lt; -360.0f) camera.HRotate = std::fmodf(camera.HRotate, 360.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (camera.VRotate &gt; 360.0f || camera.VRotate &lt; -360.0f) camera.VRotate = std::fmodf(camera.VRotate, 360.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragX = (Input::Click[Mouse::DragL]) ? Input::Click[Mouse::DragLX] : Input::Click[Mouse::DragRX];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragY = (Input::Click[Mouse::DragL]) ? Input::Click[Mouse::DragLY] : Input::Click[Mouse::DragRY];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragX = -1; prevDragY = -1; // マウスのドラッグがないときはリセット<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateCamera()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラの位置と回転値をセット、カメラの位置は原点<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">DxLib::SetCameraPositionAndAngle</span>(<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::VGet(camera.x, camera.y, camera.z),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate * DX_PI_F / 180.0f, camera.HRotate * DX_PI_F / 180.0f, camera.TRotate * DX_PI_F / 180.0f);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // まとめてUpdateしたいときはUpdateを使い、個別にUIやKeyやMouseを別々にタイミングを取りながらUpdateしたいときは Updateは呼ばない<br>
        &nbsp;&nbsp;&nbsp; void Update()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateKeyInput();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateMouseInput();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateCamera();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void Draw()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 原点からx軸(R:赤) y軸(G:緑) z軸(B:青)をライン表示する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(1.0f * 5.0f, 0.0f * 5.0f, 0.0f * 5.0f), GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(0.0f * 5.0f, 1.0f * 5.0f, 0.0f * 5.0f), GetColor(0, 255, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(0.0f * 5.0f, 0.0f * 5.0f, 1.0f * 5.0f), GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 画面に回転量を描画<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, DxLib::GetColor(255, 255, 255), "Cam(x:%f y:%f z:%f)", camera.x, camera.y, camera.z);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 20, DxLib::GetColor(255, 255, 255), "Rot(V:%f H:%f T:%f)", camera.VRotate, camera.HRotate, camera.TRotate);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        #endif<br>
      </p>
      <br>
      <p><code>main.cpp</code>のコードにEditorクラスを使ってカメラの視点を移動、回転させてみま しょう。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        <br>
        <em>#include "Editor.h"</em><br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
        &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
        &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
        &nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply", Data); // .plyデータをロード 軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう<br>
        <br>
        &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
        <br>
        &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
        &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
        &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
        <br>
        &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
        &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
        &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
        &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        <br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
        &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = <em>0.0f</em>; keyControlXYZ.y = <em>0.0f</em>; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>//奥行0.1～5000までをカメラの描画範囲とする<br>
          &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens(); // スクリーンの位置やドラッグによる移動を更新する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画像のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(<em>1.0f, 1.0f, 1.0f</em>); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0<em></em><em></em>, <em>100</em>, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 半透明のスクリーンも描ける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); // サブのスクリーンを全部描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>editor.Draw(); // エディタのDraw処理</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      <br>
      <p>いかがでしょうか？カメラの視点の位置をマウスの左ドラッグで移動、右ドラッグで回転、<br>
        キーボードのT,Yキーでカメラz軸回転、キーボードのH,Jキーでカメラy軸回転、キーボードのV,Bキーでカメラx軸回転できるようになりましたか？<br>
        <br>
        <br>
        <br>
        <br>
      </p>
    </a><a id="mozTocId0007" class="mozTocH1">
      <h1>キーボードのWSキーでカメラ視点を手前や奥に移動でき るようにする</h1>
      <p><code>Editor.h</code>を変更してキーボードのWSキーでカメラ視点を手前や奥に移動できるようにします。</p>
      <p class="source">#ifndef EDITOR_H_<br>
        #define EDITOR_H_<br>
        <br>
        #include "DxLib.h"<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        <br>
        #include "Singleton.h"<br>
        <br>
        class Editor : public Singleton&lt;Editor&gt;<br>
        {<br>
        public:<br>
        <br>
        &nbsp;&nbsp;&nbsp; struct Camera<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x = 0.f, y = 0.0f, z = -10.0f; // カメラはz軸マイナス位置からz軸プラス向きに原点を見る形で初期化される<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; inline Camera&amp; operator +=(VECTOR move) { x += move.x; y += move.y; z += move.z; return *this; } // VECTOR型を足したときはカメラを移動させる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float VRotate = 0.0f, HRotate = 0.0f, TRotate = 0.0f; // X軸 V,Y軸 H,Z軸 T まわりのカメラのオイラー回転の角度<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float wheelSpeed = 1.0f; // マウスのホイールと連動した際のカメラのスピード<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // <span style="font-weight: bold;">スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向の単位ベクトル(ノルム) を求める</span><br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR <span style="font-weight: bold;">GetCameraWorldDirByScreenXY</span>(float screenX = (float)Input::MouseX, float screenY = (float)Input::MouseY)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // スクリーン(X,Y)からマウスの指すワールド座標(X,Y,Z)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR currentPos = <span

          style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet(screenX, screenY, 0.0f));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラからマウスの指す位置への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return DxLib::VNorm(DxLib::VGet(currentPos.x - x, currentPos.y - y, currentPos.z - z));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; };<br>
        &nbsp;&nbsp;&nbsp; Camera camera;<br>
        <br>
        &nbsp;&nbsp;&nbsp; int prevDragX = -1, prevDragY = -1; // 前フレームでのスクリーン上でのドラッグXY位置<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; bool isInitFinished = false; // 一回でもInitされたかのフラグ<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; void Init()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isInitFinished) return; // 最初の一回だけInit処理をするためのフラグ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitFinished = true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateKeyInput()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>float camXYZSpeed = 1.0f;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向のの単位ベクトル(ノルム)を求める<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR camNorm = camera.GetCameraWorldDirByScreenXY((float)Input::MouseX, (float)Input::MouseY);<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // キーボードのWSキーでカメラ視点を手前や奥に移動できるようにする<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_W))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(camNorm.x * camXYZSpeed, camNorm.y * camXYZSpeed, camNorm.z * camXYZSpeed);<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_S))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(-camNorm.x * camXYZSpeed, -camNorm.y * camXYZSpeed, -camNorm.z * camXYZSpeed);</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_V))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_B))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_H))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_J))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_T))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_Y))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateMouseInput()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!SubScreen::isMouseOvered) // マウスオーバーしているSubscreenがないとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::MouseWheel != 0.0f) // マウスのホイールをグリグリしたとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界の奥への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR camNorm = camera.<span

          style="font-weight: bold;">GetCameraWorldDirByScreenXY</span>((float)Input::MouseX, (float)Input::MouseY);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camSpeed = camera.wheelSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.wheelSpeed *= (camera.wheelSpeed &lt; 100.0f) ? 1.5f : 1.0f; // カメラのズーム速度を加速する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 求めた単位ベクトル×カメラのスピードぶんカメラの位置を移動<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.x += camNorm.x * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.y += camNorm.y * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.z += camNorm.z * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (camera.wheelSpeed &gt; 0.1f) camera.wheelSpeed *= 0.9f; // カメラのズーム速度を減衰する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else camera.wheelSpeed = 0.1f; // カメラのズーム速度を減衰して最小0.1にすることで繊細なズーム調整もできるようにする<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((Input::Click[Mouse::DragL] || Input::Click[Mouse::DragR]) &amp;&amp; Screen::IsInsideWindow())<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != -1 &amp;&amp; prevDragY != -1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 前の位置prevと現在の位置に移動があれば、その差ぶんだけ+=することでドラッグ移動を実現<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragL]) // マウス左クリック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragLX] || prevDragY != Input::Click[Mouse::DragLY])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // マウスポインタがある画面上の座標に該当する３Ｄ空間上の座標を取得 https://dxlib.xsrv.jp/function/dxfunc_3d_camera.html#R12N11<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float positionRatio = 0.9f;// 奥行の位置 Near 面 0.0f ～ 1.0f Far 面<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR start = <span

          style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet((float)prevDragX, (float)prevDragY, positionRatio));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR end = <span

          style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet((float)Input::Click[Mouse::DragLX], (float)Input::Click[Mouse::DragLY], positionRatio));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camSpeed = 400; // ドラッグに対するカメラの移動速度<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.x -= (end.x - start.x) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.y -= (end.y - start.y) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.z -= (end.z - start.z) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragR]) // マウス右クリック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // カメラの角度を変更<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragRX])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate += (float)(Input::Click[Mouse::DragRX] - prevDragX);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragY != Input::Click[Mouse::DragRY])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate += (float)(Input::Click[Mouse::DragRY] - prevDragY);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ±360度を超えたら割り算の余りを設定して 例.365度 → 5度に戻してやる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (camera.HRotate &gt; 360.0f || camera.HRotate &lt; -360.0f) camera.HRotate = std::fmodf(camera.HRotate, 360.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (camera.VRotate &gt; 360.0f || camera.VRotate &lt; -360.0f) camera.VRotate = std::fmodf(camera.VRotate, 360.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragX = (Input::Click[Mouse::DragL]) ? Input::Click[Mouse::DragLX] : Input::Click[Mouse::DragRX];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragY = (Input::Click[Mouse::DragL]) ? Input::Click[Mouse::DragLY] : Input::Click[Mouse::DragRY];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragX = -1; prevDragY = -1; // マウスのドラッグがないときはリセット<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateCamera()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラの位置と回転値をセット、カメラの位置は原点<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngle(<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::VGet(camera.x, camera.y, camera.z),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate * DX_PI_F / 180.0f, camera.HRotate * DX_PI_F / 180.0f, camera.TRotate * DX_PI_F / 180.0f);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // まとめてUpdateしたいときはUpdateを使い、個別にUIやKeyやMouseを別々にタイミングを取りながらUpdateしたいときは Updateは呼ばない<br>
        &nbsp;&nbsp;&nbsp; void Update()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateKeyInput();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateMouseInput();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateCamera();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void Draw()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 原点からx軸(R:赤) y軸(G:緑) z軸(B:青)をライン表示する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(1.0f * 5.0f, 0.0f * 5.0f, 0.0f * 5.0f), GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(0.0f * 5.0f, 1.0f * 5.0f, 0.0f * 5.0f), GetColor(0, 255, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(0.0f * 5.0f, 0.0f * 5.0f, 1.0f * 5.0f), GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 画面に回転量を描画<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, DxLib::GetColor(255, 255, 255), "Cam(x:%f y:%f z:%f)", camera.x, camera.y, camera.z);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 20, DxLib::GetColor(255, 255, 255), "Rot(V:%f H:%f T:%f)", camera.VRotate, camera.HRotate, camera.TRotate);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        #endif<br>
      </p>
      <p>いかがでしょうか？カメラの視点の位置をキーボードのWSキーでカメラ視点を手前や奥に移動できるようになりましたか？<br>
        重要なのはGetCameraWorldDirByScreenXY関数でカメラ画面の視界(ワールド座標)の奥への方向のの単位ベクトル(ノルム)を求めることです<br>
        カメラの視点を移動するときはXYZ軸に対して+1するようなシンプルな計算ではうまくいきません<br>
        <span style="text-decoration: underline;">あてになるのは「カメラから見た奥行方向」の大きさ1の単位ベクトル</span>です。このベクトルを+1方向で奥、-1方向で手前にカメラを移動できます<br>
        GetCameraWorldDirByScreenXY関数の中では DxLib::ConvScreenPosToWorldPos を使って <br>
        スクリーンの2D(X,Y)からマウスの指すワールド座標3D(X,Y,Z)を求めています<br>
        <span style="text-decoration: underline;">スクリーンの2D位置からワールドの3D位置を変換する処理が</span>重 要なキーとなっているのでこの関数の存在は知っておきましょう<br>
      </p>
      <br>
      <br>
      <br>
    </a><a id="mozTocId0008" class="mozTocH1">
      <h1>キーボードのDAキーとEQキーでカメラ視点を左右や上 下に移動できるようにする</h1>
      <p><code>Editor.h</code>を変更してキーボードのDAキーとEQキーでカメラ視点を左右や上下に移動できるようにします。</p>
      <p class="source">#ifndef EDITOR_H_<br>
        #define EDITOR_H_<br>
        <br>
        #include "DxLib.h"<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        <br>
        #include "Singleton.h"<br>
        <br>
        class Editor : public Singleton&lt;Editor&gt;<br>
        {<br>
        public:<br>
        <br>
        &nbsp;&nbsp;&nbsp; struct Camera<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x = 0.f, y = 0.0f, z = -10.0f; // カメラはz軸マイナス位置からz軸プラス向きに原点を見る形で初期化される<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; inline Camera&amp; operator +=(VECTOR move) { x += move.x; y += move.y; z += move.z; return *this; } // VECTOR型を足したときはカメラを移動させる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float VRotate = 0.0f, HRotate = 0.0f, TRotate = 0.0f; // X軸 V,Y軸 H,Z軸 T まわりのカメラのオイラー回転の角度<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float wheelSpeed = 1.0f; // マウスのホイールと連動した際のカメラのスピード<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR GetCameraWorldDirByScreenXY(float screenX = (float)Input::MouseX, float screenY = (float)Input::MouseY)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // スクリーン(X,Y)からマウスの指すワールド座標(X,Y,Z)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR currentPos = <span

          style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet(screenX, screenY, 0.0f));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラからマウスの指す位置への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return DxLib::VNorm(DxLib::VGet(currentPos.x - x, currentPos.y - y, currentPos.z - z));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// スクリーンの2Dの start位置XY から end位置XY の方向 が ワールド座標3D においてどんなベクトルになるかを求める<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR GetWorldDirByCameraScreenXYDir(float screenStartX = (float)Input::MouseX, float screenStartY = (float)Input::MouseY,<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float screenEndX = (float)(Input::MouseX + 1), float screenEndY = (float)(Input::MouseY + 1))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // スクリーン(X,Y)からマウスの指すワールド座標(X,Y,Z)を求める<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR startPos = <span

            style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet(screenStartX, screenStartY, 0.0f));<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR endPos = <span

            style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet(screenEndX, screenEndY, 0.0f));<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ワールド座標におけるstartからendへ向かう方向のベクトルを求める<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return DxLib::VGet(endPos.x - startPos.x, endPos.y - startPos.y, endPos.z - startPos.z);<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</em><br>
        &nbsp;&nbsp;&nbsp; };<br>
        &nbsp;&nbsp;&nbsp; Camera camera;<br>
        <br>
        &nbsp;&nbsp;&nbsp; int prevDragX = -1, prevDragY = -1; // 前フレームでのスクリーン上でのドラッグXY位置<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; bool isInitFinished = false; // 一回でもInitされたかのフラグ<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; void Init()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isInitFinished) return; // 最初の一回だけInit処理をするためのフラグ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitFinished = true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateKeyInput()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camXYZSpeed = 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向のの単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR camNorm = camera.GetCameraWorldDirByScreenXY((float)Input::MouseX, (float)Input::MouseY);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // キーボードのWSキーでカメラ視点を手前や奥に移動できるようにする<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_W))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(camNorm.x * camXYZSpeed, camNorm.y * camXYZSpeed, camNorm.z * camXYZSpeed);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_S))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(-camNorm.x * camXYZSpeed, -camNorm.y * camXYZSpeed, -camNorm.z * camXYZSpeed);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// スクリーンの 2D上のX方向 が ワールド座標 3D ではどんな方向ベクトルになるかを求める<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR xCamDir = VNorm(camera.GetWorldDirByCameraScreenXYDir((float)Input::MouseX, (float)Input::MouseY, (float)(Input::MouseX + 10), (float)Input::MouseY));<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_D))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(xCamDir.x * camXYZSpeed, xCamDir.y * camXYZSpeed, xCamDir.z * camXYZSpeed);<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_A))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(-xCamDir.x * camXYZSpeed, -xCamDir.y * camXYZSpeed, -xCamDir.z * camXYZSpeed);</em><br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// スクリーンの 2D上のY方向 が ワールド座標 3D ではどんな方向ベクトルになるかを求める<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR yCamDir = VNorm(camera.GetWorldDirByCameraScreenXYDir((float)Input::MouseX, (float)Input::MouseY, (float)Input::MouseX, (float)(Input::MouseY + 10)));<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_Q))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(yCamDir.x * camXYZSpeed, yCamDir.y * camXYZSpeed, yCamDir.z * camXYZSpeed);<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_E))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(-yCamDir.x * camXYZSpeed, -yCamDir.y * camXYZSpeed, -yCamDir.z * camXYZSpeed);</em><br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_V))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_B))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_H))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_J))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_T))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_Y))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateMouseInput()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!SubScreen::isMouseOvered) // マウスオーバーしているSubscreenがないとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::MouseWheel != 0.0f) // マウスのホイールをグリグリしたとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界の奥への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR camNorm = camera.<span

          style="font-weight: bold;">GetCameraWorldDirByScreenXY</span>((float)Input::MouseX, (float)Input::MouseY);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camSpeed = camera.wheelSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.wheelSpeed *= (camera.wheelSpeed &lt; 100.0f) ? 1.5f : 1.0f; // カメラのズーム速度を加速する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 求めた単位ベクトル×カメラのスピードぶんカメラの位置を移動<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.x += camNorm.x * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.y += camNorm.y * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.z += camNorm.z * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (camera.wheelSpeed &gt; 0.1f) camera.wheelSpeed *= 0.9f; // カメラのズーム速度を減衰する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else camera.wheelSpeed = 0.1f; // カメラのズーム速度を減衰して最小0.1にすることで繊細なズーム調整もできるようにする<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((Input::Click[Mouse::DragL] || Input::Click[Mouse::DragR]) &amp;&amp; Screen::IsInsideWindow())<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != -1 &amp;&amp; prevDragY != -1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 前の位置prevと現在の位置に移動があれば、その差ぶんだけ+=することでドラッグ移動を実現<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragL]) // マウス左クリック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragLX] || prevDragY != Input::Click[Mouse::DragLY])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // マウスポインタがある画面上の座標に該当する３Ｄ空間上の座標を取得 https://dxlib.xsrv.jp/function/dxfunc_3d_camera.html#R12N11<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float positionRatio = 0.9f;// 奥行の位置 Near 面 0.0f ～ 1.0f Far 面<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR start = <span

          style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet((float)prevDragX, (float)prevDragY, positionRatio));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR end = <span

          style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet((float)Input::Click[Mouse::DragLX], (float)Input::Click[Mouse::DragLY], positionRatio));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camSpeed = 400; // ドラッグに対するカメラの移動速度<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.x -= (end.x - start.x) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.y -= (end.y - start.y) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.z -= (end.z - start.z) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragR]) // マウス右クリック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // カメラの角度を変更<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragRX])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate += (float)(Input::Click[Mouse::DragRX] - prevDragX);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragY != Input::Click[Mouse::DragRY])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate += (float)(Input::Click[Mouse::DragRY] - prevDragY);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ±360度を超えたら割り算の余りを設定して 例.365度 → 5度に戻してやる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (camera.HRotate &gt; 360.0f || camera.HRotate &lt; -360.0f) camera.HRotate = std::fmodf(camera.HRotate, 360.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (camera.VRotate &gt; 360.0f || camera.VRotate &lt; -360.0f) camera.VRotate = std::fmodf(camera.VRotate, 360.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragX = (Input::Click[Mouse::DragL]) ? Input::Click[Mouse::DragLX] : Input::Click[Mouse::DragRX];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragY = (Input::Click[Mouse::DragL]) ? Input::Click[Mouse::DragLY] : Input::Click[Mouse::DragRY];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragX = -1; prevDragY = -1; // マウスのドラッグがないときはリセット<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateCamera()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラの位置と回転値をセット、カメラの位置は原点<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngle(<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::VGet(camera.x, camera.y, camera.z),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate * DX_PI_F / 180.0f, camera.HRotate * DX_PI_F / 180.0f, camera.TRotate * DX_PI_F / 180.0f);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // まとめてUpdateしたいときはUpdateを使い、個別にUIやKeyやMouseを別々にタイミングを取りながらUpdateしたいときは Updateは呼ばない<br>
        &nbsp;&nbsp;&nbsp; void Update()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateKeyInput();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateMouseInput();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateCamera();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void Draw()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 原点からx軸(R:赤) y軸(G:緑) z軸(B:青)をライン表示する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(1.0f * 5.0f, 0.0f * 5.0f, 0.0f * 5.0f), GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(0.0f * 5.0f, 1.0f * 5.0f, 0.0f * 5.0f), GetColor(0, 255, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(0.0f * 5.0f, 0.0f * 5.0f, 1.0f * 5.0f), GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 画面に回転量を描画<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, DxLib::GetColor(255, 255, 255), "Cam(x:%f y:%f z:%f)", camera.x, camera.y, camera.z);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 20, DxLib::GetColor(255, 255, 255), "Rot(V:%f H:%f T:%f)", camera.VRotate, camera.HRotate, camera.TRotate);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        #endif<br>
      </p>
      <p>いかがでしょう?キーボードのDAキーとEQキーでカメラ視点を左 右や上下に移動できるようになりましたか?<br>
        カメラの上下左右方向でも重要なのは 2Dのスクリーン から 3Dのワールド座標 での方向のベクトルを求めることです<br>
        GetWorldDirByCameraScreenXYDir関数の中でもDxLib::ConvScreenPosToWorldPos関数を使って 2D → 3D座標 への変換を行っています<br>
        カメラの左右移動方向は<span style="text-decoration: underline;">「スクリーンの枠」の左右方向</span>、 カメラの上下移動方向は<span

          style="text-decoration: underline;">「スクリーンの枠」の上下方向</span>と 平行になるベクトルです<br>
      </p>
      <br>
      <br>
      <br>
    </a><a id="mozTocId0009" class="mozTocH1">
      <h1>Unityのアセットストアからとってきたテクスチャ1 枚のシンプルな3DモデルをDXのモデルビューアで.mv1形式に変換して表示させてみる</h1>
    </a>
    <p><a id="mozTocId0009" class="mozTocH1">複雑な3Dモデルだとテクスチャリンクつけなおしやボーンが崩れた りして大変なので下記リンクのシンプルな無料3DモデルをUnityにインポートします<br>
      </a><a href="https://assetstore.unity.com/packages/3d/characters/humanoids/fantasy/devil-animated-character-60777?locale=ja-JP&amp;srsltid=AfmBOor53ggeWTlrD6CMx0iQtZj3gZrHiPBdYgzpG2Ljhm4FIBT912Q3">https://assetstore.unity.com/packages/3d/characters/humanoids/fantasy/devil-animated-character-60777?locale=ja-JP&amp;srsltid=AfmBOor53ggeWTlrD6CMx0iQtZj3gZrHiPBdYgzpG2Ljhm4FIBT912Q3</a> <br>
    </p>
    <p>Unityの[Window]→[Package Manager]を開いて、取得したデビルのキャラのアセットを[Download]<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset1.png" alt=""><br>
    </p>
    <p><br>
      Unityへ[Import]ボタンでインポートする<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset2.png" alt=""><br>
    </p>
    <p><br>
      Assetフォルダ→Devilフォルダ→Animationsフォルダの「devil@fly」を[右クリック]→ [Show in Explorer]で3DのモデルのあるフォルダをWindowsで開く<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset3.png" alt=""><br>
    </p>
    <p><br>
      Unityのアセットフォルダの3DモデルをコピーしてDXのプロジェクトのImgaeフォルダへコピペする<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset4.png" alt=""><br>
    </p>
    <p><br>
      DXライブラリをインストールしたフォルダの中のToolフォルダにDXモデルビューアがあるので起動する<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset5.png" alt=""><br>
    </p>
    <p><br>
      [マテリアル]→[lambert1(ランバート反射マテリアル)]→[拡散光(ディフーズ反射)]→[ディフーズマッ プ]のテクスチャリンクの[参照]先にファイルがないので<br>
      3Dモデルが灰色で表示されてしまう<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset6.png" alt=""><br>
    </p>
    <p><br>
      Unityの[Assetsフォルダ]→[Devilフォルダ]→[Textureフォルダ]のテクスチャを[右クリッ ク]→[Show in Explorer]でWindowsのフォルダ上で画像ファイルを見つける<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset7.png" alt=""><br>
    </p>
    <p><br>
      DXのプロジェクトのImageフォルダへテクスチャ画像をコピペする<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset8.png" alt=""><br>
    </p>
    <p><br>
      DXのモデルビューアで3Dモデルを開きなおすか、<br>
      [マテリアル]→[lambert1]→[拡散光]→[ディフーズマップ]のテクスチャリンクの[参照]を押してコピペし た画像に参照を貼りなおすと<br>
      3Dモデル表面にテクスチャ画像が反映される<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset9.png" alt=""><br>
      <br>
    </p>
    <p>[ファイル]→[名前を付けて保存]でDXのプロジェクトのImageフォルダに.mv1形式(DXで扱える3Dモデル形式)で保存する<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset10.png" alt=""><br>
    </p>
    <p><br>
    </p>
    <p><code>main.cpp</code>のコードに.mv1形式の3Dモデルをロードして、描画表示させるプログラムを追加してみましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
      #include "Input.h"<br>
      #include "Screen.h"<br>
      #include "Ply.h"<br>
      <br>
      #include "Editor.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;&nbsp; <em>int devil3DModel = DxLib::MV1LoadModel("Image/devil@fly.mv1"); // 3Dモデルをmv1形式で読込み</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
      &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
      &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
      &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
      &nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply", Data); // .plyデータをロード 軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう<br>
      <br>
      &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
      &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
      &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
      <br>
      &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
      &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
      &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
      &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      <br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
      &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
      &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f; keyControlXYZ.z = 0;<br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
      <br>
      &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens(); // スクリーンの位置やドラッグによる移動を更新する<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f, 1.0f, 1.0f); // 拡大縮小スケール<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0<em></em><em></em>, 100, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 半透明のスクリーンも描ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height, GetColor(0, 255, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); // サブのスクリーンを全部描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); // エディタのDraw処理<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょうか?MV1形式の3Dモデルがちゃんと表示されたでしょうか?<br>
    Unityのアセットは基本100倍のスケールで制作されているのでマウスをぐりぐりさせてズームアウトさせないとデカすぎて見えないはずです。<br>
    こういうトラブルを回避するために事前にエディタの直感的な操作を準備しておいたのです。<br>
    <p> <img src="image/mv1_from_unity_asset11.png" alt=""><br>
      <br>
    </p>
    <p><span style="font-weight: bold;">[練習問題]</span> .plyのときに DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] <br>
      したのと同じように.mv1形式の3Dモデルにもスケールや回転や移動の行列を反映させてみよ<br>
    </p>
    <br>
    <br>
    <br>
    <a id="mozTocId0010" class="mozTocH1">
      <h1>MV1形式の3Dモデルをアニメーション描画する</h1>
      <br>
      <p><code>main.cpp</code>のコードに.mv1形式の3Dモデルにデフォルトでアニメがついていたら、そのアニメをモデルにアタッチしてアニメーションさせるプログラムを追加してみましょう。</p>
    </a>
    <p class="source"><a id="mozTocId0010" class="mozTocH1">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        <br>
        #include "Editor.h"<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; int devil3DModel = DxLib::MV1LoadModel("Image/devil@fly.mv1"); // 3Dモデルをmv1形式で読込み<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>float animTime = 0.0f; // アニメの現在時刻<br>
          &nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
          &nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
          &nbsp;&nbsp;&nbsp; int DefalutAnimNum = DxLib::<span style="font-weight: bold;">MV1GetAnimNum</span>(devil3DModel); // 3Dモデル内のアニメの数<br>
          &nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, int&gt; animNameToIndex; // アニメ名からアニメのインデックス番号への辞書<br>
          &nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, float&gt; animNameToTotalTime; // アニメ名からアニメの総再生時間への辞書<br>
          &nbsp;&nbsp;&nbsp; for (int index = 0; index &lt; DefalutAnimNum; ++index)<br>
          &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // アニメの数ぶん順番にアタッチを設定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* animName = DxLib::MV1GetAnimName(devil3DModel, index); // アニメーション名を取得<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アニメ名からインデックス番号を得るために辞書に登録しておく<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">animNameToIndex</span>[animName] = DxLib::<span

            style="font-weight: bold;">MV1AttachAnim</span>(devil3DModel, index); // アニメをアタッチして、その番号を辞書に登録<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">animNameToTotalTime</span>[animName] = DxLib::<span

            style="font-weight: bold;">MV1GetAttachAnimTotalTime</span>(devil3DModel, index); // アニメをループさせるためにアニメの総再生時間を辞書に記録しておく<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        &nbsp;&nbsp;&nbsp; </a><a id="mozTocId0009" class="mozTocH1"><br>
        &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
        &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
        &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
        &nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply", Data); // .plyデータをロード 軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう<br>
        <br>
        &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
        <br>
        &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
        &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
        &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
        <br>
        &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
        &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
        &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
        &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        <br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
        &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens(); // スクリーンの位置やドラッグによる移動を更新する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f, 1.0f, 1.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0<em></em><em></em>, 100, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>std::string <span

            style="font-weight: bold;">animName</span> = "Take 001"; // アニメ名:DXモデルビューアでアニメ名をきちんと確認したほうがよい↓<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(animNameToTotalTime.count(animName) &gt; 0 &amp;&amp; "指定されたアニメ名のアニメはMV1に付属していませんでした");<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime += animStepTime * animSpeed; // 1.0×2倍 なら2倍速でアニメ時刻が進む<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animTime &gt; <span

            style="font-weight: bold;">animNameToTotalTime</span>[<span

            style="font-weight: bold;">animName</span>])<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime = 0.0f; // 0秒目へとアニメをループさせる<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 再生時間をセットする<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::<span style="font-weight: bold;">MV1SetAttachAnimTime</span>(devil3DModel, <span

            style="font-weight: bold;">animNameToIndex</span>[<span style="font-weight: bold;">animName</span>], animTime);</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 半透明のスクリーンも描ける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); // サブのスクリーンを全部描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); // エディタのDraw処理<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</a></p>
    <br>
    アニメ名をDXモデルビューアーの[アニメ]から確認<br>
    <p> <img src="image/mv1_from_unity_asset12.png" alt=""><br>
    </p>
    <p><br>
      アニメの総再生時間とアニメのインデックス番号はここ<br>
    </p>
    <p><img src="image/mv1_from_unity_asset13.png" alt=""><br>
    </p>
    <p>いかがですか?3Dキャラがアニメーションしたでしょうか?<br>
      アニメーションの時刻を進めるプログラムを書くには<br>
      アニメーション番号(No.)かアニメーション名(例.Take 001)を使う必要があるのでDXモデルビューアーで確認して間違わないようにしましょう<br>
    </p>
    <br>
    <a id="mozTocId0011" class="mozTocH1">
      <h1>複数の3DモデルやアニメをResourceクラスで2 重ロード しないよう読み込んで複数アニメを切替えする</h1>
      <p><code>Resource.hを新規作成</code>してResourceクラスで画像やテクスチャや3Dモデルなどのリソースを 2重にロー ドしないよう読み込んだときにstd::unordered_mapのfiles辞書に登録する機能を準備する。</p>
      <p class="source">#ifndef RESOURCE_H_<br>
        #define RESOURCE_H_<br>
        <br>
        #include "DxLib.h"<br>
        <br>
        #include &lt;vector&gt;<br>
        #include &lt;string&gt;<br>
        #include &lt;memory&gt; // 共有ポインタstd::shared_ptrを使う<br>
        #include &lt;unordered_map&gt; // 高速辞書&lt;ファイルパス, 共有リソース&gt;で一度読み込んだファイルはかぶらないように(2重ロード防止)する<br>
        #include &lt;assert.h&gt;<br>
        <br>
        struct Resource : public std::enable_shared_from_this&lt;Resource&gt;<br>
        {&nbsp;&nbsp;&nbsp; // [std::shared_ptrでthisポインタをつかうためには]↑ https://www.kabuku.co.jp/developers/cpp_enable_shared_from_this<br>
        &nbsp;&nbsp;&nbsp; enum class Type { None, MV1, Ply, Texture, Sound, SE };<br>
        &nbsp;&nbsp;&nbsp; Type m_type{ Type::None }; // データの種類<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; m_handles; // ロードしたリソースのハンドル番号<br>
        &nbsp;&nbsp;&nbsp; inline operator int() { return (m_handles.size() &gt; 0) ? m_handles[0] : -1; } // intでキャストした場合には先頭の0個目のハンドル番号を返す<br>
        &nbsp;&nbsp;&nbsp; std::string m_FilePath{ "" }; // ロードしたリソースのファイルパス<br>
        &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;std::string, std::shared_ptr&lt;Resource&gt;&gt; files; // ロード済みのリソースファイルを保管する辞書<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual ~Resource() {}<br>
        <br>
        protected: // コンストラクタ経由の生成経路を隠蔽してMakeShared関数経由でしか生成できないようにする<br>
        &nbsp;&nbsp;&nbsp; Resource(const std::string&amp; filePath = "", Type type = Type::None) : m_FilePath{ filePath }, m_type{ type } {}<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; //[protectedなコンストラクタでもstd::make_sharedで呼ぶテク] https://gintenlabo.hatenablog.com/entry/20131211/1386771626<br>
        &nbsp;&nbsp;&nbsp; template&lt;typename ResourceT&gt;<br>
        &nbsp;&nbsp;&nbsp; struct ProtectedCall : public ResourceT<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; template&lt;class... ArgsT&gt; // std::make_sharedはprotectedな継承クラスは呼べないのでそれを回避するテクニック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; explicit ProtectedCall(ArgsT&amp;&amp;... args)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : ResourceT(std::forward&lt;ArgsT&gt;(args)...) { } //std::forwardで複数引数を完全転送で引き渡し https://proc-cpuinfo.fixstars.com/2016/03/c-html/<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタをprotected:にしてあるのでこのMakeShared関数経由でしかResourceの新規生成はできないように縛ってある<br>
        &nbsp;&nbsp;&nbsp; template&lt;typename ResourceT, typename... ArgsT&gt;<br>
        &nbsp;&nbsp;&nbsp; static std::shared_ptr&lt;ResourceT&gt; MakeShared(const std::string&amp; filePath = "", ArgsT... args)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (files.find(filePath) == files.end()) // 辞書に未登録のファイルの場合は<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; files[filePath] = std::make_shared&lt;ProtectedCall&lt;ResourceT&gt;&gt;(filePath, std::forward&lt;ArgsT&gt;(args)...); // 辞書へ登録<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return std::dynamic_pointer_cast&lt;ResourceT&gt;(files[filePath]); //[共有ポインタの派生先へのダウンキャスト] https://cdecrement.blog.fc2.com/blog-entry-15.html<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; template&lt;typename ResourceT&gt; // 指定されたfilepathのデータをResourceT型の共有ポインタとして返す<br>
        &nbsp;&nbsp;&nbsp; static std::shared_ptr&lt;ResourceT&gt; at(const std::string&amp; filepath)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(files.count(filepath) &gt; 0 &amp;&amp; "指定されたファイル名のファイルは未生成です。MakeShared関数で生成してからアクセスしてください");<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return std::dynamic_pointer_cast&lt;ResourceT&gt;(files.at(filepath)); //[共有ポインタの派生先へのダウンキャスト] https://komorinfo.com/blog/cast-of-smart-pointers/ <br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; static size_t count(const std::string&amp; filepath) { return files.count(filepath); }<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual int Load(const std::string&amp; filePath = "") = 0; //[ = 0 純粋仮想関数] ロード関数をoverrideして色んな種類のファイルのロードを実装する<br>
        };<br>
        <br>
        struct Texture : public Resource<br>
        {<br>
        protected: // ファクトリーパターンでコンストラクタ経由の生成経路をprotected隠蔽(ResourceクラスのMakeShared関数経由でしか新規生成は できない)<br>
        &nbsp;&nbsp;&nbsp; Texture(const std::string&amp; filePath = "", int m_XNum = 1, int m_YNum = 1, int m_XSize = 1, int m_YSize = 1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : Resource(filePath, Type::Texture), m_XNum{ m_XNum }, m_YNum{ m_YNum }, m_XSize{ m_XSize }, m_YSize{ m_YSize } {}<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; int m_XNum = 1, m_YNum = 1, m_XSize = 1, m_YSize = 1; // XNum,YNumはx,y方向の分割画像の数 XSize,YSizeは画像の横×縦のサイズ(pixel数)<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline int operator[](std::size_t index) const { //constは変更できないから添え字[]の 読み取り専用処理<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return m_handles[index]; // 読み取り専用(returnの型が &amp;参照ついてないので書き換え不可能)<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // すでにロードしてあるハンドルをDeleteGraphで破棄する<br>
        &nbsp;&nbsp;&nbsp; virtual ~Texture() { DeleteGraph(); }<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual int DeleteGraph() // すでにロードしてあるハンドルをDxLib::DeleteGraphで破棄する<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int result = 0;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int handle : m_handles)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; result = (result == -1) ? -1 : DxLib::DeleteGraph(handle); // 一つでもDeleteに失敗したら-1<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::vector&lt;int&gt;().swap(m_handles); // ハンドルの配列を完全に消去<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return result;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual int Load(const std::string&amp; filePath = "") override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (filePath == "" &amp;&amp; m_FilePath == "") return -1;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (files.count(filePath) &gt; 0 &amp;&amp; m_handles.size() &gt; 0) return files[filePath]-&gt;m_handles[0]; // すでに辞書にロード済みハンドルがあった<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (filePath != "" &amp;&amp; m_FilePath == "") m_FilePath = filePath; // 読み出しファイルパスを記録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (m_XNum &gt; 1 || m_YNum &gt; 1) return LoadDivGraph(m_FilePath, m_XNum, m_YNum, m_XSize, m_YSize); // 分割画像としてロード<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int loadHandle = DxLib::LoadGraph(m_FilePath.c_str()); // ファイルをロードする<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(loadHandle != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (loadHandle == -1) return -1; // ロード失敗<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_handles.emplace_back(loadHandle); // ロード成功ならハンドル番号を記録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // [std::shared_ptrへthis↓ポインタをつかうためには] https://cpprefjp.github.io/reference/memory/enable_shared_from_this.html<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; files.emplace(m_FilePath, shared_from_this()); // 辞書へ登録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::GetGraphSize(loadHandle, &amp;m_XSize, &amp;m_YSize); // 横XSize×縦YSizeを得る<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return loadHandle;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual int LoadDivGraph(const std::string&amp; filePath = "", int XNum = -1, int YNum = -1, int XSize = -1, int YSize = -1)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (files.count(filePath) &gt; 0 &amp;&amp; m_handles.size() &gt; 0) return files[filePath]-&gt;m_handles[0]; // すでに辞書にロード済みのファイルのとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (filePath == "") return -1;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (filePath == "" &amp;&amp; m_FilePath == "") return -1;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (filePath != "" &amp;&amp; m_FilePath == "") m_FilePath = filePath; // 読み出しファイルパスを記録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (XNum &gt; 0) m_XNum = XNum; // 数値を設定<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (YNum &gt; 0) m_YNum = YNum;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (XSize &gt; 0) m_XSize = XSize;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (YSize &gt; 0) m_YSize = YSize;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_handles.resize(m_XNum * m_YNum); // XNum×YNum個ぶんの配列を事前確保しておく<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int result = DxLib::LoadDivGraph(m_FilePath.c_str(), m_XNum * m_YNum, m_XNum, m_YNum, m_XSize, m_YSize, m_handles.data());<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(result != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int handle : m_handles) assert(handle != -1); // 画像読込失敗、たてやよこのサイズの指定がおかしいのかも<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // [std::shared_ptrへthis↓ポインタをつかうためには] https://cpprefjp.github.io/reference/memory/enable_shared_from_this.html<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; files.emplace(m_FilePath, shared_from_this()); // 辞書へ登録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return m_handles[0]; // とりあえずは先頭配列を返す<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        #endif<br>
      </p>
      <p><code>Resource.cppを新規作成</code>してResourceクラスのstd::unordered_mapのfiles辞書の宣言をする。</p>
      <p class="source">#include "Resource.h"<br>
        <br>
        std::unordered_map&lt;std::string, std::shared_ptr&lt;Resource&gt;&gt; Resource::files;</p>
      <br>
      <p><code>DataMV1.hを新規作成</code>してResourceクラスを継承して3Dモデルのロードやアニメをアタッチして管理する機能を追加する。</p>
      <p class="source">#ifndef DATAMV1_H_<br>
        #define DATAMV1_H_<br>
        <br>
        #include "DxLib.h"<br>
        <br>
        #include "Resource.h"<br>
        <br>
        #include &lt;unordered_map&gt; // 高速辞書配列<br>
        <br>
        struct DataMV1 : public Resource<br>
        {<br>
        protected: // ファクトリーパターンでコンストラクタ経由の生成経路をprotected隠蔽(ResourceクラスのMakeShared関数経由でしか新規生成は できない)<br>
        &nbsp;&nbsp;&nbsp; DataMV1(std::string filePath = "")<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Resource(filePath, Type::MV1) {}<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; int m_DefalutAnimNum = -1; // 3Dモデル内のデフォルトのアニメの数<br>
        &nbsp;&nbsp;&nbsp; int m_AttachAnimNum = 0; // この3Dモデルにアタッチされたアニメの数(デフォルトのアニメに加えて追加アタッチされたアニメの数も含む)<br>
        <br>
        &nbsp;&nbsp;&nbsp; struct AnimInfo // アニメに関する情報<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int index = -1; // アニメのインデックス番号<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float endTime = 0.0f; // アニメの終了時刻(総再生時間):超えるとループかストップさせる<br>
        &nbsp;&nbsp;&nbsp; };<br>
        &nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, AnimInfo&gt; m_AnimInfo; // 「ファイルパス + ":" + アニメ名」 から アニメの情報への辞書<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ["devil@fly.fbx:Take 00"]のように m_FilePath + ":" + animName の形式にして<br>
        &nbsp;&nbsp;&nbsp; //&nbsp; ファイル1とファイル2で両方"Take 00"というアニメ名を使っていたときに辞書がかぶっちゃうことを予防する必要がある<br>
        &nbsp;&nbsp;&nbsp; AnimInfo&amp; operator [] (const std::string&amp; animPathName)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_AnimInfo.at(animPathName);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; size_t count(const std::string&amp; animPathName) { return m_AnimInfo.count(animPathName); }<br>
        <br>
        &nbsp;&nbsp;&nbsp; bool isInitialized = false; //[継承2重ロード対策]ロード済みになったらtrueに falseのときにLoadするとリロード<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual ~DataMV1()<br>
        &nbsp;&nbsp;&nbsp; {// 仮想デストラクタ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear();// データのお掃除<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual int DeleteModels() // すでにロードしてあるハンドルをDxLib::MV1DeleteModelで破棄する<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int result = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int handle : m_handles)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = (result == -1) ? -1 : DxLib::MV1DeleteModel(handle); // 一つでもDeleteに失敗したら-1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt;().swap(m_handles); // ハンドルの配列を完全に消去<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, AnimInfo&gt;().swap(m_AnimInfo); // アニメの辞書をクリア<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // データをクリアしてメモリを節約する<br>
        &nbsp;&nbsp;&nbsp; virtual void clear()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteModels(); // すでにロードしてあるハンドルをDxLib::MV1DeleteModelで破棄する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = false; //ロード済みフラグをOFF<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ３Ｄアニメのアタッチ、DXライブラリの機能をラッピング<br>
        &nbsp;&nbsp;&nbsp; // https://dxlib.xsrv.jp/function/dxfunc_3d_model_1.html#R4N1<br>
        &nbsp;&nbsp;&nbsp; virtual void AttachAnim(DataMV1&amp; otherMV1Anim)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // モデルに含まれるアニメーションの数を取得する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int Num = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_handles[0] == otherMV1Anim.m_handles[0])<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Num = m_AttachAnimNum = DxLib::MV1GetAnimNum(m_handles[0]); // 3Dモデル内のアニメ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // 追加の別mv1ファイルのアニメのアタッチのとき↓は Num = 追加側のアニメ数, m_AttachAnimNum = Num + m_AttachAnimNumを格納<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_AttachAnimNum += (Num = DxLib::MV1GetAnimNum(otherMV1Anim.m_handles[0])); // アニメの追加アタッチ数だけ総アニメ数を加算 <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; Num; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // アニメの数ぶん順番にアタッチを設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* animName = DxLib::MV1GetAnimName(otherMV1Anim.m_handles[0], i); // アニメーション名を取得<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int animSrcHandle = (m_handles[0] == otherMV1Anim.m_handles[0]) ? -1 : otherMV1Anim.m_handles[0]; // 3Dモデル内アニメ(-1) or 追加アタッチアニメ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int attachedIndex = m_AnimInfo[otherMV1Anim.m_FilePath + ":" + animName].index = DxLib::MV1AttachAnim(m_handles[0], i, animSrcHandle, FALSE); // アタッチとその番号を辞書に登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //アニメ総時間の取得と登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (attachedIndex != -1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_AnimInfo[otherMV1Anim.m_FilePath + ":" + animName].endTime = DxLib::MV1GetAttachAnimTotalTime(m_handles[0], attachedIndex);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_AnimInfo[otherMV1Anim.m_FilePath + ":" + animName].endTime = 0.0f; //アニメアタッチ失敗時はアニメ進行を0.0に<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ファイルの読み込み<br>
        &nbsp;&nbsp;&nbsp; virtual int Load(const std::string&amp; filePath = "") override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (filePath == "" &amp;&amp; m_FilePath == "") return -1; //ファイル名がない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (files.count(filePath) &gt; 0 &amp;&amp; isInitialized) return 0; // すでに辞書にロード済みファイルがあった<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (filePath != "" &amp;&amp; m_FilePath == "") m_FilePath = filePath; // 読み出しファイルパスを記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear(); //データを一旦クリア<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int loadHandle = DxLib::MV1LoadModel(m_FilePath.c_str()); // 3Dモデルモデル読込み<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (loadHandle == -1) assert("3Dモデルファイル見つからず読込み失敗！" == "");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (loadHandle == -1) return -1; // ロード失敗<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_handles.emplace_back(loadHandle); // ロード成功ならハンドル番号を記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [std::shared_ptrへthis↓ポインタをつかうためには] https://cpprefjp.github.io/reference/memory/enable_shared_from_this.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; files.emplace(m_FilePath, shared_from_this()); // 辞書へ登録<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_DefalutAnimNum = DxLib::MV1GetAnimNum(m_handles[0]); // 3Dモデル内にデフォルトでついていたアニメの数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int index = 0; index &lt; m_DefalutAnimNum; ++index)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // アニメの数ぶん順番にアタッチを設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* animName = DxLib::MV1GetAnimName(m_handles[0], index); // アニメーション名を取得<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アニメ名からアニメのインデックス番号を得るために辞書に登録しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アニメのアタッチする前の大元のファイルパス + アニメ名"例.Take 00"など を組み合わせないと<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ファイル1とファイル2で両方"Take 00"というアニメ名を使っていたときに辞書がかぶっちゃって唯一性が保てない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_AnimInfo[m_FilePath + ":" + animName].index = DxLib::MV1AttachAnim(m_handles[0], index); // アニメをアタッチして、その番号を辞書に登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アニメをループさせるためにアニメの総再生時間を辞書に記録しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_AnimInfo[m_FilePath + ":" + animName].endTime = DxLib::MV1GetAttachAnimTotalTime(m_handles[0], index);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++m_AttachAnimNum; // アニメの数を +1 カウントする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = true;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        #endif<br>
      </p>
      <br>
      devilのデータをMV1形式に変換するにあたって、Blenderを通してリグ付けをしたいのだが、<br>
      Blenderで読み込めないバージョンのFBXとして書き出されたFBXモデル(devil)を、一旦UnityのFBXエクスポータで保存しなおして<br>
      FBXの保存バージョンを変えてしまうことでBlenderで読み込めるようにします。<br>
      <p><img src="image/mv1_from_unity_fbx_exporter1.png" alt="" style=""><br>
      </p>
      <p><br>
        UnityにFBXエクスポーターをインストールすると、<br>
        変換したいモデルをアセットのフォルダから選択した状態で[GameObject]→[Export To FBX]ができるようになっているので<br>
        クリックして出てきたウィンドウの[Export]ボタンをクリックします<br>
      </p>
      <p><img src="image/mv1_from_unity_fbx_exporter2.png" alt="" style=""><br>
      </p>
      <p><br>
        デフォルトの保存先はUnityのアセットフォルダと違って<br>
        /ユーザー の /My projectフォルダ の中の /Assetsフォルダ の中<br>
        になっていて混乱しやすいのでUnityウィンドウの左下に表示された Successfully exported: C:○○○ ～ を注意深く見て、<br>
        エクスポータから出力されたファイルの保存先をたどって、出力されたFBXファイルをDXのImageフォルダにコピーしておきます<br>
      </p>
      <p><img src="image/mv1_from_unity_fbx_exporter3.png" alt="" style=""><br>
      </p>
      <p><br>
      </p>
    </a>
    <p><a id="mozTocId0011" class="mozTocH1">mixamoのサイトにアクセスして、<br>
      </a><a href="https://www.adobe.com/products/substance3d/plugins/mixamo-in-blender.html">https://www.adobe.com/products/substance3d/plugins/mixamo-in-blender.html</a> <br>
      Blender上でmixamoに対応したリグを3Dモデルに自動で入れてくれる「Mixamo Blender add-on」をダウンロードしておいてから、<br>
      Blenderを開いて、[編集]→[プリファレンス]から[アドオン]を開いて[インストール]ボタンを押して、mixamoのサイトからダ ウンロードしたファイルを開きます。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter4.png" alt="" style=""><br>
    </p>
    <p><br>
      [アドオンをインストール]すると[プリファレンス]から[アドオン]でMixamo Rigで検索すると<br>
      (Blenderのバージョンが3.0台であれば)「アニメーション:Mixamo Rig」にチェックが入れられるようになっています。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter5.png" alt="" style=""><br>
    </p>
    <p><br>
      [ファイル]から[インポート]で[FBX(.fbx)]からUnityのFBXエクスポータから書き出したdevilのFBXモデルを読み込んでから、<br>
      画面の右上のXYZ軸の横にある「 &lt; 」をクリックするとMixamoのタブを出すことができます。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter6.png" alt="" style=""><br>
    </p>
    <p><br>
      Mixamoのadd-onを使うと[Create Control Rig]を押せば自動でMixamo向けに対応したアニメのモーション用のリグを3Dモデルに埋め込んでくれます。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter7.png" alt="" style=""><br>
    </p>
    <p><br>
      Mixamo向けのリグを埋め込んでから[ファイル]→[エクスポート]→[FBX(.fbx)]から「Mixamo対応リグの入っ たFBXモデル」を保存書き出しします。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter8.png" alt="" style=""><br>
    </p>
    <p><br>
      保存するファイル名は他のファイルとごっちゃになって混乱しないように「devil@mixamo_addon.fbx」など区別しやすい名前を付けて保 存しておきます。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter9.png" alt="" style=""><br>
    </p>
    <p><br>
    </p>
    <p>mixamoのモーションをいれるサイトにアクセスして<br>
      <a href="https://www.mixamo.com/#/?page=1&amp;type=Motion%2CMotionPack">https://www.mixamo.com/#/?page=1&amp;type=Motion%2CMotionPack</a> <br>
      右端の[UPLOAD CHARACTER]ボタンを押して出てきたウィンドウに先ほど書き出した「devil@mixamo_addon.fbx」ファイルをドラッ グ&amp;ドロップします。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter10.png" alt="" style=""><br>
    </p>
    <p><br>
      Mixamo対応リグが入ったFBXモデルならばアップロードが成功してキャラクターが動いている画面が出てくるので[NEXT]を押します。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter11.png" alt="" style=""><br>
    </p>
    <p><br>
      左側から好きなモーションを選択して、[DOWNLOAD]ボタンを押すと好きなモーションを付けたキャラをダウンロードできるようになります。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter12.png" alt="" style=""><br>
    </p>
    <p><br>
      Format(ダウンロードするFBXのフォーマット)やSkin(3Dポリゴンの表面データも付属したデータか)などを設定して[DOWNLOAD]ボ タンでダウンロードします。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter13.png" alt="" style=""><br>
    </p>
    <p><br>
      どのモーションを付けたかわかりやすいようにdevil@kick.fbxなどのファイル名に変えてから、DXのImageフォルダへコピーします。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter14.png" alt="" style=""><br>
    </p>
    <p><br>
      DXのモデルビューワーから[ファイル]→[開く]で「devil@kick.fbx」を読み込んで、<br>
      [アニメーション]でmixamo.comのアニメがついていることを確認したら、<br>
      [ファイル]→[名前を付けて保存]から「devil@kick.mv1」というファイル名でMV1形式の3Dモデルを変換書き出しします。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter15.png" alt="" style=""><br>
    </p>
    <p><br>
      複数のモーションの切替を試すためにキックのモーションだけでなく、ジャンプなどのモーションも「devil@jump.mv1」としてDXのImage フォルダに書き出しておきます。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter16.png" alt="" style=""><br>
    </p>
    書き出したMV1形式の3Dモデルをプログラム上で切り替えられるようにしてキーボードの「0」キーと「1」キーで切り替えられるようにしていきましょ う。<br>
    <br>
    <p><code>main.cpp</code>のコードにMV1形式のファイルを複数ロードしてキーボードの 0 1 などの数字キーでアニメを切替えできる機能を追加する。</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
      #include "Input.h"<br>
      #include "Screen.h"<br>
      #include "Ply.h"<br>
      <em>#include "DataMV1.h"</em><br>
      <br>
      #include "Editor.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      &nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<u><br>
        &nbsp;&nbsp;&nbsp; int devil3DModel = DxLib::MV1LoadModel("Image/devil@fly.mv1"); // 3Dモデルをmv1形式で読込み<br>
        <br>
        &nbsp;&nbsp;&nbsp; float animTime = 0.0f; // アニメの現在時刻 &nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
        &nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
        &nbsp;&nbsp;&nbsp; int DefalutAnimNum = DxLib::MV1GetAnimNum(devil3DModel); // 3Dモデル内のアニメの数<br>
        &nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, int&gt; animNameToIndex; // アニメ名からアニメのインデックス番号への辞書<br>
        &nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, float&gt; animNameToTotalTime; // アニメ名からアニメの総再生時間への辞書<br>
        &nbsp;&nbsp;&nbsp; for (int index = 0; index &lt; DefalutAnimNum; ++index)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // アニメの数ぶん順番にアタッチを設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* animName = DxLib::MV1GetAnimName(devil3DModel, index); // アニメーション名を取得<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アニメ名からインデックス番号を得るために辞書に登録しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animNameToIndex[animName] = DxLib::MV1AttachAnim(devil3DModel, index); // アニメをアタッチして、その番号を辞書に登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animNameToTotalTime[animName] = DxLib::MV1GetAttachAnimTotalTime(devil3DModel, index); // アニメをループさせるためにアニメの総再生時間を辞書に記録しておく<br>
        &nbsp;&nbsp;&nbsp; }</u><br>
      &nbsp;&nbsp;&nbsp; <em>float animTime = 0.0f; // アニメの現在時刻<br>
        &nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
        &nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@kick.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;Load(); // 3Dモデルをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilAttackAnimData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@jump.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilAttackAnimData-&gt;Load(); // 3Dの追加アニメデータをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;AttachAnim(*pDevilAttackAnimData); // アニメを追加でflyのほうをベースとしたモデルにアタッチ<br>
        &nbsp;&nbsp;&nbsp; int <span style="font-weight: bold;">animeButton</span> = 0; // ボタンでアニメを切り替えられるようにする</em><br>
      <br>
      <u>&nbsp;&nbsp;&nbsp; int texImage = -1;<br>
        &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
        &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る&nbsp;</u> <br>
      &nbsp;&nbsp;&nbsp; <em>std::shared_ptr&lt;Texture&gt; pTexImage = Resource::MakeShared&lt;Texture&gt;("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; pTexImage-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; assert((int)*pTexImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
      &nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply", Data); // .plyデータをロード 軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう<br>
      <br>
      &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
      &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
      &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
      <br>
      &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
      &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
      &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
      &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      <br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
      &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
      &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f; keyControlXYZ.z = 0;<br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
      <br>
      &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens(); // スクリーンの位置やドラッグによる移動を更新する<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// キーボードの 0 1 キーで3Dアニメを切り替えられるようにする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_0))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_1))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 1;</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width =&nbsp; <em>pTexImage-&gt;m_XSize</em>; float height =&nbsp; <em>pTexImage-&gt;m_YSize</em>; // テクスチャ画像のサイズ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f, 1.0f, 1.0f); // 拡大縮小スケール<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, <em>(int)*pTexImage</em>, FALSE); // 三角形ポリゴンをたくさん描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1DrawModel(<em>(int)*DevilData</em>); // 3Dモデル(.mv1形式)を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0<em></em><em></em>, 100, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// ファイルのパス + ":" + アニメ名でアクセス</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string <em><span

          style="font-weight: bold;">animPathName</span></em> = <em>(<span

          style="font-weight: bold;">animeButton </span>== 0) ? "Image/devil@kick.mv1:mixamo.com" : "Image/devil@jump.mv1:mixamo.com";<br>
      </em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(<em>pDevilData-&gt;count(<span

          style="font-weight: bold;">animPathName</span>)</em> &gt; 0 &amp;&amp; "指定されたアニメ名のアニメはMV1に付属していませんでした");<em><br>
      </em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime += animStepTime * animSpeed; // 1.0×2倍 なら2倍速でアニメ時刻が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animTime &gt; (*pDevilData)[<em><span

          style="font-weight: bold;">animPathName</span></em>].endTime)<em><br>
      </em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime = 0.0f; // 0秒目へとアニメをループさせる<em><br>
        <br>
      </em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 再生時間をセットする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1SetAttachAnimTime(<em>(int)*pDevilData, (*pDevilData)[<span

          style="font-weight: bold;">animPathName</span>].index</em>, animTime);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 半透明のスクリーンも描ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height, GetColor(0, 255, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); // サブのスクリーンを全部描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); // エディタのDraw処理<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    いかがでしょう?キーボードの0キーと1キーでキャラのモーションを切替えできるようになりましたか?<br>
    0と1キー以外にもいろんなモーションを付けてみて切り替えられるか試してみましょう。<br>
    <br>
    <br>
    <br>
    <br>
    <a id="mozTocId0012" class="mozTocH1">
      <h1>.ply形式の3DモデルデータをResourceクラスを継承したDataPly構造体で読み込む</h1>
      <p><code>DataPly.hを新規作成</code>し てResourceクラスを継承して .ply形式の3Dモデルデータを読み込む機能を追加してmain.cppのコードをすっきりさせてしまいましょう。</p>
      <p class="source">#ifndef DATAPLY_H_<br>
        #define DATAPLY_H_<br>
        <br>
        #include "Dxlib.h"<br>
        <br>
        #include &lt;memory&gt;<br>
        #include &lt;vector&gt;<br>
        #include &lt;string&gt;<br>
        <br>
        #include &lt;assert.h&gt; // 読込み失敗表示用<br>
        <br>
        #include "Ply.h"<br>
        <br>
        #include "Resource.h"<br>
        <br>
        // .ply形式の3Dモデルデータを読み込む構造体<br>
        struct DataPly : public Resource<br>
        {<br>
        protected: // ファクトリーパターンでコンストラクタ経由の生成経路をprotected隠蔽(ResourceクラスのMakeShared関数経由でしか新規生成は できない)<br>
        &nbsp;&nbsp;&nbsp; DataPly(std::string filePath = "", bool isGPUBufferRendering = false)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Resource(filePath, Type::Ply), isGPUBufferRendering{ isGPUBufferRendering } {}<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; size_t numIndex = 0;<br>
        &nbsp;&nbsp;&nbsp; int VertexBufHandle{ -1 }; // GPU側の頂点バッファへのハンドル番号<br>
        &nbsp;&nbsp;&nbsp; int IndexBufHandle{ -1 }; // GPU側のインデックスバッファへのハンドル番号<br>
        &nbsp;&nbsp;&nbsp; bool isSendDataToGPU = false; // GPUへデータを転送済みか<br>
        &nbsp;&nbsp;&nbsp; bool isGPUBufferRendering; // GPUバッファにVertexとIndexデータを送ってCPU側にはデータをもたないようにするか?<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
        <br>
        &nbsp;&nbsp;&nbsp; Ply::Data Data; //.plyのデータ<br>
        <br>
        &nbsp;&nbsp;&nbsp; bool isInitialized = false; //[継承2重ロード対策]ロード済みになったらtrueに falseのときにLoadするとリロード<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual ~DataPly()<br>
        &nbsp;&nbsp;&nbsp; {// 仮想デストラクタ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear();// 2次元配列データのお掃除<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual void clearCPUData() // CPU上の配列データをクリアする<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // [確実にメモリを空にするには] http://vivi.dyndns.org/tech/cpp/vector.html#shrink_to_fit<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt;().swap(Vertex); // 空のテンポラリオブジェクトでリセット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;unsigned int&gt;().swap(Index); // 空のテンポラリオブジェクトでリセット<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual void clearGPUData() // GPU上のバッファデータをクリアする<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteVertexBuffer(VertexBufHandle); // GPUの頂点バッファを削除する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteIndexBuffer(IndexBufHandle); // GPUのインデックスバッファを削除する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VertexBufHandle = -1; IndexBufHandle = -1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSendDataToGPU = false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGPUBufferRendering = false;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // データをクリアしてメモリを節約する<br>
        &nbsp;&nbsp;&nbsp; virtual void clear()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data.clear();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clearCPUData(); // CPU上の配列データをクリアする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clearGPUData(); // GPUのインデックスバッファを削除する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = false; //ロード済みフラグをOFF<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ファイルの読み込み<br>
        &nbsp;&nbsp;&nbsp; virtual int Load(const std::string&amp; filePath = "") override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (filePath == "" &amp;&amp; m_FilePath == "") return -1; //ファイル名がない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (files.count(filePath) &gt; 0 &amp;&amp; isInitialized) return 0; // すでに辞書にロード済みファイルがあった<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (filePath != "" &amp;&amp; m_FilePath == "") m_FilePath = filePath; // 読み出しファイルパスを記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear(); //データを一旦クリア<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ply::load(m_FilePath, Data); // .plyデータをロード<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [std::shared_ptrへthis↓ポインタをつかうためには] https://www.kabuku.co.jp/developers/cpp_enable_shared_from_this<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; files.emplace(m_FilePath, shared_from_this()); // リソースの辞書へ登録 https://cpprefjp.github.io/reference/memory/enable_shared_from_this.html<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報]https://jp.mathworks.com/help/vision/ug/the-ply- format.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* face_uv = (Data["face"]-&gt;properties.has_key("texcoord")) ? Data["face"]-&gt;properties["texcoord"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)// i + face_index-&gt;listCounts[nFace], ++nFace)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //size_t count = face_index-&gt;listCounts[nFace]; // ポリゴンならインデックス数は3 四角形ならインデックス数は4 .. 5 .. 6<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //size_t nPolygon = count - 2; // 三角ポリゴンの数 = インデックスの数 - 2 (例) 3 - 2 = 1ポリゴン , 4 - 2 = 2ポリゴン ..<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t n = 0; n &lt; nPolygon; ++n)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Vertex[index].su != -1.0f) // su sv の suが初期値-1でなく設定済なら頂点の被りとして新しいnewIndexとして新規Index番号で点を新規登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int newIndex = Vertex.size();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex.emplace_back(Vertex[index]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index = newIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index.push_back(newIndex);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index].su = 0.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (face_uv != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index].u = face_uv[uvIndex];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index].v = 1.0f - face_uv[uvIndex + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isGPUBufferRendering)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendDataToGPU(); // GPUのバッファへVertexとIndexデータ配列を送信<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = true;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void SendDataToGPU() // GPUのバッファへVertexとIndexデータ配列を送信<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int result = false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VertexBufHandle = DxLib::CreateVertexBuffer(Vertex.size(), DX_VERTEX_TYPE_SHADER_3D); // 頂点バッファを作成<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = DxLib::SetVertexBufferData(0, Vertex.data(), Vertex.size(), VertexBufHandle); // 頂点バッファに頂点データを転送する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //UpdateVertexBuffer(VertexBufHandle, UpdateStartIndex, UpdateVertexNum); // 頂点バッファハンドルの頂点バッファへの変更を適用する( GetBufferVertexBuffer で取得したバッファへの変更を反映する )<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result == -1) return;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexBufHandle = DxLib::CreateIndexBuffer(Index.size(), DX_INDEX_TYPE_32BIT); // インデックスバッファを作成<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = DxLib::SetIndexBufferData(0, Index.data(), Index.size(), IndexBufHandle); // インデックスバッファにインデックスデータを転送する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result == -1) return;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGPUBufferRendering = true;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSendDataToGPU = true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        #endif<br>
      </p>
      <br>
      <p><code>main.cpp</code>のコードを.ply形式の3DデータをDataPly構造体経由で読み込む形に変更する。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        #include "DataMV1.h"<br>
        <em>#include "DataPly.h"</em><br>
        <br>
        #include "Editor.h"<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; float animTime = 0.0f; // アニメの現在時刻<br>
        &nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
        &nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@kick.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;Load(); // 3Dモデルをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilAttackAnimData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@jump.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilAttackAnimData-&gt;Load(); // 3Dの追加アニメデータをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;AttachAnim(*pDevilAttackAnimData); // アニメを追加でflyのほうをベースとしたモデルにアタッチ<br>
        &nbsp;&nbsp;&nbsp; int animeButton = 0; // ボタンでアニメを切り替えられるようにする<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; pTexImage = Resource::MakeShared&lt;Texture&gt;("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; pTexImage-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; assert((int)*pTexImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>std::shared_ptr&lt;DataPly&gt; pPlyData = Resource::MakeShared&lt;DataPly&gt;("Image/dice.ply");<br>
          &nbsp;&nbsp;&nbsp; pPlyData-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)</em><br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; <u>Ply::Data Data; // .plyのデータのクラス<br>
          &nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply", Data); // .plyデータをロード 軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう</u><br>
        <br>
        &nbsp;&nbsp;&nbsp; <u>size_t numIndex = 0; // インデックスの数<br>
          &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
          &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
          <br>
          &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
          &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
          &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
          <br>
          &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
          &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
          &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
          &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
          &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
          &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
          &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
          &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
          &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
          &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
          <br>
          &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
          &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
          &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
          &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
          &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
          <br>
          &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
          &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
          <br>
          &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }</u><br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens(); // スクリーンの位置やドラッグによる移動を更新する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードの 0 1 キーで3Dアニメを切り替えられるようにする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_0))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_1))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 1;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width =&nbsp; pTexImage-&gt;m_XSize; float height =&nbsp; pTexImage-&gt;m_YSize; // テクスチャ画像のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f, 1.0f, 1.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(<em>pPlyData-&gt;</em>Vertex.data(), <em>pPlyData-&gt;</em>Vertex.size(), <em>pPlyData-&gt;</em>Index.data(), <em>pPlyData-&gt;</em>numIndex / 3, (int)*pTexImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 100, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ファイルのパス + ":" + アニメ名でアクセス<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string animPathName = (animeButton == 0) ? "Image/devil@kick.mv1:mixamo.com" : "Image/devil@jump.mv1:mixamo.com";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(pDevilData-&gt;count(animPathName) &gt; 0 &amp;&amp; "指定されたアニメ名のアニメはMV1に付属していませんでした");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime += animStepTime * animSpeed; // 1.0×2倍 なら2倍速でアニメ時刻が進む<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animTime &gt; (*pDevilData)[animPathName].endTime)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime = 0.0f; // 0秒目へとアニメをループさせる<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 再生時間をセットする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1SetAttachAnimTime((int)*pDevilData, (*pDevilData)[animPathName].index, animTime);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 半透明のスクリーンも描ける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); // サブのスクリーンを全部描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); // エディタのDraw処理<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう? devilのデータに隠れて見えにくいですが、ダイスの.ply形式のデータが今まで通り表示されていますでしょうか? <br>
      <br>
      <br>
    </a><a id="mozTocId0013" class="mozTocH1">
      <h1>Vector3に色々な関数を用意して3D空間の当たり判定をする</h1>
      <br>
      <p><code>Vector3.hを新規作成</code>してxyzの3D座標を取り扱えるようにして、さらに様々な当たり判定に使うための関数(線などとの最短距離を計算する)もセットで導入しておきましょう。</p>
      <p class="source">#ifndef VECTOR3_H_<br>
        #define VECTOR3_H_<br>
        <br>
        #include "DxLib.h"<br>
        <br>
        #include &lt;array&gt; //vector配列と基本同じだが【有限】の個数である違いがあるxyzなど3つ固定の個数ならstd::vectorよりstd::array型がよい<br>
        #include &lt;cmath&gt;<br>
        #include &lt;limits&gt; // 無限大などをstd::numeric_limits&lt;float&gt;::infinity()で取得<br>
        #include &lt;float.h&gt; // FLT_EPSILONでfloat型のとりうる最小の極小値を得る<br>
        #include &lt;memory&gt; // 共有ポインタを使う<br>
        <br>
        #ifndef GET_CLAMP // GET_CLAMPマクロの定義がなかったら定義して使う<br>
        // a と b 小さい方の値を求める<br>
        #define&nbsp;&nbsp;&nbsp; GET_MIN( a, b )&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ( ( (a) &lt; (b) ) ? (a) : (b) )<br>
        // a と b 大きい方の値を求める<br>
        #define&nbsp;&nbsp;&nbsp; GET_MAX( a , b )&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ( ( (a) &gt; (b) ) ? (a) : (b) )<br>
        // aを min から max の値に留める<br>
        #define&nbsp;&nbsp;&nbsp; GET_CLAMP( a, min, max )&nbsp;&nbsp;&nbsp; GET_MAX( min, GET_MIN( a, max ) )<br>
        #endif<br>
        <br>
        // 軸のタイプ X軸:Axis3D::X, Y軸:Axis3D::Y, Z軸:Axis3D::Z<br>
        enum class Axis3D { X = 0, Y, Z };<br>
        <br>
        //★【UnityのVector演算コード】<br>
        // https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
        <br>
        // 3変数x,y,zを持つ構造体。3つの数字をまとめて扱うならXYZ座標以外にも使える。x,y,z別々に足したり引いたり面倒なときこそ<br>
        struct Vector3<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // struct型はpublic:がなくてもデフォルトがpublic:&nbsp; private:を書けばプライベートにもできる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //float x = 0; // x座標<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //float y = 0; // y座標<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //float z = 0; // z座標 3つの定義をunionで配列xyzと共用することでxyz[1]=5.5f;とすると yも5.5となる【運命共用体】(メモリ上は同じ位置になる)<br>
        <br>
        &nbsp;&nbsp;&nbsp; union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x;// x座標<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float y;// y座標<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float z;// z座標<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }; //[匿名共用体とは] https://zenn.dev/block/articles/beda29f11f05afc147ef<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float r, g, b; }; // 赤緑青のRGB成分としてつかいたいとき<br>
        #ifdef DX_LIB_H // DXlibを#includeしていればDX_LIB_Hも定義済みなので下記も定義される VECTORの定義はDXライブラリ版のVector3<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR dxVec;<br>
        #endif<br>
        &nbsp;&nbsp;&nbsp; }; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(float*)キャストすればx,y,zデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator float* () const { return (float*)this; }<br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(const float*)キャストすればx,y,zデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator const float* () const { return (const float*)this; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ 初期化 z = 0.fでzのデフォルト値があるので2Dとしても使える<br>
        &nbsp;&nbsp;&nbsp; inline Vector3(float x = 0.0f, float y = 0.0f, float z = 0.0f)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;xyz = { x,y,z };// たった1行で書ける<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; // デストラクタ<br>
        &nbsp;&nbsp;&nbsp; ~Vector3() {}<br>
        <br>
        &nbsp;&nbsp;&nbsp; // Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 zero;// = { 0.f, 0.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 one; // = { 1.f, 1.f, 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 forward;// = { 0.f, 0.f, 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 back; // = { 0.f, 0.f, -1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 up; // = { 0.f, 1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 down;// = { 0.f, -1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 left; // = {-1.f, 0.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 right;// = { 1.f, 0.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; //[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 negativeInfinity;<br>
        &nbsp;&nbsp;&nbsp; //[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 positiveInfinity;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // destArrayにデータを保管しておく<br>
        &nbsp;&nbsp;&nbsp; Vector3&amp; copyToArray(std::array&lt;float, 3&gt;&amp; destArray)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destArray = this-&gt;xyz;//配列としてコピー<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; // sourceArray配列からVector3データを生成<br>
        &nbsp;&nbsp;&nbsp; Vector3 fromArray(std::array&lt;float, 3&gt;&amp; sourceArray) const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Vector3{ sourceArray[0], sourceArray[1], sourceArray[2] }; //配列から初期化<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; // ベクトルの長さ(原点0から点(x,y,z)までの距離)<br>
        &nbsp;&nbsp;&nbsp; inline float magnitude() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::sqrt(x * x + y * y + z * z); // √(x*x + y*y + z*z)<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)<br>
        &nbsp;&nbsp;&nbsp; inline float sqrMagnitude() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x * x + y * y + z * z; // x*x + y*y + z*z<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; // 正規化したベクトルを返す<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 normalized() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float mag = magnitude();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mag &lt; 0.00001f) // ほぼ0ベクトルか?<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Vector3{ x / mag, y / mag, z / mag }; // x / |x|, y / |y|, z / |z|<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; /*-----　演算子オーバーロード　-----*/<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 逆ベクトル<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 operator - () const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Vector3(-this-&gt;x, -this-&gt;y, -this-&gt;z);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // Vectorをそのまま足し合わせる<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 operator + () const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Vector3&amp; operator += (const Vector3&amp; add_v3)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x += add_v3.x;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;y += add_v3.y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;z += add_v3.z;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this; //[関数連鎖] *thisを返すことで v1 + v2 + v3見たく数珠繋ぎできる<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Vector3&amp; operator -= (const Vector3&amp; minus_v3)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x -= minus_v3.x;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;y -= minus_v3.y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;z -= minus_v3.z;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Vector3&amp; operator *= (float multiply_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x *= multiply_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;y *= multiply_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;z *= multiply_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 0.fで割ったときは±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; inline Vector3&amp; operator /= (float divide_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (divide_num == 0.0f) // 0で割ったら±無限大を返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *this = Vector3{ ((this-&gt;x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((this-&gt;y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((this-&gt;z &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x /= divide_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;y /= divide_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;z /= divide_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 代入演算子 x,y,zを全部 change_numに変える<br>
        &nbsp;&nbsp;&nbsp; inline Vector3&amp; operator = (float change_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x = change_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;y = change_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;z = change_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 一致演算子 x,y,zが全部一致するか 一つでも違えばfalse<br>
        &nbsp;&nbsp;&nbsp; inline bool operator == (const Vector3&amp; v3_other) const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;x != v3_other.x) return false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;y != v3_other.y) return false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;z != v3_other.z) return false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 不一致演算子<br>
        &nbsp;&nbsp;&nbsp; inline bool operator != (const Vector3&amp; v3_other) const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(*this == v3_other);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; /*---- 以下 DXライブラリ向けにVector3とDX版Vectorの変換方法を用意 ---------------*/<br>
        <br>
        &nbsp; // DXlibを#includeしていればDX_LIB_Hも定義済みなので下記関数も定義される VECTORの定義はDXライブラリ版のVector3<br>
        #ifdef DX_LIB_H<br>
        &nbsp; // Vector3からDxLibのVECTORへの変換<br>
        &nbsp;&nbsp;&nbsp; inline VECTOR Vec3ToVec()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR Result;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result.x = this-&gt;x;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result.y = this-&gt;y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result.z = this-&gt;z;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Result;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 左辺値がDXのVECTOR型のときの=代入対応<br>
        &nbsp;&nbsp;&nbsp; inline operator VECTOR() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR Result;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result.x = this-&gt;x;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result.y = this-&gt;y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result.z = this-&gt;z;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Result;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 右辺値がDXのVECTOR型のときの=代入対応<br>
        &nbsp;&nbsp;&nbsp; inline Vector3&amp; operator = (const VECTOR&amp; other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x = other.x;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;y = other.y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;z = other.z;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ DXのVECTOR型から = 初期化できるように<br>
        &nbsp;&nbsp;&nbsp; inline Vector3(VECTOR other) : x{ other.x }, y{ other.y }, z{ other.z } {}<br>
        <br>
        #endif<br>
        <br>
        #ifdef BT_VECTOR3_H<br>
        &nbsp;&nbsp;&nbsp; // 右辺値が 物理エンジンBullet の btVector3型ときの = 代入対応 (btVector3型:右手→左手:DirectX系 位置変換)<br>
        &nbsp;&nbsp;&nbsp; inline Vector3&amp; operator = (const btVector3&amp; right)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // Z軸にはマイナスをつけて右手系を左手系に変換 http://dolpetticoat.blog.fc2.com/blog-entry-92.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = (float)right.getX(), y = (float)right.getY(), z = -(float)right.getZ();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ 物理エンジンBullet の btVector3型 から = 初期化できるように (btVector3型:右手→左手:DirectX系 位置変換)<br>
        &nbsp;&nbsp;&nbsp; inline Vector3(const btVector3&amp; other) : x{ (float)other.getX() }, y{ (float)other.getY() }, z{ -(float)other.getZ() } {}<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; inline operator btVector3() const { return btVector3{x, y, -z}; }<br>
        #endif<br>
        };<br>
        <br>
        #ifdef BT_VECTOR3_H<br>
        <br>
        // btVector3型:右手→左手:DirectX系 オイラー回転を変換 http://dolpetticoat.blog.fc2.com/blog-entry-92.html<br>
        inline Vector3 rotationXYZ(const btVector3&amp; eulerZYX) { return Vector3{ -(float)eulerZYX.getX(), -(float)eulerZYX.getY(),(float)eulerZYX.getZ() }; }<br>
        <br>
        #endif<br>
        <br>
        <br>
        // Vector3どうしの足し算 割り算 掛け算 割り算などの 基本演算の グローバル定義<br>
        <br>
        <br>
        // Vector同士の足し算 x,y,z個別に足し合わせる<br>
        inline Vector3 operator + (const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 v3; //注意 vec1 = vec1 + vec2のとき vec1の数値が書き変わったら嫌だからv3を新たに用意<br>
        &nbsp;&nbsp;&nbsp; v3.x = left.x + right.x; //[コレはダメ] left.x = left.x + right.x;<br>
        &nbsp;&nbsp;&nbsp; v3.y = left.y + right.y;<br>
        &nbsp;&nbsp;&nbsp; v3.z = left.z + right.z;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v3;<br>
        }<br>
        <br>
        // Vector同士の引き算 x,y,z個別に足し合わせる<br>
        inline Vector3 operator - (const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 v3; //注意 vec1 = vec1 - vec2のとき vec1の数値が書き変わったら嫌だからv3を新たに用意<br>
        &nbsp;&nbsp;&nbsp; v3.x = left.x - right.x; //[コレはダメ] left.x = left.x - right.x;<br>
        &nbsp;&nbsp;&nbsp; v3.y = left.y - right.y;<br>
        &nbsp;&nbsp;&nbsp; v3.z = left.z - right.z;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v3;<br>
        }<br>
        <br>
        // Vectorと数値の掛け算 x,y,z個別に掛け合わせる<br>
        inline Vector3 operator * (const Vector3&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 v3;<br>
        &nbsp;&nbsp;&nbsp; v3.x = left.x * right;<br>
        &nbsp;&nbsp;&nbsp; v3.y = left.y * right;<br>
        &nbsp;&nbsp;&nbsp; v3.z = left.z * right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v3;<br>
        }<br>
        <br>
        <br>
        // 数値とVectorの掛け算 x,y,z個別に掛け合わせる<br>
        inline Vector3 operator * (float left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 v3;<br>
        &nbsp;&nbsp;&nbsp; v3.x = left * right.x;<br>
        &nbsp;&nbsp;&nbsp; v3.y = left * right.y;<br>
        &nbsp;&nbsp;&nbsp; v3.z = left * right.z;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v3;<br>
        }<br>
        <br>
        // Vectorと数値の割り算 x,y,z個別に割り合わせる<br>
        // 0.fで割ると±無限大を返す<br>
        inline Vector3 operator / (const Vector3&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (right == 0.0f) // 0で割ったら±無限大を返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Vector3{ ((left.x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((left.y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((left.z &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector3 v3;<br>
        &nbsp;&nbsp;&nbsp; v3.x = left.x / right;<br>
        &nbsp;&nbsp;&nbsp; v3.y = left.y / right;<br>
        &nbsp;&nbsp;&nbsp; v3.z = left.z / right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v3;<br>
        }<br>
        <br>
        // 比較不等号 &lt; 演算子<br>
        inline bool operator &lt; (const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &lt; right.x;<br>
        &nbsp;&nbsp;&nbsp; if (left.y != right.y) return left.y &lt; right.y;<br>
        &nbsp;&nbsp;&nbsp; return left.z &lt; right.z;<br>
        }<br>
        <br>
        // 比較不等号 &gt; 演算子<br>
        inline bool operator &gt; (const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &gt; right.x;<br>
        &nbsp;&nbsp;&nbsp; if (left.y != right.y) return left.y &gt; right.y;<br>
        &nbsp;&nbsp;&nbsp; return left.z &gt; right.z;<br>
        }<br>
        <br>
        // 比較不等号 &lt;= 演算子<br>
        inline bool operator &lt;= (const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &gt; right);<br>
        }<br>
        <br>
        // 比較不等号 &gt;= 演算子<br>
        inline bool operator &gt;= (const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &lt; right);<br>
        }<br>
        <br>
        // 2つのベクトルの内積<br>
        inline float dot(const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return left.x * right.x + left.y * right.y + left.z * right.z; //普通にx同士,y同士,z同士掛けるだけ<br>
        }<br>
        <br>
        // 2つのベクトルの外積<br>
        inline Vector3 cross(const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return Vector3{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left.y * right.z - left.z * right.y, // x = 左y * 右z - 左z * 右y<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left.z * right.x - left.x * right.z, // y = 左z * 右x - 左x * 右z<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left.x * right.y - left.y * right.x };// z = 左x * 右y - 左y * 右x //行列独特の特殊な掛け方<br>
        }<br>
        <br>
        // ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)<br>
        inline float sqrMagnitude(const Vector3&amp; vec)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return vec.x * vec.x + vec.y * vec.y + vec.z * vec.z; // x*x + y*y + z*z<br>
        }<br>
        <br>
        // ベクトルの長さ(原点0から点(x,y,z)までの距離)<br>
        inline float magnitude(const Vector3&amp; vec)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return std::sqrt(sqrMagnitude(vec)); // √x*x + y*y + z*z<br>
        }<br>
        <br>
        // start と end の間の距離<br>
        inline float distance(const Vector3&amp; start, const Vector3&amp; end)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return (start - end).magnitude();<br>
        }<br>
        <br>
        // 直線上にある2つのベクトル間を補間(start:開始位置&nbsp; end:終了位置&nbsp; t = 補間の割合 tは0～1の範囲にクランプしない)<br>
        inline Vector3 lerpUnclamped(const Vector3&amp; start, const Vector3&amp; end, float t)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return start + (end - start) * t;<br>
        }<br>
        <br>
        // 線形補間する start:開始位置&nbsp; end:終了位置&nbsp; t = 補間の割合（start側が100%&nbsp; 0.0～1.0&nbsp; end側が100% でブレンド) tは0～1の範囲にクランプする<br>
        inline Vector3 lerp(const Vector3&amp; start, const Vector3&amp; end, float t)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return lerpUnclamped(start,end, GET_CLAMP(t, 0.0f, 1.0f) );<br>
        }<br>
        <br>
        <br>
        // 2つのベクトルのx,y,zのそれぞれ大きいほうの数値で構成したベクトルを求める 例. v1(1,2,3) v2(3,2,1) なら(3,2,3)になる<br>
        inline Vector3 maximize(const Vector3&amp; v1, const Vector3&amp; v2)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 result;<br>
        &nbsp;&nbsp;&nbsp; result.x = (v1.x &gt; v2.x) ? v1.x : v2.x;<br>
        &nbsp;&nbsp;&nbsp; result.y = (v1.y &gt; v2.y) ? v1.y : v2.y;<br>
        &nbsp;&nbsp;&nbsp; result.z = (v1.z &gt; v2.z) ? v1.z : v2.z;<br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        }<br>
        <br>
        <br>
        // 2つのベクトルのx,y,zのそれぞれ小さいほうの数値で構成したベクトルを求める 例. v1(1,2,3) v2(3,2,1) なら(1,2,1)になる<br>
        inline Vector3 minimize(const Vector3&amp; v1, const Vector3&amp; v2)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 result;<br>
        &nbsp;&nbsp;&nbsp; result.x = (v1.x &lt; v2.x) ? v1.x : v2.x;<br>
        &nbsp;&nbsp;&nbsp; result.y = (v1.y &lt; v2.y) ? v1.y : v2.y;<br>
        &nbsp;&nbsp;&nbsp; result.z = (v1.z &lt; v2.z) ? v1.z : v2.z;<br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        }<br>
        <br>
        // 2次補間する start:開始位置 mid:中間制御点 end:終了位置&nbsp; t = 補間の割合（start側が100%&nbsp; 0.0～1.0&nbsp; end側が100% でブレンド)<br>
        inline Vector3 quadratic(const Vector3&amp; start, const Vector3&amp; mid, const Vector3&amp; end, float t)<br>
        {&nbsp;&nbsp;&nbsp; //[ベジェ曲線補間の3点ver.] https://ja.javascript.info/bezier-curve<br>
        &nbsp;&nbsp;&nbsp; return start * (1.0f - t) * (1.0f - t) + 2 * mid * t * (1.0f - t) + end * t * t;<br>
        }<br>
        <br>
        <br>
        // ベジェ曲線の補間をする start:開始位置 mid1:中間制御点1&nbsp; mid2:中間制御点2 end:終了位置&nbsp; t = 補間の割合（start側が100%&nbsp; 0.0～1.0&nbsp; end側が100%)<br>
        inline Vector3 bezier(const Vector3&amp; start, const Vector3&amp; mid1, const Vector3&amp; mid2, const Vector3&amp; end, float t)<br>
        {&nbsp;&nbsp;&nbsp; //[ベジェ曲線補間の4点ver.] https://ja.javascript.info/bezier-curve<br>
        &nbsp;&nbsp;&nbsp; Vector3 vec;<br>
        &nbsp;&nbsp;&nbsp; vec.x = start.x * (1.0f - t) * (1.0f - t) * (1.0f - t) + 3 * (1.0f - t) * (1.0f - t) * t * mid1.x + 3 * (1.0f - t) * t * t * mid2.x + t * t * t * end.x;<br>
        &nbsp;&nbsp;&nbsp; vec.y = start.y * (1.0f - t) * (1.0f - t) * (1.0f - t) + 3 * (1.0f - t) * (1.0f - t) * t * mid1.y + 3 * (1.0f - t) * t * t * mid2.y + t * t * t * end.y;<br>
        &nbsp;&nbsp;&nbsp; vec.z = start.z * (1.0f - t) * (1.0f - t) * (1.0f - t) + 3 * (1.0f - t) * (1.0f - t) * t * mid1.z + 3 * (1.0f - t) * t * t * mid2.z + t * t * t * end.z;<br>
        &nbsp;&nbsp;&nbsp; return vec;<br>
        }<br>
        <br>
        <br>
        // 2つのベクトルの各成分をかけ算<br>
        inline Vector3 scale(const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return Vector3{ left.x * right.x, left.y * right.y, left.z * right.z };<br>
        }<br>
        <br>
        // ベクトルを別のベクトルに投影<br>
        inline Vector3 project(const Vector3&amp; vector, const Vector3&amp; on_normal)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float sqrMag = on_normal.sqrMagnitude();<br>
        &nbsp;&nbsp;&nbsp; if (sqrMag &lt; 0.00001f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Vector3::zero;<br>
        &nbsp;&nbsp;&nbsp; return on_normal * dot(vector, on_normal) / sqrMag;<br>
        }<br>
        <br>
        // 平面に垂直な法線ベクトルにより定義される平面上にベクトルを射影<br>
        inline Vector3 projectOnPlane(const Vector3&amp; vector, const Vector3&amp; planeNormal)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return vector - project(vector, planeNormal);<br>
        }<br>
        <br>
        // 仰角:radPolar[単位:ラジアン] 方位角:radAzimuth[単位:ラジアン]から方位ベクトル(極座標の位置の単位ベクトル)を求める<br>
        inline Vector3 polarDir(float radPolar, float radAzimuth)<br>
        {&nbsp;&nbsp; //[球体表面上の点へ向かう方位ベクトル] https://www.pentacreation.com/blog/2020/12/201225.html<br>
        &nbsp;&nbsp;&nbsp; Vector3 result;<br>
        &nbsp;&nbsp;&nbsp; result.x =&nbsp; std::cos(radPolar) * std::sin(radAzimuth);<br>
        &nbsp;&nbsp;&nbsp; result.y = -std::sin(radPolar);<br>
        &nbsp;&nbsp;&nbsp; result.z =&nbsp; std::cos(radPolar) * std::cos(radAzimuth);<br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        }<br>
        <br>
        // 2つのベクトルの角度θを求める(単位:ラジアン)<br>
        inline float radAngle(const Vector3&amp; start, const Vector3&amp; end)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float cos_theta = dot(start, end) / (start.magnitude() * end.magnitude());<br>
        &nbsp;&nbsp;&nbsp; return std::acos( GET_CLAMP(cos_theta, -1.0f, 1.0f) );<br>
        }<br>
        <br>
        // 三角ポリゴンの面法線を求める p0,p1,p2:三角ポリゴンの3点の位置ベクトル<br>
        inline Vector3 polygonNorm(const Vector3&amp; p0, const Vector3&amp; p1, const Vector3&amp; p2)<br>
        {&nbsp;&nbsp; //[DirectX:左手系(時計回りの親指が上)]<br>
        &nbsp;&nbsp;&nbsp; // 直線p1p0 と 直線p2p1 の外積を求めて、それを単位ベクトルNorm化する<br>
        &nbsp;&nbsp;&nbsp; return cross(p0 - p1, p1 - p2).normalized();<br>
        }<br>
        <br>
        // 反射ベクトルを求める input:入射ベクトル&nbsp; eNorm:単位法線ベクトル<br>
        inline Vector3 reflection(const Vector3&amp; input, const Vector3&amp; eNorm)<br>
        {&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内積↓<br>
        &nbsp;&nbsp;&nbsp; // [計算式]反射ベクトル = 2 * ( -入射・法線 ) * 法線 + 入射<br>
        &nbsp;&nbsp;&nbsp; return 2 * dot(-input, eNorm) * eNorm + input;<br>
        }<br>
        <br>
        // 壁ずりベクトル(単位化済)を求める input:入射ベクトル&nbsp; eNorm:単位法線ベクトル<br>
        inline Vector3 wallscratch(const Vector3&amp; input, const Vector3&amp; eNorm)<br>
        {&nbsp;&nbsp; // http://marupeke296.com/COL_Basic_No5_WallVector.html<br>
        &nbsp;&nbsp;&nbsp; return (input - dot(input, eNorm) * eNorm).normalized();<br>
        }<br>
        <br>
        // 屈折ベクトルを求める input:入射ベクトル eNorm:単位法線ベクトル 屈折比率: n = n1 / n2 (入射角度:θ1 屈折角度:θ2)<br>
        inline Vector3 refraction(const Vector3&amp; input, const Vector3&amp; eNorm, float n)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; //[ベクトルの屈折] https://tyfkda.github.io/blog/2009/07/19/refraction.html<br>
        &nbsp;&nbsp;&nbsp; Vector3 inverse = -input; // 逆ベクトル<br>
        &nbsp;&nbsp;&nbsp; float cos_theta1 = dot(inverse, eNorm); // cosθ1 = -入射ベクトル・法線ベクトル<br>
        &nbsp;&nbsp;&nbsp; float cosT2 = 1.0f - n * n * (1.0f - cos_theta1 * cos_theta1); // <br>
        &nbsp;&nbsp;&nbsp; if (cosT2 &lt;= 0.0f) return Vector3{ 0.0f, 0.0f, 0.0f }; // 屈折光はでてこない<br>
        &nbsp;&nbsp;&nbsp; float abs_cosT2 = (cosT2 &lt; 0) ? -cosT2 : cosT2;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 屈折比率: n = n1 / n2 (入射角度:θ1 屈折角度:θ2)<br>
        &nbsp;&nbsp;&nbsp; // 屈折ベクトル = n * -入射 + 法線 * (n * cosθ1 - √(1 - n * n * (1 - cosθ1 * cosθ1) )<br>
        &nbsp;&nbsp;&nbsp; return n * inverse + eNorm * (n * cos_theta1 - std::sqrt(abs_cosT2));<br>
        }<br>
        <br>
        // 円周率×2<br>
        #define PI_2 3.14159265358979323846264f * 2<br>
        <br>
        // ラジアン: 0～2π (0°～ 360°)の範囲に変換<br>
        #define RAD_NORMALIZE( rad ) ( ( rad &gt;= 0.0f ) ? std::fmod( rad, PI_2 ): std::fmod( rad, PI_2 ) + PI_2 )<br>
        <br>
        // ベクトルから Pitch(ピッチ) を求める https://watako-lab.com/2019/01/23/roll_pitch_yaw/<br>
        inline float pitch(const Vector3&amp; vec)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float length = vec.magnitude();<br>
        &nbsp;&nbsp;&nbsp; if (length == 0) return 0.0f; // ベクトルの長さが0のときは0°<br>
        <br>
        &nbsp;&nbsp;&nbsp; // こたえを 0～2π (0°～ 360°)の範囲に変換してreturn<br>
        &nbsp;&nbsp;&nbsp; return RAD_NORMALIZE( std::asin(-vec.y / length) );<br>
        }<br>
        <br>
        // ベクトルから Yaw(ヨー) を求める https://watako-lab.com/2019/01/23/roll_pitch_yaw/<br>
        inline float yaw(const Vector3&amp; vec)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float length = vec.magnitude();<br>
        &nbsp;&nbsp;&nbsp; if (length == 0) return 0.0f; // ベクトルの長さが0のときは0°<br>
        <br>
        &nbsp;&nbsp;&nbsp; return RAD_NORMALIZE( std::atan2(vec.x / length, vec.z / length) );<br>
        }<br>
        <br>
        // 一時定義したマクロを #undef で未定義に戻す<br>
        #undef PI_2<br>
        #undef RAD_NORMALIZE<br>
        <br>
        // 重心座標を求める 点 p0:重心座標を求めたい位置 三角形の点: p1 p2 p3 https://zellij.hatenablog.com/entry/20131207/p1<br>
        inline Vector3 barycentric(const Vector3&amp; p0, const Vector3&amp; p1, const Vector3&amp; p2, const Vector3&amp; p3)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 v2 = p2 - p1;<br>
        &nbsp;&nbsp;&nbsp; Vector3 v3 = p3 - p1;<br>
        &nbsp;&nbsp;&nbsp; Vector3 v0 = p0 - p1;<br>
        &nbsp;&nbsp;&nbsp; float d22 = dot(v2, v2);<br>
        &nbsp;&nbsp;&nbsp; float d23 = dot(v2, v3);<br>
        &nbsp;&nbsp;&nbsp; float d33 = dot(v3, v3);<br>
        &nbsp;&nbsp;&nbsp; float d02 = dot(v0, v2);<br>
        &nbsp;&nbsp;&nbsp; float d03 = dot(v0, v3);<br>
        &nbsp;&nbsp;&nbsp; float denom = d22 * d33 - d23 * d23;<br>
        &nbsp;&nbsp;&nbsp; float v = (d33 * d02 - d23 * d03) / denom;<br>
        &nbsp;&nbsp;&nbsp; float w = (d22 * d03 - d23 * d02) / denom;<br>
        &nbsp;&nbsp;&nbsp; return&nbsp; p1 * (1.0f - v - w) + p2 * v + p3 * w;<br>
        }<br>
        <br>
        // 調べたい点point から一番近い直線上の点を求める linePos: 線の起点 lineVec:線のベクトル isInfinite:無限に延びる線か? result_t:接点までの直線パラメータ t<br>
        inline Vector3 nearestPointOnLine(const Vector3&amp; point, const Vector3&amp; lineStart, const Vector3&amp; lineDir, bool isInfinite = true, float* result_t = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float t; // 直線のパラメータ t (tが0だと始点startの位置、tが増えると始点からより遠くに延長された位置になる)<br>
        &nbsp;&nbsp;&nbsp; float lineLengthSq = lineDir.sqrMagnitude();<br>
        &nbsp;&nbsp;&nbsp; if (lineLengthSq &lt; FLT_EPSILON) // 線分のベクトルの長さがほぼ0なら<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result_t != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result_t = 0.0f; // 直線パラメータ t は起点の位置だから 0 の位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return lineStart; // 線分の始点が最も近い<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; linePosToPoint = point - lineStart; // 線の起点linePos から 調べたい点pointへのベクトル<br>
        <br>
        &nbsp;&nbsp;&nbsp; t = dot(lineDir, linePosToPoint) / lineLengthSq; // 調べたい座標に最も近い lineVec線上の座標 への直線パラメータ t を計算<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (isInfinite == false) // 有限線分のとき (線が無限に延びてないタイプのとき)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = GET_CLAMP(t, 0.0f, 1.0f); // 有限の線だから GET_CLAMP でtの値を 0.0f～1.0fの間に限定する<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result_t != nullptr) // result_tがnullptrじゃなければ 直線パラメータ t もついでに計算結果を返却しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result_t = t;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return lineDir * t + lineStart; // lineVecの方向をt倍のばして一番近い直線上の点の位置を求める<br>
        }<br>
        <br>
        <br>
        // 平行で交わらない線分line0 と 線分line1 の一番近い点を求める isInfinite:無限の長さの線かどうか result0:line0上の最も近い点 result1:line1上の最も近い点 <br>
        inline void nearestPointOfParallelLine(const Vector3&amp; line0Start, const Vector3&amp; line0End, const Vector3&amp; line1Start, const Vector3&amp; line1End,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isInfinite = false, Vector3* result0 = nullptr, Vector3* result1 = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float t0, t1, t; // 直線のパラメータを求める<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector3 answer0 = nearestPointOnLine(line1Start, line0Start, line0End - line0Start, true, &amp;t0); // 始点line1Start から一番近い直線line0上の点を求める<br>
        &nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入して返す<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (isInfinite == true) // 無限の長さの線ならば<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer1 = line1Start; // line1の起点が一番近い<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1; // resultがnullptrじゃなければ答えを代入して返す<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; tmpPoint = nearestPointOnLine(line1End, line0Start, line0End - line0Start, true, &amp;t1); // 終点line1end から一番近い直線line0上の点を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((t0 &lt; 0.0f) &amp;&amp; (t1 &lt; 0.0f)) // 最も近い点 が line0もline1も両方【始点】より外側の延長線上にあるとき<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer0 = line0Start; // 始点が答え(最も近い点)になる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer1 = (t0 &lt; t1) ? line1End : line1Start;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入して返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((t0 &gt; 1.0f) &amp;&amp; (t1 &gt; 1.0f)) // 最も近い点 が line0もline1も両方【終点】より外側の延長線上にあるとき<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer0 = line0End; // 終点が答え(最も近い点)になる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer1 = (t0 &lt; t1) ? line1Start : line1End;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入して返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = 0.5f * (GET_CLAMP(t0, 0.0f, 1.0f) + GET_CLAMP(t1, 0.0f, 1.0f)); <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer0 = (line0End - line0Start) * t + line0Start; // line0の方向をt倍のばして一番近い直線上の点の位置を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer1 = nearestPointOnLine(answer0, line1Start, line1End - line1Start, true); // 点answer0 から一番近い直線line1上の点を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入して返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        }<br>
        <br>
        // 線分line0 と 線分line1 の【有限の線上範囲内】での一番近い点を求める result0:line0上に収まる最も近い点 result1:line1上に収まる最も近い点 <br>
        inline void nearestPointsOnFiniteLines(const Vector3&amp; line0Start, const Vector3&amp; line0End, const Vector3&amp; line1Start, const Vector3&amp; line1End, <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t0, float t1, Vector3&amp; result0, Vector3&amp; result1)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 v0 = line0End - line0Start; // line0 の start点 から end点 へ向かう ベクトル<br>
        &nbsp;&nbsp;&nbsp; Vector3 v1 = line1End - line1Start; // line1 の start点 から end点 へ向かう ベクトル<br>
        &nbsp;&nbsp;&nbsp; if ( (t0 &lt; 0.0f || 1.0f &lt; t0) &amp;&amp; (t1 &lt; 0.0f || 1.0f &lt; t1) ) // t0 も t1 も両方 0～1.0の範囲外(line0とline1の始点から終点の範囲内におさまってない)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = GET_CLAMP(t0, 0.0f, 1.0f); // まず t0 を 0～1.0以内に収める(0以下 や 1以上 でも 0 や 1 にする)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer0 = v0 * t0 + line0Start; // v0の方向を t0倍 のばした直線line0上 の 範囲内の点 の位置を一旦、求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer1 = nearestPointOnLine(answer0, line1Start, v1, true, &amp;t1); // 範囲内の点↑answer0 から 一番近い 直線line1(無限長)上の点 を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (t1 &lt; 0.0f || 1.0f &lt; t1) // t1が 直線line1 の 始点0 ～ 終点1.0 の↑範囲外ならば t1を0～1.0の範囲に収めてさらに再計算<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = GET_CLAMP(t1, 0.0f, 1.0f); // t1 = 0～1.0以内に収めて再計算<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer1 = v1 * t1 + line1Start; // v1の方向を t1倍 のばして一番近い直線上の点の位置を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer0 = nearestPointOnLine(answer1, line0Start, v0, false); // 点answer1 から 一番近い 直線line0(有限)上の点 を求めなおす<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer1 = nearestPointOnLine(answer0, line1Start, v1, false); // 点answer0 から 一番近い 直線line1(有限)上の点 を求めなおす<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result0 = answer0; // 求めたanswer で 結果 result を確定して関数外へ返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (t0 &lt; 0.0f || 1.0f &lt; t0) // t0 が 0～1.0の範囲におさまっていない(line0の始点から終点の範囲内におさまってない)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = GET_CLAMP(t0, 0.0f, 1.0f); // t0 を 0～1.0以内に収める(0以下 や 1以上 でも 0 や 1 にする)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer0 = v0 * t0 + line0Start; // v0の方向を t0倍 のばした直線line0上 の 範囲内の点 の位置を一旦、求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer1 = nearestPointOnLine(answer0, line1Start, v1, false); // 点answer0 から 一番近い 直線line1(有限)上の点 を求める<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result0 = answer0; // 求めたanswer で 結果 result を確定して関数外へ返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (t1 &lt; 0.0f || 1.0f &lt; t1) // t1 が 0～1.0の範囲におさまっていない(line1の始点から終点の範囲内におさまってない)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = GET_CLAMP(t1, 0.0f, 1.0f); // t1 を 0～1.0以内に収める(0以下 や 1以上 でも 0 や 1 にする)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer1 = v1 * t1 + line1Start; // v0の方向を t0倍 のばした直線line0上 の 範囲内の点 の位置を一旦、求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer0 = nearestPointOnLine(answer1, line0Start, v0, false); // 点answer1 から 一番近い 直線line0(有限)上の点 を求める<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result0 = answer0; // 求めたanswer で 結果 result を確定して関数外へ返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        }<br>
        <br>
        <br>
        // 点:point と box:AABB(軸並行境界ボックス：Axis-Aligned Bounding Box)の最短距離の2乗 http://marupeke296.com/COL_3D_No11_AABBvsPoint.html<br>
        inline float sqrNearestLengthPoint_AABB(const Vector3&amp; point, const Vector3&amp; boxMin, const Vector3&amp; boxMax)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float sqLength = 0.0f; // 長さのべき乗の値を足していく<br>
        &nbsp;&nbsp;&nbsp; for (auto i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 各軸で点が最小値以下もしくは最大値以上ならば、差を考慮<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (point.xyz[i] &lt; boxMin.xyz[i])&nbsp; // i=0:X,,i=1:Y, i=2はZの意味です<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqLength += (point.xyz[i] - boxMin.xyz[i]) * (point.xyz[i] - boxMin.xyz[i]); // 距離の2乗<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (point.xyz[i] &gt; boxMax.xyz[i])<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqLength += (point.xyz[i] - boxMax.xyz[i]) * (point.xyz[i] - boxMax.xyz[i]); // 距離の2乗<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return sqLength; //&nbsp; // 距離の2乗を足していった合計を返す<br>
        }<br>
        <br>
        // 点:point と box:AABB(軸並行境界ボックス：Axis-Aligned Bounding Box)の最短距離 http://marupeke296.com/COL_3D_No11_AABBvsPoint.html<br>
        inline float nearestLengthPoint_AABB(const Vector3&amp; point, const Vector3&amp; boxMin, const Vector3&amp; boxMax)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return std::sqrtf(sqrNearestLengthPoint_AABB(point, boxMin, boxMax)); // 距離の2乗を足していった合計の√を取る<br>
        }<br>
        <br>
        // 点:point0 と box1:OBB(有向境界ボックス：Oriented Bounding Box)の各軸の超過ベクトル result:OBB上の一番近い点を返す<br>
        inline Vector3 overLengthPoint_OBB(const Vector3&amp; point0,<br>
        &nbsp;&nbsp;&nbsp; const Vector3&amp; centerOBB1, const Vector3&amp; sizeOBB1, const std::array&lt;Vector3, 3&gt;&amp; axisOBB1,<br>
        &nbsp;&nbsp;&nbsp; Vector3* result = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 v10 = point0 - centerOBB1; // OBBの中心→pointのベクトル<br>
        &nbsp;&nbsp;&nbsp; Vector3 overLength{ 0.0f, 0.0f, 0.0f }; // 最終的な長さを求めるベクトル<br>
        &nbsp;&nbsp;&nbsp; float dist;<br>
        &nbsp;&nbsp;&nbsp; // 各軸についてはみ出た部分のベクトルを算出 http://marupeke296.com/COL_3D_No12_OBBvsPoint.html<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = sizeOBB1.xyz[i] / 2; // 軸の中心からはしっこまでの距離<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dist = dot(v10, axisOBB1[i]); // OBBの中心→pointのベクトルとOBBの軸の内積<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (L &gt; 0) // L=0は計算できない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float s = dist / L; // distをLで割る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sの値から、はみ出した部分があればそのベクトルを加算<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float abs_s = (s &lt; 0) ? -s : s; // sの絶対値を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (abs_s &gt; 1) // sの絶対値が1を超えた部分がはみ出したベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overLength += (1 - abs_s) * L * axisOBB1[i]; // はみ出した部分のベクトル算出<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result != nullptr) // resultがnullptrじゃなければOBB上の一番近い点も求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // OBB上の一番近い点の算出 http://distancevector.web.fc2.com/collision.html#OBBPoint<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dist &gt; L) dist = L; // distがLの長さを超えても L の長さに制限する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dist &lt; -L) dist = -L;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result += dist * axisOBB1[i]; // OBB上の一番近い点に i の軸方向の距離を反映<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return overLength; // 超過ベクトルを返す<br>
        }<br>
        <br>
        // 点:point と box:OBB(有向境界ボックス：Oriented Bounding Box)の最短距離 result:OBB上の一番近い点を返す<br>
        inline float nearestLengthPoint_OBB(const Vector3&amp; point, <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Vector3&amp; centerOBB, const Vector3&amp; sizeOBB, const std::array&lt;Vector3,3&gt;&amp; axisOBB,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3* result = nullptr)<br>
        {&nbsp;&nbsp; // 各軸の超過距離のベクトルの大きさを出力 http://marupeke296.com/COL_3D_No12_OBBvsPoint.html<br>
        &nbsp;&nbsp;&nbsp; return overLengthPoint_OBB(point, centerOBB, sizeOBB, axisOBB, result).magnitude();<br>
        }<br>
        <br>
        // 点:point と box:OBB(有向境界ボックス：Oriented Bounding Box)の最短距離の2乗 result:OBB上の一番近い点を返す<br>
        inline float sqrNearestLengthPoint_OBB(const Vector3&amp; point,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Vector3&amp; centerOBB, const Vector3&amp; sizeOBB, const std::array&lt;Vector3, 3&gt;&amp; axisOBB,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3* result = nullptr)<br>
        {&nbsp;&nbsp; // 各軸の超過距離のベクトルの大きさの2乗を出力 http://marupeke296.com/COL_3D_No12_OBBvsPoint.html<br>
        &nbsp;&nbsp;&nbsp; return overLengthPoint_OBB(point, centerOBB, sizeOBB, axisOBB, result).sqrMagnitude();<br>
        }<br>
        <br>
        #endif<br>
      </p>
      <br>
      <p><code>Vector3.cppを新規作成</code>してstatic変数の初期化コードを実装します。</p>
      <p class="source">#include "Vector3.h"<br>
        <br>
        // Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
        Vector3 const Vector3::zero = Vector3(0.f, 0.f, 0.f);<br>
        Vector3 const Vector3::one = Vector3(1.f, 1.f, 1.f);<br>
        Vector3 const Vector3::forward = Vector3(0.f, 0.f, 1.f);<br>
        Vector3 const Vector3::back = Vector3(0.f, 0.f, -1.f);<br>
        Vector3 const Vector3::up = Vector3(0.f, 1.f, 0.f);<br>
        Vector3 const Vector3::down = Vector3(0.f, -1.f, 0.f);<br>
        Vector3 const Vector3::left = Vector3(-1.f, 0.f, 0.f);<br>
        Vector3 const Vector3::right = Vector3(1.f, 0.f, 0.f);<br>
        //[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
        Vector3 const Vector3::negativeInfinity = Vector3(-std::numeric_limits&lt;float&gt;::infinity(), -std::numeric_limits&lt;float&gt;::infinity(), -std::numeric_limits&lt;float&gt;::infinity());<br>
        //[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
        Vector3 const Vector3::positiveInfinity = Vector3(std::numeric_limits&lt;float&gt;::infinity(), std::numeric_limits&lt;float&gt;::infinity(), std::numeric_limits&lt;float&gt;::infinity());<br>
      </p>
      <br>
      つぎにVector3を使って、平面を表現するPlane4.hを準備します。<br>
      実は平面(無限)は、驚くことにデータ的には、 <b>原点からの距離:dist と 平面に垂直な法線ベクトル:n のたった2つだけの要素で確定</b>できてしまいます。<br>
      <p><img src="image/plane_polygon_collision.png" alt="" style=""><br>
      </p>
      <p><code>Plane4.hを新規作成</code>して原点からの距離:dist と 平面に垂直な法線ベクトル:n である無限の平面を数学的に表現する準備をします。</p>
      <p class="source">#ifndef PLANE_H_<br>
        #define PLANE_H_<br>
        <br>
        #include "Vector3.h"<br>
        #include &lt;cmath&gt;<br>
        #include &lt;float.h&gt; // 極小値ε FLT_EPSILON を使う<br>
        <br>
        //[UnityのPlane平面の例] https://docs.unity3d.com/ja/2022.3/ScriptReference/Plane.html<br>
        // 内部的には内積や外積だけで計算処理が実装されている<br>
        <br>
        struct Plane4 // 数学的な平面(無限)の定義 Plane4の4はVector3のような float型を4つ持つという意味<br>
        {<br>
        &nbsp;&nbsp;&nbsp; union // 共用体unionで法線struct{nx, ny, nz} と 法線nを同じメモリ上の位置にする つまり nx = n.x, ny = n.y, nz = n.zになる<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //struct { float nx, ny, nz; }; // 面法線x,y,z成分<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; n{0.0f,0.0f,0.0f};&nbsp;&nbsp;&nbsp; // 面から出る法線ベクトル<br>
        &nbsp;&nbsp;&nbsp; };<br>
        &nbsp;&nbsp;&nbsp; float dist = 0.0f;&nbsp; // 原点[まで]の距離 [参考] https://nyama41.hatenablog.com/entry/unity_plane_distance<br>
        <br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(float*)キャストすればnx,ny,nz,distデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator float* () const { return (float*)this; }<br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(const float*)キャストすればnx,ny,nz,distデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator const float* () const { return (const float*)this; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Plane4(const Plane4&amp; other) : n{ other.n }, dist{ other.dist } {} // コピーコンストラクタ return *thisを使うため<br>
        <br>
        &nbsp;&nbsp;&nbsp; Plane4(float normX = 0.0f, float normY = 0.0f, float normZ = 0.0f, float distance = 0.0f) : n{ Vector3{normX, normY, normZ } }, dist{ distance } {}<br>
        &nbsp;&nbsp;&nbsp; Plane4(const Vector3&amp; norm, float distance) : n{ norm }, dist{ distance } {}<br>
        &nbsp;&nbsp;&nbsp; // 平面上の点point と 平面の法線ペクトルnorm から 平面方程式パラメータdist(原点からの距離)をdotで計算して 平面を生成する <br>
        &nbsp;&nbsp;&nbsp; Plane4(const Vector3&amp; point, const Vector3&amp; norm) : n{ norm }, dist{ -dot(norm, point) } {}<br>
        &nbsp;&nbsp;&nbsp; // 三角ポリゴン 3点p0,p1,p2 から平面を確定させて生成 dist(原点からの距離) は 法線normal と 点p0 から計算<br>
        &nbsp;&nbsp;&nbsp; Plane4(const Vector3&amp; p0, const Vector3&amp; p1, const Vector3&amp; p2) : n{ polygonNorm(p0, p1, p2) }, dist{ -dot(n, p0) } {}<br>
        <br>
        &nbsp;&nbsp;&nbsp; ~Plane4() {}<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 平面を正規化する (平面の法線を単位ベクトル化する)<br>
        &nbsp;&nbsp;&nbsp; inline Plane4 normalized() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float mag = n.magnitude();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (mag &lt; 0.00001f) // ほぼ0ベクトルか？<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Plane4{ n / mag, dist / mag};<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 原点から一番近い平面上の点を求める 法線ベクトルにマイナス方向のdist(原点からの距離)を掛けることで原点から一番近い平面上の1点になる<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 nearestFromOrigin() { return n * -dist; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 平面 から 点point までの距離を求める<br>
        &nbsp;&nbsp;&nbsp; inline float distance(const Vector3&amp; point) const { return dot(n, point) + dist; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 位置はそのままに表裏をひっくり返す https://nekojara.city/unity-plane-struct<br>
        &nbsp;&nbsp;&nbsp; inline Plane4&amp; flip() { n = -n; dist = -dist; return *this; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 位置はそのままに表裏をひっくり返した平面を複製する(もとのPlane4はかわらない) https://nekojara.city/unity-plane-struct<br>
        &nbsp;&nbsp;&nbsp; inline Plane4 flipedCopy() { return Plane4(-n, -dist); }<br>
        <br>
        &nbsp;&nbsp;&nbsp; /*-----　演算子オーバーロード　-----*/<br>
        <br>
        &nbsp;&nbsp;&nbsp; // + 演算子のオペレータ<br>
        &nbsp;&nbsp;&nbsp; inline Plane4 operator + () const { return *this; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // - 逆向き平面 (法線ベクトルが逆向き)<br>
        &nbsp;&nbsp;&nbsp; inline Plane4 operator - () const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Plane4(-n, -dist);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; enum class Side<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; OnPlane, // 平面上にある<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; InterPlane, // 平面を横切る<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Front, // 平面から見て前面にある<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Behind, // 平面から見て背面にある<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 点point が平面上、前面、背面側のどこにあるかを返し、resultDistにはその距離を返す<br>
        &nbsp;&nbsp;&nbsp; inline Side pointSide(const Vector3&amp; point, float* resultDist = nullptr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float answerDist = this-&gt;distance(point); // 平面 から pointへの距離<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (resultDist != nullptr) *resultDist = answerDist; // 答え(距離)を返す<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (answerDist &gt; FLT_EPSILON) return Side::Front; // 平面の前面の側に点pointがある<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (answerDist &lt; FLT_EPSILON) return Side::Behind; // 平面の背面の側に点pointがある<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Side::OnPlane; // 点point が平面上にある<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 球(中心:center,半径:Radius) が 平面上、前面、背面側のどこにあるかを返し、resultDistにはその距離を返す<br>
        &nbsp;&nbsp;&nbsp; inline Side sphereSide(const Vector3&amp; center, const float Radius, float* resultDist = nullptr) const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float answerDist = distance(center); // 平面 から 球の中心:center の距離<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (resultDist != nullptr) *resultDist = answerDist; // 答え(距離)を返す<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float absDist = (answerDist &lt; 0) ? -answerDist : answerDist;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (absDist &lt; Radius) return Side::OnPlane; // 球 が平面上にある<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (answerDist &gt;= Radius)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Side::Front; // 平面の前面の側に 球 がある<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Side::Behind; // 平面の背面の側に 球 がある<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 法線から一番近い点(AABBの正の頂点)を求める https://edom18.hateblo.jp/entry/2017/10/29/112908<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 positivePoint_AABB(const Vector3&amp; boxMin, const Vector3&amp; boxMax) const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 result = boxMin;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 boxSize = boxMax - boxMin;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (n.x &gt; 0) result.x += boxSize.x;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (n.y &gt; 0) result.y += boxSize.y;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (n.z &gt; 0) result.z += boxSize.z;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return result;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 法線から一番近い点(AABBの正の頂点)から平面までの距離を返す https://edom18.hateblo.jp/entry/2017/10/29/112908<br>
        &nbsp;&nbsp;&nbsp; inline float positiveDistance_AABB(const Vector3&amp; boxMin, const Vector3&amp; boxMax) const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return distance(positivePoint_AABB(boxMin, boxMax));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 法線から一番遠い点(AABBの負の頂点)を求める https://edom18.hateblo.jp/entry/2017/10/29/112908<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 negativePoint_AABB(const Vector3&amp; boxMin, const Vector3&amp; boxMax) const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 result = boxMin;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 boxSize = boxMax - boxMin;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (n.x &lt; 0) result.x += boxSize.x;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (n.y &lt; 0) result.y += boxSize.y;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (n.z &lt; 0) result.z += boxSize.z;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return result;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 法線から一番遠い点(AABBの正の頂点)から平面までの距離を返す https://edom18.hateblo.jp/entry/2017/10/29/112908<br>
        &nbsp;&nbsp;&nbsp; inline float negativeDistance_AABB(const Vector3&amp; boxMin, const Vector3&amp; boxMax) const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return distance(negativePoint_AABB(boxMin, boxMax));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        <br>
        // 一致 == 演算子オペレータ 法線ベクトルnorm と 距離 distが一致する<br>
        inline bool operator == (const Plane4&amp; left, const Plane4&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; (left.n == right.n &amp;&amp; left.dist == right.dist);<br>
        }<br>
        <br>
        // 不一致 != 演算子オペレータ 法線ベクトルnorm か 距離 distが一致しない<br>
        inline bool operator != (const Plane4&amp; left, const Plane4&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left == right);<br>
        }<br>
        <br>
        // 平面 と ベクトルの内積 (平面の法線ベクトル と 他のベクトルの内積)<br>
        inline float dot(const Plane4&amp; plane, const Vector3&amp; rightVec)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return plane.nx * rightVec.x + plane.ny * rightVec.y + plane.nz * rightVec.z; //普通にx同士,y同士,z同士掛けるだけ<br>
        }<br>
        <br>
        // 線形補間する start:開始位置&nbsp; end:終了位置&nbsp; t = 補間の割合（start側が100%&nbsp; 0.0～1.0&nbsp; end側が100% でブレンド)<br>
        inline Plane4 lerp(const Plane4&amp; start, const Plane4&amp; end, float t)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Plane4 plane;<br>
        &nbsp;&nbsp;&nbsp; plane.n = start.n * (1.0f - t) + end.n * t; // startを始点に tの割合ぶんendへ近づける<br>
        &nbsp;&nbsp;&nbsp; plane.n = plane.n.normalized(); // 法線を単位ベクトル化(大きさ1)する<br>
        &nbsp;&nbsp;&nbsp; plane.dist = start.dist * (1.0f - t) + end.dist * t;<br>
        &nbsp;&nbsp;&nbsp; return plane;<br>
        }<br>
        <br>
        // 2次補間する start:開始位置 mid:中間制御点 end:終了位置&nbsp; t = 補間の割合（start側が100%&nbsp; 0.0～1.0&nbsp; end側が100% でブレンド)<br>
        inline Plane4 quadratic(const Plane4&amp; start, const Plane4&amp; mid, const Plane4&amp; end, float t)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Plane4 plane;<br>
        &nbsp;&nbsp;&nbsp; plane.n = start.n * (1.0f - t) * (1.0f - t) + 2 * mid.n * t * (1.0f - t) + end.n * t * t;<br>
        &nbsp;&nbsp;&nbsp; plane.n = plane.n.normalized(); // 法線を単位ベクトル化(大きさ1)する<br>
        &nbsp;&nbsp;&nbsp; plane.dist = start.dist * (1.0f - t) * (1.0f - t) + 2 * mid.dist * t * (1.0f - t) + end.dist * t * t;<br>
        &nbsp;&nbsp;&nbsp; return plane;<br>
        }<br>
        <br>
        #endif<br>
      </p>
      <br>
      そして、次はこのVector3.hとPlane4.hを駆使して、3D空間での当たり判定をする関数を定義するCollision3D.hを準備します。<br>
      <br>
      <p><code>Collision3D.hを新規作成</code>して球、円柱、カプセル、線、三角ポリゴン、平面などや光線(レイ)との当たり判定をするためのisCollision系関数群を準備します。</p>
      <p class="source">#ifndef COLLISION3D_H_<br>
        #define COLLISION3D_H_<br>
        <br>
        #include "Vector3.h"<br>
        #include "Plane4.h"<br>
        <br>
        //-------------- 球、円柱、線分(レイ)、カプセル、ポリゴンのエッジなどの当たり判定---------------------------<br>
        <br>
        // 軸並行境界ボックス同士 AABB 0 と AABB 1 の当たり判定 https://developer.mozilla.org/ja/docs/Games/Techniques/3D_collision_detection<br>
        inline bool isCollisionAABB_AABB(const Vector3&amp; boxMin0, const Vector3&amp; boxMax0, const Vector3&amp; boxMin1, const Vector3&amp; boxMax1)<br>
        {&nbsp;&nbsp; // min と maxを比べればよい<br>
        &nbsp;&nbsp;&nbsp; return boxMin0.x &lt;= boxMax1.x &amp;&amp; boxMax0.x &gt;= boxMin1.x &amp;&amp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boxMin0.y &lt;= boxMax0.y &amp;&amp; boxMax0.y &gt;= boxMin1.y &amp;&amp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boxMin0.z &lt;= boxMax1.z &amp;&amp; boxMax0.z &gt;= boxMin1.z;<br>
        }<br>
        <br>
        // 点:point と box:AABB(軸並行境界ボックス：Axis-Aligned Bounding Box)の当たり判定 http://marupeke296.com/COL_3D_No11_AABBvsPoint.html<br>
        inline bool isCollisionPoint_AABB(const Vector3&amp; point, const Vector3&amp; leftTop, const Vector3&amp; rightBottom)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return nearestLengthPoint_AABB(point, leftTop, rightBottom) &gt; 0; // 最短距離が0以上なら当たっている<br>
        }<br>
        <br>
        // 点:point と box:OBB(有向境界ボックス：Oriented Bounding Box)の当たり判定 result:OBB上の一番近い点を返す<br>
        inline bool isCollisionPoint_OBB(const Vector3&amp; point, <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Vector3&amp; centerOBB, const Vector3&amp; sizeOBB, const std::array&lt;Vector3, 3&gt;&amp; axisOBB,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3* result = nullptr)<br>
        {&nbsp;&nbsp; //[OBBと点の衝突判定] http://marupeke296.com/COL_3D_No12_OBBvsPoint.html<br>
        &nbsp;&nbsp;&nbsp; return sqrNearestLengthPoint_OBB(point, centerOBB, sizeOBB, axisOBB, result) &gt; 0; // 最短距離が0じゃなければ当たっている<br>
        }<br>
        <br>
        // 球体 と OBB(有向境界ボックス)の衝突判定<br>
        inline bool isCollisionSphere_OBB(const Vector3&amp; center0, float Radius0, <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Vector3&amp; centerOBB, const Vector3&amp; sizeOBB, const std::array&lt;Vector3, 3&gt;&amp; axisOBB)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 nearestOnOBB; // OBB上の一番近い点<br>
        &nbsp;&nbsp;&nbsp; overLengthPoint_OBB(center0, centerOBB, sizeOBB, axisOBB, &amp;nearestOnOBB);<br>
        &nbsp;&nbsp;&nbsp; // OBB上の一番近い点 と 半径の2乗を比べる http://distancevector.web.fc2.com/collision.html#OBBSphere<br>
        &nbsp;&nbsp;&nbsp; Vector3 dist = nearestOnOBB - center0;<br>
        &nbsp;&nbsp;&nbsp; return dot(dist, dist) &lt;= Radius0 * Radius0;<br>
        }<br>
        <br>
        // 光線:ray と box:AABB(軸並行境界ボックス：Axis-Aligned Bounding Box)の当たり判定 http://marupeke296.com/COL_3D_No18_LineAndAABB.html<br>
        inline bool isCollisionAABB_Ray(const Vector3&amp; boxMin, const Vector3&amp; boxMax,<br>
        &nbsp;&nbsp;&nbsp; const Vector3&amp; rayPos, const Vector3&amp; rayDir, Vector3* result = nullptr, float* result_t = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float _t; // 変数tの一時参照先<br>
        &nbsp;&nbsp;&nbsp; // result_tがnullptrじゃなければ&nbsp;&nbsp; ↓参照先&nbsp; : ↓nullptrなら<br>
        &nbsp;&nbsp;&nbsp; float&amp; t = (result_t != nullptr) ? *result_t : _t;<br>
        &nbsp;&nbsp;&nbsp; t = -FLT_MAX; // 初期値はfloat型の最小値からはじめる<br>
        &nbsp;&nbsp;&nbsp; float t_max = FLT_MAX; // 初期値はfloat型の最大値<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 交差判定<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // レイの方向ベクトルの絶対値がほぼ0のときは割り算の分母にできないので要チェック<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float absRayDir = (rayDir.xyz[i] &lt; 0) ? -rayDir.xyz[i] : rayDir.xyz[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (absRayDir &lt; FLT_EPSILON) // レイ方向の大きさがほぼ0なら<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // レイの始点がボックスの範囲外なら交差しない(レイ方向がほぼ0なので到達不可能)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rayPos.xyz[i] &lt; boxMin.xyz[i] || rayPos.xyz[i] &gt; boxMax.xyz[i])<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 交差していない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // スラブとの距離を算出<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // t1が近スラブ、t2が遠スラブとの距離<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t1 = (boxMin.xyz[i] - rayPos.xyz[i]) / rayDir.xyz[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t2 = (boxMax.xyz[i] - rayPos.xyz[i]) / rayDir.xyz[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (t1 &gt; t2) // t1のほうが大きければ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // t1とt2を入れ替えてから判定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float tmp = t1; t1 = t2; t2 = tmp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (t1 &gt; t) t = t1; // t1が現在のtより大きければtを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (t2 &lt; t_max) t_max = t2; // t2が現在のt_maxより小さければt_maxを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (t &gt;= t_max) // スラブ交差チェック (t のほうが t_max より大きいか)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 交差していない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result != nullptr) // resultがnullptrじゃなければ結果を代入して返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = rayPos + t * rayDir;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return (t &gt;= 0); // t &gt;=0 で rayDirのプラス方向に交差点があればtrue<br>
        }<br>
        <br>
        // 線分(有限):line0→1 と box:OBB(有向境界ボックス：Oriented Bounding Box)の当たり判定 http://distancevector.web.fc2.com/collision.html#OBBSphere<br>
        inline bool isCollisionOBB_Line(const Vector3&amp; centerOBB, const Vector3&amp; sizeOBB, const std::array&lt;Vector3, 3&gt;&amp; axisOBB,<br>
        &nbsp;&nbsp;&nbsp; const Vector3&amp; line0start, const Vector3&amp; line1End, Vector3* result = nullptr, float* result_t = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 mid = (line0start + line1End) * 0.5f; // 線分line0→1の中間点01<br>
        &nbsp;&nbsp;&nbsp; Vector3 end = line1End - mid; // 中間点01→line1Endのベクトル<br>
        &nbsp;&nbsp;&nbsp; mid = mid - centerOBB; // OBBの中心→中間点01<br>
        &nbsp;&nbsp;&nbsp; // OBBの3軸とのdotを取る<br>
        &nbsp;&nbsp;&nbsp; mid = Vector3{ dot(axisOBB[0], mid), dot(axisOBB[1], mid), dot(axisOBB[2], mid) };<br>
        &nbsp;&nbsp;&nbsp; end = Vector3{ dot(axisOBB[0], end), dot(axisOBB[1], end), dot(axisOBB[2], end) };<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector3 abs_end; // endの絶対値abs<br>
        &nbsp;&nbsp;&nbsp; abs_end.x = std::abs(end.x);<br>
        &nbsp;&nbsp;&nbsp; if (std::abs(mid.x) &gt; sizeOBB.x / 2 + abs_end.x) return false;<br>
        &nbsp;&nbsp;&nbsp; abs_end.y = std::abs(end.y);<br>
        &nbsp;&nbsp;&nbsp; if (std::abs(mid.y) &gt; sizeOBB.y / 2 + abs_end.y) return false;<br>
        &nbsp;&nbsp;&nbsp; abs_end.z = std::abs(end.z);<br>
        &nbsp;&nbsp;&nbsp; if (std::abs(mid.z) &gt; sizeOBB.z / 2 + abs_end.z) return false;<br>
        &nbsp;&nbsp;&nbsp; abs_end.x += FLT_EPSILON;<br>
        &nbsp;&nbsp;&nbsp; abs_end.y += FLT_EPSILON;<br>
        &nbsp;&nbsp;&nbsp; abs_end.z += FLT_EPSILON;<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (std::abs(mid.y * end.z - mid.z * end.y) &gt; sizeOBB.y * abs_end.z + sizeOBB.z * abs_end.y) return false;<br>
        &nbsp;&nbsp;&nbsp; if (std::abs(mid.z * end.x - mid.x * end.z) &gt; sizeOBB.x * abs_end.z + sizeOBB.z * abs_end.x) return false;<br>
        &nbsp;&nbsp;&nbsp; if (std::abs(mid.x * end.y - mid.y * end.x) &gt; sizeOBB.x * abs_end.y + sizeOBB.y * abs_end.x) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return true;<br>
        }<br>
        <br>
        <br>
        // 球体と球体の衝突判定<br>
        inline bool isCollisionSphere_Sphere(const Vector3&amp; center0, float Radius0, const Vector3&amp; center1, float Radius1)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return (center1 - center0).sqrMagnitude() &lt;= (Radius0 + Radius1) * (Radius0 + Radius1);<br>
        }<br>
        <br>
        // 2つの球0(速度:v0)と球1(速度:v1)の衝突までの時間と位置を取得(双方の球は指定のベクトル方向に等速で進む場合)<br>
        // stepTime : 球0,球1が進む時間<br>
        // resultTime : 衝突時刻&nbsp; resultPos : 衝突位置（接点）<br>
        // resultCenter0,1 : 衝突時の球0,球1の中心座標<br>
        inline bool isCollisionSphere_Sphere_At(float stepTime,<br>
        &nbsp;&nbsp;&nbsp; const Vector3&amp; center0, const float radius0, const Vector3&amp; v0,<br>
        &nbsp;&nbsp;&nbsp; const Vector3&amp; center1, const float radius1, const Vector3&amp; v1,<br>
        &nbsp;&nbsp;&nbsp; float&amp; resultTime, Vector3&amp; resultPos,<br>
        &nbsp;&nbsp;&nbsp; Vector3* resultCenter0 = nullptr, Vector3* resultCenter1 = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // http://marupeke296.com/COL_3D_No9_GetSphereColliTimeAndPos.html<br>
        &nbsp;&nbsp;&nbsp; // 前位置及び到達位置におけるパーティクル間のベクトルを算出<br>
        &nbsp;&nbsp;&nbsp; Vector3 prev01 = center1 - center0;<br>
        &nbsp;&nbsp;&nbsp; Vector3 next01 = center1 + v1 * stepTime - center0 + v0 * stepTime;<br>
        &nbsp;&nbsp;&nbsp; Vector3 dif01 = next01 - prev01;<br>
        &nbsp;&nbsp;&nbsp; float radius01 = radius0 + radius1;<br>
        &nbsp;&nbsp;&nbsp; float radius01Sq = radius01 * radius01;<br>
        &nbsp;&nbsp;&nbsp; float dif01sqm = dif01.sqrMagnitude();<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (dif01sqm == 0) // 衝突判定に衝突検知の解の公式を使えない場合<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 初期段階 t = 0ですでに衝突しているか？<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((center1 - center0).sqrMagnitude() &gt; radius01Sq)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resultTime = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // resultCenterがnullptrじゃなければ、center0と1を答えとしてreturnする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (resultCenter0 != nullptr) *resultCenter0 = center0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (resultCenter1 != nullptr) *resultCenter1 = center1;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (center1 == center0) // 中心位置が一緒の場合は<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resultPos = center0; // 中心点を衝突点として返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp; // 球center0→center1のベクトル方向に長さradius0の所を衝突点とする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resultPos = center0 + (radius0 / radius01) * prev01;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // 同じ方向に移動<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; // else 衝突検知可能<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 最初から衝突しているか？<br>
        &nbsp;&nbsp;&nbsp; if ((center1 - center0).sqrMagnitude() &lt;= radius01Sq)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resultTime = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resultPos = center0 + radius0 / radius01 * prev01;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // resultCenterがnullptrじゃなければ、center0と1を答えとしてreturnする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (resultCenter0 != nullptr) *resultCenter0 = center0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (resultCenter1 != nullptr) *resultCenter1 = center1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; float Q = dot(prev01, dif01);<br>
        &nbsp;&nbsp;&nbsp; float prev01sqm = prev01.sqrMagnitude();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 衝突判定式<br>
        &nbsp;&nbsp;&nbsp; float judge = Q * Q - dif01sqm * (prev01sqm - radius01 * radius01);<br>
        &nbsp;&nbsp;&nbsp; if (judge &lt; 0) return false; // 衝突していない<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 衝突時間の算出<br>
        &nbsp;&nbsp;&nbsp; float judge_sqrt = std::sqrtf(judge);<br>
        &nbsp;&nbsp;&nbsp; float t_plus = (-Q + judge_sqrt) / dif01sqm;<br>
        &nbsp;&nbsp;&nbsp; float t_minus = (-Q - judge_sqrt) / dif01sqm;<br>
        &nbsp;&nbsp;&nbsp; if (t_minus &gt; t_plus)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // t_minusを小さい方に入れ替え<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float tmp = t_minus;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t_minus = t_plus;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t_plus = tmp;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 時間外衝突か？<br>
        &nbsp;&nbsp;&nbsp; if (t_minus &lt; 0.0f || t_minus &gt; 1.0f) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 衝突位置の決定<br>
        &nbsp;&nbsp;&nbsp; resultTime = t_minus * stepTime;<br>
        &nbsp;&nbsp;&nbsp; Vector3 answer0 = center0 + v0 * stepTime * t_minus;<br>
        &nbsp;&nbsp;&nbsp; Vector3 answer1 = center1 + v1 * stepTime * t_minus;<br>
        &nbsp;&nbsp;&nbsp; resultPos = answer0 + radius0 / radius01 * (answer1 - answer0);<br>
        &nbsp;&nbsp;&nbsp; // resultCenterがnullptrじゃなければ、answer0と1を答えとしてreturnする<br>
        &nbsp;&nbsp;&nbsp; if (resultCenter0 != nullptr) *resultCenter0 = answer0;<br>
        &nbsp;&nbsp;&nbsp; if (resultCenter1 != nullptr) *resultCenter1 = answer1;<br>
        &nbsp;&nbsp;&nbsp; return true; // 衝突した<br>
        }<br>
        <br>
        // 衝突してtime時刻経過後の 球0,1(衝突時速度:v0,1 質量:weight0,1 反発係数:refRate0,1)の<br>
        // 反発後の位置result_center と 速度result_v を求める<br>
        inline bool getCollisionPosVecSphere_Sphere_After(float time,<br>
        &nbsp;&nbsp;&nbsp; const Vector3&amp; center0, const Vector3&amp; v0, float weight0, float refRate0,<br>
        &nbsp;&nbsp;&nbsp; const Vector3&amp; center1, const Vector3&amp; v1, float weight1, float refRate1,<br>
        &nbsp;&nbsp;&nbsp; Vector3* result_center0 = nullptr, Vector3* result_v0 = nullptr,<br>
        &nbsp;&nbsp;&nbsp; Vector3* result_center1 = nullptr, Vector3* result_v1 = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // http://marupeke296.com/COL_MV_No1_HowToCalcVelocity.html<br>
        &nbsp;&nbsp;&nbsp; float totalWeight = weight0 + weight1; // 質量の合計<br>
        &nbsp;&nbsp;&nbsp; float refRate = (1 + refRate0 * refRate1); // 反発率<br>
        &nbsp;&nbsp;&nbsp; Vector3 c01 = center1 - center0; // 衝突軸ベクトル<br>
        &nbsp;&nbsp;&nbsp; c01 = c01.normalized();<br>
        &nbsp;&nbsp;&nbsp; float dot_v10_c01 = dot((v0 - v1), c01); // 内積算出<br>
        &nbsp;&nbsp;&nbsp; const Vector3 ConstVec = refRate * dot_v10_c01 / totalWeight * c01; // 反発定数ベクトル<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 衝突後速度ベクトルの算出<br>
        &nbsp;&nbsp;&nbsp; Vector3 answer_v0 = -weight1 * ConstVec + v0;<br>
        &nbsp;&nbsp;&nbsp; Vector3 answer_v1 =&nbsp; weight0 * ConstVec + v1;<br>
        &nbsp;&nbsp;&nbsp; if (result_v0 != nullptr) *result_v0 = answer_v0;<br>
        &nbsp;&nbsp;&nbsp; if (result_v1 != nullptr) *result_v1 = answer_v1;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 衝突後位置の算出<br>
        &nbsp;&nbsp;&nbsp; Vector3 answer_center0 = center0 + time * answer_v0;<br>
        &nbsp;&nbsp;&nbsp; Vector3 answer_center1 = center1 + time * answer_v1;<br>
        &nbsp;&nbsp;&nbsp; if (result_center0 != nullptr) *result_center0 = answer_center0;<br>
        &nbsp;&nbsp;&nbsp; if (result_center1 != nullptr) *result_center1 = answer_center1;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return true;<br>
        }<br>
        <br>
        // 球体とレイ(光線)の当たり判定 rayPos:レイの起点 rayDir:レイの方向 result0:球体とレイの衝突開始点 result1:球体とレイの衝突終了点 <br>
        inline bool isCollisionSphere_Ray(const Vector3&amp; center, float Radius, const Vector3&amp; rayPos, const Vector3&amp; rayDir, Vector3* result0 = nullptr, Vector3* result1 = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; centerToRayPos = rayPos - center; // 球体の中心からレイの起点までを結ぶベクトル<br>
        &nbsp;&nbsp;&nbsp; // 球体とレイの交差判定を行う<br>
        &nbsp;&nbsp;&nbsp; float rayDistSq = rayDir.sqrMagnitude(); // レイの方向ベクトル大きさの2乗<br>
        &nbsp;&nbsp;&nbsp; float rayDirDot = dot(centerToRayPos, rayDir); // レイと球の中心を結ぶ線とレイの方向の内積(レイの方向へ直角に下したベクトル)<br>
        &nbsp;&nbsp;&nbsp; float rayToSphereSq = centerToRayPos.sqrMagnitude() - Radius * Radius; // レイ起点から球の表面までの距離の2乗<br>
        &nbsp;&nbsp;&nbsp; float dif = rayDirDot * rayDirDot - rayDistSq * rayToSphereSq;<br>
        &nbsp;&nbsp;&nbsp; if (dif &lt; 0.0f) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp; float sqrt_dif = std::sqrt(dif);<br>
        &nbsp;&nbsp;&nbsp; float t0 = (-rayDirDot - sqrt_dif) / rayDistSq; // 交点までt0倍のばせば球体とレイの衝突開始点になる<br>
        &nbsp;&nbsp;&nbsp; float t1 = (-rayDirDot + sqrt_dif) / rayDistSq; // 交点までt1倍のばせば球体とレイの衝突終了点になる<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; // t0の位置のほうがレイの起点から近くなり、rayDirのプラス方向の点がt0になるようにt0とt1を入れ替え<br>
        &nbsp;&nbsp;&nbsp; if (t0 &gt;= 0 &amp;&amp; t1 &gt;= 0 &amp;&amp; t1 &lt; t0 || t0 &lt; 0 &amp;&amp; t1 &gt;= 0 || t0 &lt; 0 &amp;&amp; t1 &lt; 0 &amp;&amp; t0 &lt; t1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // tmpに一時的にt1を保管して t0 と t1を入れ替え<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float tmp = t1; t1 = t0; t0 = tmp;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result0 != nullptr) // resultがnullptrじゃないときには球体とレイの交点も求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result0 = rayDir * t0 + rayPos; // レイの方向をt0倍のばして球体との交点の位置を求める<br>
        &nbsp;&nbsp;&nbsp; if (result1 != nullptr) // resultがnullptrじゃないときには球体とレイの交点も求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result1 = rayDir * t1 + rayPos; // レイの方向をt1倍のばして球体との交点の位置を求める<br>
        <br>
        &nbsp;&nbsp;&nbsp; return (t0 &gt;= 0) || (t1 &gt;= 0); // rayDirのプラス方向に衝突点があるならtrue<br>
        }<br>
        <br>
        // 無限円柱(シリンダー)がレイ(起点:rayPos 方向ベクトル:rayDir)と衝突するか? result0:円柱とレイが衝突した貫通開始点&nbsp; result1:円柱とレイが衝突した貫通終了点 <br>
        inline bool isCollisionCilinderInf_Ray(const Vector3&amp; cilinderStart, const Vector3&amp; cilinderEnd, float cilinderRadius, const Vector3&amp; rayPos, const Vector3&amp; rayDir, Vector3* result0 = nullptr, Vector3* result1 = nullptr)<br>
        {&nbsp;&nbsp; //[円柱とレイの当たり判定] http://marupeke296.com/COL_3D_No25_RayToSilinder.html<br>
        &nbsp;&nbsp;&nbsp; Vector3 p1 = cilinderStart - rayPos; // レイの起点からシリンダーの 始点 に向かうベクトル<br>
        &nbsp;&nbsp;&nbsp; //Vector3 p2 = cilinderEnd - rayPos; // レイの起点からシリンダーの 終点 に向かうベクトル<br>
        &nbsp;&nbsp;&nbsp; Vector3 s = cilinderEnd - cilinderStart; // シリンダーの軸に沿うベクトル<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 各種内積値 v = rayDirとして考える<br>
        &nbsp;&nbsp;&nbsp; float Dvv = rayDir.sqrMagnitude();<br>
        &nbsp;&nbsp;&nbsp; float Dsv = dot(s, rayDir);<br>
        &nbsp;&nbsp;&nbsp; float Dpv = dot(p1, rayDir);<br>
        &nbsp;&nbsp;&nbsp; float Dss = s.sqrMagnitude();<br>
        &nbsp;&nbsp;&nbsp; float Dps = dot(p1, s);<br>
        &nbsp;&nbsp;&nbsp; float Dpp = p1.sqrMagnitude();<br>
        &nbsp;&nbsp;&nbsp; float rr = cilinderRadius * cilinderRadius;<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (Dss == 0.0f) return false; // 円柱が定義されない<br>
        <br>
        &nbsp;&nbsp;&nbsp; float A = Dvv - Dsv * Dsv / Dss;<br>
        &nbsp;&nbsp;&nbsp; float B = Dpv - Dps * Dsv / Dss;<br>
        &nbsp;&nbsp;&nbsp; float C = Dpp - Dps * Dps / Dss - rr;<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (A == 0.0f) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp; float d = B * B - A * C;<br>
        &nbsp;&nbsp;&nbsp; if (d &lt; 0.0f) return false; // レイが円柱と衝突していない<br>
        &nbsp;&nbsp;&nbsp; d = std::sqrtf(d);<br>
        <br>
        &nbsp;&nbsp;&nbsp; float t0 = (B - d) / A;<br>
        &nbsp;&nbsp;&nbsp; float t1 = (B + d) / A;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // t0の位置のほうがレイの起点から近くなり、rayDirのプラス方向の点がt0になるようにt0とt1を入れ替え<br>
        &nbsp;&nbsp;&nbsp; if (t0 &gt;= 0 &amp;&amp; t1 &gt;= 0 &amp;&amp; t1 &lt; t0 || t0 &lt; 0 &amp;&amp; t1 &gt;= 0 || t0 &lt; 0 &amp;&amp; t1 &lt; 0 &amp;&amp; t0 &lt; t1)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // tmpに一時的にt1を保管して t0 と t1を入れ替え<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float tmp = t1; t1 = t0; t0 = tmp;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result0 != nullptr) // resultがnullptrじゃないときにはシリンダとレイの交点も求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result0 = rayDir * t0 + rayPos; // レイの方向をt0倍のばしてシリンダとの交点の位置を求める<br>
        &nbsp;&nbsp;&nbsp; if (result1 != nullptr) // resultがnullptrじゃないときには球体とシリンダの交点も求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result1 = rayDir * t1 + rayPos; // レイの方向をt1倍のばしてシリンダとの交点の位置を求める<br>
        <br>
        &nbsp;&nbsp;&nbsp; return (t0 &gt;= 0) || (t1 &gt;= 0); // rayDirのプラス方向に衝突点があるならtrue<br>
        }<br>
        <br>
        // カプセルがレイ(起点:rayPos 方向ベクトル:rayDir)と衝突するか? result0:カプセルとレイが衝突した貫通開始点&nbsp; result1:カプセルとレイが衝突した貫通終了点 <br>
        inline bool isCollisionCapsule_Ray(const Vector3&amp; capsuleStart0, const Vector3&amp; capsuleEnd1, float capsuleRadius,<br>
        &nbsp;&nbsp;&nbsp; const Vector3&amp; rayPos, const Vector3&amp; rayDir, Vector3* result0 = nullptr, Vector3* result1 = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; //[カプセルとレイの当たり判定] http://marupeke296.com/COL_3D_No26_RayToCapsule.html<br>
        &nbsp;&nbsp;&nbsp; bool result0inSphere0 = false;<br>
        &nbsp;&nbsp;&nbsp; bool result0inSphere1 = false;<br>
        &nbsp;&nbsp;&nbsp; bool result0inCilinder01 = false;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // Q1の検査<br>
        &nbsp;&nbsp;&nbsp; if (isCollisionSphere_Ray(capsuleStart0, capsuleRadius, rayPos, rayDir, result0, result1) &amp;&amp; dot(capsuleEnd1 - capsuleStart0, *result0 - capsuleStart0) &lt;= 0.0f)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result0inSphere0 = true; // result0は球面上(capsuleStart0が中心の球)にある<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (isCollisionSphere_Ray(capsuleEnd1, capsuleRadius, rayPos, rayDir, result0, result1) &amp;&amp; dot(capsuleStart0 - capsuleEnd1, *result0 - capsuleEnd1) &lt;= 0.0f)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result0inSphere1 = true; // result0は球面上(capsuleEnd1が中心の球)にある<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (isCollisionCilinderInf_Ray(capsuleStart0, capsuleEnd1, capsuleRadius, rayPos, rayDir, result0, result1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; dot(capsuleEnd1 - capsuleStart0, *result0 - capsuleStart0) &gt; 0.0f<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; dot(capsuleStart0 - capsuleEnd1, *result0 - capsuleEnd1) &gt; 0.0f)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result0inCilinder01 = true; // result0は円柱面にある<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // レイは衝突していない<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result1 != nullptr)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // result1の検査<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float tx, ty, tz; // ダミー<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0inSphere0 &amp;&amp; dot(capsuleEnd1 - capsuleStart0, *result1 - capsuleStart0) &lt;= 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // result0、result1 両方 球面上(capsuleStart0が中心の球)にある<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (result0inSphere1 &amp;&amp; dot(capsuleStart0 - capsuleEnd1, *result1 - capsuleEnd1) &lt;= 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // result0、result1 両方 球面上(capsuleEnd1が中心の球)にある<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (result0inCilinder01<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; dot(capsuleEnd1 - capsuleStart0, *result1 - capsuleStart0) &gt; 0.0f<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; dot(capsuleStart0 - capsuleEnd1, *result1 - capsuleEnd1) &gt; 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // result0、result1 両方 円柱面にある<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionSphere_Ray(capsuleStart0, capsuleRadius, rayPos, rayDir, nullptr, result1) &amp;&amp; dot(capsuleEnd1 - capsuleStart0, *result1 - capsuleStart0) &lt;= 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // result1 は 球面上(capsulStart0が中心の球)にある<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionSphere_Ray(capsuleEnd1, capsuleRadius, rayPos, rayDir, nullptr, result1) &amp;&amp; dot(capsuleStart0 - capsuleEnd1, *result1 - capsuleEnd1) &lt;= 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // result1 は 球面上(capsuleEnd1が中心の球)にある<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // result1 が円柱上にある事が確定したのでresult1を計算<br>
        &nbsp;&nbsp;&nbsp; isCollisionCilinderInf_Ray(capsuleStart0, capsuleEnd1, capsuleRadius, rayPos, rayDir, nullptr, result1);<br>
        &nbsp;&nbsp;&nbsp; return true; // result1 が円柱上にある<br>
        }<br>
        <br>
        <br>
        // 球体と有限の線分との当たり判定 lineStart:線の起点 lineEnd:線の終点 result:球体と線分の交点<br>
        inline bool isCollisionSphere_Line(const Vector3&amp; center, float Radius, <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Vector3&amp; lineStart, const Vector3&amp; lineEnd, Vector3* result0 = nullptr, Vector3* result1 = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; lineVec = lineEnd - lineStart; // endからstartを引いて有限の線分のベクトルを求める<br>
        &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; nearestPoint = nearestPointOnLine(center, lineStart, lineVec, false); // 点center から一番近い直線lineVec上の点を求める<br>
        <br>
        &nbsp;&nbsp;&nbsp; float distSq = (center - nearestPoint).sqrMagnitude(); // 球体の中心と lineVec線上 の一番近い点の距離の2乗を求める<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (distSq &gt; Radius * Radius) return false; // 距離の2乗が球体の半径の2乗よりも長い場合は球と線は衝突していない<br>
        &nbsp;&nbsp;&nbsp; // ↑有限の線なので半径との距離を比べてしまえばあとは 球体とレイ(無限の線)の判定と変わらない<br>
        &nbsp;&nbsp;&nbsp; return isCollisionSphere_Ray(center, Radius, lineStart, lineVec.normalized(), result0, result1); // 球体とレイ(光線)の当たり判定<br>
        }<br>
        <br>
        // 線分line0 と 線分line1 の当たり判定 isInfinite:無限の長さの線かどうか epsilon:判定の精度 result0:line0上の最も近い点 result1:line1上の最も近い点 <br>
        inline bool isCollisionLine_Line(const Vector3&amp; line0Start, const Vector3&amp; line0End, const Vector3&amp; line1Start, const Vector3&amp; line1End,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isInfinite = false, float epsilon = 0.001f, Vector3* result0 = nullptr, Vector3* result1 = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float t0, t1;<br>
        &nbsp;&nbsp;&nbsp; Vector3 answer0, answer1; // answer0:line0上の最も近い点 answer1:line1上の最も近い点<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector3 v0 = line0End - line0Start; // line0 のベクトル<br>
        &nbsp;&nbsp;&nbsp; Vector3 v1 = line1End - line1Start; // line1 のベクトル<br>
        &nbsp;&nbsp;&nbsp; float lengthSq0 = v0.sqrMagnitude(); // ベクトルの大きさ(長さ)の2乗<br>
        &nbsp;&nbsp;&nbsp; float lengthSq1 = v1.sqrMagnitude(); // ベクトルの大きさ(長さ)の2乗<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (lengthSq0 &lt; FLT_EPSILON) // 線分のベクトルの長さがほぼ0なら 実質、点line0Start と 線line1 との当たり判定でよい<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer0 = line0Start; // line0の起点が一番近い<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer1 = nearestPointOnLine(line0Start, line1Start, v1, isInfinite); // 点line0Start から一番近い直線line1上の点を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (lengthSq1 &lt; FLT_EPSILON)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer1 = line1Start; // line1の起点が一番近い<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer0 = nearestPointOnLine(line1Start, line0Start, v0, isInfinite); // 点line1Start から一番近い直線line0上の点を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else // line0 と line1 の大きさが 0 よりは充分に大きい なら 線どうしの当たり判定とみなして計算してもよい<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[参考動画:直線と直線の最短距離] https://youtu.be/b3fwHCKkro0?t=196<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // この動画の式を変形して dif01判定を事前分離し 0 での割り算を回避<br>
        #if 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dv0v1 = -dot(v0, v1);// = dot(v0, -v1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dv1v1 = lengthSq1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dv0v0 = lengthSq0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; v01 = line1Start - line0Start;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _t1 = (dv0v1 * dot(v0, v01) - dv0v0 * dot(v1, v01)) / (dv1v1 * dv0v0 - dv0v1 * dv1v0);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (dv1v0 * dot(v0, v01) - lengthSq0 * dot(v1, v01)) / (lengthSq1 * lengthSq0 - dv0v1 * dv0v1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _dif01 = lengthSq0 * lengthSq1 - dv0v1 * dv0v1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _dot_v0v01 = -dot(v0, v01); // = dot(v0, -v01);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _dot_v1v01 = dot(v1, v01); // = -dot(v1, -v01);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float ___t1 = (dv0v1 * dot(v0, -v01) - lengthSq0 * dot(v1, -v01)) / dif01;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (-dv0v1 * _dot_v1v01 + lengthSq0 * _dot_v1v01) / dif01;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _t0 = dot(v0, (line1Start + (-v1) * t1 - line0Start)) / lengthSq0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = dot(v0, (v01 - v1 * t1)) / lengthSq0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (dot_v0v01 - dot_v0v1 * t1) / lengthSq0; // ムズイけど出た<br>
        #endif<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dot_v0v1 = -dot(v0, v1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // aとbが同じ向きで平行なら |a||b| - a・b = 0に近づく https://www.nekonecode.com/math-lab/pages/collision2/point-and-segment/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dif01 = lengthSq0 * lengthSq1 - dot_v0v1 * dot_v0v1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float absDif01 = (dif01 &lt; 0) ? -dif01 : dif01; // dif01の絶対値<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (absDif01 &lt; FLT_EPSILON) // 線が交差しないとき(最小誤差ε以内のとき)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 交差しない線どうしの最も近い点を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearestPointOfParallelLine(line0Start, line0End, line1Start, line1End, isInfinite, &amp;answer0, &amp;answer1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入して関数の外に返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // 線が交差するとき(最小誤差εを超えるとき)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 交差する線分の同士の最も近い点を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; v01 = line1Start - line0Start;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dot_v0v01 = dot(v0, v01);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dot_v1v01 = -dot(v1, v01);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = (lengthSq0 * dot_v1v01 - dot_v0v01 * dot_v0v1) / dif01;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = (dot_v0v01 - dot_v0v1 * t1) / lengthSq0;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer0 = v0 * t0 + line0Start; // v0の方向をt0倍のばして一番近い直線上の点の位置を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer1 = v1 * t1 + line1Start; // v1の方向をt1倍のばして一番近い直線上の点の位置を求める<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 有限の線の場合で、線を超えた位置(0～1.0の範囲外)に最も近い点が見つかった場合<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((isInfinite == false) &amp;&amp; (t0 &lt; 0.0f || 1.0f &lt; t0 || t1 &lt; 0.0f || 1.0f &lt; t1))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 線分line0 と 線分line1 の【有限の線上範囲内】での一番近い点を求めなおす(0～1の範囲内に収まるもっとも近い点を求めなおす) <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearestPointsOnFiniteLines(line0Start, line0End, line1Start, line1End, t0, t1, answer0, answer1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入して関数の外に返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 最も近い点どうしの距離の2乗 が epsilon(精度の2乗) 以下なら線どうしは衝突と判定<br>
        &nbsp;&nbsp;&nbsp; if ((answer1 - answer0).sqrMagnitude() &lt;= epsilon * epsilon) return true;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; false;<br>
        }<br>
        <br>
        // カプセル0 capsule0 と カプセル1 capsule1 の当たり判定 result0:カプセル0の芯line0線上のline1に最も近い点 result1:カプセル1の芯line1線上のline0に最も近い点 <br>
        inline bool isCollisionCapsule_Capsule(const Vector3&amp; capsule0Start, const Vector3&amp; capsule0End, float capsule0Radius,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Vector3&amp; capsule1Start, const Vector3&amp; capsule1End, float capsule1Radius,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3* result0 = nullptr, Vector3* result1 = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 nearest0;<br>
        &nbsp;&nbsp;&nbsp; Vector3 nearest1;<br>
        &nbsp;&nbsp;&nbsp; // カプセルどうしの当たり判定は、実質、線(有限)どうしの当たり判定(線の 距離epsilon が カプセル0半径 + カプセル1半径↓)<br>
        &nbsp;&nbsp;&nbsp; bool isCollision = isCollisionLine_Line(capsule0Start, capsule0End, capsule1Start, capsule1End, false, capsule0Radius + capsule1Radius, &amp;nearest0, &amp;nearest1);&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; // カプセル軸上の最短距離をむすぶ 法線ベクトル:norm と 距離:mag を求める<br>
        &nbsp;&nbsp;&nbsp; Vector3 v01 = nearest1 - nearest0; // 最短距離の2点 nearest0 から nearest1 へ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp; float mag01 = v01.magnitude(); // nearest0とnearest1の距離<br>
        &nbsp;&nbsp;&nbsp; Vector3 norm01 = v01.normalized(); // 正規化normalizeする<br>
        &nbsp;&nbsp;&nbsp; if (mag01 == 0.0f) // カプセルの軸が交差しているときはnearest0とnearest1が同じ点になっちゃう<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 center0 = (capsule0Start + capsule0End) / 2.0f; // カプセル0の中心点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 center1 = (capsule1Start + capsule1End) / 2.0f; // カプセル1の中心点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; norm01 = (center1 - center0).normalized(); // 中心同士の差ベクトルを法線に<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (center0 == center1) // 中心位置が完全一致するときは<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; norm01 = Vector3{ 1.0f,0.0f,0.0f }; // 仕方ないからx軸方向に引き離す(2DでもつじつまあうようにX軸で)<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector3 answer0 = nearest0 + norm01 * capsule0Radius; // nearest0からnearest1の方向へ、カプセル半径0の半径 進んだ位置が衝突点<br>
        &nbsp;&nbsp;&nbsp; Vector3 answer1 = nearest1 - norm01 * capsule1Radius; // nearest1からnearest0の方向へ、カプセル半径1の半径 進んだ位置が衝突点<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0;<br>
        &nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp; return isCollision;<br>
        }<br>
        <br>
        // point がポリゴンpPolygonの内側にあるか判定 numVertices:ポリゴンの頂点の数 percent:99% の精度でポリゴンの内部<br>
        inline bool isInsidePolygon(const Vector3&amp; point, const Vector3* pPoly, unsigned int numVertices, float percent = 0.99f)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float cos_theta, length1, length2;<br>
        &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; v1, v2;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ポリゴンの各頂点とpPointとの間の角度の合計が2πに近ければpPointはポリゴンの内部にある<br>
        &nbsp;&nbsp;&nbsp; float angle = 0.0f;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; numVertices; i++)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v1 = pPoly[i] - point; // pointとi番目のポリゴンの頂点を結ぶベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v2 = pPoly[(i + 1) % numVertices] - point; // pPointとi+1番目の頂点を結ぶベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length1 = v1.magnitude();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length2 = v2.magnitude();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点と交点の距離が 0.0001f以下ならポリゴンの内部と判定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (length1 &lt; 0.0001f || length2 &lt; 0.0001f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; true;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 二つのベクトルのあいだのcosθ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos_theta = dot(v1, v2) / (length1 * length2);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 角度の合計を足して合計を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle += std::acos(GET_CLAMP(cos_theta, -1.0f, 1.0f));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; constexpr float pi2 = 2 * 3.14159265359; // 2π = 360°<br>
        &nbsp;&nbsp;&nbsp; if (angle &gt;= percent * pi2) return true; // 角度の合計が 2π×0.99f 以上ならばポリゴンの内部判定<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; false;<br>
        }<br>
        <br>
        // ポリゴン pPolyのエッジ と 球(中心:center 半径:Radius) が当たっているか? result0:ポリゴンに当たらない位置へ球を押し戻すベクトル<br>
        inline bool isCollisionPolyEdge_Sphere(const Vector3* pPoly, int numVertices, const Vector3&amp; center, float Radius, Vector3* result0 = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; numVertices; i++) // 全てのポリゴンの点について調べる<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 球体の中心座標とポリゴンを結ぶ線分上の最も近い座標を求める */<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 polyEdgeVec = pPoly[(i + 1) % numVertices] - pPoly[i]; // ポリゴンの2点をつなぐ線(エッジ)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 nearest = nearestPointOnLine(center, pPoly[i], polyEdgeVec, false); // 球の中心から最も近いポリゴン線上の 点nearset<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 線分上の座標と球体の中心座標の距離を求める */<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float nearestDistSq = (nearest - center).sqrMagnitude(); // 球の中心 から 点nearset までの距離の2乗<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 球体から 1番近いポリゴン線上の点 と 球体中心 の距離 が球の半径以下なら当たっている<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nearestDistSq &lt; Radius * Radius)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ポリゴンと球体とが当たっているときは result0に ポリゴンに当たらないように球体を 押し戻すベクトル を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != NULL) // 一番近い点から球中心へのベクトルを norm(単位化) して それを (半径 - 半径から一番近い点)倍すればあたらない位置になる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result0 = (center - nearest).normalized() * (Radius - std::sqrt(nearestDistSq));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; true; // 当たっている<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; return false; // 当たっていない<br>
        }<br>
        <br>
        <br>
        //-------------- 平面に関する当たり判定---------------------------<br>
        <br>
        // 平面plane と 球(中心:center 半径:Radius)が衝突するか result:平面から球を押し戻した距離<br>
        inline bool isCollisionPlane_Sphere(const Plane4&amp; plane, <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Vector3&amp; center, float Radius, float* resultDist = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float dist = plane.distance(center); // 平面と球の中心の距離<br>
        &nbsp;&nbsp;&nbsp; float abs_dist = (dist &lt; 0) ? -dist : dist; // 平面との距離の絶対値<br>
        &nbsp;&nbsp;&nbsp; if (resultDist != nullptr) *resultDist = Radius - dist; // 半径 - 平面との距離をresultDistで返す<br>
        &nbsp;&nbsp;&nbsp; return (abs_dist &lt;= Radius); // 平面との距離が 半径以下なら当たっている:true<br>
        }<br>
        <br>
        // 球(移動prev0→next1)が平面と衝突する時刻result_timeと位置result_posを求める<br>
        inline bool isCollisionPlane_Sphere_At(const Plane4&amp; plane, //const Vector3&amp; posOnPlane,<br>
        &nbsp;&nbsp;&nbsp; const Vector3&amp; prevCenter0, const Vector3&amp; nextCenter1, float radius,<br>
        &nbsp;&nbsp;&nbsp; float* result_time = nullptr, Vector3* result_pos = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // http://marupeke296.com/COL_MV_No2_SpherePlaneColliTimePos.html<br>
        &nbsp;&nbsp;&nbsp; //Vector3 C0 = prevCenter0 - posOnPlane; // 平面上の一点から現在位置へのベクトル<br>
        &nbsp;&nbsp;&nbsp; Vector3 v01 = nextCenter1 - prevCenter0; // 現在位置から予定位置までのベクトル<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 平面と中心点の距離を算出<br>
        &nbsp;&nbsp;&nbsp; //float Dot_C0 = dot(C0, plane.n);<br>
        &nbsp;&nbsp;&nbsp; float dist0 = plane.distance(prevCenter0);<br>
        &nbsp;&nbsp;&nbsp; float abs_dist0 = std::fabs(dist0);<br>
        &nbsp;&nbsp;&nbsp; // 進行方向v01と法線nの関係をチェックするためdotを取る<br>
        &nbsp;&nbsp;&nbsp; float dot_v01_n = dot(v01, plane.n);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 平面と平行に移動しながらめり込んでいる特殊なケース<br>
        &nbsp;&nbsp;&nbsp; if ((0.00001f - std::fabs(dot_v01_n) &gt; 0.0f) &amp;&amp; (abs_dist0 &lt; radius))<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 永遠にめり込みから抜け出せないので最大時刻を返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result_time != nullptr) *result_time = FLT_MAX;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 衝突位置は仕方ないので今の位置をresultとしてreturnする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result_pos != nullptr) *result_pos = prevCenter0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 交差時間の算出<br>
        &nbsp;&nbsp;&nbsp; float answer_time = (radius - dist0) / dot_v01_n;<br>
        &nbsp;&nbsp;&nbsp; if (result_time != nullptr) *result_time = answer_time;<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; // 衝突位置の算出<br>
        &nbsp;&nbsp;&nbsp; Vector3 answer_pos = prevCenter0 + answer_time * v01;<br>
        &nbsp;&nbsp;&nbsp; if (result_pos != nullptr) *result_pos = answer_pos;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // めり込んでいたら衝突として処理終了(距離が半径以下)<br>
        &nbsp;&nbsp;&nbsp; if (abs_dist0 &lt; radius) return true;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 平面の原点に向かう法線nに対して移動が逆向き(dotが0以上→cosθ&gt;=0)なら衝突しない<br>
        &nbsp;&nbsp;&nbsp; if (dot_v01_n &gt;= 0) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 時間が0～1の間にあれば衝突<br>
        &nbsp;&nbsp;&nbsp; if (0 &lt;= answer_time &amp;&amp; answer_time &lt;= 1) return true;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return false;<br>
        }<br>
        <br>
        // 平面plane(動いていない)に対する球0(反射率:refRate0)の反射後time時刻経過後の位置result_center0と速度result_v0を求める<br>
        inline bool getCollisionPosVecPlane_Sphere_After(float time, const Plane4&amp; plane,<br>
        &nbsp;&nbsp;&nbsp; const Vector3&amp; center0, const Vector3&amp; v0, float refRate0,<br>
        &nbsp;&nbsp;&nbsp; Vector3* result_center0, Vector3* result_v0)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 反射後速度を算出<br>
        &nbsp;&nbsp;&nbsp; Vector3 answer_v0 = v0 - (1 + refRate0) * dot(plane.n, v0) * plane.n;<br>
        &nbsp;&nbsp;&nbsp; if (result_v0 != nullptr) *result_v0 = answer_v0;<br>
        &nbsp;&nbsp;&nbsp; // 移動位置を計算<br>
        &nbsp;&nbsp;&nbsp; Vector3 answer_center0 = center0 + answer_v0 * time;<br>
        &nbsp;&nbsp;&nbsp; if (result_center0 != nullptr) *result_center0 = answer_center0;<br>
        &nbsp;&nbsp;&nbsp; return true;<br>
        }<br>
        <br>
        // 平面plane が AABB(軸並行境界ボックス) と 衝突するか result:平面からAABBを押し戻した距離<br>
        inline bool isCollisionPlane_AABB(const Plane4&amp; plane,<br>
        &nbsp;&nbsp;&nbsp; const Vector3&amp; boxMin, const Vector3&amp; boxMax, float* resultDist = nullptr)<br>
        {&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; //[平面とAABBの当たり判定] https://edom18.hateblo.jp/entry/2017/10/29/112908<br>
        &nbsp;&nbsp;&nbsp; float positiveDistance = plane.positiveDistance_AABB(boxMin, boxMax);<br>
        &nbsp;&nbsp;&nbsp; if (positiveDistance &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (resultDist != nullptr) *resultDist = -positiveDistance; // 平面までの距離の大きさを返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 平面の外側<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; float negativeDistance = plane.negativeDistance_AABB(boxMin, boxMax);<br>
        &nbsp;&nbsp;&nbsp; if (negativeDistance &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // negativeDistanceは0以下なのでマイナスをつけて+の大きさにして返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (resultDist != nullptr) *resultDist = -negativeDistance; // めり込んだ距離の大きさを返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // 平面を横切る<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (resultDist != nullptr) *resultDist = negativeDistance; // めり込んだ距離の大きさを返す<br>
        &nbsp;&nbsp;&nbsp; return false;<br>
        }<br>
        <br>
        // 平面plane が OBB(有向境界ボックス) と 衝突するか result:平面からOBBを押し戻した距離<br>
        inline bool isCollisionPlane_OBB(const Vector3&amp; planePos, const Plane4&amp; plane,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Vector3&amp; centerOBB, const Vector3&amp; sizeOBB, const std::array&lt;Vector3, 3&gt;&amp; axisOBB,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float* result = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 平面の法線に対するOBBの射影線の長さを算出 http://marupeke296.com/COL_3D_No14_OBBvsPlane.html<br>
        &nbsp;&nbsp;&nbsp; float r = 0.0f; // 近接距離<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r += std::abs(dot(axisOBB[i] * sizeOBB.xyz[i]/2, plane.n));<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 平面とOBBの距離を算出<br>
        &nbsp;&nbsp;&nbsp; float s = dot(centerOBB - planePos, plane.n);<br>
        &nbsp;&nbsp;&nbsp; float abs_s = (s &lt; 0) ? -s : s; // sの絶対値<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; if (result != nullptr)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 平面からの押し戻し距離を算出<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s &gt; 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = r - abs_s;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = r + abs_s;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 衝突判定<br>
        &nbsp;&nbsp;&nbsp; if (abs_s - r &lt; 0.0f) return true; // 衝突している<br>
        &nbsp;&nbsp;&nbsp; return false; // 衝突していない<br>
        }<br>
        <br>
        <br>
        // 平面plane が レイ(起点:rayPos 方向ベクトル:rayDir) と 衝突するか result:平面とレイが衝突した場合の交点<br>
        inline bool isCollisionPlane_Ray(const Plane4&amp; plane, const Vector3&amp; rayPos, const Vector3&amp; rayDir, Vector3* result = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 rayDirNorm = rayDir.normalized();<br>
        &nbsp;&nbsp;&nbsp; Vector3 planeRay = rayPos - (-plane.n * plane.dist); // planeの起点からレイの始点へのベクトル<br>
        &nbsp;&nbsp;&nbsp; float dot_Plane_RayNorm = dot(rayDirNorm, plane.n);<br>
        &nbsp;&nbsp;&nbsp; if (dot_Plane_RayNorm == 0.0f) return false; // dot が 0の場合は平面と直線が平行になるのでレイと平面は交差しない<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result != nullptr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t = -dot(planeRay, plane.n) / dot_Plane_RayNorm; //[tの式] https://knzw.tech/raytracing/?page_id=78<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer = rayDirNorm * t + rayPos; // t倍にレイの方向を延長して 平面との交点を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = answer;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return true;<br>
        }<br>
        <br>
        <br>
        // 平面 plane と 線(始点lineStart と 終点lineEnd を結ぶ線) が 接触するか<br>
        inline bool isCollisionPlane_Line(const Plane4&amp; plane, const Vector3&amp; lineStart, const Vector3&amp; lineEnd, Vector3* result = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 線の始点から平面までの距離 と 線の終点から平面までの距離 の符号が 両方+ または 両方- なら<br>
        &nbsp;&nbsp;&nbsp; if (plane.distance(lineStart) * plane.distance(lineEnd) &gt; 0)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 始点も終点も平面から見て 同じ サイドにあるので 線 と 平面はクロス しない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 始点と終点が平面から見て&nbsp; 逆&nbsp; サイドにあるので 線 と 平面はクロス する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面plane が レイ(起点:lineStart 方向ベクトル:lineEnd - lineStart) と 衝突するか<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return isCollisionPlane_Ray(plane, lineStart, lineEnd - lineStart, result); // resultに交点が求まる<br>
        &nbsp;&nbsp;&nbsp; }<br>
        }<br>
        <br>
        // 平面plane とカプセルの当たり判定 resultDist:押し戻し距離を返す<br>
        inline bool isCollisionPlane_Capsule(const Plane4&amp; plane,<br>
        &nbsp;&nbsp;&nbsp; const Vector3&amp; capsuleStart, const Vector3&amp; capsuleEnd, float capsuleRadius, float* resultDist = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float distStart = plane.distance(capsuleStart);<br>
        &nbsp;&nbsp;&nbsp; float absDistStart = (distStart &lt; 0) ? -distStart : distStart;<br>
        &nbsp;&nbsp;&nbsp; float distEnd = plane.distance(capsuleEnd);<br>
        &nbsp;&nbsp;&nbsp; float absDistEnd = (distEnd &lt; 0) ? -distEnd : distEnd;<br>
        &nbsp;&nbsp;&nbsp; // 線の始点から平面までの距離 と 線の終点から平面までの距離 の符号が 両方+ なら<br>
        &nbsp;&nbsp;&nbsp; if (distStart &gt; 0 &amp;&amp; distEnd &gt; 0)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 始点も終点も平面から見て法線の方向のサイドにあるので 線 と 平面はクロス しない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (resultDist != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *resultDist = (distStart &lt; distEnd) ? capsuleRadius - distStart<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : capsuleRadius - distEnd; // 半径 - 平面との距離をresultDistで返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // startとendのうち平面との距離が近いほうが 半径以下なら当たっている<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (distStart &lt; distEnd)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (distStart &lt;= capsuleRadius);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else return (distEnd &lt;= capsuleRadius);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; if (resultDist != nullptr) // startとendでめり込みの距離が大きいほうの距離を押し戻す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *resultDist = (distStart &gt; 0) ? capsuleRadius - distEnd<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (distEnd &gt; 0) ? capsuleRadius - distStart<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (distStart &lt; distEnd) ? capsuleRadius - distStart : capsuleRadius - distEnd;<br>
        &nbsp;&nbsp;&nbsp; return true;<br>
        }<br>
        <br>
        // 三角ポリゴン pPoly(頂点数:numVertices 平面:plane上に存在) が 線分(始点:lineStart 終点:lineEnd) と 交わるか result:ポリゴンと線分の交点<br>
        inline bool isCollisionPoly_Line(const Vector3* pPoly, unsigned int numVertices, const Plane4&amp; plane, const Vector3&amp; lineStart, const Vector3&amp; lineEnd, Vector3* result = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; answer; // 面と線分の交点<br>
        &nbsp;&nbsp;&nbsp; // 面と線分の交点をまず求める<br>
        &nbsp;&nbsp;&nbsp; if (isCollisionPlane_Line(plane, lineStart, lineEnd, &amp;answer) == false) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (isInsidePolygon(answer, pPoly, numVertices)) // 面と線の交わる交点 が ポリゴン内に存在する点なのかチェック<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result != nullptr) *result = answer; // result に こたえ(ポリゴンと線分の交点) を設定し返す<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // 交点がポリゴン内部にあった<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return false; // 面と線が交わらない&nbsp;&nbsp; もしくは&nbsp;&nbsp; 交わったとしても 交点がポリゴン内部になかった<br>
        }<br>
        <br>
        // 三角ポリゴン pPoly(頂点数:numVertices 平面:plane上に存在) が レイ(始点:rayPos 方向:rayDir) と 交わるか result:ポリゴンとレイの交点<br>
        inline bool isCollisionPoly_Ray(const Vector3* pPoly, unsigned int numVertices, const Plane4&amp; plane, const Vector3&amp; rayPos, const Vector3&amp; rayDir, Vector3* result = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; //[この他にも色んなレイとポリゴンの交差判定法はある] https://pheema.hatenablog.jp/entry/ray-triangle-intersection<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; answer; // 面と線分の交点<br>
        &nbsp;&nbsp;&nbsp; // 面とレイの交点をまず求める<br>
        &nbsp;&nbsp;&nbsp; if (isCollisionPlane_Ray(plane, rayPos, rayDir, &amp;answer) == false) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (isInsidePolygon(answer, pPoly, numVertices)) // 面と線の交わる交点 が ポリゴン内に存在する点なのかチェック<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result != nullptr) *result = answer; // result に こたえ(ポリゴンと線分の交点) を設定し返す<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // 交点がポリゴン内部にあった<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return false; // 面と線が交わらない&nbsp;&nbsp; もしくは&nbsp;&nbsp; 交わったとしても 交点がポリゴン内部になかった<br>
        }<br>
        <br>
        // 三角ポリゴン pPoly(頂点数:numVertices 平面:plane上に存在) が レイ(始点:rayPos 方向:rayDir) と 交わるか result:ポリゴンとレイの交点<br>
        inline bool isCollisionPoly_Sphere(const Vector3* pPoly, unsigned int numVertices, const Plane4&amp; plane, const Vector3&amp; center, float Radius, Vector3* result = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float distance;<br>
        &nbsp;&nbsp;&nbsp; // まず、球とポリゴンのある平面が交差するかを求め、球の中心までの距離 distance をもとめる<br>
        &nbsp;&nbsp;&nbsp; if (plane.sphereSide(center, Radius, &amp;distance) != Plane4::Side::InterPlane) return false; // 交差していない<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector3 point = center - plane.n * distance; // 球の中心 - 面法線 * 距離 でポリゴン上の交点<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (isInsidePolygon(point, pPoly, numVertices)) // 交点point が ポリゴン内に存在する点なのかチェック<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float overDist = Radius - distance; // めり込みすぎた距離<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (distance &lt; 0) overDist = -overDist; // めり込みすぎた距離がマイナス方向の場合<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = plane.n * overDist; // result に こたえ(ポリゴンにめり込みすぎを押し戻すベクトル) を設定し返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // 交点がポリゴン内部にあった<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return isCollisionPolyEdge_Sphere(pPoly, numVertices, center, Radius, result); // ポリゴンのエッジ部分が球体と交差しているか<br>
        }<br>
        <br>
        #endif<br>
      </p>
      <br>
      <br>
      <br>
      では、準備したVector3.hとCollision3D.hを使って、3D空間の当たり判定を試してみましょう。<br>
      <p><code>main.cpp</code>のコードにCollision3D.hのisCollision系関数を使って、3D空間の当たり判定をする処理を追加してみます。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        #include "DataMV1.h"<br>
        #include "DataPly.h"<br>
        <em>#include "Collision3D.h"</em><br>
        <br>
        #include "Editor.h"<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; float animTime = 0.0f; // アニメの現在時刻<br>
        &nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
        &nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@kick.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;Load(); // 3Dモデルをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilAttackAnimData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@jump.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilAttackAnimData-&gt;Load(); // 3Dの追加アニメデータをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;AttachAnim(*pDevilAttackAnimData); // アニメを追加でflyのほうをベースとしたモデルにアタッチ<br>
        &nbsp;&nbsp;&nbsp; int animeButton = 0; // ボタンでアニメを切り替えられるようにする<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; pTexImage = Resource::MakeShared&lt;Texture&gt;("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; pTexImage-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; assert((int)*pTexImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataPly&gt; pPlyData = Resource::MakeShared&lt;DataPly&gt;("Image/dice.ply");<br>
        &nbsp;&nbsp;&nbsp; pPlyData-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; <br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens(); // スクリーンの位置やドラッグによる移動を更新する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードの 0 1 キーで3Dアニメを切り替えられるようにする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_0))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_1))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 1;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width =&nbsp; pTexImage-&gt;m_XSize; float height =&nbsp; pTexImage-&gt;m_YSize; // テクスチャ画像のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f, 1.0f, 1.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(pPlyData-&gt;Vertex.data(), pPlyData-&gt;Vertex.size(), pPlyData-&gt;Index.data(), pPlyData-&gt;numIndex / 3, (int)*pTexImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 100, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ファイルのパス + ":" + アニメ名でアクセス<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string animPathName = (animeButton == 0) ? "Image/devil@kick.mv1:mixamo.com" : "Image/devil@jump.mv1:mixamo.com";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(pDevilData-&gt;count(animPathName) &gt; 0 &amp;&amp; "指定されたアニメ名のアニメはMV1に付属していませんでした");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime += animStepTime * animSpeed; // 1.0×2倍 なら2倍速でアニメ時刻が進む<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animTime &gt; (*pDevilData)[animPathName].endTime)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime = 0.0f; // 0秒目へとアニメをループさせる<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 画面奥へ向かう光線レイを求める<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 rayStart = DxLib::ConvScreenPosToWorldPos(VGet(Input::MouseX, Input::MouseY, 0.0f));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 rayEnd = DxLib::ConvScreenPosToWorldPos(VGet(Input::MouseX, Input::MouseY, 1.0f));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(rayStart, rayEnd, GetColor(255, 255, 0));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 球0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 sphere0Center{ 10,10,10 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float sphere0Radius = 10;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 collision0;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision0 = isCollisionSphere_Line(sphere0Center, sphere0Radius, rayStart, rayEnd, &amp;collision0); // 球と光線(レイ)の当たり判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(sphere0Center, sphere0Radius, 16, (isCollision0) ? GetColor(255, 0, 0) : GetColor(255, 255, 255), GetColor(255, 255, 255), FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision0) DxLib::DrawSphere3D(collision0, 0.5, 16, GetColor(255, 0, 0), GetColor(255, 255, 255), TRUE); // レイと当たった部分に赤い球を表示<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 球1<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 sphere1Center{ 10,-10,10 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float sphere1Radius = 10;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 collision1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision1 = isCollisionSphere_Ray(sphere1Center, sphere1Radius, rayStart, rayEnd - rayStart, &amp;collision1); // 球と光線(レイ)の当たり判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(sphere1Center, sphere1Radius, 16, (isCollision1) ? GetColor(0, 255, 0) : GetColor(255, 255, 255), GetColor(255, 255, 255), FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision1) DxLib::DrawSphere3D(collision1, 0.5, 16, GetColor(0, 255, 0), GetColor(255, 255, 255), TRUE); // レイと当たった部分に緑の球を表示</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 再生時間をセットする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1SetAttachAnimTime((int)*pDevilData, (*pDevilData)[animPathName].index, animTime);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 半透明のスクリーンも描ける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); // サブのスクリーンを全部描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); // エディタのDraw処理<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう? レイと球の当たり判定が表示されたでしょうか? <br>
      <br>
      <br>
    </a><a id="mozTocId0014" class="mozTocH1">
      <h1>ドラッグできるオブジェクトのコントロール点を用意して当たり判定の球やカプセルなどの幅や高さを調整できるようにする</h1>
      <p><code>DragObject.hを新規作成</code>してVector3を継承して、ドラッグできる機能を追加しましょう。</p>
      <p class="source">#ifndef DRAG_OBJECT_H_<br>
        #define DRAG_OBJECT_H_<br>
        <br>
        #include "DxLib.h"<br>
        #include "Vector3.h"<br>
        #include "Collision3D.h"<br>
        <br>
        #include &lt;memory&gt;<br>
        <br>
        // ドラッグできるVector3の点の基底クラス、Vector3との違いはvirtual仮想関数群を持ちUpdateなどの関数をoverrideできる設計になっていること<br>
        struct DragPoint : public Vector3<br>
        {<br>
        &nbsp;&nbsp;&nbsp; DragPoint(float x = 0.0f, float y = 0.0f, float z = 0.0f) : Vector3(x, y, z) {}<br>
        &nbsp;&nbsp;&nbsp; DragPoint(const Vector3&amp; other) : Vector3(other.x, other.y, other.z) {}<br>
        &nbsp;&nbsp;&nbsp; DragPoint(VECTOR other) : Vector3(other) {}<br>
        &nbsp;&nbsp;&nbsp; virtual ~DragPoint() {};<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 継承overrideして親や子などを持たせれば親の変更を子に伝搬させる設計も可能<br>
        &nbsp;&nbsp;&nbsp; virtual void Update() {}<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 継承overrideして所有オーナーなどを持たせれば半径などの変更をオーナーに伝搬させる設計も可能<br>
        &nbsp;&nbsp;&nbsp; virtual void UpdateOwner() {}<br>
        <br>
        &nbsp;&nbsp;&nbsp; // screenXY:スクリーン上のXY位置 が ドラッグ点から幅:centerWidthの範囲内ならドラッグ当たり判定がtrue<br>
        &nbsp;&nbsp;&nbsp; virtual bool isCollisionOnScreenXY(Vector3&amp; resultCenter, const VECTOR&amp; screenXY, const float centerWidth = 6.0f)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR pos2D = DxLib::ConvWorldPosToScreenPos(*this);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pos2D.z &lt; 0.0f || 1.0f &lt; pos2D.z) return false; // カメラ視野の奥行クリップ値(近:0.0f～1.0f:遠)の範囲外ならfalse<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pos2D.x - centerWidth / 2 &lt;= screenXY.x &amp;&amp; screenXY.x &lt;= pos2D.x + centerWidth / 2<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &amp;&amp; pos2D.y - centerWidth / 2 &lt;= screenXY.y &amp;&amp; screenXY.y &lt;= pos2D.y + centerWidth / 2)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; resultCenter = *this; // ドラッグ点の中心点の3D位置を返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // override継承してscreenXYの位置にあるコントロール点を返す(なかったら空のweak_ptrがreturnされる)<br>
        &nbsp;&nbsp;&nbsp; virtual bool GetControlPointOnScreenXY(std::weak_ptr&lt;DragPoint&gt;&amp; pResult, const VECTOR&amp; screenXY, const float centerWidth = 6.0f)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pResult = std::weak_ptr&lt;DragPoint&gt;(); // 観測対象のない空のweak_ptrを返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // rayPosの位置からrayDirの方向にレイを飛ばして衝突判定 resultCollision:衝突した点の衝突位置 resultCenter:衝突点の中心位置<br>
        &nbsp;&nbsp;&nbsp; virtual bool isCollision(const Vector3&amp; rayPos, const Vector3&amp; rayDir, Vector3&amp; resultCollision, Vector3&amp; resultCenter)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // overrideで継承して球やカプセルなどの当たり判定を実装する<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 点をドラッグできる点として中心位置をスクリーン上に四角形で描く<br>
        &nbsp;&nbsp;&nbsp; virtual void Draw(const float centerWidth = 6.0f, unsigned int rectColor = GetColor(255, 255, 255), int FillFlag = TRUE)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR screenXY = DxLib::ConvWorldPosToScreenPos(*this);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (0 &lt;= screenXY.z &amp;&amp; screenXY.z &lt;= 1.0f) // zは奥行クリップ値(near:0～1.0:far)⇒範囲外ならカメラ視野外 <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawBox(screenXY.x - centerWidth / 2, screenXY.y - centerWidth / 2,<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; screenXY.x + centerWidth / 2, screenXY.y + centerWidth / 2, rectColor, FillFlag);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        // DrogPointの点を継承してドラッグできるカプセルや球体などのオブジェクトの基底オブジェクトを定義する<br>
        struct DragObject : public DragPoint<br>
        {<br>
        &nbsp;&nbsp;&nbsp; unsigned int m_color; // オブジェクトを描画する色<br>
        &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;DragPoint&gt;&gt; m_controlPoints; // 半径などを変えるためのコントロール点<br>
        &nbsp;&nbsp;&nbsp; DragObject(float x = 0.0f, float y = 0.0f, float z = 0.0f, unsigned int color = GetColor(255, 255, 255))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : DragPoint(x, y, z), m_color{ color } {}<br>
        &nbsp;&nbsp;&nbsp; DragObject(const Vector3&amp; other, unsigned int color = GetColor(255, 255, 255))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : DragPoint(other.x, other.y, other.z), m_color{ color } {}<br>
        &nbsp;&nbsp;&nbsp; DragObject(VECTOR other, unsigned int color = GetColor(255, 255, 255)) : DragPoint(other), m_color{ color } {}<br>
        &nbsp;&nbsp;&nbsp; virtual ~DragObject() {};<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual void Update() override // 配下のコントロール点をすべて更新<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (auto itr = m_controlPoints.begin(); itr != m_controlPoints.end(); )<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pControlPoint = *itr; // コントロール点への共有ポインタ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pControlPoint-&gt;Update(); // 配下のコントロール点をすべて更新<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ++itr; // for文のイテレータを次の点へすすめる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // screenXYの位置にあるコントロール点を返す なかったら空のweak_ptrがreturnされる<br>
        &nbsp;&nbsp;&nbsp; virtual bool GetControlPointOnScreenXY(std::weak_ptr&lt;DragPoint&gt;&amp; pResult, const VECTOR&amp; screenXY, const float centerWidth = 6.0f) override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (auto itr = m_controlPoints.begin(); itr != m_controlPoints.end(); )<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pControlPoint = *itr; // コントロール点への共有ポインタ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ++itr; // for文のイテレータを次の点へすすめる<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 collisionCenter; // 衝突点を探す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pControlPoint-&gt;isCollisionOnScreenXY(collisionCenter, screenXY, centerWidth)) // スクリーン上の四角のドラッグ点<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pResult = pControlPoint;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pResult = std::weak_ptr&lt;DragPoint&gt;(); // 見つからなかったら観測対象のない空のweak_ptrを返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        <br>
        // 球体の当たり判定をもつドラッグ中心点<br>
        struct DragSphere : public DragObject<br>
        {<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; float m_height; // ドラッグ球の当たり判定の大きさ(球の高さ)<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 球の高さ(=半径の1/2)をコントロールする点<br>
        &nbsp;&nbsp;&nbsp; struct ControlPoint : public DragObject<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DragSphere&amp; m_owner; // コントロール点のオーナー所有者<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ControlPoint(DragSphere&amp; owner, unsigned int color = GetColor(255, 255, 255))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : m_owner{ owner }, DragObject(owner.x + owner.m_height / 2, owner.y, owner.z, color) {}<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual ~ControlPoint() {}<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual void Update() override { this-&gt;xyz = (m_owner + Vector3{ m_owner.m_height / 2, 0.0f, 0.0f }).xyz; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual void UpdateOwner() override<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.m_height = (*this - m_owner).magnitude() * 2; // コントロール点との距離の2倍=高さ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.xyz = (*this + (m_owner - *this).normalized() * m_owner.m_height / 2).xyz;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.Update(); // オーナーの配下のコントロール点すべてに更新を伝搬<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; DragSphere(float x = 0.0f, float y = 0.0f, float z = 0.0f, float height = 1.0f, unsigned int color = GetColor(255, 255, 255))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : DragObject(x, y, z, color), m_height{ height }<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_controlPoints.emplace_back(std::make_shared&lt;ControlPoint&gt;(*this, color));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; virtual ~DragSphere() {}<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 描画などに必要なパラメータを得る<br>
        &nbsp;&nbsp;&nbsp; inline void GetParams(Vector3&amp; center, float&amp; radius)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; center = *this; // x,y,zのデータを読み出し<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; radius = m_height / 2; // 半径は高さの 1/2<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // rayPosの位置からrayDirの方向にレイを飛ばして球との衝突判定 resultCollision:衝突した点の衝突位置 resultCenter:衝突点の中心位置<br>
        &nbsp;&nbsp;&nbsp; virtual bool isCollision(const Vector3&amp; rayPos, const Vector3&amp; rayDir, Vector3&amp; resultCollision, Vector3&amp; resultCenter) override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isCollisionSphere_Ray(*this, m_height / 2, rayPos, rayDir, &amp;resultCollision))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; resultCenter = *this; // 衝突した点の中心位置をresultで返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; // ドラッグ点とスクリーンのマウスカーソルから飛ばしたレイが衝突した<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // ドラッグ点とスクリーンのマウスカーソルから飛ばしたレイが衝突しなかった<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ドラッグ点の中心位置と球体を描く<br>
        &nbsp;&nbsp;&nbsp; virtual void Draw(const float centerWidth = 6.0f, unsigned int rectColor = GetColor(255, 255, 255), int FillFlag = TRUE) override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 center = *this; // 中心位置のxyzのデータを読み出し<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int DivNum = 8; // 球面ポリゴンの分割数<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 球体を描く<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(center, m_height / 2, DivNum, m_color, GetColor(255, 255, 255), FALSE);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // x軸(R:赤) y軸(G:緑) z軸(B:青)をライン表示する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(center, center + Vector3{ m_height / 2, 0.0f, 0.0f }, GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(center, center + Vector3{ 0.0f, m_height / 2, 0.0f }, GetColor(0, 255, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(center, center + Vector3{ 0.0f, 0.0f, m_height / 2 }, GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (auto controlPoint : m_controlPoints) // 配下のコントロール点を描く<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; controlPoint-&gt;Draw(centerWidth, rectColor);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DragPoint::Draw(centerWidth, rectColor, FillFlag); // スクリーン上のドラッグ中心点を描く<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        // カプセルの当たり判定をもつドラッグ中心点<br>
        struct DragCapsule : public DragObject<br>
        {<br>
        protected:<br>
        &nbsp;&nbsp;&nbsp; float m_height{ 0.0f }; // カプセルの高さ<br>
        &nbsp;&nbsp;&nbsp; Axis3D m_direction{ Axis3D::Y }; // カプセルの軸の方向<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; // カプセルの半径<br>
        &nbsp;&nbsp;&nbsp; float m_radius{ 1.0f };<br>
        &nbsp;&nbsp;&nbsp; // カプセルの高さ<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 height() const { return m_height; }<br>
        &nbsp;&nbsp;&nbsp; // カプセルの向く方向軸(height高さの方向軸)<br>
        &nbsp;&nbsp;&nbsp; inline Axis3D direction() const { return m_direction; }<br>
        &nbsp;&nbsp;&nbsp; // カプセルの軸の長さ(高さ)の半分(ハーフ)の位置<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 axisHalf() const {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector3{ (m_direction == Axis3D::X) ? m_height / 2.0f : 0.0f,<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (m_direction == Axis3D::Y) ? m_height / 2.0f : 0.0f,<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (m_direction == Axis3D::Z) ? m_height / 2.0f : 0.0f };<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; // カプセルの軸の始点<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 start() const { return *this - axisHalf(); }<br>
        &nbsp;&nbsp;&nbsp; // カプセルの軸の終点<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 end() const { return *this + axisHalf(); }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // カプセルの半径をコントロールする点<br>
        &nbsp;&nbsp;&nbsp; struct ControlPointRadius : public DragObject<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DragCapsule&amp; m_owner; // コントロール点のオーナー所有者<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ControlPointRadius(DragCapsule&amp; owner, unsigned int color = GetColor(255, 255, 255))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : m_owner{ owner }, DragObject(owner.x + owner.m_radius, owner.y, owner.z, color) {}<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual ~ControlPointRadius() {}<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual void Update() override { this-&gt;xyz = (m_owner + Vector3{ m_owner.m_radius, 0.0f, 0.0f }).xyz; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual void UpdateOwner() override<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.m_radius = (*this - m_owner).magnitude(); // オーナーの中心点との距離が半径<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.xyz = (*this + (m_owner - *this).normalized() * m_owner.m_radius).xyz;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.Update(); // オーナーの配下のコントロール点すべてに更新を伝搬<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // カプセルの高さをコントロールする点<br>
        &nbsp;&nbsp;&nbsp; struct ControlPointHeight : public DragObject<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DragCapsule&amp; m_owner; // コントロール点のオーナー所有者<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ControlPointHeight(DragCapsule&amp; owner, unsigned int color = GetColor(255, 255, 255))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : m_owner{ owner }, DragObject(owner.end(), color) {}<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual ~ControlPointHeight() {}<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual void Update() override { this-&gt;xyz = m_owner.end().xyz; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual void UpdateOwner() override<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.m_height = (*this - m_owner).magnitude() * 2; // コントロール点との距離の2倍=高さ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.xyz = (*this + (m_owner - *this).normalized() * m_owner.m_height / 2).xyz;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.Update(); // オーナーの配下のコントロール点すべてに更新を伝搬<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; DragCapsule(float x = 0.0f, float y = 0.0f, float z = 0.0f, float radius = 1.0f, float height = 0.0f, Axis3D direction = Axis3D::Y, unsigned int color = GetColor(255, 255, 255))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : DragObject(x, y, z, color), m_radius{ radius }, m_height{ height }, m_direction{ direction }<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_controlPoints.emplace_back(std::make_shared&lt;ControlPointRadius&gt;(*this, color));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_controlPoints.emplace_back(std::make_shared&lt;ControlPointHeight&gt;(*this, color));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; virtual ~DragCapsule() {}<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 描画などに必要なパラメータを得る<br>
        &nbsp;&nbsp;&nbsp; inline void GetParams(Vector3&amp; center, Vector3&amp; start, Vector3&amp; end, float&amp; radius)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; center = *this; // x,y,zのデータを読み出し<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 axis_half = axisHalf(); // カプセルの軸の長さ(高さ)の半分(ハーフ)の位置<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; start = center - axis_half; // カプセルの軸の始点(-なので下側)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; end = center + axis_half; // カプセルの軸の始点(+なので上側)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; radius = m_radius;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // rayPosの位置からrayDirの方向にレイを飛ばしてカプセルとの衝突判定 resultCollision:衝突した点の衝突位置 resultCenter:衝突点の中心位置<br>
        &nbsp;&nbsp;&nbsp; virtual bool isCollision(const Vector3&amp; rayPos, const Vector3&amp; rayDir, Vector3&amp; resultCollision, Vector3&amp; resultCenter) override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float radius;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 center,axisStart, axisEnd;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; GetParams(center, axisStart, axisEnd, radius); // 必要なパラメータを得る<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カプセルとレイの当たり判定<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isCollisionCapsule_Ray(axisStart, axisEnd, m_radius, rayPos, rayDir, &amp;resultCollision))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; resultCenter = center; // 衝突した点の中心位置をresultで返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; // ドラッグ点を中心とするカプセルと飛ばしたレイが衝突した<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // ドラッグ点を中心とするカプセルと飛ばしたレイが衝突しなかった<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ドラッグ点の中心位置とカプセルを描く<br>
        &nbsp;&nbsp;&nbsp; virtual void Draw(const float centerWidth = 6.0f, unsigned int rectColor = GetColor(255, 255, 255), int FillFlag = TRUE) override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float radius;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 center, axisStart, axisEnd;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; GetParams(center, axisStart, axisEnd, radius); // 必要なパラメータを得る<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int DivNum = 8; // カプセル表面ポリゴンの分割数<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カプセルを描く<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawCapsule3D(axisStart, axisEnd, m_radius, DivNum, m_color, GetColor(255, 255, 255), FALSE);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // x軸(R:赤) y軸(G:緑) z軸(B:青)をライン表示する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float axisX = (m_direction == Axis3D::X) ? m_height / 2.0f : m_radius;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float axisY = (m_direction == Axis3D::Y) ? m_height / 2.0f : m_radius;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float axisZ = (m_direction == Axis3D::Z) ? m_height / 2.0f : m_radius;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(center, center + Vector3{ axisX, 0.0f, 0.0f }, GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(center, center + Vector3{ 0.0f, axisY, 0.0f }, GetColor(0, 255, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(center, center + Vector3{ 0.0f, 0.0f, axisZ }, GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (auto controlPoint : m_controlPoints)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; controlPoint-&gt;Draw(centerWidth, rectColor);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DragPoint::Draw(centerWidth, rectColor, FillFlag); // スクリーン上のドラッグ中心点を描く<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        // ボックスの当たり判定をもつドラッグ中心点<br>
        struct DragBox : public DragObject<br>
        {<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; Vector3 m_Size{ 1.0f,1.0f,1.0f }; // ボックスのサイズ<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ボックスの幅をコントロールする点<br>
        &nbsp;&nbsp;&nbsp; struct ControlPointWidth : public DragObject<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DragBox&amp; m_owner; // コントロール点のオーナー所有者<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ControlPointWidth(DragBox&amp; owner, unsigned int color = GetColor(255, 255, 255))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : m_owner{ owner }, DragObject(owner.x + owner.m_Size.x / 2, owner.y, owner.z, color) {}<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual ~ControlPointWidth() {}<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual void Update() override { this-&gt;xyz = Vector3{ m_owner.x + m_owner.m_Size.x / 2,m_owner.y,m_owner.z }.xyz; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual void UpdateOwner() override<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.m_Size.x = (*this - m_owner).magnitude() * 2; // コントロール点との距離の2倍=高さ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.xyz = (*this + (m_owner - *this).normalized() * m_owner.m_Size.x / 2).xyz;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.Update(); // オーナーの配下のコントロール点すべてに更新を伝搬<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ボックスの高さをコントロールする点<br>
        &nbsp;&nbsp;&nbsp; struct ControlPointHeight : public DragObject<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DragBox&amp; m_owner; // コントロール点のオーナー所有者<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ControlPointHeight(DragBox&amp; owner, unsigned int color = GetColor(255, 255, 255))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : m_owner{ owner }, DragObject(owner.x, owner.y + owner.m_Size.y / 2, owner.z, color) {}<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual ~ControlPointHeight() {}<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual void Update() override { this-&gt;xyz = Vector3{ m_owner.x, m_owner.y + m_owner.m_Size.y / 2, m_owner.z }.xyz; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual void UpdateOwner() override<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.m_Size.y = (*this - m_owner).magnitude() * 2; // コントロール点との距離の2倍=高さ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.xyz = (*this + (m_owner - *this).normalized() * m_owner.m_Size.y / 2).xyz;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.Update(); // オーナーの配下のコントロール点すべてに更新を伝搬<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ボックスの奥行zをコントロールする点<br>
        &nbsp;&nbsp;&nbsp; struct ControlPointDepth : public DragObject<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DragBox&amp; m_owner; // コントロール点のオーナー所有者<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ControlPointDepth(DragBox&amp; owner, unsigned int color = GetColor(255, 255, 255))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : m_owner{ owner }, DragObject(owner.x, owner.y, owner.z + owner.m_Size.z / 2, color) {}<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual ~ControlPointDepth() {}<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual void Update() override { this-&gt;xyz = Vector3{ m_owner.x, m_owner.y, m_owner.z + m_owner.m_Size.z / 2 }.xyz; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual void UpdateOwner() override<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.m_Size.z = (*this - m_owner).magnitude() * 2; // コントロール点との距離の2倍=高さ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.xyz = (*this + (m_owner - *this).normalized() * m_owner.m_Size.z / 2).xyz;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_owner.Update(); // オーナーの配下のコントロール点すべてに更新を伝搬<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; DragBox(float x = 0.0f, float y = 0.0f, float z = 0.0f, Vector3 size = Vector3{ 1.0f, 1.0f, 1.0f }, unsigned int color = GetColor(255, 255, 255))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : DragObject(x, y, z, color), m_Size{ size }<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_controlPoints.emplace_back(std::make_shared&lt;ControlPointWidth&gt;(*this, color));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_controlPoints.emplace_back(std::make_shared&lt;ControlPointHeight&gt;(*this, color));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_controlPoints.emplace_back(std::make_shared&lt;ControlPointDepth&gt;(*this, color));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; virtual ~DragBox() {}<br>
        <br>
        &nbsp;&nbsp;&nbsp; // サイズのx,y,zのどれかがマイナスならプラスに直す<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 sizeMinMax()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector3{ (m_Size.x &lt; 0) ? -m_Size.x : m_Size.x,<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;(m_Size.y &lt; 0) ? -m_Size.y : m_Size.y,<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;(m_Size.z &lt; 0) ? -m_Size.z : m_Size.z };<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 描画などに必要なパラメータを得る<br>
        &nbsp;&nbsp;&nbsp; inline void GetParams(Vector3&amp; center, Vector3&amp; boxMin, Vector3&amp; boxMax)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; center = *this; // x,y,zのデータを読み出し<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 boxHalfSize = sizeMinMax() / 2;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; boxMin = center - boxHalfSize;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; boxMax = center + boxHalfSize;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // rayPosの位置からrayDirの方向にレイを飛ばしてカプセルとの衝突判定 resultCollision:衝突した点の衝突位置 resultCenter:衝突点の中心位置<br>
        &nbsp;&nbsp;&nbsp; virtual bool isCollision(const Vector3&amp; rayPos, const Vector3&amp; rayDir, Vector3&amp; resultCollision, Vector3&amp; resultCenter) override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 center, boxMin, boxMax;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; GetParams(center, boxMin, boxMax); // 必要なパラメータを得る<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ボックスとレイの当たり判定<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isCollisionAABB_Ray(boxMin, boxMax, rayPos, rayDir, &amp;resultCollision))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; resultCenter = center; // 衝突した点の中心位置をresultで返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true; // ドラッグ点を中心とするカプセルと飛ばしたレイが衝突した<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // ドラッグ点を中心とするボックスと飛ばしたレイが衝突しなかった<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ドラッグ点の中心位置とボックスを描く<br>
        &nbsp;&nbsp;&nbsp; virtual void Draw(const float centerWidth = 6.0f, unsigned int rectColor = GetColor(255, 255, 255), int FillFlag = TRUE) override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 center, boxMin, boxMax;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; GetParams(center, boxMin, boxMax); // 必要なパラメータを得る<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ボックスを描く<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawCube3D(boxMin, boxMax, m_color, GetColor(255, 255, 255), FALSE);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // x軸(R:赤) y軸(G:緑) z軸(B:青)をライン表示する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(center, center + Vector3{ m_Size.x / 2, 0.0f, 0.0f }, GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(center, center + Vector3{ 0.0f, m_Size.y / 2, 0.0f }, GetColor(0, 255, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(center, center + Vector3{ 0.0f, 0.0f, m_Size.z / 2 }, GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (auto controlPoint : m_controlPoints) // 配下のコントロール点を描く<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; controlPoint-&gt;Draw(centerWidth, rectColor);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DragPoint::Draw(centerWidth, rectColor, FillFlag); // スクリーン上のドラッグ中心点を描く<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        #endif</p>
      <br>
      <p><code>Editor.h</code>を変更してドラッグ点のリストを移動できるようにします。</p>
      <p class="source">#ifndef EDITOR_H_<br>
        #define EDITOR_H_<br>
        <br>
        #include "DxLib.h"<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        <em>#include "Vector3.h"<br>
          #include "DragObject.h"</em><br>
        <br>
        #include "Singleton.h"<br>
        <br>
        <em>#include &lt;list&gt; // 連結リストstd::listを使う<br>
          #include &lt;memory&gt;<br>
          #include &lt;cmath&gt;</em><br>
        <br>
        class Editor : public Singleton&lt;Editor&gt;<br>
        {<br>
        public:<br>
        <br>
        &nbsp;&nbsp;&nbsp; struct Camera<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x = 0.f, y = 0.0f, z = -10.0f; // カメラはz軸マイナス位置からz軸プラス向きに原点を見る形で初期化される<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>inline operator VECTOR() { return VGet(x, y, z); }<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; inline operator Vector3() const { return Vector3{ x, y, z }; }</em><br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; inline Camera&amp; operator +=(VECTOR move) { x += move.x; y += move.y; z += move.z; return *this; } // VECTOR型を足したときはカメラを移動させる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float VRotate = 0.0f, HRotate = 0.0f, TRotate = 0.0f; // X軸 V,Y軸 H,Z軸 T まわりのカメラのオイラー回転の角度<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float wheelSpeed = 1.0f; // マウスのホイールと連動した際のカメラのスピード<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR GetCameraWorldDirByScreenXY(float screenX = (float)Input::MouseX, float screenY = (float)Input::MouseY)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // スクリーン(X,Y)からマウスの指すワールド座標(X,Y,Z)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR currentPos = DxLib::ConvScreenPosToWorldPos(VGet(screenX, screenY, 0.0f));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラからマウスの指す位置への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return DxLib::VNorm(DxLib::VGet(currentPos.x - x, currentPos.y - y, currentPos.z - z));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの2Dの start位置XY から end位置XY の方向 が ワールド座標3D においてどんなベクトルになるかを求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR GetWorldDirByCameraScreenXYDir(float screenStartX = (float)Input::MouseX, float screenStartY = (float)Input::MouseY,<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float screenEndX = (float)(Input::MouseX + 1), float screenEndY = (float)(Input::MouseY + 1))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // スクリーン(X,Y)からマウスの指すワールド座標(X,Y,Z)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR startPos = DxLib::ConvScreenPosToWorldPos(VGet(screenStartX, screenStartY, 0.0f));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR endPos = DxLib::ConvScreenPosToWorldPos(VGet(screenEndX, screenEndY, 0.0f));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ワールド座標におけるstartからendへ向かう方向のベクトルを求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return DxLib::VGet(endPos.x - startPos.x, endPos.y - startPos.y, endPos.z - startPos.z);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; };<br>
        &nbsp;&nbsp;&nbsp; Camera camera;<br>
        <br>
        <em>&nbsp;&nbsp;&nbsp; bool isDraggingPoints = false; // 点をドラッグ中かどうか<br>
          &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;DragPoint&gt; pDraggingPoint; // ドラッグ中の点への弱共有ポインタ<br>
          &nbsp;&nbsp;&nbsp; int startDragX = -1, startDragY = -1; // ドラッグを開始したスクリーン上の点のXY位置<br>
          &nbsp;&nbsp;&nbsp; Vector3 startDrag2D; // ドラッグを開始したスクリーン位置(zはクリップ面位置near:0.0f～1.0f:far)<br>
          &nbsp;&nbsp;&nbsp; Vector3 startDrag3D; // ドラッグを開始した3D位置</em><br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; int prevDragX = -1, prevDragY = -1; // 前フレームでのスクリーン上でのドラッグXY位置<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; bool isInitFinished = false; // 一回でもInitされたかのフラグ<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; void Init()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isInitFinished) return; // 最初の一回だけInit処理をするためのフラグ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitFinished = true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateKeyInput()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camXYZSpeed = 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向のの単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR camNorm = camera.GetCameraWorldDirByScreenXY((float)Input::MouseX, (float)Input::MouseY);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // キーボードのWSキーでカメラ視点を手前や奥に移動できるようにする<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_W))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(camNorm.x * camXYZSpeed, camNorm.y * camXYZSpeed, camNorm.z * camXYZSpeed);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_S))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(-camNorm.x * camXYZSpeed, -camNorm.y * camXYZSpeed, -camNorm.z * camXYZSpeed);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの 2D上のX方向 が ワールド座標 3D ではどんな方向ベクトルになるかを求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR xCamDir = VNorm(camera.GetWorldDirByCameraScreenXYDir((float)Input::MouseX, (float)Input::MouseY, (float)(Input::MouseX + 10), (float)Input::MouseY));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_D))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(xCamDir.x * camXYZSpeed, xCamDir.y * camXYZSpeed, xCamDir.z * camXYZSpeed);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_A))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(-xCamDir.x * camXYZSpeed, -xCamDir.y * camXYZSpeed, -xCamDir.z * camXYZSpeed);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの 2D上のY方向 が ワールド座標 3D ではどんな方向ベクトルになるかを求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR yCamDir = VNorm(camera.GetWorldDirByCameraScreenXYDir((float)Input::MouseX, (float)Input::MouseY, (float)Input::MouseX, (float)(Input::MouseY + 10)));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_Q))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(yCamDir.x * camXYZSpeed, yCamDir.y * camXYZSpeed, yCamDir.z * camXYZSpeed);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_E))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(-yCamDir.x * camXYZSpeed, -yCamDir.y * camXYZSpeed, -yCamDir.z * camXYZSpeed);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_V))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_B))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_H))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_J))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_T))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_Y))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <em>&nbsp;&nbsp;&nbsp; void UpdateDragPoints(std::list&lt;std::weak_ptr&lt;DragPoint&gt;&gt;* pDragPoints = nullptr)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bool isMouseDragging = (Input::Click[Mouse::DragL] || Input::Click[Mouse::DragR]) &amp;&amp; Screen::IsInsideWindow();<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isDraggingPoints &amp;&amp; SubScreen::isMouseOvered) { isDraggingPoints = false; return; }<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR nearestCollision; // 一番近い衝突点を探す<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float nearestDistSq = DxLib::GetCameraFar() * DxLib::GetCameraFar(); // カメラ視野のクリップ設定のFar(最遠)の2乗<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float nearestDist = DxLib::GetCameraFar(); // 一番近い点までの距離を探す<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isDraggingPoints)<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (auto itr = pDragPoints-&gt;begin(); itr != pDragPoints-&gt;end(); )<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pDragPoint = itr-&gt;lock(); // ドラッグ点への共有ポインタ<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!pDragPoint) // 弱リンク先の点本体がすでに削除済の点だったら<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //[for文でたどっている途中の削除] https://piy.hatenadiary.org/entry/20090616/1245173713<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; itr = pDragPoints-&gt;erase(itr); // ドラッグ点リンクをリストから削除して<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue; // ループで次の点へ進む<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ++itr; // for文のイテレータを次の点へすすめる<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR screenXY = VGet(Input::MouseX, Input::MouseY, 0.0f); // スクリーン上のマウス位置<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // マウスポインタの位置から画面奥へのレイ<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR rayPos = DxLib::ConvScreenPosToWorldPos(screenXY);<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR rayDir = camera.GetCameraWorldDirByScreenXY(Input::MouseX, Input::MouseY);<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;DragPoint&gt; pControlPoint; // コントロール点への弱共有ポインタ<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 collisionPoint, collisionCenter; // 衝突点を探す<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pDragPoint-&gt;isCollisionOnScreenXY(collisionCenter, screenXY, 6.0f)) // スクリーン上の四角のドラッグ点<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pDraggingPoint = pDragPoint;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; startDrag3D = collisionCenter;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; startDrag2D = DxLib::ConvWorldPosToScreenPos(collisionCenter);<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; startDragX = Input::MouseX, startDragY = Input::MouseY;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isDraggingPoints = true;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; break;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (pDragPoint-&gt;GetControlPointOnScreenXY(pControlPoint, screenXY, 6.0f))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pDraggingPoint = pControlPoint;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; startDrag3D = *pControlPoint.lock();<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; startDrag2D = DxLib::ConvWorldPosToScreenPos(startDrag3D);<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; startDragX = Input::MouseX, startDragY = Input::MouseY;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isDraggingPoints = true;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; break;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (pDragPoint-&gt;isCollision(rayPos, rayDir, collisionPoint, collisionCenter))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float distSq = (collisionPoint - camera).sqrMagnitude(); // カメラと衝突位置の2乗<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (distSq &lt; nearestDistSq) // 現在の最短距離の2乗(nearestDistSq)以下か?<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; nearestDistSq = distSq; // 一番近い距離の2乗を更新<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //nearestDist = (collisionCenter - camera).magnitude(); // 一番近い距離を更新<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; nearestCollision = collisionPoint; // 一番近い衝突点を更新して一番手前を探す<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pDraggingPoint = pDragPoint;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; startDrag2D = DxLib::ConvWorldPosToScreenPos(collisionCenter);<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; startDragX = Input::MouseX, startDragY = Input::MouseY;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isDraggingPoints = true;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pDraggingPos = pDraggingPoint.lock(); // ドラッグ中の点をlock<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isMouseDragging || !pDraggingPos)<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; startDragX = startDragY = -1;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pDraggingPoint = std::weak_ptr&lt;DragPoint&gt;(); // pDraggingPointの観測先を空へとリセットする<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isDraggingPoints = false;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (pDraggingPos)<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR nowDrag3D = DxLib::ConvScreenPosToWorldPos(startDrag2D + VGet(Input::MouseX - startDragX, Input::MouseY - startDragY, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (startDragX != -1 &amp;&amp; startDragY != -1)<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ドラッグ開始位置startDragと現在の位置に移動があれば、その差ぶん移動した位置の3D位置を設定してドラッグ移動を実現<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragL]) // マウス左クリック<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //DxLib::DrawSphere3D(nowDrag3D, 0.05, 8, GetColor(255, 0, 255), GetColor(255, 255, 255), FALSE);<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *pDraggingPos = nowDrag3D;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pDraggingPos-&gt;UpdateOwner(); // オーナーの半径などを連動して更新<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pDraggingPos-&gt;Update();<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isDraggingPoints = true;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateMouseInput()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!SubScreen::isMouseOvered) // マウスオーバーしているSubscreenがないとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::MouseWheel != 0.0f) // マウスのホイールをグリグリしたとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界の奥への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR camNorm = camera.GetCameraWorldDirByScreenXY((float)Input::MouseX, (float)Input::MouseY);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camSpeed = camera.wheelSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.wheelSpeed *= (camera.wheelSpeed &lt; 100.0f) ? 1.5f : 1.0f; // カメラのズーム速度を加速する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 求めた単位ベクトル×カメラのスピードぶんカメラの位置を移動<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.x += camNorm.x * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.y += camNorm.y * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.z += camNorm.z * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (camera.wheelSpeed &gt; 0.1f) camera.wheelSpeed *= 0.9f; // カメラのズーム速度を減衰する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else camera.wheelSpeed = 0.1f; // カメラのズーム速度を減衰して最小0.1にすることで繊細なズーム調整もできるようにする<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((Input::Click[Mouse::DragL] || Input::Click[Mouse::DragR]) &amp;&amp; Screen::IsInsideWindow())<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != -1 &amp;&amp; prevDragY != -1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 前の位置prevと現在の位置に移動があれば、その差ぶんだけ+=することでドラッグ移動を実現<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragL]) // マウス左クリック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragLX] || prevDragY != Input::Click[Mouse::DragLY])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // マウスポインタがある画面上の座標に該当する３Ｄ空間上の座標を取得 https://dxlib.xsrv.jp/function/dxfunc_3d_camera.html#R12N11<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float positionRatio = 0.9f;// 奥行の位置 Near 面 0.0f ～ 1.0f Far 面<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR start = DxLib::ConvScreenPosToWorldPos(VGet((float)prevDragX, (float)prevDragY, positionRatio));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR end = DxLib::ConvScreenPosToWorldPos(VGet((float)Input::Click[Mouse::DragLX], (float)Input::Click[Mouse::DragLY], positionRatio));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camSpeed = 400; // ドラッグに対するカメラの移動速度<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.x -= (end.x - start.x) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.y -= (end.y - start.y) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.z -= (end.z - start.z) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragR]) // マウス右クリック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // カメラの角度を変更<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragRX])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate += (float)(Input::Click[Mouse::DragRX] - prevDragX);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragY != Input::Click[Mouse::DragRY])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate += (float)(Input::Click[Mouse::DragRY] - prevDragY);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ±360度を超えたら割り算の余りを設定して 例.365度 → 5度に戻してやる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (camera.HRotate &gt; 360.0f || camera.HRotate &lt; -360.0f) camera.HRotate = std::fmodf(camera.HRotate, 360.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (camera.VRotate &gt; 360.0f || camera.VRotate &lt; -360.0f) camera.VRotate = std::fmodf(camera.VRotate, 360.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragX = (Input::Click[Mouse::DragL]) ? Input::Click[Mouse::DragLX] : Input::Click[Mouse::DragRX];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragY = (Input::Click[Mouse::DragL]) ? Input::Click[Mouse::DragLY] : Input::Click[Mouse::DragRY];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragX = -1; prevDragY = -1; // マウスのドラッグがないときはリセット<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateCamera()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラの位置と回転値をセット、カメラの位置は原点<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngle(<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::VGet(camera.x, camera.y, camera.z),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate * DX_PI_F / 180.0f, camera.HRotate * DX_PI_F / 180.0f, camera.TRotate * DX_PI_F / 180.0f);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // まとめてUpdateしたいときはUpdateを使い、個別にUIやKeyやMouseを別々にタイミングを取りながらUpdateしたいときは Updateは呼ばない<br>
        &nbsp;&nbsp;&nbsp; void Update()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateKeyInput();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateMouseInput();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateCamera();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void Draw()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 原点からx軸(R:赤) y軸(G:緑) z軸(B:青)をライン表示する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(1.0f * 5.0f, 0.0f * 5.0f, 0.0f * 5.0f), GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(0.0f * 5.0f, 1.0f * 5.0f, 0.0f * 5.0f), GetColor(0, 255, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(0.0f * 5.0f, 0.0f * 5.0f, 1.0f * 5.0f), GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 画面に回転量を描画<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, DxLib::GetColor(255, 255, 255), "Cam(x:%f y:%f z:%f)", camera.x, camera.y, camera.z);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 20, DxLib::GetColor(255, 255, 255), "Rot(V:%f H:%f T:%f)", camera.VRotate, camera.HRotate, camera.TRotate);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        #endif<br>
      </p>
      <br>
      <p><code>MyDraw.hを新規作成</code>して、平面を描く機能を準備します。</p>
      <p class="source">#ifndef MYDRAW_H_<br>
        #define MYDRAW_H_<br>
        <br>
        #include "DxLib.h"<br>
        #include "Vector3.h"<br>
        #include "Plane4.h"<br>
        <br>
        class MyDraw<br>
        {<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; // 3Dの矢印の先っぽのタイプ None:無し Cone:三角錐 Cube:立方体 Sphere:球体<br>
        &nbsp;&nbsp;&nbsp; enum class ArrowType { None, Cone, Cube, Sphere };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 3Dの矢印(位置:start→end)を描く arrowWidth:矢印の先端の円錐などの幅(球の半径) arrowHeight:矢印の先端の円錐などの高さ(球の時は使わない)<br>
        &nbsp;&nbsp;&nbsp; static int DrawArrow3D(const Vector3&amp; start, const Vector3&amp; end, ArrowType startType = ArrowType::None, ArrowType endType = ArrowType::Cone, float arrowWidth = 0.1f, float arrowHeight = 0.2f, unsigned int color = GetColor(255, 255, 255))<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; unsigned int difColor = color; // 拡散反射の色<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; unsigned int spcColor = GetColor(0, 0, 0); // 鏡面反射の色(0,0,0)で鏡面反射は黒(反射無し)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int DivNum = 8; // ポリゴン分割数(三角錐や球体などを例.8分割したポリゴンで表示する)<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (startType == ArrowType::Cone) // start側の矢印のタイプが三角錐のとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawCone3D(start, start + (end - start).normalized() * arrowHeight, arrowWidth / 2.0f, DivNum, difColor, spcColor, TRUE);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (endType == ArrowType::Cone) // end側の矢印のタイプが三角錐のとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawCone3D(end, end + (start - end).normalized() * arrowHeight, arrowWidth / 2.0f, DivNum, difColor, spcColor, TRUE);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (startType == ArrowType::Cube) // start側の矢印のタイプがキューブ(立方体)のとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawCube3D(start, start + (end - start).normalized() * arrowHeight, difColor, spcColor, TRUE);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (endType == ArrowType::Cube) // end側の矢印のタイプがキューブ(立方体)のとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawCube3D(end, end + (start - end).normalized() * arrowHeight, difColor, spcColor, TRUE);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (startType == ArrowType::Sphere) // start側の矢印のタイプが球体のとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(start, arrowWidth / 2.0f, DivNum, difColor, spcColor, TRUE);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (endType == ArrowType::Sphere) // end側の矢印のタイプが球体のとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(end, arrowWidth / 2.0f, DivNum, difColor, spcColor, TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return DxLib::DrawLine3D(start, end, color);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 平面のグリッドを描く(平面;plane を end の位置まで Divnum分割して描く)<br>
        &nbsp;&nbsp;&nbsp; static int DrawPlane(const Plane4&amp; plane, const Vector3&amp; end, unsigned int DivNum, unsigned int color = GetColor(255, 255, 255))<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (DivNum == 0) return -1;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 planePos = -plane.dist * plane.n;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 vPlaneEnd = end - planePos;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 vPlaneEndNorm = vPlaneEnd.normalized();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float mag = vPlaneEnd.magnitude();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float divMag = mag / DivNum;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 crossPlaneEndNorm = cross(vPlaneEnd, plane.n).normalized();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (unsigned int i = 1; i &lt;= DivNum; ++i)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for(unsigned int j = 1; j &lt;= DivNum; ++j)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(planePos - divMag * i * vPlaneEndNorm - divMag * i * crossPlaneEndNorm,<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; planePos + divMag * i * vPlaneEndNorm - divMag * i * crossPlaneEndNorm, color);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(planePos - divMag * i * vPlaneEndNorm + divMag * i * crossPlaneEndNorm,<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; planePos + divMag * i * vPlaneEndNorm + divMag * i * crossPlaneEndNorm, color);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(planePos - divMag * i * crossPlaneEndNorm - divMag * i * vPlaneEndNorm,<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; planePos + divMag * i * crossPlaneEndNorm - divMag * i * vPlaneEndNorm, color);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(planePos - divMag * i * crossPlaneEndNorm + divMag * i * vPlaneEndNorm,<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; planePos + divMag * i * crossPlaneEndNorm + divMag * i * vPlaneEndNorm, color);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        #endif<br>
      </p>
      <br>
      <p><code>main.cpp</code>のコードを一旦、ちらかった部分を削除して整理します。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        #include "DataMV1.h"<br>
        #include "DataPly.h"<br>
        #include "Collision3D.h"<br>
        <br>
        #include "Editor.h"<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; float animTime = 0.0f; // アニメの現在時刻<br>
        &nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
        &nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@kick.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;Load(); // 3Dモデルをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilAttackAnimData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@jump.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilAttackAnimData-&gt;Load(); // 3Dの追加アニメデータをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;AttachAnim(*pDevilAttackAnimData); // アニメを追加でflyのほうをベースとしたモデルにアタッチ<br>
        &nbsp;&nbsp;&nbsp; int animeButton = 0; // ボタンでアニメを切り替えられるようにする<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; pTexImage = Resource::MakeShared&lt;Texture&gt;("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; pTexImage-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; assert((int)*pTexImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataPly&gt; pPlyData = Resource::MakeShared&lt;DataPly&gt;("Image/dice.ply");<br>
        &nbsp;&nbsp;&nbsp; pPlyData-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; <br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>SubScreen::UpdateScreens(); // スクリーンの位置やドラッグによる移動を更新する</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードの 0 1 キーで3Dアニメを切り替えられるようにする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_0))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_1))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 1;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width =&nbsp; pTexImage-&gt;m_XSize; float height =&nbsp; pTexImage-&gt;m_YSize; // テクスチャ画像のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f, 1.0f, 1.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(pPlyData-&gt;Vertex.data(), pPlyData-&gt;Vertex.size(), pPlyData-&gt;Index.data(), pPlyData-&gt;numIndex / 3, (int)*pTexImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 100, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ファイルのパス + ":" + アニメ名でアクセス<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string animPathName = (animeButton == 0) ? "Image/devil@kick.mv1:mixamo.com" : "Image/devil@jump.mv1:mixamo.com";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(pDevilData-&gt;count(animPathName) &gt; 0 &amp;&amp; "指定されたアニメ名のアニメはMV1に付属していませんでした");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime += animStepTime * animSpeed; // 1.0×2倍 なら2倍速でアニメ時刻が進む<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animTime &gt; (*pDevilData)[animPathName].endTime)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime = 0.0f; // 0秒目へとアニメをループさせる<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>// 画面奥へ向かう光線レイを求める<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 rayStart = DxLib::ConvScreenPosToWorldPos(VGet(Input::MouseX, Input::MouseY, 0.0f));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 rayEnd = DxLib::ConvScreenPosToWorldPos(VGet(Input::MouseX, Input::MouseY, 1.0f));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(rayStart, rayEnd, GetColor(255, 255, 0));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 球0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 sphere0Center{ 10,10,10 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float sphere0Radius = 10;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 collision0;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision0 = isCollisionSphere_Line(sphere0Center, sphere0Radius, rayStart, rayEnd, &amp;collision0); // 球と光線(レイ)の当たり判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(sphere0Center, sphere0Radius, 16, (isCollision0) ? GetColor(255, 0, 0) : GetColor(255, 255, 255), GetColor(255, 255, 255), FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision0) DxLib::DrawSphere3D(collision0, 0.5, 16, GetColor(255, 0, 0), GetColor(255, 255, 255), TRUE); // レイと当たった部分に赤い球を表示<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 球1<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 sphere1Center{ 10,-10,10 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float sphere1Radius = 10;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 collision1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision1 = isCollisionSphere_Ray(sphere1Center, sphere1Radius, rayStart, rayEnd - rayStart, &amp;collision1); // 球と光線(レイ)の当たり判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(sphere1Center, sphere1Radius, 16, (isCollision1) ? GetColor(0, 255, 0) : GetColor(255, 255, 255), GetColor(255, 255, 255), FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision1) DxLib::DrawSphere3D(collision1, 0.5, 16, GetColor(0, 255, 0), GetColor(255, 255, 255), TRUE); // レイと当たった部分に緑の球を表示</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 再生時間をセットする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1SetAttachAnimTime((int)*pDevilData, (*pDevilData)[animPathName].index, animTime);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 半透明のスクリーンも描ける<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height, GetColor(0, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
          <br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); // サブのスクリーンを全部描く</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); // エディタのDraw処理<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      <br>
      <p><code>main.cpp</code>のコードにドラッグできるコントロール点をもつカプセルや球体やボックスやポリゴン平面を追加します。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        #include "DataMV1.h"<br>
        #include "DataPly.h"<br>
        #include "Collision3D.h"<br>
        <em>#include "MyDraw.h" // 自作の描画処理</em><br>
        <br>
        #include "Editor.h"<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; float animTime = 0.0f; // アニメの現在時刻<br>
        &nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
        &nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@kick.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;Load(); // 3Dモデルをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilAttackAnimData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@jump.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilAttackAnimData-&gt;Load(); // 3Dの追加アニメデータをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;AttachAnim(*pDevilAttackAnimData); // アニメを追加でflyのほうをベースとしたモデルにアタッチ<br>
        &nbsp;&nbsp;&nbsp; int animeButton = 0; // ボタンでアニメを切り替えられるようにする<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; pTexImage = Resource::MakeShared&lt;Texture&gt;("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; pTexImage-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; assert((int)*pTexImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataPly&gt; pPlyData = Resource::MakeShared&lt;DataPly&gt;("Image/dice.ply");<br>
        &nbsp;&nbsp;&nbsp; pPlyData-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; <br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>float radius_lineStart0 = 0.2f, radius_lineEnd1 = 0.2f; // カプセルと球体の半径の初期設定<br>
          &nbsp;&nbsp;&nbsp; // カプセル点(0)<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DragCapsule&gt; lineStart0 = std::make_shared&lt;DragCapsule&gt;(-3, 0, -4, radius_lineStart0, 1.0f, Axis3D::Y, GetColor(255, 165, 165));<br>
          &nbsp;&nbsp;&nbsp; // 球体の点(1)<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DragSphere&gt; lineEnd1 = std::make_shared&lt;DragSphere&gt;(-2, -3, -3.5f, radius_lineEnd1 * 2, GetColor(255, 165, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 三角ポリゴン(2)<br>
          &nbsp;&nbsp;&nbsp; std::vector&lt;std::shared_ptr&lt;DragPoint&gt;&gt; poly2_Pos = { std::make_shared&lt;DragPoint&gt;(-3.0f,-2.0f,-4.0f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::make_shared&lt;DragPoint&gt;(-2.0f,-2.0f,-3.0f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::make_shared&lt;DragPoint&gt;(-2.0f,-2.0f,-4.0f) }; // ポリゴンの3点<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 四角ボックスの点(4)<br>
          &nbsp;&nbsp;&nbsp; Vector3 boxSize{ 1.0f,2.0f,3.0f };<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DragBox&gt; boxPoint4 = std::make_shared&lt;DragBox&gt;(7, -3, 4, boxSize, GetColor(255, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp; std::list&lt;std::weak_ptr&lt;DragPoint&gt;&gt; dragPoints; // ドラッグ対象の点の共有ポインタのリスト<br>
          <br>
          &nbsp;&nbsp;&nbsp; dragPoints.emplace_back(lineStart0); // リストにカプセル点0を追加<br>
          &nbsp;&nbsp;&nbsp; dragPoints.emplace_back(lineEnd1); // リストに球体の点1を追加<br>
          &nbsp;&nbsp;&nbsp; dragPoints.emplace_back(boxPoint4); // リストに四角ボックスの点4を追加<br>
          <br>
          &nbsp;&nbsp;&nbsp; dragPoints.emplace_back(poly2_Pos[0]); // リストにポリゴン2の3点を追加<br>
          &nbsp;&nbsp;&nbsp; dragPoints.emplace_back(poly2_Pos[1]);<br>
          &nbsp;&nbsp;&nbsp; dragPoints.emplace_back(poly2_Pos[2]);</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>editor.UpdateDragPoints(&amp;dragPoints); // ドラッグ点のリストを更新</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if (!editor.isDraggingPoints)　</em>editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードの 0 1 キーで3Dアニメを切り替えられるようにする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_0))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_1))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 1;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width =&nbsp; pTexImage-&gt;m_XSize; float height =&nbsp; pTexImage-&gt;m_YSize; // テクスチャ画像のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f, 1.0f, 1.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(pPlyData-&gt;Vertex.data(), pPlyData-&gt;Vertex.size(), pPlyData-&gt;Index.data(), pPlyData-&gt;numIndex / 3, (int)*pTexImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 100, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ファイルのパス + ":" + アニメ名でアクセス<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string animPathName = (animeButton == 0) ? "Image/devil@kick.mv1:mixamo.com" : "Image/devil@jump.mv1:mixamo.com";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(pDevilData-&gt;count(animPathName) &gt; 0 &amp;&amp; "指定されたアニメ名のアニメはMV1に付属していませんでした");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime += animStepTime * animSpeed; // 1.0×2倍 なら2倍速でアニメ時刻が進む<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animTime &gt; (*pDevilData)[animPathName].endTime)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime = 0.0f; // 0秒目へとアニメをループさせる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 再生時間をセットする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1SetAttachAnimTime((int)*pDevilData, (*pDevilData)[animPathName].index, animTime);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 三角ポリゴン(2)を含む平面<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Plane4 plane_poly2{ *poly2_Pos[0],*poly2_Pos[1],*poly2_Pos[2] }; // 3点を含む平面を求める<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 collision2; // ポリゴン2と線(lineStart0→lineEnd1)の交点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 polygon[3] = { *poly2_Pos[0],*poly2_Pos[1],*poly2_Pos[2] };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角ポリゴン(2) と 線(lineStart0→lineEnd1) の当たり判定 をして 交点collision2 も求める<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision2 = isCollisionPoly_Line(polygon, 3, plane_poly2, *lineStart0, *lineEnd1, &amp;collision2);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角ポリゴン(2)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawTriangle3D(*poly2_Pos[0], *poly2_Pos[1], *poly2_Pos[2], GetColor(255, 255, 255), FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // lineStart0から平面の中心へ向かう線 を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(*lineStart0, -plane_poly2.n * plane_poly2.dist, GetColor(255, 165, 165));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面の中心 から 交点collision2 へ向かう(水色) を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(-plane_poly2.n * plane_poly2.dist, collision2, GetColor(0, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面の中心 に水色の球を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(-plane_poly2.n * plane_poly2.dist, 0.05, 16, GetColor(0, 255, 255), GetColor(255, 255, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面の中心 から 原点 に向かう線(水色)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(-plane_poly2.n * plane_poly2.dist, Vector3{0,0,0}, GetColor(0, 255, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ポリゴンを横切る線lineStart0→lineEnd1を結ぶ線(オレンジ)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(*lineStart0, *lineEnd1, GetColor(255, 165, 0));<br>
          &nbsp;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 collisionRay2; // 三角ポリゴン(2)とマウスカーソルの光線(rayPos)の交点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollisionRay2 = isCollisionPoly_Line(polygon, 3, plane_poly2, rayStart, rayEnd - rayStart, &amp;collisionRay2);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // カメラの始点から飛ばしたレイと三角ポリゴン(2)の交点に目印の球を描画<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollisionRay2) DxLib::DrawSphere3D(collisionRay2, 0.01, 16, GetColor(255, 165, 0), GetColor(255, 255, 255), FALSE);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角ポリゴン(2)の存在する平面を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawPlane(plane_poly2, *poly2_Pos[0], 8,GetColor(0,255,255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角ポリゴン(2)の存在する平面の単位法線方向の矢印(緑色)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawArrow3D(-plane_poly2.n * plane_poly2.dist, -plane_poly2.n * plane_poly2.dist + plane_poly2.n,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::ArrowType::None, MyDraw::ArrowType::Cone, 0.1f, 0.2f, GetColor(0, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面と軸並行ボックス(4)AABBの当たり判定とその押し戻しゴーストを描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 boxMin, boxMax, boxCenter;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boxPoint4-&gt;GetParams(boxCenter, boxMin, boxMax);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float distAABB; // 押し戻し距離(当たってないときは平面までの距離)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollisionPlaneAABB = isCollisionPlane_AABB(plane_poly2, boxMin, boxMax, &amp;distAABB);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollisionPlaneAABB) // 平面とボックスが衝突したら↓法線×押し戻し距離 ぶんずらしてゴーストを描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawCube3D(boxMin + plane_poly2.n * distAABB,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boxMax + plane_poly2.n * distAABB, GetColor(255, 255, 255), GetColor(255, 255, 255), FALSE);<br>
          &nbsp;&nbsp; &nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面とカプセル(0)の当たり判定とその押し戻しゴーストを描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 centerCapsule, startCapsule, endCapsule;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float radiusCapsule;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lineStart0-&gt;GetParams(centerCapsule, startCapsule, endCapsule, radiusCapsule); // 線の始点lineStart0からカプセル(0)のパラメータを得る<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float distCapsule; // 平面からカプセルをどれだけ押しもどせば当たらなくなるかの距離<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollisionPlaneCapsule = isCollisionPlane_Capsule(plane_poly2, startCapsule, endCapsule, radiusCapsule, &amp;distCapsule);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollisionPlaneCapsule) // 平面とカプセルが衝突していたら、平面の法線n方向に押し戻したゴーストを描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawCapsule3D(startCapsule + plane_poly2.n * distCapsule,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endCapsule + plane_poly2.n * distCapsule, radiusCapsule, 8, GetColor(255, 255, 255), GetColor(255, 255, 255), FALSE);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面と球体(1)の当たり判定とその押し戻しゴーストを描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float sphereRadius;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 sphereCenter;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lineEnd1-&gt;GetParams(sphereCenter, sphereRadius); // 線の終点lineEnd1から球体(1)のパラメータを得る<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float distSphere; // 平面から球をどれだけ押し戻せば当たらなくなるかの距離 <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollisionPlaneSphere = isCollisionPlane_Sphere(plane_poly2, sphereCenter, sphereRadius, &amp;distSphere);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollisionPlaneSphere) // 平面と球が衝突していたら、平面の法線n方向に押し戻したゴーストを描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(*lineEnd1 + plane_poly2.n * distSphere, sphereRadius, 8, GetColor(255, 255, 255), GetColor(255, 255, 255), FALSE);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision2)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 三角ポリゴン(2)と線(lineStart0→lineEnd1)の交わった交点に橙の球を表示<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(collision2, 0.05, 16, GetColor(255, 165, 0), GetColor(255, 255, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 球の中心とポリゴンの3点を結ぶ線の角度の合計がほぼ360度(2π)になるかがポリゴン内部かの判定条件となる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(collision2, *poly2_Pos[0], GetColor(255, 165, 165));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(collision2, *poly2_Pos[1], GetColor(255, 165, 165));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(collision2, *poly2_Pos[2], GetColor(255, 165, 165));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ドラッグ点とその当たり判定のオブジェクト(ボックスや球やカプセルなど)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto dragPoint : dragPoints)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dragPoint.lock()-&gt;Draw(); //ドラッグ点とそのまわりに広がる当たり判定範囲のカプセルやボックスなどをまとめて描く</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); // エディタのDraw処理<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？四角い点をドラッグすることで当たり判定の中心位置をコントロールすることができるようになったでしょうか？<br>
      ポリゴンの3点を移動させると、球やカプセルの押し戻し位置のゴーストも変わることも試して、平面との当たり判定を確かめてみましょう。<br>
      <br>
      <br>
    </a><a id="mozTocId0015" class="mozTocH1">
      <h1>3Dモデルをクオータニオンで安定して回転できるようにする</h1>
    </a> <code>Quaternion.hを新規作成</code>して<a href="https://qiita.com/Arihi/items/4b306feb3d9e6cd93204">ジンバルロック</a><a

      id="mozTocId0015" class="mozTocH1">の心配のない回転の定義を追加しましょう。<br>
      <p class="source">#ifndef QUATERNION_H_<br>
        #define QUATERNION_H_<br>
        <br>
        #include "DxLib.h"<br>
        #include &lt;cmath&gt;<br>
        #include &lt;vector&gt;<br>
        #include "Vector3.h"<br>
        <br>
        // クオータニオン http://noa1105.seesaa.net/article/239449116.html<br>
        struct Quaternion<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float x, y, z, w;<br>
        &nbsp;&nbsp;&nbsp; VECTOR eular(); // オイラー角を得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Quaternion(float x = 0.0f, float y = 0.0f, float z = 0.0f, float w = 1.0f) : x{ x }, y{ y }, z{ z }, w{ w } {}<br>
        <br>
        &nbsp;&nbsp;&nbsp; ~Quaternion() {}<br>
        <br>
        &nbsp;&nbsp;&nbsp; //[コンストラクタ] 回転クォータニオン Axis軸(x軸,y軸,z軸)周りにradianの角度回転したクオータニオンを生成<br>
        &nbsp;&nbsp;&nbsp; inline Quaternion(float radian, const Vector3&amp; axis) : w{ 1.0f }, x{ 0.0f }, y{ 0.0f }, z{ 0.0f }<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; setRotate(radian, axis.x, axis.y, axis.z);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // axis軸周り に 回転角度radian 回転したクオータニオンを設定する <br>
        &nbsp;&nbsp;&nbsp; inline Quaternion&amp; setRotate(float radian, float axisX, float axisY, float axisZ)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float norm, cos_rad2, sin_rad2;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; norm = axisX * axisX + axisY * axisY + axisZ * axisZ;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (norm &lt;= 0.0f) return *this; // normの2乗 が 0 なら そのままreturn<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; norm = 1.0 / std::sqrt(norm);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; axisX *= norm; axisY *= norm; axisZ *= norm;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cos_rad2 = std::cosf(radian / 2.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sin_rad2 = std::sinf(radian / 2.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; w = cos_rad2;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; x = sin_rad2 * axisX;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; y = sin_rad2 * axisY;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; z = sin_rad2 * axisZ;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // axis軸周り に 回転角度radian 回転したクオータニオンを設定する <br>
        &nbsp;&nbsp;&nbsp; inline Quaternion&amp; setRotate(float radian, const Vector3&amp; axis)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return setRotate(radian, axis.x, axis.y, axis.z);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ヨー ピッチ ロールで指定する形でクオータニオンの回転を設定する<br>
        &nbsp;&nbsp;&nbsp; inline Quaternion&amp; setYawPitchRoll(float yaw, float pitch, float roll)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //[ヨー ピッチ ロールについて] http://fantom1x.blog130.fc2.com/blog-entry-255.html<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float sinYaw&nbsp;&nbsp; = std::sinf(yaw / 2.0f),&nbsp;&nbsp; cosYaw&nbsp;&nbsp; = std::cosf(yaw / 2.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float sinPitch = std::sinf(pitch / 2.0f), cosPitch = std::cosf(pitch / 2.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float sinRoll&nbsp; = std::sinf(roll / 2.0f),&nbsp; cosRoll&nbsp; = std::cosf(roll / 2.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; x = sinRoll * cosPitch * cosYaw - cosRoll * sinPitch * sinYaw;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; y = cosRoll * sinPitch * cosYaw + sinRoll * cosPitch * sinYaw;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; z = cosRoll * cosPitch * sinYaw - sinRoll * sinPitch * cosYaw;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; w = cosRoll * cosPitch * cosYaw + sinRoll * sinPitch * sinYaw;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; // 単位クオータニオンを返す<br>
        &nbsp;&nbsp;&nbsp; static Quaternion identity()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Quaternion{ 0.0f, 0.0f, 0.0f, 1.0f };<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // クオータニオンの大きさ<br>
        &nbsp;&nbsp;&nbsp; inline float magnitude() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return std::sqrtf(x * x + y * y + z * z + w * w); // √(x*x + y*y + z*z + w*w)<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // クオータニオンの大きさの2乗<br>
        &nbsp;&nbsp;&nbsp; inline float sqrMagnitude() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return x * x + y * y + z * z + w * w;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 正規化したクオータニオンを返す<br>
        &nbsp;&nbsp;&nbsp; inline Quaternion normalized() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float mag = magnitude();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (mag &lt; 0.00001f) // ほぼ0か？<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Quaternion{ 0.0f, 0.0f, 0.0f, 0.0f };<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Quaternion{ x / mag, y / mag, z / mag, w / mag }; // x / |x|, y / |y|, z / |z|, w / |w|<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 自身(this)を正規化する<br>
        &nbsp;&nbsp;&nbsp; inline Quaternion&amp; normalize()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *this = this-&gt;normalized(); // 自身を正規化したクオータニオンに置き換える<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; // 逆クオータニオンを返す(メンバ関数版)<br>
        &nbsp;&nbsp;&nbsp; inline Quaternion inverse() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float mag = magnitude();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (mag &lt; 0.00001f) // ほぼ0か？<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Quaternion{ 0.0f, 0.0f, 0.0f, 0.0f };<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Quaternion{ -x / mag, -y / mag, -z / mag, w / mag }; // -x / |x|, -y / |y|, -z / |z|, w / |w|<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // クオータニオンからx,y,z軸Axis軸周りの回転角度 result_radian と 軸axisをreturnする<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 getAxisAngle(float* result_radian = nullptr) const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float angle = std::acosf(w);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float sin_angle = std::sinf(angle);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (result_radian != nullptr) *result_radian = angle * 2.0f; // result_radianに計算した角度を返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector3{ x / sin_angle, y / sin_angle, z / sin_angle };<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 回転角度だけを求める<br>
        &nbsp;&nbsp;&nbsp; inline float getAngle() const { return std::acosf(w) * 2.0f; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ヨーを求める(単位:ラジアン)<br>
        &nbsp;&nbsp;&nbsp; inline float getYaw() const { return std::asin(-2.0f * (x * z - w * y)); }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ピッチを求める(単位:ラジアン)<br>
        &nbsp;&nbsp;&nbsp; inline float getPitch() const { return std::atan2(w * w - x * x - y * y + z * z, 2.0f * (y * z + w * x)); }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ロールを求める(単位:ラジアン)<br>
        &nbsp;&nbsp;&nbsp; inline float getRoll() const { return std::atan2(w * w + x * x - y * y - z * z, 2.0f * (x * y + w * z)); }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 演算子operatorのオーバーロード<br>
        <br>
        &nbsp;&nbsp;&nbsp; // マイナスをつけたクオータニオン<br>
        &nbsp;&nbsp;&nbsp; inline Quaternion operator -() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Quaternion{ -x, -y, -z, -w };<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // プラスをつけたクオータニオン<br>
        &nbsp;&nbsp;&nbsp; inline Quaternion operator + () const { return *this; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // +=加算演算子のオーバーロード<br>
        &nbsp;&nbsp;&nbsp; inline Quaternion operator += (const Quaternion&amp; right)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; x = x + right.x;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; y = y + right.y;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; z = z + right.z;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; w = w + right.w;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // -=減算演算子のオーバーロード<br>
        &nbsp;&nbsp;&nbsp; inline Quaternion operator -= (const Quaternion&amp; right)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; x = x - right.x;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; y = y - right.y;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; z = z - right.z;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; w = w - right.w;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // *= クオータニオン同士の掛け算演算子のオーバーロード<br>
        &nbsp;&nbsp;&nbsp; inline Quaternion operator *= (const Quaternion&amp; right)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Quaternion tmp{x,y,z,w};<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; w = tmp.w * right.w - (tmp.x * right.x + tmp.y * right.y + tmp.z * right.z);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; x = tmp.w * right.x + right.w * tmp.x + (tmp.y * right.z - tmp.z * right.y);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; y = tmp.w * right.y + right.w * tmp.y + (tmp.z * right.x - tmp.x * right.z);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; z = tmp.w * right.z + right.w * tmp.z + (tmp.x * right.y - tmp.y * right.x);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // *= クオータニオンの数値倍の掛け算演算子のオーバーロード<br>
        &nbsp;&nbsp;&nbsp; inline Quaternion operator *= (float right)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; w = w * right;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; x = x * right;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; y = y * right;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; z = z * right;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // /= クオータニオンを数値で割る演算子のオーバーロード<br>
        &nbsp;&nbsp;&nbsp; inline Quaternion operator /= (float right)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; w = w / right;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; x = x / right;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; y = y / right;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; z = z / right;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void SetRotation(VECTOR eularAngle); // 0～360度のオイラー角でクオータニオンを再設定する<br>
        private:<br>
        &nbsp;&nbsp;&nbsp; VECTOR _eular = VGet(0, 0, 0); // 0～360度のオイラー角<br>
        };<br>
        <br>
        // クォータニオンどうしを足し算<br>
        inline Quaternion operator + (const Quaternion&amp; left, const Quaternion&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Quaternion result;<br>
        &nbsp;&nbsp;&nbsp; result.x = left.x + right.x;<br>
        &nbsp;&nbsp;&nbsp; result.y = left.y + right.y;<br>
        &nbsp;&nbsp;&nbsp; result.z = left.z + right.z;<br>
        &nbsp;&nbsp;&nbsp; result.w = left.w + right.w;<br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        }<br>
        <br>
        // クォータニオンどうしで引き算<br>
        inline Quaternion operator - (const Quaternion&amp; left, const Quaternion&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Quaternion result;<br>
        &nbsp;&nbsp;&nbsp; result.x = left.x - right.x;<br>
        &nbsp;&nbsp;&nbsp; result.y = left.y - right.y;<br>
        &nbsp;&nbsp;&nbsp; result.z = left.z - right.z;<br>
        &nbsp;&nbsp;&nbsp; result.w = left.w - right.w;<br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        }<br>
        <br>
        // クォータニオンどうしのかけ算を計算<br>
        inline Quaternion operator * (const Quaternion&amp; q1, const Quaternion&amp; q2)<br>
        {&nbsp;&nbsp;&nbsp; // w,x,y,zパラメータの計算<br>
        &nbsp;&nbsp;&nbsp; Quaternion result;<br>
        &nbsp;&nbsp;&nbsp; result.w = q1.w * q2.w - (q1.x * q2.x + q1.y * q2.y + q1.z * q2.z);<br>
        &nbsp;&nbsp;&nbsp; result.x = q1.w * q2.x + q2.w * q1.x + (q1.y * q2.z - q1.z * q2.y);<br>
        &nbsp;&nbsp;&nbsp; result.y = q1.w * q2.y + q2.w * q1.y + (q1.z * q2.x - q1.x * q2.z);<br>
        &nbsp;&nbsp;&nbsp; result.z = q1.w * q2.z + q2.w * q1.z + (q1.x * q2.y - q1.y * q2.x);<br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        }<br>
        <br>
        // クォータニオンをスカラー倍する乗算(右側にfloat)<br>
        inline Quaternion operator * (const Quaternion&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Quaternion result;<br>
        &nbsp;&nbsp;&nbsp; result.x = left.x * right;<br>
        &nbsp;&nbsp;&nbsp; result.y = left.y * right;<br>
        &nbsp;&nbsp;&nbsp; result.z = left.z * right;<br>
        &nbsp;&nbsp;&nbsp; result.w = left.w * right;<br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        }<br>
        <br>
        // クォータニオンをスカラー倍する乗算(左側にfloat)<br>
        inline Quaternion operator * (float left, const Quaternion&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return right * left; // 上の定義(左:クオータニオン)を再利用する<br>
        }<br>
        <br>
        // ベクトルにクォータニオンをかけ算して座標変換<br>
        inline Vector3 operator * (const Quaternion&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 result;<br>
        &nbsp;&nbsp;&nbsp; float _2x = left.x * 2.0f, _2y = left.y * 2.0f, _2z = left.z * 2.0f;<br>
        &nbsp;&nbsp;&nbsp; float x2x = left.x * _2x,&nbsp; y2y = left.y * _2y,&nbsp; z2z = left.z * _2z;<br>
        &nbsp;&nbsp;&nbsp; float x2y = left.x * _2y,&nbsp; x2z = left.x * _2z,&nbsp; y2z = left.y * _2z;<br>
        &nbsp;&nbsp;&nbsp; float w2x = left.w * _2x,&nbsp; w2y = left.w * _2y,&nbsp; w2z = left.w * _2z;<br>
        <br>
        &nbsp;&nbsp;&nbsp; result.x = (1.0f - (y2y + z2z)) * right.x + (x2y - w2z) * right.y + (x2z + w2y) * right.z;<br>
        &nbsp;&nbsp;&nbsp; result.y = (x2y + w2z) * right.x + (1.0f - (x2x + z2z)) * right.y + (y2z - w2x) * right.z;<br>
        &nbsp;&nbsp;&nbsp; result.z = (x2z - w2y) * right.x + (y2z + w2x) * right.y + (1.0f - (x2x + y2y)) * right.z;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        }<br>
        <br>
        // 一致演算子のオーバーロード<br>
        inline bool operator == (const Quaternion&amp; q1, const Quaternion&amp; q2)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return (q1.x == q2.x &amp;&amp; q1.y == q2.y &amp;&amp; q1.z == q2.z &amp;&amp; q1.w == q2.w);<br>
        }<br>
        <br>
        // 不一致演算子のオーバーロード<br>
        inline bool operator != (const Quaternion&amp; q1, const Quaternion&amp; q2)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return !(q1 == q2);<br>
        }<br>
        <br>
        <br>
        // クオータニオンの内積<br>
        inline float dot(const Quaternion&amp; q1, const Quaternion&amp; q2)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;<br>
        }<br>
        <br>
        // クオータニオンの線形補間 q1→q2へ(t:補間値パラメータ)<br>
        inline Quaternion lerp(const Quaternion&amp; q1, const Quaternion&amp; q2, float t)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Quaternion result;<br>
        &nbsp;&nbsp;&nbsp; result.x = q1.x * (1 - t) + q2.x * t; // t と 1-tの比率でブレンド<br>
        &nbsp;&nbsp;&nbsp; result.y = q1.y * (1 - t) + q2.y * t;<br>
        &nbsp;&nbsp;&nbsp; result.z = q1.z * (1 - t) + q2.z * t;<br>
        &nbsp;&nbsp;&nbsp; result.w = q1.w * (1 - t) + q2.w * t;<br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        }<br>
        <br>
        // クオータニオンの球面線形補間 q1→q2(t:補間値パラメータ)<br>
        inline Quaternion slerp(const Quaternion&amp; q1, const Quaternion&amp; q2, float t)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Quaternion result;<br>
        &nbsp;&nbsp;&nbsp; Quaternion q2_dash;<br>
        &nbsp;&nbsp;&nbsp; float cos_theta = q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;<br>
        &nbsp;&nbsp;&nbsp; if (cos_theta &lt; 0.0f) // cosθが0以下のときは<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cos_theta = -cos_theta; // cosθに-をつけて+にする<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; q2_dash = -q2; // q2も-をつけて+にしておく<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; q2_dash = q2; // cosθ &gt;= 0のときはそのままq2を使う<br>
        <br>
        &nbsp;&nbsp;&nbsp; float _1_t = 1.0f - t;<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (1.0f - cos_theta &gt; 0.001f) // cosθが1.0fではないときは<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 球面線形補間では t と 1-tの代わりに 角度θについてのtと1-t での sinθで補間<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float theta = std::acosf(cos_theta);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; _1_t = std::sinf(theta * _1_t) / std::sinf(theta);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; t = std::sinf(theta * t) / std::sinf(theta);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // t と _1_t を使って球面線形補間を計算する<br>
        &nbsp;&nbsp;&nbsp; result.x = q1.x * _1_t + q2_dash.x * t;<br>
        &nbsp;&nbsp;&nbsp; result.y = q1.y * _1_t + q2_dash.y * t;<br>
        &nbsp;&nbsp;&nbsp; result.z = q1.z * _1_t + q2_dash.z * t;<br>
        &nbsp;&nbsp;&nbsp; result.w = q1.w * _1_t + q2_dash.w * t;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result.normalized(); // 正規化normalizeしてから返す<br>
        }<br>
        <br>
        // 回転クォータニオン Axis軸(x軸,y軸,z軸)周りにradianの角度回転したクオータニオンを生成<br>
        inline Quaternion CreateRotationQuaternion(double radian, VECTOR axis)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Quaternion result;<br>
        &nbsp;&nbsp;&nbsp; float norm, cos_rad2, sin_rad2;<br>
        &nbsp;&nbsp;&nbsp; result.w = result.x = result.y = result.z = 0.0;<br>
        <br>
        &nbsp;&nbsp;&nbsp; norm = axis.x * axis.x + axis.y * axis.y + axis.z * axis.z;<br>
        &nbsp;&nbsp;&nbsp; if (norm &lt;= 0.0) return result;<br>
        <br>
        &nbsp;&nbsp;&nbsp; norm = 1.0 / std::sqrt(norm);<br>
        &nbsp;&nbsp;&nbsp; axis.x *= norm;<br>
        &nbsp;&nbsp;&nbsp; axis.y *= norm;<br>
        &nbsp;&nbsp;&nbsp; axis.z *= norm;<br>
        <br>
        &nbsp;&nbsp;&nbsp; cos_rad2 = std::cosf(radian / 2.0f);<br>
        &nbsp;&nbsp;&nbsp; sin_rad2 = std::sinf(radian / 2.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp; result.w = cos_rad2;<br>
        &nbsp;&nbsp;&nbsp; result.x = sin_rad2 * axis.x;<br>
        &nbsp;&nbsp;&nbsp; result.y = sin_rad2 * axis.y;<br>
        &nbsp;&nbsp;&nbsp; result.z = sin_rad2 * axis.z;<br>
        <br>
        #if 0 // [比較]DXライブラリの回転を表すクォータニオンを返す関数<br>
        &nbsp;&nbsp;&nbsp; // 回転を表すクォータニオンを返す<br>
        &nbsp;&nbsp;&nbsp; extern FLOAT4 QTRot(VECTOR Axis, float Angle)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; FLOAT4 Result;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float Cos;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float Sin;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float Square;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float Size;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Square = Axis.x * Axis.x + Axis.y * Axis.y + Axis.z * Axis.z;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Square &lt; 0.0000001f)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return F4Get(-1.0f, -1.0f, -1.0f, -1.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Size = _SQRT(Square);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; _SINCOS(0.5f * Angle, &amp;Sin, &amp;Cos);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Result.w = Cos;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Result.x = Axis.x / Size * Sin;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Result.y = Axis.y / Size * Sin;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Result.z = Axis.z / Size * Sin;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Result;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        #endif<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        }<br>
        <br>
        //クオータニオンを基礎となるbaseMatとオイラー角(pitchX,yawY,rollZ)から得る<br>
        inline Quaternion GetQuaternion(MATRIX&amp; baseMat, VECTOR eularAngle)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // [DXでクオータニオン] http://noa1105.seesaa.net/article/239449116.html<br>
        &nbsp;&nbsp;&nbsp; Quaternion quaternion;&nbsp; //クォータニオン<br>
        &nbsp;&nbsp;&nbsp; float pitchX = eularAngle.x, yawY = eularAngle.y, rollZ = eularAngle.z;<br>
        &nbsp;&nbsp;&nbsp; //float yaw = m_rotation.x, pitch = m_rotation.y, roll = m_rotation.z;<br>
        &nbsp;&nbsp;&nbsp; // [z→x→yの順に回転] https://qiita.com/fullmated/items/ac62ebd1206a6487232d<br>
        &nbsp;&nbsp;&nbsp; //ロール<br>
        &nbsp;&nbsp;&nbsp; VECTOR zAxis = VGet(baseMat.m[2][0], baseMat.m[2][1], baseMat.m[2][2]);<br>
        &nbsp;&nbsp;&nbsp; quaternion = quaternion * CreateRotationQuaternion(rollZ, zAxis);<br>
        &nbsp;&nbsp;&nbsp; //ピッチ<br>
        &nbsp;&nbsp;&nbsp; VECTOR xAxis = VGet(baseMat.m[0][0], baseMat.m[0][1], baseMat.m[0][2]);<br>
        &nbsp;&nbsp;&nbsp; quaternion = quaternion * CreateRotationQuaternion(pitchX, xAxis);<br>
        &nbsp;&nbsp;&nbsp; //ヨー<br>
        &nbsp;&nbsp;&nbsp; VECTOR yAxis = VGet(baseMat.m[1][0], baseMat.m[1][1], baseMat.m[1][2]);<br>
        &nbsp;&nbsp;&nbsp; quaternion = quaternion * CreateRotationQuaternion(yawY, yAxis);<br>
        <br>
        &nbsp;&nbsp;&nbsp; return quaternion;<br>
        }<br>
        <br>
        //位置クォータニオン<br>
        inline Quaternion CreateXYZToQuaternion(double PosX, double PosY, double PosZ)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Quaternion ans;<br>
        &nbsp;&nbsp;&nbsp; ans.w = 0.0;<br>
        &nbsp;&nbsp;&nbsp; ans.x = PosX;<br>
        &nbsp;&nbsp;&nbsp; ans.y = PosY;<br>
        &nbsp;&nbsp;&nbsp; ans.z = PosZ;<br>
        &nbsp;&nbsp;&nbsp; return ans;<br>
        }<br>
        <br>
        //クォータニオンから回転行列へ<br>
        inline MATRIX QuaternionToMatrix(Quaternion q)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; MATRIX mat = MGetIdent();<br>
        &nbsp;&nbsp;&nbsp; //X軸<br>
        &nbsp;&nbsp;&nbsp; mat.m[0][0] = 1.0f - 2.0f * q.y * q.y - 2.0f * q.z * q.z;<br>
        &nbsp;&nbsp;&nbsp; mat.m[0][1] = 2.0f * q.x * q.y + 2.0f * q.w * q.z;<br>
        &nbsp;&nbsp;&nbsp; mat.m[0][2] = 2.0f * q.x * q.z - 2.0f * q.w * q.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; //Y軸<br>
        &nbsp;&nbsp;&nbsp; mat.m[1][0] = 2.0f * q.x * q.y - 2.0f * q.w * q.z;<br>
        &nbsp;&nbsp;&nbsp; mat.m[1][1] = 1.0f - 2.0f * q.x * q.x - 2.0f * q.z * q.z;<br>
        &nbsp;&nbsp;&nbsp; mat.m[1][2] = 2.0f * q.y * q.z + 2.0f * q.w * q.x;<br>
        <br>
        &nbsp;&nbsp;&nbsp; //Z軸<br>
        &nbsp;&nbsp;&nbsp; mat.m[2][0] = 2.0f * q.x * q.z + 2.0f * q.w * q.y;<br>
        &nbsp;&nbsp;&nbsp; mat.m[2][1] = 2.0f * q.y * q.z - 2.0f * q.w * q.x;<br>
        &nbsp;&nbsp;&nbsp; mat.m[2][2] = 1.0f - 2.0f * q.x * q.x - 2.0f * q.y * q.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return mat;<br>
        }<br>
        <br>
        // クオータニオンを角度(単位:ラジアン0～2π)へ<br>
        inline VECTOR ToAngle(float x, Quaternion q)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; double cosX = std::cos(x);<br>
        <br>
        &nbsp;&nbsp;&nbsp; double sinY = (2 * q.x * q.z + 2 * q.y * q.w) / cosX;<br>
        &nbsp;&nbsp;&nbsp; double cosY = (2 * std::pow(q.w, 2) + 2 * std::pow(q.z, 2) - 1) / cosX;<br>
        &nbsp;&nbsp;&nbsp; double y = std::atan2(sinY, cosY);<br>
        <br>
        &nbsp;&nbsp;&nbsp; double sinZ = (2 * q.x * q.y + 2 * q.z * q.w) / cosX;<br>
        &nbsp;&nbsp;&nbsp; double cosZ = (2 * std::pow(q.w, 2) + 2 * std::pow(q.y, 2) - 1) / cosX;<br>
        &nbsp;&nbsp;&nbsp; double z = std::atan2(sinZ, cosZ);<br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR angles;<br>
        &nbsp;&nbsp;&nbsp; angles.x = std::fmodf((x &gt; 0.0f) ? x : 2.0f * DX_PI_F + x, 2.0f * DX_PI_F); //2π=360 [xを0.0～2πの範囲に] https://mathwords.net/razian<br>
        &nbsp;&nbsp;&nbsp; angles.y = std::fmodf((y &gt; 0.0f) ? y : 2.0f * DX_PI_F + y, 2.0f * DX_PI_F);<br>
        &nbsp;&nbsp;&nbsp; angles.z = std::fmodf((z &gt; 0.0f) ? z : 2.0f * DX_PI_F + z, 2.0f * DX_PI_F);<br>
        &nbsp;&nbsp;&nbsp; return angles;<br>
        }<br>
        <br>
        // クオータニオンを角度へ(単位:ラジアン0～2π) [ジンバルロック状態のとき]https://qiita.com/yaegaki/items/7b6b1f487553def8e647<br>
        inline VECTOR ToAngleZimbalLock(float x, float z, Quaternion q)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float y;<br>
        &nbsp;&nbsp;&nbsp; if (x &gt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; double yMinusZ = std::atan2(2 * q.x * q.y - 2 * q.z * q.w, 2 * std::pow(q.w, 2) + 2 * std::pow(q.x, 2) - 1);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; y = yMinusZ + z;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; double yPlusZ = std::atan2(-(2 * q.x * q.y - 2 * q.z * q.w), 2 * std::pow(q.w, 2) + 2 * std::pow(q.x, 2) - 1);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; y = yPlusZ - z;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR angles;<br>
        &nbsp;&nbsp;&nbsp; angles.x = std::fmodf((x &gt; 0.0f) ? x : 2.0f * DX_PI_F + x, 2.0f * DX_PI_F); //2π=360 [xを0.0～2πの範囲に] https://mathwords.net/razian<br>
        &nbsp;&nbsp;&nbsp; angles.y = std::fmodf((y &gt; 0.0f) ? y : 2.0f * DX_PI_F + y, 2.0f * DX_PI_F);<br>
        &nbsp;&nbsp;&nbsp; angles.z = std::fmodf((z &gt; 0.0f) ? z : 2.0f * DX_PI_F + z, 2.0f * DX_PI_F);<br>
        &nbsp;&nbsp;&nbsp; return angles;<br>
        }<br>
        <br>
        // 同じ回転を表す角度を取得する https://qiita.com/yaegaki/items/7b6b1f487553def8e647<br>
        inline VECTOR GetSameRotationAngle(VECTOR angle)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; VECTOR sameRot;<br>
        &nbsp;&nbsp;&nbsp; // x = 180度 - x, y = 180度 + y, z = 180度 + z つまり π - x, π + y, π + z が同じ回転の角度の候補<br>
        &nbsp;&nbsp;&nbsp; sameRot.x = DX_PI_F - angle.x;<br>
        &nbsp;&nbsp;&nbsp; sameRot.y = DX_PI_F + angle.y;<br>
        &nbsp;&nbsp;&nbsp; sameRot.z = DX_PI_F + angle.z;<br>
        &nbsp;&nbsp;&nbsp; return sameRot;<br>
        }<br>
        <br>
        // クオータニオンを角度(単位:ラジアン)に戻す: return オイラー角度(x,y,z)それぞれの軸の回転ラジアン<br>
        inline std::vector&lt;VECTOR&gt; QuaternionToAngle(Quaternion q)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; double sinX = 2 * q.y * q.z - 2 * q.x * q.w;<br>
        &nbsp;&nbsp;&nbsp; double absSinX = std::abs(sinX); // 角度の絶対値(単位:ラジアン)<br>
        &nbsp;&nbsp;&nbsp; const double threshold = 0.001;<br>
        &nbsp;&nbsp;&nbsp; // X軸の回転が0度付近の場合、0になるか360で差が大きいので0に丸める<br>
        &nbsp;&nbsp;&nbsp; if (absSinX &lt; threshold)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sinX = 0.0;<br>
        <br>
        &nbsp;&nbsp;&nbsp; //[オイラー角とジンバルロック(±90度のとき無数に角度がありうる)]https://qiita.com/yaegaki/items/7b6b1f487553def8e647<br>
        &nbsp;&nbsp;&nbsp; float x = (float)std::asin(-sinX);<br>
        &nbsp;&nbsp;&nbsp; // X軸の回転が90度付近の場合はジンバルロック状態になっている<br>
        &nbsp;&nbsp;&nbsp; if (std::isnan(x) || std::abs((std::abs(x) - DX_PI_F / 2)) &lt; threshold)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float sign = (sinX &lt; 0) ? -1.0f : 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; x = sign * (DX_PI_F / 2);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR result = ToAngleZimbalLock(x, 0.0f, q); // // Z = 0.0fの時の角度を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return { result, GetSameRotationAngle(result) }; //それと同じ回転を表す角度も候補として返す<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // x 度と π-x 度の2種類の角度とそれらと同じ回転を表す角度も候補として返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR result1 = ToAngle(x, q);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR result2 = ToAngle(DX_PI_F - x, q);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return { result1, result2, GetSameRotationAngle(result1),GetSameRotationAngle(result2) };<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        #if 0<br>
        &nbsp;&nbsp;&nbsp; //[回転行列から角度に戻す]https://qiita.com/q_tarou/items/46e5045068742dfb2fa6<br>
        &nbsp;&nbsp;&nbsp; VECTOR resultAngle; // オイラー角度(x,y,z)それぞれの軸の回転ラジアン<br>
        &nbsp;&nbsp;&nbsp; MATRIX matRot = QuaternionToMatrix(q); // クオータニオンから回転行列を得る<br>
        &nbsp;&nbsp;&nbsp; const double threshold = 0.001;<br>
        &nbsp;&nbsp;&nbsp; if (std::abs(matRot.m[2][1] - 1.0) &lt; threshold) // matRot.m[2][1] = sin(x) = 1の時<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; resultAngle.x = DX_PI_F / 2;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; resultAngle.y = 0;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; resultAngle.z = std::atan2(matRot.m[1][0], matRot.m[0][0]);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (std::abs(matRot.m[2][1] + 1.0) &lt; threshold) // matRot.m[2][1] = sin(x) = -1の時<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; resultAngle.x = -DX_PI_F / 2;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; resultAngle.y = 0;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; resultAngle.z = std::atan2(matRot.m[1][0], matRot.m[0][0]);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; resultAngle.x = std::asin(matRot.m[2][1]);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; resultAngle.y = std::atan2(-matRot.m[2][0], matRot.m[2][2]);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; resultAngle.z = std::atan2(-matRot.m[0][1], matRot.m[1][1]);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return resultAngle;<br>
        #endif<br>
        }<br>
        <br>
        inline VECTOR Quaternion::eular() // オイラー角を得る<br>
        {<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;VECTOR&gt; angles = QuaternionToAngle(*this); // クオータニオンを角度(単位:ラジアン)に戻す<br>
        &nbsp;&nbsp;&nbsp; float xDifMin = angles[0].x - _eular.x; // 現在の角度との差をとる<br>
        &nbsp;&nbsp;&nbsp; xDifMin = (xDifMin &lt; 0) ? -xDifMin : xDifMin; // 絶対値に直す<br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 1, iSize = angles.size(); i &lt; iSize; ++i) // 角度の候補が2つ以上あるので一番現在の角度との差が小さい角度を採用する<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float xDif = angles[1].x - _eular.x; // 現在の角度との差をとる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; xDif = (xDif &lt; 0) ? -xDif : xDif; // 絶対値に直す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; angles[0].x = (xDifMin &lt; xDif) ? angles[0].x : angles[i].x; // 差が小さい方の角度を採用する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; angles[0].y = (xDifMin &lt; xDif) ? angles[0].y : angles[i].y;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; angles[0].z = (xDifMin &lt; xDif) ? angles[0].z : angles[i].z;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; _eular.x = angles[0].x * 180.0f / DX_PI_F;<br>
        &nbsp;&nbsp;&nbsp; _eular.y = angles[0].y * 180.0f / DX_PI_F;<br>
        &nbsp;&nbsp;&nbsp; _eular.z = angles[0].z * 180.0f / DX_PI_F;<br>
        &nbsp;&nbsp;&nbsp; return _eular;<br>
        }<br>
        <br>
        // 0～360度のオイラー角でクオータニオンを再設定する<br>
        inline void Quaternion::SetRotation(VECTOR eularAngle)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; this-&gt;_eular = eularAngle;<br>
        &nbsp;&nbsp;&nbsp; VECTOR radAngle = VGet(eularAngle.x / 180.0f * DX_PI_F, eularAngle.y / 180.0f * DX_PI_F, eularAngle.z / 180.0f * DX_PI_F);<br>
        &nbsp;&nbsp;&nbsp; MATRIX mat;<br>
        &nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;mat); // 単位行列を作成<br>
        &nbsp;&nbsp;&nbsp; Quaternion q = GetQuaternion(mat, radAngle); // x,y,z軸に対してrotationで指定された角度回転<br>
        &nbsp;&nbsp;&nbsp; this-&gt;w = q.w; this-&gt;x = q.x; this-&gt;y = q.y; this-&gt;z = q.z;<br>
        }<br>
        <br>
        #if 0 //[比較] DXのクオータニオン関数<br>
        <br>
        // 3次元空間上の点を任意の軸の周りに任意の角度だけ回転させる関数<br>
        extern VECTOR VRotQ(VECTOR P, VECTOR Axis, float Angle)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; VECTOR Result;<br>
        &nbsp;&nbsp;&nbsp; FLOAT4 Temp;<br>
        &nbsp;&nbsp;&nbsp; FLOAT4 RotQ;<br>
        &nbsp;&nbsp;&nbsp; float Cos;<br>
        &nbsp;&nbsp;&nbsp; float Sin;<br>
        &nbsp;&nbsp;&nbsp; float Square;<br>
        &nbsp;&nbsp;&nbsp; float Size;<br>
        &nbsp;&nbsp;&nbsp; Square = Axis.x * Axis.x + Axis.y * Axis.y + Axis.z * Axis.z;<br>
        &nbsp;&nbsp;&nbsp; if (Square &lt; 0.0000001f)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return VGet(-1.0f, -1.0f, -1.0f);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; Size = _SQRT(Square);<br>
        &nbsp;&nbsp;&nbsp; _SINCOS(0.5f * -Angle, &amp;Sin, &amp;Cos);<br>
        &nbsp;&nbsp;&nbsp; RotQ.w = Cos;<br>
        &nbsp;&nbsp;&nbsp; RotQ.x = Axis.x / Size * Sin;<br>
        &nbsp;&nbsp;&nbsp; RotQ.y = Axis.y / Size * Sin;<br>
        &nbsp;&nbsp;&nbsp; RotQ.z = Axis.z / Size * Sin;<br>
        &nbsp;&nbsp;&nbsp; Temp.w = P.x * RotQ.x + RotQ.y * P.y + RotQ.z * P.z;<br>
        &nbsp;&nbsp;&nbsp; Temp.x = P.x * RotQ.w - RotQ.y * P.z + RotQ.z * P.y;<br>
        &nbsp;&nbsp;&nbsp; Temp.y = P.y * RotQ.w - RotQ.z * P.x + RotQ.x * P.z;<br>
        &nbsp;&nbsp;&nbsp; Temp.z = P.z * RotQ.w - RotQ.x * P.y + RotQ.y * P.x;<br>
        &nbsp;&nbsp;&nbsp; Result.x = RotQ.x * Temp.w + Temp.x * RotQ.w + (Temp.y * RotQ.z - Temp.z * RotQ.y);<br>
        &nbsp;&nbsp;&nbsp; Result.y = RotQ.y * Temp.w + Temp.y * RotQ.w + (Temp.z * RotQ.x - Temp.x * RotQ.z);<br>
        &nbsp;&nbsp;&nbsp; Result.z = RotQ.z * Temp.w + Temp.z * RotQ.w + (Temp.x * RotQ.y - Temp.y * RotQ.x);<br>
        &nbsp;&nbsp;&nbsp; return Result;<br>
        }<br>
        <br>
        #endif<br>
        <br>
        #endif<br>
      </p>
      <br>
      <br>
      クオータニオンについての数学はムズイので、とにかく重要なとこは下記スライドの赤枠の部分<b>「クオータニオンを回転行列に変換しているRへの式」</b>に着目<br>
      <br>
      <img src="image/quaternion_math.png"><br>
      <br>
      これで、クオータニオンを普通のX軸Y軸Z軸のオイラー角に変換できます。下記の抜き出したコードの数式と上の赤枠を比較してみよう。<br>
      <br>
      <p class="source">抜き出したクオータニオンから、X軸、Y軸、Z軸のオイラー角への変換式のぶぶん。<br>
        //クォータニオンから回転行列へ<br>
        inline MATRIX QuaternionToMatrix(Quaternion q)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; MATRIX mat = MGetIdent();<br>
        &nbsp;&nbsp;&nbsp; //X軸<br>
        &nbsp;&nbsp;&nbsp; mat.m[0][0] = 1.0f - 2.0f * q.y * q.y - 2.0f * q.z * q.z;<br>
        &nbsp;&nbsp;&nbsp; mat.m[0][1] = 2.0f * q.x * q.y + 2.0f * q.w * q.z;<br>
        &nbsp;&nbsp;&nbsp; mat.m[0][2] = 2.0f * q.x * q.z - 2.0f * q.w * q.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; //Y軸<br>
        &nbsp;&nbsp;&nbsp; mat.m[1][0] = 2.0f * q.x * q.y - 2.0f * q.w * q.z;<br>
        &nbsp;&nbsp;&nbsp; mat.m[1][1] = 1.0f - 2.0f * q.x * q.x - 2.0f * q.z * q.z;<br>
        &nbsp;&nbsp;&nbsp; mat.m[1][2] = 2.0f * q.y * q.z + 2.0f * q.w * q.x;<br>
        <br>
        &nbsp;&nbsp;&nbsp; //Z軸<br>
        &nbsp;&nbsp;&nbsp; mat.m[2][0] = 2.0f * q.x * q.z + 2.0f * q.w * q.y;<br>
        &nbsp;&nbsp;&nbsp; mat.m[2][1] = 2.0f * q.y * q.z - 2.0f * q.w * q.x;<br>
        &nbsp;&nbsp;&nbsp; mat.m[2][2] = 1.0f - 2.0f * q.x * q.x - 2.0f * q.y * q.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return mat;<br>
        }<br>
      </p>
    </a> 数学的には、qとqの逆クオータニオン-1(単位1のときは共役)とではさみこまれているのでR1 R2 R3..と順に掛け算していっても大丈夫なことも頭の片隅に。<br>
    くわしい内容は<a href="https://qiita.com/drken/items/0639cf34cce14e8d58a5">ネットでいろいろ検索</a>してわかる範囲で数式をおいかけてみるがよろし。<br>
    <a id="mozTocId0001" class="mozTocH1"> <br>
      UnityでもGameObjectの内部では、オイラー角ではなくて、クオータニオンが使われています。UI上ではX,Y,Zの角度が見えるけどあれは見せかけです。<br>
      <br>
      <p><code>main.cpp</code>のコードをいったんまっさらきれいにします。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        #include "DataMV1.h"<br>
        #include "DataPly.h"<br>
        #include "Collision3D.h"<br>
        #include "MyDraw.h" // 自作の描画処理<br>
        <br>
        #include "Editor.h"<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; float animTime = 0.0f; // アニメの現在時刻<br>
        &nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
        &nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@kick.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;Load(); // 3Dモデルをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilAttackAnimData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@jump.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilAttackAnimData-&gt;Load(); // 3Dの追加アニメデータをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;AttachAnim(*pDevilAttackAnimData); // アニメを追加でflyのほうをベースとしたモデルにアタッチ<br>
        &nbsp;&nbsp;&nbsp; int animeButton = 0; // ボタンでアニメを切り替えられるようにする<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; pTexImage = Resource::MakeShared&lt;Texture&gt;("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; pTexImage-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; assert((int)*pTexImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataPly&gt; pPlyData = Resource::MakeShared&lt;DataPly&gt;("Image/dice.ply");<br>
        &nbsp;&nbsp;&nbsp; pPlyData-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; <br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
        &nbsp;&nbsp;&nbsp; <u>// サブのスクリーンを生成する<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
          &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
          &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");</u><br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; <u>float radius_lineStart0 = 0.2f, radius_lineEnd1 = 0.2f; // カプセルと球体の半径の初期設定<br>
          &nbsp;&nbsp;&nbsp; // カプセル点(0)<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DragCapsule&gt; lineStart0 = std::make_shared&lt;DragCapsule&gt;(-3, 0, -4, radius_lineStart0, 1.0f, Axis3D::Y, GetColor(255, 165, 165));<br>
          &nbsp;&nbsp;&nbsp; // 球体の点(1)<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DragSphere&gt; lineEnd1 = std::make_shared&lt;DragSphere&gt;(-2, -3, -3.5f, radius_lineEnd1 * 2, GetColor(255, 165, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 三角ポリゴン(2)<br>
          &nbsp;&nbsp;&nbsp; std::vector&lt;std::shared_ptr&lt;DragPoint&gt;&gt; poly2_Pos = { std::make_shared&lt;DragPoint&gt;(-3.0f,-2.0f,-4.0f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::make_shared&lt;DragPoint&gt;(-2.0f,-2.0f,-3.0f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::make_shared&lt;DragPoint&gt;(-2.0f,-2.0f,-4.0f) }; // ポリゴンの3点<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 四角ボックスの点(4)<br>
          &nbsp;&nbsp;&nbsp; Vector3 boxSize{ 1.0f,2.0f,3.0f };<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DragBox&gt; boxPoint4 = std::make_shared&lt;DragBox&gt;(7, -3, 4, boxSize, GetColor(255, 255, 0));</u><br>
        <br>
        &nbsp;&nbsp;&nbsp; std::list&lt;std::weak_ptr&lt;DragPoint&gt;&gt; dragPoints; // ドラッグ対象の点の共有ポインタのリスト<br>
        <br>
        &nbsp;&nbsp;&nbsp; <u>dragPoints.emplace_back(lineStart0); // リストにカプセル点0を追加<br>
          &nbsp;&nbsp;&nbsp; dragPoints.emplace_back(lineEnd1); // リストに球体の点1を追加<br>
          &nbsp;&nbsp;&nbsp; dragPoints.emplace_back(boxPoint4); // リストに四角ボックスの点4を追加<br>
          <br>
          &nbsp;&nbsp;&nbsp; dragPoints.emplace_back(poly2_Pos[0]); // リストにポリゴン2の3点を追加<br>
          &nbsp;&nbsp;&nbsp; dragPoints.emplace_back(poly2_Pos[1]);<br>
          &nbsp;&nbsp;&nbsp; dragPoints.emplace_back(poly2_Pos[2]);</u><br>
        <br>
        &nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateDragPoints(&amp;dragPoints); // ドラッグ点のリストを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!editor.isDraggingPoints) editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードの 0 1 キーで3Dアニメを切り替えられるようにする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_0))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_1))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 1;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width =&nbsp; pTexImage-&gt;m_XSize; float height =&nbsp; pTexImage-&gt;m_YSize; // テクスチャ画像のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f, 1.0f, 1.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(pPlyData-&gt;Vertex.data(), pPlyData-&gt;Vertex.size(), pPlyData-&gt;Index.data(), pPlyData-&gt;numIndex / 3, (int)*pTexImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 100, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ファイルのパス + ":" + アニメ名でアクセス<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string animPathName = (animeButton == 0) ? "Image/devil@kick.mv1:mixamo.com" : "Image/devil@jump.mv1:mixamo.com";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(pDevilData-&gt;count(animPathName) &gt; 0 &amp;&amp; "指定されたアニメ名のアニメはMV1に付属していませんでした");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime += animStepTime * animSpeed; // 1.0×2倍 なら2倍速でアニメ時刻が進む<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animTime &gt; (*pDevilData)[animPathName].endTime)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime = 0.0f; // 0秒目へとアニメをループさせる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 再生時間をセットする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1SetAttachAnimTime((int)*pDevilData, (*pDevilData)[animPathName].index, animTime);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>// 三角ポリゴン(2)を含む平面<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Plane4 plane_poly2{ *poly2_Pos[0],*poly2_Pos[1],*poly2_Pos[2] }; // 3点を含む平面を求める<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 collision2; // ポリゴン2と線(lineStart0→lineEnd1)の交点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 polygon[3] = { *poly2_Pos[0],*poly2_Pos[1],*poly2_Pos[2] };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角ポリゴン(2) と 線(lineStart0→lineEnd1) の当たり判定 をして 交点collision2 も求める<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision2 = isCollisionPoly_Line(polygon, 3, plane_poly2, *lineStart0, *lineEnd1, &amp;collision2);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角ポリゴン(2)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawTriangle3D(*poly2_Pos[0], *poly2_Pos[1], *poly2_Pos[2], GetColor(255, 255, 255), FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // lineStart0から平面の中心へ向かう線 を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(*lineStart0, -plane_poly2.n * plane_poly2.dist, GetColor(255, 165, 165));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面の中心 から 交点collision2 へ向かう(水色) を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(-plane_poly2.n * plane_poly2.dist, collision2, GetColor(0, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面の中心 に水色の球を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(-plane_poly2.n * plane_poly2.dist, 0.05, 16, GetColor(0, 255, 255), GetColor(255, 255, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面の中心 から 原点 に向かう線(水色)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(-plane_poly2.n * plane_poly2.dist, Vector3{0,0,0}, GetColor(0, 255, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ポリゴンを横切る線lineStart0→lineEnd1を結ぶ線(オレンジ)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(*lineStart0, *lineEnd1, GetColor(255, 165, 0));<br>
          &nbsp;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 collisionRay2; // 三角ポリゴン(2)とマウスカーソルの光線(rayPos)の交点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollisionRay2 = isCollisionPoly_Line(polygon, 3, plane_poly2, rayStart, rayEnd - rayStart, &amp;collisionRay2);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // カメラの始点から飛ばしたレイと三角ポリゴン(2)の交点に目印の球を描画<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollisionRay2) DxLib::DrawSphere3D(collisionRay2, 0.01, 16, GetColor(255, 165, 0), GetColor(255, 255, 255), FALSE);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角ポリゴン(2)の存在する平面を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawPlane(plane_poly2, *poly2_Pos[0], 8,GetColor(0,255,255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角ポリゴン(2)の存在する平面の単位法線方向の矢印(緑色)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawArrow3D(-plane_poly2.n * plane_poly2.dist, -plane_poly2.n * plane_poly2.dist + plane_poly2.n,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::ArrowType::None, MyDraw::ArrowType::Cone, 0.1f, 0.2f, GetColor(0, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面と軸並行ボックス(4)AABBの当たり判定とその押し戻しゴーストを描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 boxMin, boxMax, boxCenter;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boxPoint4-&gt;GetParams(boxCenter, boxMin, boxMax);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float distAABB; // 押し戻し距離(当たってないときは平面までの距離)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollisionPlaneAABB = isCollisionPlane_AABB(plane_poly2, boxMin, boxMax, &amp;distAABB);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollisionPlaneAABB) // 平面とボックスが衝突したら↓法線×押し戻し距離 ぶんずらしてゴーストを描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawCube3D(boxMin + plane_poly2.n * distAABB,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boxMax + plane_poly2.n * distAABB, GetColor(255, 255, 255), GetColor(255, 255, 255), FALSE);<br>
          &nbsp;&nbsp; &nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面とカプセル(0)の当たり判定とその押し戻しゴーストを描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 centerCapsule, startCapsule, endCapsule;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float radiusCapsule;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lineStart0-&gt;GetParams(centerCapsule, startCapsule, endCapsule, radiusCapsule); // 線の始点lineStart0からカプセル(0)のパラメータを得る<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float distCapsule; // 平面からカプセルをどれだけ押しもどせば当たらなくなるかの距離<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollisionPlaneCapsule = isCollisionPlane_Capsule(plane_poly2, startCapsule, endCapsule, radiusCapsule, &amp;distCapsule);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollisionPlaneCapsule) // 平面とカプセルが衝突していたら、平面の法線n方向に押し戻したゴーストを描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawCapsule3D(startCapsule + plane_poly2.n * distCapsule,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endCapsule + plane_poly2.n * distCapsule, radiusCapsule, 8, GetColor(255, 255, 255), GetColor(255, 255, 255), FALSE);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面と球体(1)の当たり判定とその押し戻しゴーストを描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float sphereRadius;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 sphereCenter;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lineEnd1-&gt;GetParams(sphereCenter, sphereRadius); // 線の終点lineEnd1から球体(1)のパラメータを得る<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float distSphere; // 平面から球をどれだけ押し戻せば当たらなくなるかの距離 <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollisionPlaneSphere = isCollisionPlane_Sphere(plane_poly2, sphereCenter, sphereRadius, &amp;distSphere);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollisionPlaneSphere) // 平面と球が衝突していたら、平面の法線n方向に押し戻したゴーストを描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(*lineEnd1 + plane_poly2.n * distSphere, sphereRadius, 8, GetColor(255, 255, 255), GetColor(255, 255, 255), FALSE);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision2)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 三角ポリゴン(2)と線(lineStart0→lineEnd1)の交わった交点に橙の球を表示<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(collision2, 0.05, 16, GetColor(255, 165, 0), GetColor(255, 255, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 球の中心とポリゴンの3点を結ぶ線の角度の合計がほぼ360度(2π)になるかがポリゴン内部かの判定条件となる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(collision2, *poly2_Pos[0], GetColor(255, 165, 165));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(collision2, *poly2_Pos[1], GetColor(255, 165, 165));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(collision2, *poly2_Pos[2], GetColor(255, 165, 165));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ドラッグ点とその当たり判定のオブジェクト(ボックスや球やカプセルなど)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto dragPoint : dragPoints)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dragPoint.lock()-&gt;Draw(); //ドラッグ点とそのまわりに広がる当たり判定範囲のカプセルやボックスなどをまとめて描く</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); // エディタのDraw処理<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      <br>
      <p><code>main.cpp</code>のコードを変更してダイスをクオータニオンで回転させるようにします。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        #include "DataMV1.h"<br>
        #include "DataPly.h"<br>
        #include "Collision3D.h"<br>
        #include "MyDraw.h" // 自作の描画処理<br>
        <em>#include "Quaternion.h"</em><br>
        <br>
        #include "Editor.h"<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; float animTime = 0.0f; // アニメの現在時刻<br>
        &nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
        &nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@kick.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;Load(); // 3Dモデルをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilAttackAnimData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@jump.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilAttackAnimData-&gt;Load(); // 3Dの追加アニメデータをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;AttachAnim(*pDevilAttackAnimData); // アニメを追加でflyのほうをベースとしたモデルにアタッチ<br>
        &nbsp;&nbsp;&nbsp; int animeButton = 0; // ボタンでアニメを切り替えられるようにする<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; pTexImage = Resource::MakeShared&lt;Texture&gt;("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; pTexImage-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; assert((int)*pTexImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataPly&gt; pPlyData = Resource::MakeShared&lt;DataPly&gt;("Image/dice.ply");<br>
        &nbsp;&nbsp;&nbsp; pPlyData-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; <br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; <u>VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転</u><br>
        &nbsp;&nbsp;&nbsp; <em>Quaternion quaternion; // 回転クオータニオン</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
        &nbsp;&nbsp;&nbsp; <br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; <br>
        <br>
        &nbsp;&nbsp;&nbsp; std::list&lt;std::weak_ptr&lt;DragPoint&gt;&gt; dragPoints; // ドラッグ対象の点の共有ポインタのリスト<br>
        <br>
        &nbsp;&nbsp;&nbsp; <br>
        <br>
        &nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateDragPoints(&amp;dragPoints); // ドラッグ点のリストを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!editor.isDraggingPoints) editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードの 0 1 キーで3Dアニメを切り替えられるようにする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_0))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_1))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 1;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width =&nbsp; pTexImage-&gt;m_XSize; float height =&nbsp; pTexImage-&gt;m_YSize; // テクスチャ画像のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f, 1.0f, 1.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) <em>quaternion *= CreateRotationQuaternion(speed * DX_PI / 180, VGet(1, 0, 0)); // X軸(1,0,0)を軸にspeed度ぶんだけ回転</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) <em>quaternion *= CreateRotationQuaternion(speed * DX_PI / 180, VGet(0, 1, 0)); // Y軸(0,1,0)を軸にspeed度ぶんだけ回転</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) <em>quaternion *= CreateRotationQuaternion(speed * DX_PI / 180, VGet(0, 0, 1)); // Z軸(0,0,1)を軸にspeed度ぶんだけ回転</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;</u><br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>matRot = MMult(matRot, MGetRotZ(zRotate));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転</u><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, QuaternionToMatrix(quaternion)); // スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(pPlyData-&gt;Vertex.data(), pPlyData-&gt;Vertex.size(), pPlyData-&gt;Index.data(), pPlyData-&gt;numIndex / 3, (int)*pTexImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>auto xyzAngle = QuaternionToAngle(quaternion); // クオータニオンからそれに対応するオイラー角度の候補を得る(候補は最大3種ありうるし、ある軸が傾いていて0度じゃない場合他の軸も連動)</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 100, GetColor(255, 255, 0), "x:%f y:%f Angle:<em>%d %d %d</em>", position.x, position.y, <em>(int)(xyzAngle[0].x * 180 / DX_PI), (int)(xyzAngle[0].y * 180 / DX_PI), (int)(xyzAngle[0].z * 180 / DX_PI)</em>);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ファイルのパス + ":" + アニメ名でアクセス<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string animPathName = (animeButton == 0) ? "Image/devil@kick.mv1:mixamo.com" : "Image/devil@jump.mv1:mixamo.com";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(pDevilData-&gt;count(animPathName) &gt; 0 &amp;&amp; "指定されたアニメ名のアニメはMV1に付属していませんでした");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime += animStepTime * animSpeed; // 1.0×2倍 なら2倍速でアニメ時刻が進む<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animTime &gt; (*pDevilData)[animPathName].endTime)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime = 0.0f; // 0秒目へとアニメをループさせる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 再生時間をセットする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1SetAttachAnimTime((int)*pDevilData, (*pDevilData)[animPathName].index, animTime);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); // エディタのDraw処理<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      いかがでしょう？キーボードのzボタン(X軸回転)、xボタン(Y軸回転)、cボタン(Z軸回転)でダイスが回転したでしょうか？<br>
      もとのx,y,zをオイラー角で2つ以上のx,y,zを同時に回転させるとぶるぶる不安定だった回転が、明確に一つの軸を中心に回転するようになったのが実感できますでしょうか？<br>
      このようにクオータニオンなら、x,y,zを同時に回転させたり、<b>X,Y,Z軸じゃない「斜め方向の軸」などを中心に回転</b>させたりすることができて、<br>
      より自由に安定した形で回転をさせることができるので、3Dの回転にはオイラー角でなく、クオータニオンを利用するのです。<br>
      <img src="image/quaternion_dice1.gif">オイラー角でのx,y,zの同時押しぶるぶる回転<br>
      <img src="image/quaternion_dice2.gif">クオータニオンでの安定した回転、斜め軸回転<br>
      <br>
    </a><a id="mozTocId0016" class="mozTocH1">
      <h1>自作したシェーダー言語をコンパイルしてGPU上で動くプログラムを実感する</h1>
    </a> まず最初に、シェーダーはC++とはまったく別の言語です。(文法は多少似てるけど)<br>
    そして、シェーダー言語はコンパイルで機械語へビルドして、事前にGPUへ送りつけておかねば動かない。<br>
    GPUは送られたシェーダー実行ファイルをもとにした処理をCPUとは独立して実行します。<br>
    つまり、いままで勉強してきたC++だけでは、あくまでCPUプログラマどまり、であること。<br>
    シェーダー言語でGPUに腕を突っ込んではじめて、GPUプログラマとして、CPUとGPUを両腕にかかえてPCの支配者への入り口に立てるのだ！！<br>
    <br>
    シェーダ言語を定めている国際的な勢力は大きく分けて二つある。<br>
    <a href="https://ja.wikipedia.org/wiki/High_Level_Shading_Language">HLSL</a>(マイクロソフトDirectX系、NVIDIA協力)と<a

      href="https://ja.wikipedia.org/wiki/GLSL">GLSL</a>(その他OpenGL:Vulkan系)の2大勢力だ。<br>
    <br>
    DXライブラリはDirectXをベースにしているので、<a href="https://ja.wikipedia.org/wiki/High_Level_Shading_Language">HLSLの仕様</a>をまずは気にしておくとよい。<br>
    シェーダー言語(拡張子.hlsl)をビルドするためのコンパイラは<a href="https://learn.microsoft.com/ja-jp/windows/win32/direct3dtools/fxc">fxc.exeファイル</a>であるが、<br>
    DXライブラリにはそのうちのエフェクト(拡張子.fx)をビルドするためのコンパイラが「DXライブラリをインストールしたフォルダ/Tool/ShaderCompiler/」というフォルダにおいてある。<br>
    まずは下記を参考にDXライブラリのツールフォルダにあるShaderCompiler.exeを探し出そう。(最新Ver.のDirectXのシェーダーをビルドするにはこれ以外にDirectXの最新版をインストールしてfxc.exeを探す必要もあるかも)<br>
    <img src="image/shader_compile1.png"><br>
    <br>
    シェーダー言語の拡張子は.hlslとか.fxになるが、<br>
    とりあえず手っ取り早くはWindowsのメモ帳で新規に空のテキストファイルを作成して、[名前を付けて保存]で拡張子を.fxファイルにして保存すればコードのファイルを作成できる。<br>
    <img src="image/shader_compile2.png"><br>
    <br>
    シェーダー言語と3D描画についての<a href="https://dxlib.xsrv.jp/program/dxprogram_3DModelShaderBase.html">DXライブラリの公式サイトのコードはここにある</a>が、<br>
    今回は入門として、ただ単に、3Dを全部赤色に塗りつぶすシェーダーを作るところから始めてみよう。<br>
    まず、上記で作成した TestVS.fx のVSは<b>Vertex Shader(Vertex:頂点 Shader:シェーダ)の略</b>だ。<br>
    3Dのキャラクターとかの3Dモデルは大量の三角形ポリゴンの面の集まりで描かれている。<br>
    そして、その三角形は3点の<b>頂点の集まり</b>だ。頂点シェーダーはその<b>大量の各点で行う計算について書いたプログラム</b>だ。<br>
    <br>
    入門者は各点で具体的に何を計算するの？とイメージできないと思うが、<br>
    例えば、点の明るさを計算することを考えてみよう。<br>
    ライト(光源)から1つの頂点へのベクトル と その頂点からカメラ へ向かうベクトル との反射を計算して、<br>
    すべてのライト(光源)について 反射する光の強さの数値を蓄積させれば、その1つの頂点の明るさが計算できる。<br>
    1万個 点があっても、GPUの中に沢山あるユニットで並列で手分けして1万個の点の明るさを 頂点シェーダー のプログラムに沿って計算させてしまえば、<br>
    画面に描くキャラクタの表面の点のひとつひとつの明るさが計算できるわけだ。<br>
    三角ポリゴンの3点の明るさが求まれば、あとはその三角形の内側の点の明るさは3点の明るさのグラデーションで計算すればいいから3Dキャラが描けるわけだ。<br>
    <br>
    これがシェード(陰影)を計算するシェーダーのからくりのおおまかな説明だ。<br>
    3D空間に大量に点が増えても、GPUの中で働く大量のユニット(アルバイト人員的な計算要員)の「人海戦術GPUパワー」で強引に計算しているイメージだ。<br>
    そして、そのシェーダー言語のプログラミングを自分でカスタマイズできれば、色んな3Dの描き方 や 色んな平行計算(AIとかも) ができるというわけ。<br>
    <br>
    今回はまずはライトとは関係なしに、蓄積する点の明るさのうち、拡散光(Diffuse)を強引に赤色[RGB = (1.0f,0,0f,0,0f)]にして描く実験をしてみよう。<br>
    <p><code>TestVS.fxをShaderフォルダに新規作成</code>して下記コードで VSOutputの拡散光(Diffuse) を 赤色[RGB = (1.0f,0,0f,0,0f)] にしてreturnさせます。</p>
    <p class="source">// 頂点シェーダーの入力 DrawPolygonIndexed3DToShader_UseVertexBuffer 用の頂点データの定義<br>
      // https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=5437<br>
      struct VS_INPUT<br>
      {<br>
      &nbsp;&nbsp;&nbsp; float3 Position&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : POSITION0 ;&nbsp;&nbsp;&nbsp; // 座標( ローカル空間 )<br>
      &nbsp;&nbsp;&nbsp; float4 SubPosition&nbsp;&nbsp;&nbsp;&nbsp; : POSITION1 ;&nbsp;&nbsp;&nbsp; // 予備座標<br>
      &nbsp;&nbsp;&nbsp; float3 Normal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : NORMAL0 ;&nbsp;&nbsp;&nbsp; // 法線( ローカル空間 )<br>
      &nbsp;&nbsp;&nbsp; float3 Tangent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : TANGENT0 ;&nbsp;&nbsp;&nbsp; // 接線( ローカル空間 )<br>
      &nbsp;&nbsp;&nbsp; float3 Binormal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : BINORMAL0 ;&nbsp;&nbsp;&nbsp; // 従法線( ローカル空間 )<br>
      &nbsp;&nbsp;&nbsp; float4 Diffuse&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : COLOR0 ;&nbsp;&nbsp;&nbsp; // ディフューズカラー<br>
      &nbsp;&nbsp;&nbsp; float4 Specular&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : COLOR1 ;&nbsp;&nbsp;&nbsp; // スペキュラカラー<br>
      &nbsp;&nbsp;&nbsp; float2 TexCoords0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : TEXCOORD0 ;&nbsp;&nbsp;&nbsp; // テクスチャ座標<br>
      &nbsp;&nbsp;&nbsp; float2 TexCoords1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : TEXCOORD1 ;&nbsp;&nbsp;&nbsp; // サブテクスチャ座標<br>
      } ;<br>
      <br>
      <br>
      // 頂点シェーダーの出力<br>
      struct VS_OUTPUT<br>
      {<br>
      &nbsp;&nbsp;&nbsp; float4 Diffuse&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : COLOR0 ;<br>
      &nbsp;&nbsp;&nbsp; float4 Specular&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : COLOR1 ;<br>
      &nbsp;&nbsp;&nbsp; float2 TexCoords0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : TEXCOORD0 ;<br>
      &nbsp;&nbsp;&nbsp; float4 Position&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : SV_POSITION ;&nbsp;&nbsp;&nbsp; // 座標( プロジェクション空間 )<br>
      } ;<br>
      <br>
      <br>
      // [DirectX11版]マテリアルパラメータ<br>
      struct DX_D3D11_CONST_MATERIAL<br>
      {<br>
      &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Diffuse ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ディフューズカラー<br>
      &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Specular ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スペキュラカラー<br>
      &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Ambient_Emissive ;&nbsp;&nbsp;&nbsp; // マテリアルエミッシブカラー + マテリアルアンビエントカラー * グローバルアンビエントカラー<br>
      <br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Power ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スペキュラの強さ<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; TypeParam0 ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // マテリアルタイプパラメータ0<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; TypeParam1 ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // マテリアルタイプパラメータ1<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; TypeParam2 ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // マテリアルタイプパラメータ2<br>
      } ;<br>
      <br>
      // [DirectX11版]フォグパラメータ<br>
      struct DX_D3D11_VS_CONST_FOG<br>
      {<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; LinearAdd ;&nbsp;&nbsp;&nbsp; // フォグ用パラメータ end / ( end - start )<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; LinearDiv ;&nbsp;&nbsp;&nbsp; // フォグ用パラメータ -1&nbsp; / ( end - start )<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Density ;&nbsp;&nbsp;&nbsp; // フォグ用パラメータ density<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; E ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // フォグ用パラメータ 自然対数の低<br>
      <br>
      &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Color ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カラー<br>
      } ;<br>
      <br>
      // [DirectX11版]ライトパラメータ<br>
      struct DX_D3D11_CONST_LIGHT<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Type ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ライトタイプ( DX_LIGHTTYPE_POINT など )<br>
      &nbsp;&nbsp;&nbsp; int3&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Padding1 ;&nbsp;&nbsp;&nbsp; // パディング１<br>
      <br>
      &nbsp;&nbsp;&nbsp; float3&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Position ;&nbsp;&nbsp;&nbsp; // 座標( ビュー空間 )<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; RangePow2 ;&nbsp;&nbsp;&nbsp; // 有効距離の２乗<br>
      <br>
      &nbsp;&nbsp;&nbsp; float3&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Direction ;&nbsp;&nbsp;&nbsp; // 方向( ビュー空間 )<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; FallOff ;&nbsp;&nbsp;&nbsp; // スポットライト用FallOff<br>
      <br>
      &nbsp;&nbsp;&nbsp; float3&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Diffuse ;&nbsp;&nbsp;&nbsp; // ディフューズカラー<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SpotParam0 ;&nbsp;&nbsp;&nbsp; // スポットライト用パラメータ０( cos( Phi / 2.0f ) )<br>
      <br>
      &nbsp;&nbsp;&nbsp; float3&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Specular ;&nbsp;&nbsp;&nbsp; // スペキュラカラー<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SpotParam1 ;&nbsp;&nbsp;&nbsp; // スポットライト用パラメータ１( 1.0f / ( cos( Theta / 2.0f ) - cos( Phi / 2.0f ) ) )<br>
      <br>
      &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Ambient ;&nbsp;&nbsp;&nbsp; // アンビエントカラーとマテリアルのアンビエントカラーを乗算したもの<br>
      <br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Attenuation0 ;&nbsp;&nbsp;&nbsp; // 距離による減衰処理用パラメータ０<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Attenuation1 ;&nbsp;&nbsp;&nbsp; // 距離による減衰処理用パラメータ１<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Attenuation2 ;&nbsp;&nbsp;&nbsp; // 距離による減衰処理用パラメータ２<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Padding2 ;&nbsp;&nbsp;&nbsp; // パディング２<br>
      } ;<br>
      <br>
      // [DirectX11版]ピクセルシェーダー・頂点シェーダー共通パラメータ<br>
      struct DX_D3D11_CONST_BUFFER_COMMON<br>
      {<br>
      &nbsp;&nbsp;&nbsp; DX_D3D11_CONST_LIGHT&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Light[ 6 ] ;&nbsp;&nbsp;&nbsp; // ライトパラメータ<br>
      &nbsp;&nbsp;&nbsp; DX_D3D11_CONST_MATERIAL&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Material ;&nbsp;&nbsp;&nbsp; // マテリアルパラメータ<br>
      &nbsp;&nbsp;&nbsp; DX_D3D11_VS_CONST_FOG&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Fog ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // フォグパラメータ<br>
      } ;<br>
      <br>
      // [DirectX11版]基本パラメータ<br>
      struct DX_D3D11_VS_CONST_BUFFER_BASE<br>
      {<br>
      &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; AntiViewportMatrix[ 4 ] ;&nbsp;&nbsp;&nbsp; // アンチビューポート行列<br>
      &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ProjectionMatrix[ 4 ] ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ビュー　→　プロジェクション行列<br>
      &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ViewMatrix[ 3 ] ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ワールド　→　ビュー行列<br>
      &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; LocalWorldMatrix[ 3 ] ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ローカル　→　ワールド行列<br>
      <br>
      &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ToonOutLineSize ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // トゥーンの輪郭線の大きさ<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DiffuseSource ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ディフューズカラー( 0.0f:マテリアル&nbsp; 1.0f:頂点 )<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SpecularSource ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スペキュラカラー(&nbsp;&nbsp; 0.0f:マテリアル&nbsp; 1.0f:頂点 )<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MulSpecularColor ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スペキュラカラー値に乗算する値( スペキュラ無効処理で使用 )<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Padding ;<br>
      } ;<br>
      <br>
      // [DirectX11版]その他の行列<br>
      struct DX_D3D11_VS_CONST_BUFFER_OTHERMATRIX<br>
      {<br>
      &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ShadowMapLightViewProjectionMatrix[ 3 ][ 4 ] ;&nbsp;&nbsp;&nbsp; // シャドウマップ用のライトビュー行列とライト射影行列を乗算したもの<br>
      &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; TextureMatrix[ 3 ][ 2 ] ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // テクスチャ座標操作用行列<br>
      } ;<br>
      <br>
      // [DirectX11版]頂点シェーダー・ピクセルシェーダー共通パラメータ<br>
      cbuffer cbD3D11_CONST_BUFFER_COMMON : register( b0 )<br>
      {<br>
      &nbsp;&nbsp;&nbsp; DX_D3D11_CONST_BUFFER_COMMON&nbsp;&nbsp;&nbsp; g_Common ;<br>
      } ;<br>
      <br>
      // [DirectX11版]基本パラメータ<br>
      cbuffer cbD3D11_CONST_BUFFER_VS_BASE&nbsp;&nbsp;&nbsp; : register( b1 )<br>
      {<br>
      &nbsp;&nbsp;&nbsp; DX_D3D11_VS_CONST_BUFFER_BASE&nbsp;&nbsp;&nbsp; g_Base ;<br>
      } ;<br>
      <br>
      // [DirectX11版]その他の行列<br>
      cbuffer cbD3D11_CONST_BUFFER_VS_OTHERMATRIX : register( b2 )<br>
      {<br>
      &nbsp;&nbsp;&nbsp; DX_D3D11_VS_CONST_BUFFER_OTHERMATRIX&nbsp;&nbsp;&nbsp; g_OtherMatrix ;<br>
      } ;<br>
      <br>
      <br>
      // main関数<br>
      VS_OUTPUT main( VS_INPUT VSInput )<br>
      {<br>
      &nbsp;&nbsp;&nbsp; VS_OUTPUT VSOutput ;<br>
      &nbsp;&nbsp;&nbsp; float4 lLocalPosition;<br>
      &nbsp;&nbsp;&nbsp; float4 lWorldPosition;<br>
      &nbsp;&nbsp;&nbsp; float4 lViewPosition;<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // 頂点座標変換 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++( 開始 )<br>
      &nbsp;&nbsp;&nbsp; // ローカル座標のセット<br>
      &nbsp;&nbsp;&nbsp; lLocalPosition.xyz = VSInput.Position;<br>
      &nbsp;&nbsp;&nbsp; lLocalPosition.w = 1.0f;<br>
      &nbsp;&nbsp;&nbsp; // ローカル座標をワールド座標に変換<br>
      &nbsp;&nbsp;&nbsp; lWorldPosition.x = dot(lLocalPosition, g_Base.LocalWorldMatrix[0]);<br>
      &nbsp;&nbsp;&nbsp; lWorldPosition.y = dot(lLocalPosition, g_Base.LocalWorldMatrix[1]);<br>
      &nbsp;&nbsp;&nbsp; lWorldPosition.z = dot(lLocalPosition, g_Base.LocalWorldMatrix[2]);<br>
      &nbsp;&nbsp;&nbsp; lWorldPosition.w = 1.0f;<br>
      &nbsp;&nbsp;&nbsp; // ワールド座標をビュー座標に変換<br>
      &nbsp;&nbsp;&nbsp; lViewPosition.x = dot(lWorldPosition, g_Base.ViewMatrix[0]);<br>
      &nbsp;&nbsp;&nbsp; lViewPosition.y = dot(lWorldPosition, g_Base.ViewMatrix[1]);<br>
      &nbsp;&nbsp;&nbsp; lViewPosition.z = dot(lWorldPosition, g_Base.ViewMatrix[2]);<br>
      &nbsp;&nbsp;&nbsp; lViewPosition.w = 1.0f;<br>
      &nbsp;&nbsp;&nbsp; // ビュー座標を射影座標に変換<br>
      &nbsp;&nbsp;&nbsp; VSOutput.Position.x = dot(lViewPosition, g_Base.ProjectionMatrix[0]);<br>
      &nbsp;&nbsp;&nbsp; VSOutput.Position.y = dot(lViewPosition, g_Base.ProjectionMatrix[1]);<br>
      &nbsp;&nbsp;&nbsp; VSOutput.Position.z = dot(lViewPosition, g_Base.ProjectionMatrix[2]);<br>
      &nbsp;&nbsp;&nbsp; VSOutput.Position.w = dot(lViewPosition, g_Base.ProjectionMatrix[3]);<br>
      &nbsp;&nbsp;&nbsp; // 頂点座標変換 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++( 終了 )<br>
      <br>
      &nbsp;&nbsp;&nbsp; VSOutput.TexCoords0 = VSInput.TexCoords0; // テクスチャの座標をそのままOutputする<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // [実験]頂点カラーの拡散光を赤色にして返す<br>
      &nbsp;&nbsp;&nbsp; <b>VSOutput.Diffuse.r = 1.0f; // R(赤の拡散値)</b><br>
      &nbsp;&nbsp;&nbsp; VSOutput.Diffuse.g = 0.0f; // G(緑の拡散値)<br>
      &nbsp;&nbsp;&nbsp; VSOutput.Diffuse.b = 0.0f; // B(青の拡散値)<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 出力パラメータを返す<br>
      &nbsp;&nbsp;&nbsp; return VSOutput ;<br>
      }<br>
    </p>
    <br>
    TestVS.fxをDXのプロジェクトのShaderフォルダに保存したら、<br>
    ①Windowsのバーからコマンドプロンプトを検索して起動して、<br>
    ②cdコマンドを実行して、<b>黒画面のコマンドプロンプト上でShaderフォルダに移動</b>する(ウインドウズがない大昔のPC初期:<a

      href="https://www.pc-koubou.jp/magazine/40">MS-DOSは文字コマンドだけでフォルダ移動など</a>をしていた時代だった)<br>
    ③コマンドプロンプトでShaderCompiler.exe /Tvs5_0 TestVS.fxを実行して TestVS.fx をビルドして TestVS.vso を生成する。<br>
    <img src="image/shader_compile3.png"><br>
    <br>
    <a id="mozTocId0016" class="mozTocH1"> 同じ要領で今度はTestPS.fxを作成して、ピクセルシェーダー(Pixel:画面のドットの各ピクセルの Shader:シェーダ)の略 も ビルドしましょう。<br>
      <p><code>TestPS.fxをShaderフォルダに新規作成</code>して下記コードで 頂点シェーダなどを経由してやってきたPSInputの拡散光(Diffuse) を そのままPSOutPutのColor0に設定してreturnさせましょう。</p>
      <p class="source">// ピクセルシェーダーの入力<br>
        struct PS_INPUT<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float4 Diffuse&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : COLOR0 ;<br>
        &nbsp;&nbsp;&nbsp; float4 Specular&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : COLOR1 ;<br>
        &nbsp;&nbsp;&nbsp; float2 TexCoords0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : TEXCOORD0 ;<br>
        } ;<br>
        <br>
        // ピクセルシェーダーの出力<br>
        struct PS_OUTPUT<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float4 Color0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : SV_TARGET0 ;&nbsp;&nbsp;&nbsp; // 色<br>
        } ;<br>
        <br>
        <br>
        // [DirectX11版]定数バッファピクセルシェーダー基本パラメータ<br>
        struct DX_D3D11_PS_CONST_BUFFER_BASE<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; FactorColor ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // アルファ値等<br>
        <br>
        &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MulAlphaColor ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カラーにアルファ値を乗算するかどうか( 0.0f:乗算しない&nbsp; 1.0f:乗算する )<br>
        &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; AlphaTestRef ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // アルファテストで使用する比較値<br>
        &nbsp;&nbsp;&nbsp; float2&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Padding1 ;<br>
        <br>
        &nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; AlphaTestCmpMode ;&nbsp;&nbsp;&nbsp; // アルファテスト比較モード( DX_CMP_NEVER など )<br>
        &nbsp;&nbsp;&nbsp; int3&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Padding2 ;<br>
        <br>
        &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IgnoreTextureColor ;&nbsp;&nbsp;&nbsp; // テクスチャカラー無視処理用カラー<br>
        } ;<br>
        <br>
        // [DirectX11版]基本パラメータ https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4904<br>
        cbuffer cbD3D11_CONST_BUFFER_PS_BASE&nbsp;&nbsp;&nbsp; : register( b1 )<br>
        {<br>
        &nbsp;&nbsp;&nbsp; DX_D3D11_PS_CONST_BUFFER_BASE&nbsp;&nbsp;&nbsp; g_Base ;<br>
        } ;<br>
        <br>
        <br>
        SamplerState g_DiffuseMapSampler&nbsp;&nbsp;&nbsp; : register( s0 ) ;&nbsp;&nbsp;&nbsp; // ディフューズマップテクスチャ<br>
        Texture2D&nbsp;&nbsp;&nbsp; g_DiffuseMapTexture&nbsp;&nbsp;&nbsp; : register( t0 ) ;&nbsp;&nbsp;&nbsp; // ディフューズマップテクスチャ<br>
        <br>
        <br>
        <br>
        // main関数<br>
        PS_OUTPUT main( PS_INPUT PSInput )<br>
        {<br>
        &nbsp;&nbsp;&nbsp; PS_OUTPUT PSOutput ;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 頂点シェーダなどを経由してやってきたDiffuse拡散光の色をそのまま画面スクリーンのピクセル色としてOutputする<br>
        &nbsp;&nbsp;&nbsp; PSOutput.Color0.r = PSInput.Diffuse.r ; // R:赤&nbsp;&nbsp;&nbsp;&nbsp; 画面スクリーン上のピクセル色<br>
        &nbsp;&nbsp;&nbsp; PSOutput.Color0.g = PSInput.Diffuse.g ; // G:緑&nbsp;&nbsp;&nbsp;&nbsp; 画面スクリーン上のピクセル色<br>
        &nbsp;&nbsp;&nbsp; PSOutput.Color0.b = PSInput.Diffuse.b ; // B:青&nbsp;&nbsp;&nbsp;&nbsp; 画面スクリーン上のピクセル色<br>
        &nbsp;&nbsp;&nbsp; PSOutput.Color0.a = PSInput.Diffuse.a ; // A:透明度 画面スクリーン上のピクセル色<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 出力パラメータを返す<br>
        &nbsp;&nbsp;&nbsp; return PSOutput ;<br>
        }<br>
      </p>
      <br>
      TestPS.fxをDXのプロジェクトのShaderフォルダに保存したら、<br>
      ①Windowsのバーからコマンドプロンプトを検索して起動して、<br>
      ②cdコマンドを実行して、黒画面のコマンドプロンプト上でShaderフォルダに移動<br>
      ③コマンドプロンプトでShaderCompiler.exe /Tps5_0 TestPS.fxを実行して TestPS.fx をビルドして TestPS.pso を生成する。<br>
      <img src="image/shader_compile4.png"><br>
      <br>
      <br>
      頂点シェーダから出た頂点はラスタライザで内側にあるピクセルがもとめられ、ピクセルシェーダはその内側のピクセルの数ぶんだけ実行されます。<br>
      頂点の3点以外の拡散光の強さDiffuse値は3点の間にあるピクセルでは適度にグラデーションで補われてやってくるので、<br>
      厳密には TestVSの出力VSOutPutのDiffuse値 ≒ TestPSの入力PSOutPutのDiffuse値 ではありますが、<br>
      VSのOutputの影響を受けたPSInputのDiffuse値が渡ってくるというイメージでいいと思います。<br>
      <img src="image/shader_compile5.png"><br>
      <br>
      <p><code>DataPly.hを変更</code>して頂点Vertexのタイプ型をVERTEX3DからVERTEX3DSHADERに変えて今回作成したシェーダーの描画に対応できるようにしましょう。</p>
      <p class="source">#ifndef DATAPLY_H_<br>
        #define DATAPLY_H_<br>
        <br>
        #include "Dxlib.h"<br>
        <br>
        #include &lt;memory&gt;<br>
        #include &lt;vector&gt;<br>
        #include &lt;string&gt;<br>
        <br>
        #include &lt;assert.h&gt; // 読込み失敗表示用<br>
        <br>
        #include "Ply.h"<br>
        <br>
        #include "Resource.h"<br>
        <br>
        // .ply形式の3Dモデルデータを読み込む構造体<br>
        struct DataPly : public Resource<br>
        {<br>
        protected: // ファクトリーパターンでコンストラクタ経由の生成経路をprotected隠蔽(ResourceクラスのMakeShared関数経由でしか新規生成は できない)<br>
        &nbsp;&nbsp;&nbsp; DataPly(std::string filePath = "", bool isGPUBufferRendering = false)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Resource(filePath, Type::Ply), isGPUBufferRendering{ isGPUBufferRendering } {}<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; size_t numIndex = 0;<br>
        &nbsp;&nbsp;&nbsp; int VertexBufHandle{ -1 }; // GPU側の頂点バッファへのハンドル番号<br>
        &nbsp;&nbsp;&nbsp; int IndexBufHandle{ -1 }; // GPU側のインデックスバッファへのハンドル番号<br>
        &nbsp;&nbsp;&nbsp; bool isSendDataToGPU = false; // GPUへデータを転送済みか<br>
        &nbsp;&nbsp;&nbsp; bool isGPUBufferRendering; // GPUバッファにVertexとIndexデータを送ってCPU側にはデータをもたないようにするか?<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;<em>VERTEX3DSHADER</em>&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
        <br>
        &nbsp;&nbsp;&nbsp; Ply::Data Data; //.plyのデータ<br>
        <br>
        &nbsp;&nbsp;&nbsp; bool isInitialized = false; //[継承2重ロード対策]ロード済みになったらtrueに falseのときにLoadするとリロード<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual ~DataPly()<br>
        &nbsp;&nbsp;&nbsp; {// 仮想デストラクタ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear();// 2次元配列データのお掃除<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual void clearCPUData() // CPU上の配列データをクリアする<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // [確実にメモリを空にするには] http://vivi.dyndns.org/tech/cpp/vector.html#shrink_to_fit<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;<em>VERTEX3DSHADER</em>&gt;().swap(Vertex); // 空のテンポラリオブジェクトでリセット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;unsigned int&gt;().swap(Index); // 空のテンポラリオブジェクトでリセット<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual void clearGPUData() // GPU上のバッファデータをクリアする<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteVertexBuffer(VertexBufHandle); // GPUの頂点バッファを削除する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteIndexBuffer(IndexBufHandle); // GPUのインデックスバッファを削除する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VertexBufHandle = -1; IndexBufHandle = -1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSendDataToGPU = false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGPUBufferRendering = false;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // データをクリアしてメモリを節約する<br>
        &nbsp;&nbsp;&nbsp; virtual void clear()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data.clear();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clearCPUData(); // CPU上の配列データをクリアする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clearGPUData(); // GPUのインデックスバッファを削除する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = false; //ロード済みフラグをOFF<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ファイルの読み込み<br>
        &nbsp;&nbsp;&nbsp; virtual int Load(const std::string&amp; filePath = "") override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (filePath == "" &amp;&amp; m_FilePath == "") return -1; //ファイル名がない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (files.count(filePath) &gt; 0 &amp;&amp; isInitialized) return 0; // すでに辞書にロード済みファイルがあった<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (filePath != "" &amp;&amp; m_FilePath == "") m_FilePath = filePath; // 読み出しファイルパスを記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear(); //データを一旦クリア<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ply::load(m_FilePath, Data); // .plyデータをロード<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [std::shared_ptrへthis↓ポインタをつかうためには] https://www.kabuku.co.jp/developers/cpp_enable_shared_from_this<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; files.emplace(m_FilePath, shared_from_this()); // リソースの辞書へ登録 https://cpprefjp.github.io/reference/memory/enable_shared_from_this.html<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報]https://jp.mathworks.com/help/vision/ug/the-ply- format.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* face_uv = (Data["face"]-&gt;properties.has_key("texcoord")) ? Data["face"]-&gt;properties["texcoord"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)// i + face_index-&gt;listCounts[nFace], ++nFace)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //size_t count = face_index-&gt;listCounts[nFace]; // ポリゴンならインデックス数は3 四角形ならインデックス数は4 .. 5 .. 6<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //size_t nPolygon = count - 2; // 三角ポリゴンの数 = インデックスの数 - 2 (例) 3 - 2 = 1ポリゴン , 4 - 2 = 2ポリゴン ..<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t n = 0; n &lt; nPolygon; ++n)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Vertex[index].su != -1.0f) // su sv の suが初期値-1でなく設定済なら頂点の被りとして新しいnewIndexとして新規Index番号で点を新規登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int newIndex = Vertex.size();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex.emplace_back(Vertex[index]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index = newIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index.push_back(newIndex);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index].su = 0.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (face_uv != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index].u = face_uv[uvIndex];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index].v = 1.0f - face_uv[uvIndex + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isGPUBufferRendering)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendDataToGPU(); // GPUのバッファへVertexとIndexデータ配列を送信<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = true;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void SendDataToGPU() // GPUのバッファへVertexとIndexデータ配列を送信<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int result = false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VertexBufHandle = DxLib::CreateVertexBuffer(Vertex.size(), DX_VERTEX_TYPE_SHADER_3D); // 頂点バッファを作成<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = DxLib::SetVertexBufferData(0, Vertex.data(), Vertex.size(), VertexBufHandle); // 頂点バッファに頂点データを転送する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //UpdateVertexBuffer(VertexBufHandle, UpdateStartIndex, UpdateVertexNum); // 頂点バッファハンドルの頂点バッファへの変更を適用する( GetBufferVertexBuffer で取得したバッファへの変更を反映する )<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result == -1) return;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexBufHandle = DxLib::CreateIndexBuffer(Index.size(), DX_INDEX_TYPE_32BIT); // インデックスバッファを作成<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = DxLib::SetIndexBufferData(0, Index.data(), Index.size(), IndexBufHandle); // インデックスバッファにインデックスデータを転送する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result == -1) return;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGPUBufferRendering = true;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSendDataToGPU = true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        #endif<br>
      </p>
      <br>
      一応、VERTEX3D型 と VERTEX3DSHADER型の定義の違いを見ておきましょう。(DxLib.hの中に定義がある)<br>
      <p class="source"> DxLib.hの中身に定義がある<br>
        (以上、略)...<br>
        // ３Ｄ描画に使用する頂点データ型<br>
        typedef struct tagVERTEX3D<br>
        {<br>
        &nbsp;&nbsp; &nbsp;VECTOR&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;pos ;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 座標<br>
        &nbsp;&nbsp; &nbsp;VECTOR&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;norm ;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 法線<br>
        &nbsp;&nbsp; &nbsp;COLOR_U8&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;dif ;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ディフューズカラー<br>
        &nbsp;&nbsp; &nbsp;COLOR_U8&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;spc ;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スペキュラカラー<br>
        &nbsp;&nbsp; &nbsp;float&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;u, v ;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// テクスチャ座標<br>
        &nbsp;&nbsp; &nbsp;float&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;su, sv ;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 補助テクスチャ座標<br>
        } VERTEX3D, *LPVERTEX3D ;<br>
        <br>
        // ３Ｄ描画に使用する頂点データ型( DrawPrimitive3DToShader用 )<br>
        // 注意…メンバ変数に追加があるかもしれませんので、宣言時の初期化( VERTEX3DSHADER Vertex = { 0.0f, 0.0f, ... というようなもの )はしない方が良いです<br>
        typedef struct tagVERTEX3DSHADER<br>
        {<br>
        &nbsp;&nbsp; &nbsp;VECTOR&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;pos ;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 座標<br>
        &nbsp;&nbsp; &nbsp;FLOAT4&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;spos ;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 補助座標<br>
        &nbsp;&nbsp; &nbsp;VECTOR&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;norm ;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 法線<br>
        &nbsp;&nbsp; &nbsp;VECTOR&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;tan ;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 接線<br>
        &nbsp;&nbsp; &nbsp;VECTOR&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;binorm ;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 従法線<br>
        &nbsp;&nbsp; &nbsp;COLOR_U8&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;dif ;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// ディフューズカラー<br>
        &nbsp;&nbsp; &nbsp;COLOR_U8&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;spc ;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// スペキュラカラー<br>
        &nbsp;&nbsp; &nbsp;float&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;u, v ;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// テクスチャ座標<br>
        &nbsp;&nbsp; &nbsp;float&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;su, sv ;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 補助テクスチャ座標<br>
        } VERTEX3DSHADER, *LPVERTEX3DSHADER ;<br>
        (以下、略).... </p>
      GPUに渡されるデータについては</a><a href="https://dxlib.xsrv.jp/function/dxfunc_3d_shader.html#R17N2">DX公式サイトにも説明</a>がある<br>
    コメントに書いてあるように、中身のメンバ変数は変わる可能性がある、<br>
    つまりゲームの3D表現ごとに描く際に必要な頂点に埋め込まれたデータは変わってくるわけなので、<br>
    3D保存データの保存データ構造 と 頂点データの定義 と シェーダのプログラム と GPU上の処理 はセットで考えられる必要があるということ。<br>
    ゆえに、ゲームごとにエンジンがカスタマイズされる際に、3Dモデルのデータの書き出しスクリプトを書く人や、<br>
    <a href="https://www.4gamer.net/games/619/G061991/20230823075/">データ構造自体からカスタマイズ</a>してシェーダのプログラムをできる人..などが、必要とされる人材となるわけです。<br>
    そのためには最低限、ポリゴンからシェーダーを経由して、画面にドットが映し出されるまでの過程をイメージできるだけのセンスが重要です。<br>
    今なぜわざわざシェーダやポリゴンデータを直接いじっているかというと、3Dの点がどういう風にシェーダのコードに渡って、画面にピクセルのドットとして描かれるかを体感して入門するためです。<br>
    <br>
    では、シェーダをmain.cppでロードして、画面に赤いサイコロを描いてみましょう。<br>
    <p><code>main.cpp</code>のコードを変更して自作シェーダーをGPU上で走らせて、サイコロを赤色で塗りつぶして描いてみましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
      #include "Input.h"<br>
      #include "Screen.h"<br>
      #include "Ply.h"<br>
      #include "DataMV1.h"<br>
      #include "DataPly.h"<br>
      #include "Collision3D.h"<br>
      #include "MyDraw.h" // 自作の描画処理<br>
      #include "Quaternion.h"<br>
      <br>
      #include "Editor.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>SetUseDirect3DVersion(DX_DIRECT3D_11); // 最新のDXライブラリはデフォルトでDirectX11版のシェーダー言語に対応しているが、念のため11に事前設定</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      &nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;&nbsp; float animTime = 0.0f; // アニメの現在時刻<br>
      &nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
      &nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@kick.mv1");<br>
      &nbsp;&nbsp;&nbsp; pDevilData-&gt;Load(); // 3Dモデルをmv1形式で読込み<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilAttackAnimData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@jump.mv1");<br>
      &nbsp;&nbsp;&nbsp; pDevilAttackAnimData-&gt;Load(); // 3Dの追加アニメデータをmv1形式で読込み<br>
      &nbsp;&nbsp;&nbsp; pDevilData-&gt;AttachAnim(*pDevilAttackAnimData); // アニメを追加でflyのほうをベースとしたモデルにアタッチ<br>
      &nbsp;&nbsp;&nbsp; int animeButton = 0; // ボタンでアニメを切り替えられるようにする<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; pTexImage = Resource::MakeShared&lt;Texture&gt;("Image/dice.png");<br>
      &nbsp;&nbsp;&nbsp; pTexImage-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
      &nbsp;&nbsp;&nbsp; assert((int)*pTexImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataPly&gt; pPlyData = Resource::MakeShared&lt;DataPly&gt;("Image/dice.ply");<br>
      &nbsp;&nbsp;&nbsp; pPlyData-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <em>int VertexShaderHandle = DxLib::LoadVertexShader("Shader/TestVS.vso"); // 頂点シェーダーを読み込む<br>
        &nbsp;&nbsp;&nbsp; int PixelShaderHandle&nbsp; = DxLib::LoadPixelShader("Shader/TestPS.pso");&nbsp; // ピクセルシェーダーを読み込む</em><br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
      &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f; keyControlXYZ.z = 0;<br>
      &nbsp;&nbsp;&nbsp; Quaternion quaternion; // 回転クオータニオン<br>
      <br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
      &nbsp;&nbsp;&nbsp; <br>
      <br>
      &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::weak_ptr&lt;DragPoint&gt;&gt; dragPoints; // ドラッグ対象の点の共有ポインタのリスト<br>
      <br>
      &nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateDragPoints(&amp;dragPoints); // ドラッグ点のリストを更新<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!editor.isDraggingPoints) editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードの 0 1 キーで3Dアニメを切り替えられるようにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_0))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 1;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width =&nbsp; pTexImage-&gt;m_XSize; float height =&nbsp; pTexImage-&gt;m_YSize; // テクスチャ画像のサイズ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f, 1.0f, 1.0f); // 拡大縮小スケール<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) quaternion *= CreateRotationQuaternion(speed * DX_PI / 180, VGet(1, 0, 0)); // X軸(1,0,0)を軸にspeed度ぶんだけ回転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) quaternion *= CreateRotationQuaternion(speed * DX_PI / 180, VGet(0, 1, 0)); // Y軸(0,1,0)を軸にspeed度ぶんだけ回転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) quaternion *= CreateRotationQuaternion(speed * DX_PI / 180, VGet(0, 0, 1)); // Z軸(0,0,1)を軸にspeed度ぶんだけ回転<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>DxLib::SetUseVertexShader(VertexShaderHandle); // 使用する頂点シェーダーをセット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUsePixelShader(PixelShaderHandle); // 使用するピクセルシェーダーをセット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseTextureToShader(0, *pTexImage); // 使用するテクスチャを0番にバインドする[ register( t0 ) ]</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, QuaternionToMatrix(quaternion)); // スケール × 回転<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D<em>ToShader</em>(pPlyData-&gt;Vertex.data(), pPlyData-&gt;Vertex.size(), pPlyData-&gt;Index.data(), pPlyData-&gt;numIndex / 3<u>, (int)*pTexImage, FALSE</u>); // 三角形ポリゴンをたくさん描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>DxLib::SetUseVertexShader(-1); // -1で毎度デフォルトのシェーダに戻しておけば他の3Dモデルの描画には影響を与えない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUsePixelShader(-1); // -1で毎度デフォルトのシェーダに戻しておけば他の3Dモデルの描画には影響を与えない</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto xyzAngle = QuaternionToAngle(quaternion); // クオータニオンからそれに対応するオイラー角度の候補を得る(候補は最大3種ありうるし、ある軸が傾いていて0度じゃない場合他の軸も連動)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 100, GetColor(255, 255, 0), "x:%f y:%f Angle:%d %d %d", position.x, position.y, (int)(xyzAngle[0].x * 180 / DX_PI), (int)(xyzAngle[0].y * 180 / DX_PI), (int)(xyzAngle[0].z * 180 / DX_PI));<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ファイルのパス + ":" + アニメ名でアクセス<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string animPathName = (animeButton == 0) ? "Image/devil@kick.mv1:mixamo.com" : "Image/devil@jump.mv1:mixamo.com";<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(pDevilData-&gt;count(animPathName) &gt; 0 &amp;&amp; "指定されたアニメ名のアニメはMV1に付属していませんでした");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime += animStepTime * animSpeed; // 1.0×2倍 なら2倍速でアニメ時刻が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animTime &gt; (*pDevilData)[animPathName].endTime)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime = 0.0f; // 0秒目へとアニメをループさせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 再生時間をセットする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1SetAttachAnimTime((int)*pDevilData, (*pDevilData)[animPathName].index, animTime);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); // エディタのDraw処理<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    いかがでしょうか？サイコロが赤で塗りつぶして描かれたでしょうか？<br>
    黒かったり白かったりする場合は、シェーダー言語のビルドに失敗しているか、シェーダーのフォルダが間違っている可能性が高いかと思うので見直してみてください。<br>
    <br>
    <br>
    <br>
    次に実験として、頂点シェーダで頂点のx位置が 0.0f以上か以下か で赤か青かに描き分ける実験をしてみよう。<br>
    <p><code>TestVS.fx</code>を変更して頂点のx位置が0.0f以上か以下かで 頂点カラーを赤か青かに描き分けます。</p>
    <p class="source"> <br>
      <br>
      <br>
      (前略).........<br>
      <br>
      // main関数<br>
      VS_OUTPUT main( VS_INPUT VSInput )<br>
      {<br>
      &nbsp;&nbsp;&nbsp; VS_OUTPUT VSOutput ;<br>
      &nbsp;&nbsp;&nbsp; float4 lLocalPosition;<br>
      &nbsp;&nbsp;&nbsp; float4 lWorldPosition;<br>
      &nbsp;&nbsp;&nbsp; float4 lViewPosition;<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // 頂点座標変換 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++( 開始 )<br>
      &nbsp;&nbsp;&nbsp; // ローカル座標のセット<br>
      &nbsp;&nbsp;&nbsp; lLocalPosition.xyz = VSInput.Position;<br>
      &nbsp;&nbsp;&nbsp; lLocalPosition.w = 1.0f;<br>
      &nbsp;&nbsp;&nbsp; // ローカル座標をワールド座標に変換<br>
      &nbsp;&nbsp;&nbsp; lWorldPosition.x = dot(lLocalPosition, g_Base.LocalWorldMatrix[0]);<br>
      &nbsp;&nbsp;&nbsp; lWorldPosition.y = dot(lLocalPosition, g_Base.LocalWorldMatrix[1]);<br>
      &nbsp;&nbsp;&nbsp; lWorldPosition.z = dot(lLocalPosition, g_Base.LocalWorldMatrix[2]);<br>
      &nbsp;&nbsp;&nbsp; lWorldPosition.w = 1.0f;<br>
      &nbsp;&nbsp;&nbsp; // ワールド座標をビュー座標に変換<br>
      &nbsp;&nbsp;&nbsp; lViewPosition.x = dot(lWorldPosition, g_Base.ViewMatrix[0]);<br>
      &nbsp;&nbsp;&nbsp; lViewPosition.y = dot(lWorldPosition, g_Base.ViewMatrix[1]);<br>
      &nbsp;&nbsp;&nbsp; lViewPosition.z = dot(lWorldPosition, g_Base.ViewMatrix[2]);<br>
      &nbsp;&nbsp;&nbsp; lViewPosition.w = 1.0f;<br>
      &nbsp;&nbsp;&nbsp; // ビュー座標を射影座標に変換<br>
      &nbsp;&nbsp;&nbsp; VSOutput.Position.x = dot(lViewPosition, g_Base.ProjectionMatrix[0]);<br>
      &nbsp;&nbsp;&nbsp; VSOutput.Position.y = dot(lViewPosition, g_Base.ProjectionMatrix[1]);<br>
      &nbsp;&nbsp;&nbsp; VSOutput.Position.z = dot(lViewPosition, g_Base.ProjectionMatrix[2]);<br>
      &nbsp;&nbsp;&nbsp; VSOutput.Position.w = dot(lViewPosition, g_Base.ProjectionMatrix[3]);<br>
      &nbsp;&nbsp;&nbsp; // 頂点座標変換 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++( 終了 )<br>
      <br>
      &nbsp;&nbsp;&nbsp; VSOutput.TexCoords0 = VSInput.TexCoords0; // テクスチャの座標をそのままOutputする<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // [実験]頂点カラーの拡散光を<em>xの位置が0.0f以上か以下かで青か赤かに描き分ける処理を書いてみる</em><br>
      &nbsp;&nbsp;&nbsp; VSOutput.Diffuse.r = <em>(VSOutput.Position.x &gt; 0.0f) ? 1.0f : 0.0f</em>; // R(赤の拡散値)<br>
      &nbsp;&nbsp;&nbsp; VSOutput.Diffuse.g = 0.0f; // G(緑の拡散値)<br>
      &nbsp;&nbsp;&nbsp; VSOutput.Diffuse.b = <em>(VSOutput.Position.x &gt; 0.0f) ? 0.0f : 1.0f</em>; // B(青の拡散値)<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 出力パラメータを返す<br>
      &nbsp;&nbsp;&nbsp; return VSOutput ;<br>
      }<br>
    </p>
    <br>
    TestVS.fxを変更したら保存して、<b>コマンドプロンプトから再びShaderCompiler.exeのコマンドでビルドしなおし</b>ます。(キーボードの<b>上キーを押すと過去に実行したコマンドが出てきて楽</b>) <br>
    いかがでしょう？実行したら、サイコロが真ん中より右方向(x＋方向:赤)か左方向(x－方向:青)かで描き分けられているでしょうか？<br>
    このように頂点シェーダを書き換えれば、3Dの点が1万個あったとしても、頂点すべてに対してfor文を1万回まわすことなくGPUで処理を行わせることができます。<br>
    3Dを描く際に、GPUにどのように計算の処理をさせているのかの実感が少し湧いたでしょうか？<br>
    <br>
    うーん、いまいちゲームに使う実感が湧かない？例えば、xやzに応じて色を描き分けられるということは、<a href="https://styly.cc/ja/tips/post-processing-water/">平面に模様をGPUで描かせることができるということ</a>です。<br>
    <br>
    <br>
    では、次の実験として、今度はTestPS.fxつまりピクセルシェーダーの方を変更して、サイコロのテクスチャの色を今作った頂点シェーダーからの色に掛け算してみましょう。<br>
    <p><code>TestPS.fx</code>を変更して下記コードで 頂点シェーダからやってくるのPSInputの拡散光(Diffuse) に テクスチャの模様の色を掛け算して合成してみましょう。</p>
    <p class="source">// ピクセルシェーダーの入力<br>
      struct PS_INPUT<br>
      {<br>
      &nbsp;&nbsp;&nbsp; float4 <b>Diffuse&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : COLOR0</b> ;<br>
      &nbsp;&nbsp;&nbsp; float4 Specular&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : COLOR1 ;<br>
      &nbsp;&nbsp;&nbsp; float2 <b>TexCoords0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : TEXCOORD0</b> ;<br>
      } ;<br>
      <br>
      // ピクセルシェーダーの出力<br>
      struct PS_OUTPUT<br>
      {<br>
      &nbsp;&nbsp;&nbsp; float4 <b>Color0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : SV_TARGET0</b> ;&nbsp;&nbsp;&nbsp; // 色<br>
      } ;<br>
      <br>
      <br>
      // [DirectX11版]定数バッファピクセルシェーダー基本パラメータ<br>
      struct DX_D3D11_PS_CONST_BUFFER_BASE<br>
      {<br>
      &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; FactorColor ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // アルファ値等<br>
      <br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MulAlphaColor ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カラーにアルファ値を乗算するかどうか( 0.0f:乗算しない&nbsp; 1.0f:乗算する )<br>
      &nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; AlphaTestRef ;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // アルファテストで使用する比較値<br>
      &nbsp;&nbsp;&nbsp; float2&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Padding1 ;<br>
      <br>
      &nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; AlphaTestCmpMode ;&nbsp;&nbsp;&nbsp; // アルファテスト比較モード( DX_CMP_NEVER など )<br>
      &nbsp;&nbsp;&nbsp; int3&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Padding2 ;<br>
      <br>
      &nbsp;&nbsp;&nbsp; float4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IgnoreTextureColor ;&nbsp;&nbsp;&nbsp; // テクスチャカラー無視処理用カラー<br>
      } ;<br>
      <br>
      // [DirectX11版]基本パラメータ https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4904<br>
      cbuffer cbD3D11_CONST_BUFFER_PS_BASE&nbsp;&nbsp;&nbsp; : register( b1 )<br>
      {<br>
      &nbsp;&nbsp;&nbsp; DX_D3D11_PS_CONST_BUFFER_BASE&nbsp;&nbsp;&nbsp; g_Base ;<br>
      } ;<br>
      <br>
      <br>
      <b>SamplerState g_DiffuseMapSampler&nbsp;&nbsp;&nbsp; : register( s0 ) ;&nbsp;&nbsp;&nbsp; // ディフューズマップテクスチャ<br>
        Texture2D&nbsp;&nbsp;&nbsp; g_DiffuseMapTexture&nbsp;&nbsp;&nbsp; : register( t0 ) ;&nbsp;&nbsp;&nbsp; // ディフューズマップテクスチャ</b><br>
      <br>
      <br>
      <br>
      // main関数<br>
      PS_OUTPUT main( PS_INPUT PSInput )<br>
      {<br>
      &nbsp;&nbsp;&nbsp; PS_OUTPUT PSOutput ;<br>
      &nbsp;&nbsp;&nbsp; <em>float4 <b>TextureDiffuseColor</b> ;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // テクスチャカラーの読み込み<br>
        &nbsp;&nbsp;&nbsp; <b>TextureDiffuseColor</b> = <b>g_DiffuseMapTexture</b>.Sample(<b>g_DiffuseMapSampler</b>, PSInput.TexCoords0);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>// 頂点シェーダなどを経由してやってきたDiffuse拡散光の色をそのまま画面スクリーンのピクセル色としてOutputする<br>
        &nbsp;&nbsp;&nbsp; PSOutput.Color0.r = PSInput.Diffuse.r ; // R:赤&nbsp;&nbsp;&nbsp;&nbsp; 画面スクリーン上のピクセル色<br>
        &nbsp;&nbsp;&nbsp; PSOutput.Color0.g = PSInput.Diffuse.g ; // G:緑&nbsp;&nbsp;&nbsp;&nbsp; 画面スクリーン上のピクセル色<br>
        &nbsp;&nbsp;&nbsp; PSOutput.Color0.b = PSInput.Diffuse.b ; // B:青&nbsp;&nbsp;&nbsp;&nbsp; 画面スクリーン上のピクセル色<br>
        &nbsp;&nbsp;&nbsp; PSOutput.Color0.a = PSInput.Diffuse.a ; // A:透明度 画面スクリーン上のピクセル色</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// [実験]出力する色はテクスチャの色とディフューズカラーをかけ算したもの<br>
        &nbsp;&nbsp;&nbsp; PSOutput.<b>Color0</b> = <b>TextureDiffuseColor</b> * PSInput.Diffuse;</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 出力パラメータを返す<br>
      &nbsp;&nbsp;&nbsp; return PSOutput ;<br>
      }<br>
    </p>
    <br>
    いかがでしょう？サイコロの模様と先ほどの頂点シェーダーで描き分けた赤と青が合成されて表示されたでしょうか？<br>
    このように、かけ算によって 色の数値 と テクスチャの模様 を GPUで各ドット(ピクセル)で、かけ算することもできるわけです。<br>
    こういった視点をもった上で、普段プレイしているゲームをプレイすると、もしかしたらこの床の模様、このアイテムの点滅や光りかた、シェーダでやってるのでは？という視点が養えます。<br>
    <br>
    <br>
  </body>
</html>
