<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>[C++]3D描画エンジン</title>
    <link rel="stylesheet" href="../style.css">
    <style>
      
    </style>
  </head>
  <body>
    <p class="title">[C++]3D描画エンジン1</p>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId0001">試しにポリゴンを表示してみる</a></li>
      <li><a href="#mozTocId0002">ポリゴンの光の色表示の基礎となっている「拡散反射光:ディフューズ値」の値を変更してみる</a></li>
      <li><a href="#mozTocId0003">シンプルな.ply形式の3Dデータフォーマットを読み取ってポリゴン表示してみる</a></li>
      <li><a href="#mozTocId0004">Blenderをインストールして3Dのサイコロとテクスチャ画像を書き出してXYZ軸を見極める</a></li>
      <li><a href="#mozTocId0005">別の描画スクリーンを作って、Windowsみたいなサブのウィンドウを描く</a></li>
      <li><a href="#mozTocId0006">エディタを自作して視点カメラを動かせるようにする</a></li>
      <li><a href="#mozTocId0007">キーボードのWSキーでカメラ視点を手前や奥に移動できるようにする</a></li>
      <li><a href="#mozTocId0008">キーボードのDAキーとEQキーでカメラ視点を左右や上下に移動できるようにする</a></li>
      <li><a href="#mozTocId0009">Unityのアセットストアからとってきたテクスチャ1枚のシンプルな3DモデルをDXのモデルビューアで.mv1形式に変換して表示させてみる</a></li>
      <li><a href="#mozTocId0010">MV1形式の3Dモデルをアニメーション描画する</a></li>
      <li><a href="#mozTocId0011">複数の3DモデルやアニメをResourceクラスで2重ロードしないよう読み込んで複数アニメを切替えする</a></li>
      <li><a href="#mozTocId0012">.ply形式の3DモデルデータをResourceクラスを継承したDataPly構造体で読み込む</a></li>
      <li><a href="#mozTocId0013">Vector3に色々な関数を用意して3D空間の当たり判定をする</a></li>
    </ol>
    <br>
    <a id="mozTocId0001" class="mozTocH1">
      <h1>試しにポリゴンを表示してみる</h1>
    </a>
    <p><a id="mozTocId0001" class="mozTocH1"><code>main.cpp</code>にプログラムを追加し、ポリゴン画像が正しく表示できるかテストします。<br>
        (DXの</a><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId0002">プロジェクトとScreen.hはシューティングの別記事を参考</a>に作っておいてください、<br>
      画像ファイルは<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId0003">シュー ティングの別記事を参考</a>にImage/boss1.pngで保管されている前提で進めます)</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
      &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
      &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
      &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0; keyControlXYZ.y = Screen::Height; keyControlXYZ.z = 0;<br>
      &nbsp;&nbsp;&nbsp; float keyControlAngle = 0.0f; // 回転<br>
      &nbsp;&nbsp;&nbsp; int animTime = 0; // アニメーションの時刻カウンタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0) <br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x = keyControlXYZ.x; float y = keyControlXYZ.y; float z = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float scaleX = 0.5f; float scaleY = 0.5f; // 拡大縮小スケール<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)でz軸(画面奥方向)まわりに画像を回転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlAngle += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_B) keyControlAngle -= speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = 0 * Deg2Rad;&nbsp; const float yRotate = 0 * Deg2Rad; const float zRotate = keyControlAngle * Deg2Rad;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u0 = 0.0f; const float v0 = 0.0f; // テクスチャのUV切り出し起点(u:0～1.0, v:0～1.0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u1 = 1.0f; const float v1 = 1.0f; // テクスチャのUV切り出し終点 1.0は画像の右下を表す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerX = x + width * scaleX / 2; // 四角形の中心(x+width/2,y-height/2,z)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerY = y - height * scaleY / 2;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityのxyz方向と回転] https://gametukurikata.com/basic/xyzaxis<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityの回転ZXYの順で適用したもの] https://light11.hatenadiary.com/entry/2019/01/24/223705<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX TransformMatrix = MGetTranslate(VGet(-centerX, -centerY, -z)); // 四角形の中心を 原点(0,0,0)に一旦移動させてから回転させる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotZ(zRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotX(xRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotY(yRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetTranslate(VGet(centerX, centerY, z))); // 四角形の中心ぶんだけ平行移動させて戻す<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 四角ポリゴンのインデックス順<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(時計回りが表面)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↓(x,y)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 0-1 4 ←(x + width * scale, y)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; |/ /|<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 2 3-5 ←(x + width * scale, y - height * scale)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↑(x, y - height * scale)&nbsp;&nbsp;&nbsp;&nbsp; ↑[UIのy方向は下だが3D空間上は上が+方向なのでheightを-1方向に]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; rectVertex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex.resize(4);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;unsigned int&gt; rectIndex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex.resize(6);&nbsp; // 4頂点のうち 右上(1と4)と左下(2と3)は同位置に2つ頂点を使う(三角形2つぶんのため) 4頂点 + 2被り = 6<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4頂点分のデータをセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左上(0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].pos = VTransform(VGet(x, y, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].norm = VGet(0.0f, 0.0f, -1.0f); // 法線ベクトル(面の反射方向:z方向-1.0のベクトルなら光がzマイナス方向に反射)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].dif = GetColorU8(255, 255, 255, 255); // 拡散反射光の色<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].spc = GetColorU8(255, 255, 255, 255); // 鏡面反射光の色<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].u = u0; // テクスチャ切り出し点 U(横方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].v = v0; // テクスチャ切り出し点 V(縦方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].su = 0.0f; // 補助テクスチャのUV(いまはない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右上(1と4)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].pos = VTransform(VGet(x + width * scaleX, y, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].norm = VGet(0.0f, 0.0f, -1.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].u = u1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].v = v0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].su = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左下(2と3)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].pos = VTransform(VGet(x, y - height * scaleY, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].norm = VGet(0.0f, 0.0f, -1.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].u = u0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].v = v1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].su = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右下(5)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].pos = VTransform(VGet(x + width * scaleX, y - height * scaleY, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].norm = VGet(0.0f, 0.0f, -1.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].u = u1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].v = v1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].su = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2ポリゴン分のインデックス順データをセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[0] = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[1] = 1; // 0-1 4<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[2] = 2; // |/ /|&nbsp;&nbsp; 0,1,2で左上ポリゴンを 3,4,5で右下ポリゴンを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[3] = 2; // 2 3-5<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[4] = 1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[5] = 3;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++animTime;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isDrawPolygon = animTime % 60 &gt; 30; // 30フレームに1回三角ポリゴン(1個)と四角(2個)を描くのを切り替える↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::<span style="font-weight: bold;">DrawPolygon32bitIndexed3D</span>(rectVertex.data(), rectVertex.size(), rectIndex.data(), (isDrawPolygon) ? 1 : 2, texImage, FALSE); // 三角形ポリゴン2枚を描画<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(VGet(x, y, z), 4.0f, 8, GetColor(255, 255, 0), GetColor(255, 255, 0),TRUE); // 左上に黄色の3D球を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f", x, y, keyControlAngle);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <p><code>main.cpp</code>のプログラムを変更し、ポリゴンのインデックスの順番がポリゴンの表(時計回 り)と裏(反時計回り)に 影響を与えることを確認しましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      // ＃includeで別ファイルのヘッダファイル.hをこのコード内に読み込む<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
      &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/boss1.png");<br>
      &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
      &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
      &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0; keyControlXYZ.y = Screen::Height; keyControlXYZ.z = 0;<br>
      &nbsp;&nbsp;&nbsp; float keyControlAngle = 0.0f; // 回転<br>
      &nbsp;&nbsp;&nbsp; int animTime = 0; // アニメーションの時刻カウンタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0) <br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x = keyControlXYZ.x; float y = keyControlXYZ.y; float z = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float scaleX = 0.5f; float scaleY = 0.5f; // 拡大縮小スケール<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)でz軸(画面奥方向)まわりに画像を回転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlAngle += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_B) keyControlAngle -= speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = 0 * Deg2Rad;&nbsp; const float yRotate = <em>keyControlAngle</em> * Deg2Rad; const float zRotate = <em>0</em> * Deg2Rad;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u0 = 0.0f; const float v0 = 0.0f; // テクスチャのUV切り出し起点(u:0～1.0, v:0～1.0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u1 = 1.0f; const float v1 = 1.0f; // テクスチャのUV切り出し終点 1.0は画像の右下を表す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerX = x + width * scaleX / 2; // 四角形の中心(x+width/2,y-height/2,z)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerY = y - height * scaleY / 2;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityのxyz方向と回転] https://gametukurikata.com/basic/xyzaxis<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityの回転ZXYの順で適用したもの] https://light11.hatenadiary.com/entry/2019/01/24/223705<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX TransformMatrix = MGetTranslate(VGet(-centerX, -centerY, -z)); // 四角形の中心を 原点(0,0,0)に一旦移動させてから回転させる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotZ(zRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotX(xRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotY(yRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetTranslate(VGet(centerX, centerY, z))); // 四角形の中心ぶんだけ平行移動させて戻す<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 四角ポリゴンのインデックス順<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(時計回りが表面)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↓(x,y)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 0-1 4 ←(x + width * scale, y)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; |/ /|<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 2 3-5 ←(x + width * scale, y - height * scale)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↑(x, y - height * scale)&nbsp;&nbsp;&nbsp;&nbsp; ↑[UIのy方向は下だが3D空間上は上が+方向なのでheightを-1方向に]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; rectVertex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex.resize(4);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;unsigned int&gt; rectIndex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex.resize(6);&nbsp; // 4頂点のうち 右上(1と4)と左下(2と3)は同位置に2つ頂点を使う(三角形2つぶんのため) 4頂点 + 2被り = 6<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4頂点分のデータをセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左上(0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].pos = VTransform(VGet(x, y, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].norm = VGet(0.0f, 0.0f, -1.0f); // 法線ベクトル(面の反射方向:z方向-1.0のベクトルなら光がzマイナス方向に反射)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].dif = GetColorU8(255, 255, 255, 255); // 拡散反射光の色<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].spc = GetColorU8(255, 255, 255, 255); // 鏡面反射光の色<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].u = u0; // テクスチャ切り出し点 U(横方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].v = v0; // テクスチャ切り出し点 V(縦方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].su = 0.0f; // 補助テクスチャのUV(いまはない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右上(1と4)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].pos = VTransform(VGet(x + width * scaleX, y, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].norm = VGet(0.0f, 0.0f, -1.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].u = u1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].v = v0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].su = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左下(2と3)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].pos = VTransform(VGet(x, y - height * scaleY, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].norm = VGet(0.0f, 0.0f, -1.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].u = u0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].v = v1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].su = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右下(5)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].pos = VTransform(VGet(x + width * scaleX, y - height * scaleY, z), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].norm = VGet(0.0f, 0.0f, -1.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].u = u1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].v = v1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].su = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].sv = 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2ポリゴン分のインデックス順データをセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[0] = <em>2</em>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[1] = 1; // 0-1 4<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[2] = <em>0</em>; // |/ /|&nbsp;&nbsp; 0,1,2で左上ポリゴンを 3,4,5で右下ポリゴンを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[3] = 2; // 2 3-5<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[4] = 1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[5] = 3;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++animTime;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isDrawPolygon = animTime % 60 &gt; 30; // 30フレームに1回三角ポリゴン(1個)と四角(2個)を描くのを切り替える↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(rectVertex.data(), rectVertex.size(), rectIndex.data(), (isDrawPolygon) ? 1 : 2, texImage, FALSE); // 三角形ポリゴン2枚を描画<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(VGet(x, y, z), 4.0f, 8, GetColor(255, 255, 0), GetColor(255, 255, 0),TRUE); // 左上に黄色の3D球を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f", x, y, keyControlAngle);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <p>いかがですか？キーボードのzキーとxキーでポリゴンをまわしてみ てポリゴンを裏から見ると表示されることが確認できましたか?<br>
    </p>
    <br>
    <br>
    <br>
    <a id="mozTocId0002" class="mozTocH1">
      <h1>ポリゴンの光の色表示の基礎となっている「拡散反射光: ディ フューズ値」の値を変更してみる</h1>
      <p><code>main.cpp</code>のプログラムを変更し、ポリゴンの<span style="text-decoration: underline;">difの値(拡散反射光:ディフューズ値)</span>がポリゴンの反射 する色に影響を与えることを確認しましょう。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
        #include "Screen.h"<br>
        // ＃includeで別ファイルのヘッダファイル.hをこのコード内に読み込む<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
        &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/boss1.png");<br>
        &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
        &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0; keyControlXYZ.y = Screen::Height; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; float keyControlAngle = 0.0f; // 回転<br>
        &nbsp;&nbsp;&nbsp; int animTime = 0; // アニメーションの時刻カウンタ<br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0) <br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x = keyControlXYZ.x; float y = keyControlXYZ.y; float z = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float scaleX = 0.5f; float scaleY = 0.5f; // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)でz軸(画面奥方向)まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlAngle += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_B) keyControlAngle -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = 0 * Deg2Rad;&nbsp; const float yRotate = <em>0</em> * Deg2Rad; const float zRotate = <em>keyControlAngle</em><em></em> * Deg2Rad;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u0 = 0.0f; const float v0 = 0.0f; // テクスチャのUV切り出し起点(u:0～1.0, v:0～1.0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u1 = 1.0f; const float v1 = 1.0f; // テクスチャのUV切り出し終点 1.0は画像の右下を表す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerX = x + width * scaleX / 2; // 四角形の中心(x+width/2,y-height/2,z)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerY = y - height * scaleY / 2;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityのxyz方向と回転] https://gametukurikata.com/basic/xyzaxis<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityの回転ZXYの順で適用したもの] https://light11.hatenadiary.com/entry/2019/01/24/223705<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX TransformMatrix = MGetTranslate(VGet(-centerX, -centerY, -z)); // 四角形の中心を 原点(0,0,0)に一旦移動させてから回転させる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetTranslate(VGet(centerX, centerY, z))); // 四角形の中心ぶんだけ平行移動させて戻す<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 四角ポリゴンのインデックス順<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(時計回りが表面)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↓(x,y)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 0-1 4 ←(x + width * scale, y)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; |/ /|<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 2 3-5 ←(x + width * scale, y - height * scale)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↑(x, y - height * scale)&nbsp;&nbsp;&nbsp;&nbsp; ↑[UIのy方向は下だが3D空間上は上が+方向なのでheightを-1方向に]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; rectVertex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex.resize(4);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;unsigned int&gt; rectIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex.resize(6);&nbsp; // 4頂点のうち 右上(1と4)と左下(2と3)は同位置に2つ頂点を使う(三角形2つぶんのため) 4頂点 + 2被り = 6<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4頂点分のデータをセット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左上(0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].pos = VTransform(VGet(x, y, z), TransformMatrix);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].norm = VGet(0.0f, 0.0f, -1.0f); // 法線ベクトル(面の反射方向:z方向-1.0のベクトルなら光がzマイナス方向に反射)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].dif = GetColorU8(255, <em>0</em>, <em>0</em>, 255); // 拡散反射光の色<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].spc = GetColorU8(255, 255, 255, 255); // 鏡面反射光の色<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].u = u0; // テクスチャ切り出し点 U(横方向)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].v = v0; // テクスチャ切り出し点 V(縦方向)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].su = 0.0f; // 補助テクスチャのUV(いまはない)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].sv = 0.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右上(1と4)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].pos = VTransform(VGet(x + width * scaleX, y, z), TransformMatrix);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].norm = VGet(0.0f, 0.0f, -1.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].dif = GetColorU8(<em>0</em>, <em>0</em>, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].u = u1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].v = v0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].su = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].sv = 0.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左下(2と3)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].pos = VTransform(VGet(x, y - height * scaleY, z), TransformMatrix);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].norm = VGet(0.0f, 0.0f, -1.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].dif = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].u = u0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].v = v1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].su = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].sv = 0.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右下(5)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].pos = VTransform(VGet(x + width * scaleX, y - height * scaleY, z), TransformMatrix);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].norm = VGet(0.0f, 0.0f, -1.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].dif = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].u = u1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].v = v1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].su = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].sv = 0.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2ポリゴン分のインデックス順データをセット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[0] = <em>0</em>;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[1] = 1; // 0-1 4<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[2] = <em>2</em>; // |/ /|&nbsp;&nbsp; 0,1,2で左上ポリゴンを 3,4,5で右下ポリゴンを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[3] = 2; // 2 3-5<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[4] = 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[5] = 3;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++animTime;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isDrawPolygon = animTime % 60 &gt; 30; // 30フレームに1回三角ポリゴン(1個)と四角(2個)を描くのを切り替える↓<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(rectVertex.data(), rectVertex.size(), rectIndex.data(), (isDrawPolygon) ? 1 : 2, texImage, FALSE); // 三角形ポリゴン2枚を描画<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(VGet(x, y, z), 4.0f, 8, GetColor(255, 255, 0), GetColor(255, 255, 0),TRUE); // 左上に黄色の3D球を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f", x, y, keyControlAngle);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      <br>
      <br>
    </a><a id="mozTocId0003" class="mozTocH1">
      <h1>シンプルな.ply形式の3Dデータフォーマットを読み取ってポリゴン表示してみる</h1>
      <p><code>メモ帳を開いて下記データをコピペして dicetest.plyという名前でImageフォルダに保存</code>しましょう。</p>
      <p class="source">ply<br>
        format ascii 1.0<br>
        comment Created by Blender 3.5.1 - www.blender.org<br>
        element vertex 14<br>
        property float x<br>
        property float y<br>
        property float z<br>
        property float nx<br>
        property float ny<br>
        property float nz<br>
        property float s<br>
        property float t<br>
        element face 12<br>
        property list uchar uint vertex_indices<br>
        end_header<br>
        -1.000000 1.000000 1.000000 0.000000 0.000000 1.000000 0.875000 0.500000<br>
        1.000000 -1.000000 1.000000 0.577350 -0.577350 0.577350 0.625000 0.750000<br>
        1.000000 1.000000 1.000000 0.577350 0.577350 0.577350 0.625000 0.500000<br>
        -1.000000 -1.000000 -1.000000 0.000000 -1.000000 0.000000 0.375000 1.000000<br>
        1.000000 -1.000000 -1.000000 0.577350 -0.577350 -0.577350 0.375000 0.750000<br>
        -1.000000 -1.000000 1.000000 -1.000000 0.000000 0.000000 0.625000 0.000000<br>
        -1.000000 1.000000 -1.000000 -0.707107 0.707107 0.000000 0.375000 0.250000<br>
        -1.000000 -1.000000 -1.000000 -1.000000 0.000000 0.000000 0.375000 0.000000<br>
        1.000000 1.000000 -1.000000 0.577350 0.577350 -0.577350 0.375000 0.500000<br>
        -1.000000 -1.000000 -1.000000 0.000000 0.000000 -1.000000 0.125000 0.750000<br>
        -1.000000 1.000000 -1.000000 0.000000 0.000000 -1.000000 0.125000 0.500000<br>
        -1.000000 1.000000 1.000000 -0.707107 0.707107 0.000000 0.625000 0.250000<br>
        -1.000000 -1.000000 1.000000 0.000000 0.000000 1.000000 0.875000 0.750000<br>
        -1.000000 -1.000000 1.000000 0.000000 -1.000000 0.000000 0.625000 1.000000<br>
        3 0 1 2<br>
        3 1 3 4<br>
        3 5 6 7<br>
        3 8 9 10<br>
        3 2 4 8<br>
        3 8 11 2<br>
        3 0 12 1<br>
        3 1 13 3<br>
        3 5 11 6<br>
        3 8 4 9<br>
        3 2 1 4<br>
        3 8 6 11<br>
      </p>
      <br>
      <p><code>Ply.hを新規作成</code>して、ファイルから.ply形式の3Dフォーマットを読み取るための処理を準 備しましょう。</p>
      <p class="source">#ifndef PLY_H_<br>
        #define PLY_H_<br>
        <br>
        #include &lt;assert.h&gt; // 読込み失敗表示用<br>
        #include &lt;string&gt;<br>
        #include &lt;vector&gt;<br>
        #include &lt;memory&gt;<br>
        #include &lt;utility&gt; // ペア型std::pairを使う<br>
        #include &lt;typeindex&gt; // std::type_indexを使えばunordered_mapの辞書のキーにfloatなどのタイプの型を指定できるようになる<br>
        #include &lt;unordered_map&gt;<br>
        #include &lt;fstream&gt; // ファイル読み出しifstreamに必要<br>
        #include &lt;sstream&gt; // 文字列ストリームに必要<br>
        #include &lt;functional&gt; // std::functionでラムダ式を関数の引数にできる<br>
        <br>
        namespace Ply //[.ply形式の3Dデータを読みだす]https://ja.wikipedia.org/wiki/PLY_(%E3%83%95%E3%82 %A1%E3%82%A4%E3%83%AB%E5%BD%A2%E5%BC%8F)<br>
        {<br>
        &nbsp;&nbsp; &nbsp;enum class FileFormat { ASCII, BINARY };<br>
        <br>
        &nbsp;&nbsp; &nbsp;const std::type_index CHAR = std::type_index(typeid(int8_t));<br>
        &nbsp;&nbsp; &nbsp;const std::type_index UCHAR = std::type_index(typeid(uint8_t));<br>
        &nbsp;&nbsp; &nbsp;const std::type_index SHORT = std::type_index(typeid(int16_t));<br>
        &nbsp;&nbsp; &nbsp;const std::type_index USHORT = std::type_index(typeid(uint16_t));<br>
        &nbsp;&nbsp; &nbsp;const std::type_index INT = std::type_index(typeid(int32_t));<br>
        &nbsp;&nbsp; &nbsp;const std::type_index UINT = std::type_index(typeid(uint32_t));<br>
        &nbsp;&nbsp; &nbsp;const std::type_index FLOAT = std::type_index(typeid(float));<br>
        &nbsp;&nbsp; &nbsp;const std::type_index DOUBLE = std::type_index(typeid(double));<br>
        <br>
        &nbsp;&nbsp; &nbsp;// ビックエンディアン方式でメモリに数値が格納される環境かチェック https://qiita.com/nia_tn1012/items/340a1f0ad71bf6085f7f<br>
        &nbsp;&nbsp; &nbsp;static bool isBigEndian()<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 0x01020304 という 4バイト数値 が メモリ上に 0x01 0x02 0x03 0x04 と上位バイトから順に格納する方式ならビッグエンディアンと判定<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const uint32_t i = 0x01020304; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↑<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return reinterpret_cast&lt;const uint8_t*&gt;(&amp;i)[0] == 1;<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;const std::unordered_map&lt;std::type_index, int&gt; dataTypeByteSize // データタイプFLOATなど から そのステップサイズ(データ量)=4バイト への変換辞書<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { CHAR, sizeof(char) }, // sizeof(char) = 1バイト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { UCHAR, sizeof(unsigned char) }, // sizeof(unsigned char) = 1バイト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { SHORT, sizeof(int16_t) }, // sizeof(int16_t) = 2バイト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { USHORT, sizeof(uint16_t) }, // sizeof(uint16_t) = 2バイト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { INT, sizeof(int32_t) }, // sizeof(int32_t) = 4バイト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { UINT, sizeof(uint32_t) }, // sizeof(uint32_t) = 4バイト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { FLOAT, sizeof(float) }, // sizeof(float) = 4バイト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { DOUBLE, sizeof(double) } // sizeof(double) = 8バイト<br>
        &nbsp;&nbsp; &nbsp;};<br>
        <br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(char) == 1, "sizeof(char) = 1バイトじゃないので何かおかしい");<br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(unsigned char) == 1, "sizeof(unsigned char) = 1バイトじゃないので何かおかしい");<br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(int16_t) == 2, "sizeof(int16_t) = 2バイトじゃないので何かおかしい");<br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(uint16_t) == 2, "sizeof(uint16_t) = 2バイトじゃないので何かおかしい");<br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(int32_t) == 4, "sizeof(int32_t) = 4バイトじゃないので何かおかしい");<br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(uint32_t) == 4, "sizeof(uint32_t) = 4バイトじゃないので何かおかしい");<br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(float) == 4, "sizeof(float) = 4バイトじゃないので何かおかしい");<br>
        &nbsp;&nbsp; &nbsp;static_assert(sizeof(double) == 8, "sizeof(double) = 8バイトじゃないので何かおかしい");<br>
        <br>
        &nbsp;&nbsp; &nbsp;const std::unordered_map&lt;std::string, std::type_index&gt; strToDataType // "int32"などの文字列 → INTなどそのタイプ(std::type_index)への変換辞書<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { "char", CHAR }, { "uchar", UCHAR }, { "uint8", UCHAR },<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { "short", SHORT }, { "ushort", USHORT }, { "uint16", USHORT },<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { "int", INT }, { "int32", INT }, { "uint", UINT }, { "uint32", UINT },<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { "float", FLOAT }, { "float32", FLOAT },<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { "double", DOUBLE }, { "float64", DOUBLE }<br>
        &nbsp;&nbsp; &nbsp;};<br>
        <br>
        &nbsp;&nbsp; &nbsp;const std::unordered_map&lt;std::type_index, std::string&gt; dataTypeToStr // INTなどそのタイプ から "int32"など文字列への変換辞書<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { CHAR, "char" }, { UCHAR, "uchar" },<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { SHORT, "short" }, { USHORT, "ushort" },<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { INT, "int" }, { UINT, "uint" },<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { FLOAT, "float" }, { DOUBLE, "double" },<br>
        &nbsp;&nbsp; &nbsp;};<br>
        <br>
        &nbsp;&nbsp; &nbsp;// std::type_index(typeid(float)) などのタイプから そのステップバイト数=4バイト に変換<br>
        &nbsp;&nbsp; &nbsp;static size_t dataTypeToStepSize(const std::type_index&amp; type)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; auto it = dataTypeByteSize.find(type);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; assert(it != dataTypeByteSize.end() &amp;&amp; "指定された type は plyのヘッダで未定義です");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return it-&gt;second;<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;// "int" や "float32"などを std::type_index(typeid(float)) など std::type_index型に変換<br>
        &nbsp;&nbsp; &nbsp;static std::type_index parseDataType(const std::string&amp; type_name)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const auto&amp; it = strToDataType.find(type_name);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (it != strToDataType.end()) return it-&gt;second;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else throw std::exception(std::string("よくわからん定義してないタイプ名が来た:" + type_name).c_str());<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;template&lt;typename Key, typename Value&gt;<br>
        &nbsp;&nbsp; &nbsp;struct IndexList<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;private:<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; typedef typename std::pair&lt;Key, std::shared_ptr&lt;Value&gt;&gt; KeyValue;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;KeyValue&gt; data; // data配列にはキー"x" "y"などとバリュー(PropertyやElementなど)の"x"の型の情報(Property)が入る<br>
        &nbsp;&nbsp; &nbsp;public:<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Value&gt; operator[] (const Key&amp; key)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto it = std::find_if(begin(), end(), [&amp;key](const KeyValue&amp; keyVal) { return keyVal.first == key; });<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(it != end() &amp;&amp; "未登録のキーに[]でアクセスしようとしました");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return it-&gt;second;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // ["x"] や ["vertex"]のようにプロパティやエレメントに[]オペレータでアクセスできる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const std::shared_ptr&lt;const Value&gt; operator[] (const Key&amp; key) const<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; &nbsp;// keyに "x" が入ってきたらdata配列のbegin()からend()までkeyが "x"になるKeyValueを探す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto it = std::find_if(begin(), end(), [&amp;key](const KeyValue&amp; keyVal) { return keyVal.first == key; });<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(it != end() &amp;&amp; "未登録のキーに[]でアクセスしようとしました");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return it-&gt;second; // "x" のsecondがfloat型ならばfloat型のデータへの共有ポインタのアクセスを返す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; bool has_key(const Key&amp; key) // xやredなどキーが.plyのヘッダで例.property float x などのように宣言されているか<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto it = std::find_if(begin(), end(), [&amp;key](const KeyValue&amp; keyVal) { return keyVal.first == key; });<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (it != end()) return true;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; return false;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; void emplace_back(const Key&amp; key, const std::shared_ptr&lt;Value&gt;&amp; value)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; data.emplace_back(key, value);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; void clear() { data.clear(); }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; typedef typename std::vector&lt;std::pair&lt;Key, std::shared_ptr&lt;Value&gt;&gt;&gt;::iterator iterator;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; typedef typename std::vector&lt;std::pair&lt;Key, std::shared_ptr&lt;Value&gt;&gt;&gt;::const_iterator const_iterator;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // 範囲for文のためのイテレータの先頭beginと終端endを定義<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; iterator begin() { return data.begin(); };<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const_iterator begin() const { return data.begin(); };<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; iterator end() { return data.end(); };<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const_iterator end() const { return data.end(); };<br>
        &nbsp;&nbsp; &nbsp;};<br>
        <br>
        &nbsp;&nbsp; &nbsp;class Property // プロパティの例. property float x なら "x" は std::vector&lt;unsigned char&gt; dataにfloat型4バイト枠data[][][][]にまたがって保管<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;public:<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // ※unsigned char型の1バイト配列として定義してあるが実際に格納されるデータは2バイトなら箱2つ[ ][ ]で[ ]をまたいで格納される<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;unsigned char&gt; data; // 読みだしたプロパティのデータの書き込み先配列<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const std::type_index type; // プロパティのタイプ 例. property float x なら floatのstd::type_index<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const unsigned int stepSize; // プロパティのデータのステップサイズ数 例. floatやint = 4バイト stepSize = 4<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const bool isList = false; // 例. property list uchar uint vertex_indices なら isList = true<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const size_t elementSize = 0; // エレメントのサイズ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //std::vector&lt;unsigned char&gt; listCounts;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Property(const std::type_index type, const size_t size, const bool isList = false, const size_t elementSize = 0)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : type{ type }, isList{ isList }, stepSize{ (unsigned int)Ply::dataTypeToStepSize(type) }, elementSize{ elementSize }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;data.resize(size * this-&gt;stepSize); // データの書き込み先配列のメモリを事前確保しておく<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; template&lt;typename T&gt; // TがPropertyのタイプと一致するか判定<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; bool isType() const { return (type == std::type_index(typeid(T))); }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; template&lt;typename T&gt; // T型としてdata配列の先頭への T型のポインタを得る(const不変縛り)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const T* ptr() const { assert(isType&lt;T&gt;()); return reinterpret_cast&lt;const T*&gt;(&amp;data[0]); }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; template&lt;typename T&gt; // T型としてdata配列の先頭への T型のポインタを得る<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; T* ptr() { assert(isType&lt;T&gt;()); return reinterpret_cast&lt;T*&gt;(data.data()); }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // data配列のサイズをPropertyのステップサイズで割ることで配列の要素数を得られる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const size_t size() const { assert(data.size() % stepSize == 0); return data.size() / stepSize; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; template&lt;typename T&gt;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const T&amp; at(const size_t i) const<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(isType&lt;T&gt;());<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert((i + 1) * stepSize &lt;= data.size()); //↓ [ ]をまたいで格納しているぶん i * stepSizeで<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return&nbsp; *reinterpret_cast&lt;const T*&gt;(&amp;data[i * stepSize]); // 2バイトなら箱2つ[ ][ ] i×2ぶんずらしたアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; template&lt;typename T&gt;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; T&amp; at(const size_t i)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(isType&lt;T&gt;());<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert((i + 1) * stepSize &lt;= data.size()); //↓ [ ]をまたいで格納しているぶん i * stepSizeで<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return&nbsp; *reinterpret_cast&lt;T*&gt;(&amp;data[i * stepSize]); // 2バイトなら箱2つ[ ][ ] i×2ぶんずらしたアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;};<br>
        <br>
        &nbsp;&nbsp; &nbsp;class Elements // .plyの各elementを表す 例. element face 12 = ポリゴンが size = 12面ぶんありdata["face"]でアクセスできる<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; size_t size_;<br>
        &nbsp;&nbsp; &nbsp;public:<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Elements(const size_t size) : size_(size) {}<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; IndexList&lt;std::string, Property&gt; properties; // elementにぶらさがっている property float x などのリスト<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; size_t size() const { return size_; }<br>
        &nbsp;&nbsp; &nbsp;};<br>
        <br>
        <br>
        &nbsp;&nbsp; &nbsp;typedef IndexList&lt;std::string, Elements&gt; Data; //　["x"] や["vertex"]のようにプロパティやエレメントに[]オペレータでアクセスして使う<br>
        <br>
        &nbsp;&nbsp; &nbsp;// Windowsで作成されたファイルは改行コード \n に \r がついたcarrige return形式になっているので除去してstd::getlineできる関数<br>
        &nbsp;&nbsp; &nbsp;inline void getline_carriage_return(std::ifstream&amp; inputfile, std::string&amp; line)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::getline(inputfile, line); // ファイルから1行をstd::getlineで取得<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // Windowsで作成されたファイルは改行コード \n に \r がついたcarrige return形式になっているので除去<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (!line.empty() &amp;&amp; line.back() == '\r')<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; line.pop_back();<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;// " "スペース区切りでresult配列に出力する<br>
        &nbsp;&nbsp; &nbsp;inline void split_space(const std::string&amp; input, std::vector&lt;std::string&gt;&amp; result)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; result.clear();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::stringstream ss(input);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; while (true)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string elem;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ss &gt;&gt; elem; // ssで&gt;&gt;するたびに" "スペースで区切られてelemに文字列が読みだされていく<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (ss.fail()) break;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; result.push_back(elem);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;inline size_t str_to_size_t(const std::string&amp; input) // 文字列をstd::stringstreamの &gt;&gt; でsize_t型の数値に変換<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::stringstream ss(input);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; size_t val; // size_t型はunsigned long long型64bit<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; ss &gt;&gt; val; // 文字列を &gt;&gt; で 数値型に変換<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (ss.fail()) throw std::exception("std::stringstream で 数値型(size_t型)に変換できない文字列がありました");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return val;<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;// テキストASCII形式のデータを読みだしてpWriteAddressへ書き込んで保管する<br>
        &nbsp;&nbsp; &nbsp;inline void readASCIIValue(std::ifstream&amp; fin, unsigned char* const pWriteAddress, const std::type_index&amp; type)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (type == Ply::CHAR)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int temp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fin &gt;&gt; temp; // 一旦 int型に変換してから8ビットにキャストして書き込む必要がある<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *reinterpret_cast&lt;int8_t*&gt;(pWriteAddress) = static_cast&lt;int8_t&gt;(temp);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::UCHAR)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int temp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fin &gt;&gt; temp; // 一旦 int型に変換してから8ビットにキャストして書き込む必要がある<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *reinterpret_cast&lt;uint8_t*&gt;(pWriteAddress) = static_cast&lt;uint8_t&gt;(temp);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::SHORT)&nbsp; fin &gt;&gt; *reinterpret_cast&lt;int16_t*&gt;(pWriteAddress);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::USHORT) fin &gt;&gt; *reinterpret_cast&lt;uint16_t*&gt;(pWriteAddress);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::INT)&nbsp;&nbsp;&nbsp; fin &gt;&gt; *reinterpret_cast&lt;int32_t*&gt;(pWriteAddress);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::UINT)&nbsp;&nbsp; fin &gt;&gt; *reinterpret_cast&lt;uint32_t*&gt;(pWriteAddress);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::FLOAT)&nbsp; fin &gt;&gt; *reinterpret_cast&lt;float*&gt;(pWriteAddress);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::DOUBLE) fin &gt;&gt; *reinterpret_cast&lt;double*&gt;(pWriteAddress);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else throw std::exception("なんか知らない未知のtype型が来たのでおかしい");<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;// .plyデータのヘッダではなく本体データをヘッダのプロパティのステップサイズに沿って読みだす<br>
        &nbsp;&nbsp; &nbsp;template &lt;Ply::FileFormat format&gt;<br>
        &nbsp;&nbsp; &nbsp;void readDataContent(std::ifstream&amp; fin, Ply::Data&amp; loadingData)//, std::function&lt;void()&gt; onVetexFunc, std::function&lt;void()&gt; onIndexFunc)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //Property型の内部のstd::vector&lt;unsigned char&gt; data;の配列の先頭アドレスへの辞書を作ってデータ書き込み先へのリンクを保持しておく<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::unordered_map&lt;Property*, unsigned char*&gt; writingPlace; // データ書込先の配列先頭アドレスを表す辞書<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; elementsKeyVal : loadingData) // elementsのキー("vertex"など)とバリュー(elements自体)のペアをループ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (auto&amp; propertyKeyVal : elementsKeyVal.second-&gt;properties) // propertyのキー("x"や"red"など)とバリュー(property自体)のペアをループ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; pProperty = propertyKeyVal.second;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; writingPlace[pProperty.get()] = pProperty-&gt;data.data(); // std::vector型のdata()を呼び出すと配列の先頭アドレスが得られる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //uint8_t max_count = 3; //property list uchar uint vertex_indices のインデックスの数は3固定だが4とかに対応するなら工夫が必要<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; elementsKeyVal : loadingData) // 各エレメントをループ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; pElements = elementsKeyVal.second;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const size_t elementsSize = pElements-&gt;size();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (size_t i = 0; i &lt; elementsSize; ++i) // 各エレメントのサイズぶんだけループ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (auto&amp; propertyKeyVal : pElements-&gt;properties) // 各エレメントの全プロパティをループ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; pProperty = propertyKeyVal.second;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!pProperty-&gt;isList) // リストじゃないとき 例. property float x など<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; pWriteAddress = writingPlace[pProperty.get()]; // 読み込んだデータの書き込み先アドレスを得る<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(pWriteAddress &gt;= pProperty-&gt;data.data() &amp;&amp; "書き込み先アドレスが事前確保したプロパティの内部配列の書き込み可能位置ではない");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //assert(ptData + prop-&gt;stepSize &lt;= prop-&gt;data.data() + prop-&gt;data.size());<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (format == FileFormat::ASCII)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; readASCIIValue(fin, pWriteAddress, pProperty-&gt;type); // テキストASCII形式をstd::ifstreamの &gt;&gt; 演算子で変換して読取<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fin.read(reinterpret_cast&lt;char*&gt;(pWriteAddress), pProperty-&gt;stepSize); // バイナリ形式をstd::ifstreamのreadで読取<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pWriteAddress += pProperty-&gt;stepSize; // 読取先アドレスをプロパティのステップサイズぶん先に進める<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else // リストのとき 例. property list uchar uint vertex_indices など<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Read count<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; uint8_t indexCount;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (format == FileFormat::ASCII)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int temp;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fin &gt;&gt; temp; // 一旦 int型に変換してから8ビットunsigned charにキャストして読み込む必要がある<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; indexCount = static_cast&lt;unsigned char&gt;(temp);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else fin.read(reinterpret_cast&lt;char*&gt;(&amp;indexCount), sizeof(indexCount));<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (fin.fail()) throw std::exception("property listは 3(三角ポリゴンインデックス) か 6(テクスチャ3点×uv 2値 = 6)のみサポート");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //property list uchar uint vertex_indices のインデックスの数は3固定だが4とかに対応するなら工夫が必要<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /*if (count &gt; max_count &amp;&amp; count != 3 &amp;&amp; count != 6)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; max_count = count;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; size_t newSize = count * prop-&gt;elementSize * prop-&gt;stepSize;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prop-&gt;data.size() &lt; newSize)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prop-&gt;data.resize(newSize);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }*/<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //prop-&gt;listCounts.push_back(count); // save each counts<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Read data<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; pWriteAddress = writingPlace[pProperty.get()]; // 読み込んだデータの書き込み先アドレスを得る<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const size_t chunkSize = indexCount * pProperty-&gt;stepSize; // 読み出すチャンクの塊のサイズ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(pWriteAddress &gt;= pProperty-&gt;data.data() &amp;&amp; "書き込み先アドレスが事前確保したプロパティの内部配列の書き込み可能位置ではない");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //assert(ptData + chunkSize &lt;= prop-&gt;data.data() + prop-&gt;data.size());<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (format == Ply::FileFormat::ASCII)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (size_t n = 0; n &lt; indexCount; ++n) // インデックスの数だけループ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; readASCIIValue(fin, pWriteAddress, pProperty-&gt;type);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pWriteAddress += pProperty-&gt;stepSize; // 読取先アドレスをステップサイズぶん先に進める<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; &nbsp;// バイナリ形式ならチャンクの塊サイズ = chunkSize ぶんまとめて高速読み出し<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fin.read(reinterpret_cast&lt;char*&gt;(pWriteAddress), chunkSize);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pWriteAddress += chunkSize; // 読取先アドレスをチャンクのサイズぶん先に進める<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;// PLY形式のデータをロードする<br>
        &nbsp;&nbsp; &nbsp;inline void load(const std::string&amp; filepath, Ply::Data&amp; loadingData)//, std::function&lt;void()&gt; onVetexFunc, std::function&lt;void()&gt; onIndexFunc)<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::string format; // .plyファイルのヘッダの format<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::string version; // .plyファイルのヘッダの version<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::ifstream fin(filepath, std::ios::binary); // バイナリ形式で読み込み<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (!fin.is_open())<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw std::exception((std::string("指定された ply ファイルが開けませんでした") + filepath).c_str());<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::string line; // 読み出し1行ライン<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Ply::getline_carriage_return(fin, line);<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Ply::Elements&gt; currentElement = nullptr;<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (line != "ply") throw std::exception(".plyファイルヘッダの先頭に ""ply"" がなかったのでフォーマットがおかしいです");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; while (line != "end_header") // .plyファイルのヘッダーの終わりを表す end_header になるまでwhileループで読取<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Ply::getline_carriage_return(fin, line);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (fin.fail()) throw std::exception(".plyファイルヘッダーの読取に失敗");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; lineContent;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Ply::split_space(line, lineContent);<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (lineContent.size() == 3 &amp;&amp; lineContent[0] == "format")<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; format = lineContent[1]; // スペース区切りの2つめ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; version = lineContent[2]; // スペース区切りの3つめ<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (lineContent.size() == 3 &amp;&amp; lineContent[0] == "element")<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const std::string&amp; name = lineContent[1]; // elementの名前 例.element vertex 14 なら"vertex"<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const size_t elementSize = Ply::str_to_size_t(lineContent[2]); // elementの数 ↑14 つまり3Dのvertex(点)が14個<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; currentElement.reset(new Ply::Elements(elementSize)); // 今から読みだすエレメントのステップするサイズが確定<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; loadingData.emplace_back(name, currentElement); // elementをデータ構造に登録<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (lineContent.size() == 3 &amp;&amp; lineContent[0] == "property") //例. property float x などの行を受け取る<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!currentElement)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw std::exception("elementが読まれてないのにpropertyが先に来ちゃったら何バイト飛ばしのステップで読みだして良いかわか らない");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const std::type_index dataType = Ply::parseDataType(lineContent[1]); // "int" "char"や"float32"などのデータタイプがlineContent[1]に入ってる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const std::string&amp; name = lineContent[2]; // x y z や red green blue など↑のintやfloatが表す数値の名前(使われ方)が入っている<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Ply::Property&gt; newProperty(new Ply::Property(dataType, currentElement-&gt;size()));<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; currentElement-&gt;properties.emplace_back(name, newProperty); // currentElementに property float x などのプロパティ情報(name="x" float)を登録<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (lineContent.size() == 5 &amp;&amp; lineContent[0] == "property" &amp;&amp; lineContent[1] == "list") //例.property list uchar uint vertex_indices などの行<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!currentElement)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw std::exception("elementが読まれてないのにpropertyが先に来ちゃったら何バイト飛ばしのステップで読みだして良いかわか らない");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const std::type_index indexCountType = Ply::parseDataType(lineContent[2]); // "uchar"などのインデックスの数を表す型がlineContent[2]に入ってる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const std::type_index dataType = Ply::parseDataType(lineContent[3]); // "int" "char"や"float32"などのデータタイプがlineContent[3]に入ってる<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const std::string&amp; name = lineContent[4]; // vertex_indices や texcoord などのインデックス数値の名前(使われ方)が入っている<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (indexCountType != Ply::UCHAR)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw std::exception("property listでは uchar 型しか インデックスの数を表す型にはつかえない 例. property list uchar uint vertex_indices");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ポリゴンindexの数は 3 固定で決め打ちしている↓のでblenderなどで「メッシュの三角面化」にチェックを入れてエクスポートする必要がある<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; size_t lineDataNum = (name == "texcoord") ? 6 : 3; // テクスチャUV(st)座標 は 6つ 点1(u,v),点2(u,v),点3(u,v) = 6つの u v<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Ply::Property&gt; newProperty(new Ply::Property(dataType, lineDataNum * currentElement-&gt;size(), true, currentElement-&gt;size()));<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; currentElement-&gt;properties.emplace_back(name, newProperty); // currentElementに 登 録&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isList = true↑<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (fin.fail()) throw std::exception(".plyファイルのヘッダを読み取ったあとの本データを読取る前にファイルエラーが出た");<br>
        <br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // ヘッダのプロパティ形式を元に本データを読み取る<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (format == "ascii") // テキストのASCII形式の場合<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // .plyデータの本体データをヘッダのプロパティのステップサイスに沿って読みだす<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Ply::readDataContent&lt;Ply::FileFormat::ASCII&gt;(fin, loadingData);//, onVetexFunc, onIndexFunc);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (fin.fail()) throw std::exception(".plyのアスキー形式のデータ読み出しに失敗しました");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else // 本体データがバイナリ形式の場合<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const bool isBigEndian = Ply::isBigEndian();<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (format != "binary_little_endian" &amp;&amp; format != "binary_big_endian")<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw std::exception(".plyのヘッダのformat部分が binary_little_endian でも binary_big_endian でもない");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((isBigEndian &amp;&amp; format != "binary_big_endian") || (!isBigEndian &amp;&amp; format != "binary_little_endian"))<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw std::exception(".plyのformat と お使いのPC環境のビックエンディアンorリトルエンディアン環境が合致していない");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // .plyデータの本体データをヘッダのプロパティのステップサイスに沿って読みだす<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Ply::readDataContent&lt;Ply::FileFormat::BINARY&gt;(fin, loadingData);//, onVetexFunc, onIndexFunc);<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (fin.fail()) throw std::exception(".plyのバイナリ形式のデータ読み出しに失敗しました");<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; char endOfFileCheck; // ファイルの終わりにchar1バイト余分に読みだしてみてちゃんとファイルの終わりまでロードできたかチェック<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fin.read(&amp;endOfFileCheck, 1);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!fin.eof()) throw std::exception("ファイルの終わりに1バイト余分に読みだしたけどファイルに続きがあるのでちゃんと完全に読みだせてない");<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;}<br>
        }<br>
        <br>
        #endif</p>
      <br>
      <p><code>main.cppを一旦まっさらにリセットしてから</code>下記のプログラムで、.ply形式のファイルをロードしてポリゴンで サイコロ型の3Dモデルが表示できるかテストします。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Screen.h"<br>
        <span style="font-weight: bold;">#include "Ply.h"</span><br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
        &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/boss1.png");<br>
        &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
        &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
        &nbsp;&nbsp;&nbsp; Ply::load("Image/<span style="font-weight: bold;">dicetest.ply</span>", Data); // .plyデータをロード<br>
        <br>
        &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
        <br>
        &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
        &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
        &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
        <br>
        &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
        &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
        &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
        &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        <br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
        &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 200.0f; keyControlXYZ.y = 200.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(100.0f, 100.0f, 100.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); // 三角形ポリゴンを描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      <br>
      <br>
    </a><a id="mozTocId0004" class="mozTocH1">
      <h1>Blenderをインストールして3Dのサイコロとテク スチャ画 像を書き出してXYZ軸を見極める</h1>
    </a>
    <p><a id="mozTocId0004" class="mozTocH1">Blenderを下記サイトを参考にインストールしましょう。<br>
      </a><a href="https://www.blender.jp/install">https://www.blender.jp/install</a> <br>
    </p>
    Blenderを開いて、上部のメニューバーから[テクスチャペイント]をクリックし[+新規]をクリックしてdiceと名前をつけてテクスチャ画像を生 成します。<br>
    <p> <img src="image/blender_dice1.png" alt=""></p>
    テクスチャ画像が生成されたら黒地に白で筆の半径50pxほどのサイコロの目を描いてみましょう。<br>
    <p> <img src="image/blender_dice2.png" alt=""></p>
    上部のメニューバーから[シェーディング]をクリックして下画面のノード画面で右クリックして[+追加]→[テクスチャ]→[画像テ クスチャ]のノードを生成
    <p> <img src="image/blender_dice3.png" alt=""></p>
    画像テクスチャノードの画像として先ほどペイントしたdiceを選びます<br>
    <p> <img src="image/blender_dice4.png" alt=""></p>
    画像テクスチャノードの[カラー]からプリンシプルBSDFノードの[ベースカラー]へと線を引っ張ってつなげるとサイコロのテクスチャ画像がでます<br>
    <p> <img src="image/blender_dice5.png" alt=""></p>
    [テクスチャペイント]をクリックして、[画像]から[名前をつけて保存]を選び、テクスチャ画像をDXのプロジェクトのImageフォルダに dice.pngとして保存<br>
    <p> <img src="image/blender_dice6.png" alt=""></p>
    メニューバーの[ファイル]→[エクスポート]→[Stanford PLY(.ply)]を選び、DXのプロジェクトのImageフォルダにdice.plyとしてエクスポート保存します。
    <p> <img src="image/blender_dice7.png" alt=""></p>
    エクスポートする際の[前方の軸][上向きの軸]はDXのmain.cppで読み取る際に対応関係があるので色んな軸の設定の仕方で実験してみましょう<br>
    <p> <img src="image/blender_dice8.png" alt=""></p>
    <p><code>main.cpp</code>のコードで読み込む.plyファイルをBlenderで作成したファイルに変えて、書き出す際のxyz 軸を変えながら試行錯誤してみましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Ply.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
      &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/<span style="font-weight: bold;">dice.png</span>");<br>
      &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
      &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
      &nbsp;&nbsp;&nbsp; Ply::load("Image/<span style="font-weight: bold;">dice.ply</span>", Data); // .plyデータをロード <span

        style="font-weight: bold;">軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう</span><br>
      <br>
      &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
      &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
      &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
      <br>
      &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
      &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
      &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
      &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      <br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(<em>-(p_y[i]), p_z[i], p_x[i]</em>);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(<em>-p_ny[i], p_nz[i], p_nx[i]</em>)) : VGet(0.0f, 0.0f, 0.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
      &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
      &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 200.0f; keyControlXYZ.y = 200.0f; keyControlXYZ.z = 0;<br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
      <br>
      &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(<em>50.0f, 50.0f, 50.0f</em>); // 拡大縮小スケール<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    <br>
    <br>
    <a id="mozTocId0005" class="mozTocH1">
      <h1>別の描画スクリーンを作って、Windowsみたいなサブのウィ ンドウを描く</h1>
      <br>
      <p><code>main.cpp</code>のコードにMakeScreen関数を使って別の描画先スクリーンを作って描画先スクリーンをスイッチする方法をテストしてみましょう。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
        &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
        &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
        &nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply", Data); // .plyデータをロード 軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう<br>
        <br>
        &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
        <br>
        &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
        &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
        &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
        <br>
        &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
        &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
        &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
        &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        <br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
        &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 200.0f; keyControlXYZ.y = 200.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>float subscreenX = 0, subscreenY = 0; // 別描画スクリーンを描く位置<br>
          &nbsp;&nbsp;&nbsp; int subscreenWidth = 600, subscreenHeight = 100;<br>
          &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE); // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドル作成を TRUE:許可<br>
          &nbsp;&nbsp;&nbsp; // [別の描画スクリーンを用意] https://dxlib.xsrv.jp/function/dxfunc_graph1.html#R3N25<br>
          &nbsp;&nbsp;&nbsp; int subscreen = DxLib::MakeScreen(subscreenWidth, subscreenHeight, FALSE);<br>
          &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE); // FLASE:通常のグラフィックハンドルを作成するモードに戻す</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>int MouseX, MouseY;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マウスの位置を取得<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetMousePoint(&amp;MouseX, &amp;MouseY);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreenX = MouseX; subscreenY = MouseY; // マウスのポインタの位置を起点にサブのスクリーンを描く</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(50.0f, 50.0f, 50.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>int tmpResetSetting = DxLib::GetUseSetDrawScreenSettingReset(); // 設定を一旦tmpに退避<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseSetDrawScreenSettingReset(FALSE); // SetDrawScreen切り替え時に設定をリセットしない(FALSE)(これをやらないとカメラ視点などがリセットされるから)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpDrawScreen = DxLib::GetDrawScreen(); // 一旦変更前のスクリーンのハンドルを退避<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawScreen(subscreen);// ゲームを描く先を用意しておいたサブスクリーンに設定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // (0,0)位置を起点に</em><em>別 スクリーン</em><em>へ文字列を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawScreen((tmpDrawScreen == -1) ? DX_SCREEN_BACK : tmpDrawScreen); // 描く先をもとのデフォルトのスクリーンに戻しておく<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseSetDrawScreenSettingReset((tmpResetSetting == -1) ? TRUE : tmpResetSetting); // 設定を元に戻す<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 画面に別スクリーンの内容を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawRectExtendGraph((int)subscreenX, (int)subscreenY, (int)(subscreenX + subscreenWidth), (int)(subscreenY + subscreenHeight), 0, 0, subscreenWidth, subscreenHeight, subscreen, FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 別スクリーンの枠を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox( (int)((int)subscreenX - 1 + 0.5f),(int)((int)subscreenY - 1 + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(subscreenX + subscreenWidth + 1) + 0.5f), (int)((int)(subscreenY + subscreenHeight + 1) + 0.5f), GetColor(255,255,255), FALSE);</em><br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <p>このサブのスクリーンの機能をこてこてに魔改造するとウィンドウズ のようなドラッグできるウィンドウをつくることもできます。<br>
      </p>
      <p><code>Input.hを新規作成</code>してドラッグや複数のスクリーンがあるときの一番上のレイヤーを保管する変数やマウスのドラッグを取れるようにしましょう。</p>
      <p class="source">#ifndef INPUT_H_<br>
        #define INPUT_H_<br>
        <br>
        #include &lt;climits&gt; //int型の最大値2147483647につかう<br>
        #include &lt;unordered_map&gt; //【高速辞書配列】<br>
        #include &lt;string&gt; // キーボード押下の文字列出力につかう<br>
        <br>
        #include "DxLib.h"<br>
        <br>
        // パッド番号<br>
        enum class Pad<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Keyboard = -3, // キーボード入力を得る<br>
        &nbsp;&nbsp;&nbsp; All = -2, // すべてのうちどれか1つでも押されたとき(マウス除く)<br>
        &nbsp;&nbsp;&nbsp; None = -1, // パッド割当て無(やられたり待機中のプレイヤに)<br>
        &nbsp;&nbsp;&nbsp; Key = 0,<br>
        &nbsp;&nbsp;&nbsp; One,<br>
        &nbsp;&nbsp;&nbsp; Two,<br>
        &nbsp;&nbsp;&nbsp; Three,<br>
        &nbsp;&nbsp;&nbsp; Four,<br>
        &nbsp;&nbsp;&nbsp; Mouse, // マウスのボタン判定に<br>
        &nbsp;&nbsp;&nbsp; NUM,&nbsp; // コントローラの数=6(マウス込み)<br>
        };<br>
        <br>
        enum class Mouse<br>
        {<br>
        &nbsp;&nbsp;&nbsp; All = -2, // すべてのうちどれか1つでも押されたとき<br>
        &nbsp;&nbsp;&nbsp; None = -1,<br>
        &nbsp;&nbsp;&nbsp; DownL, //[左クリック押した瞬間=1]<br>
        &nbsp;&nbsp;&nbsp; DragL, //[左ドラッグ中=1]<br>
        &nbsp;&nbsp;&nbsp; UpL, //[左クリック離した瞬間=1]<br>
        &nbsp;&nbsp;&nbsp; DownR, //[右クリック押した瞬間=1]<br>
        &nbsp;&nbsp;&nbsp; DragR, //[右ドラッグ中=1]<br>
        &nbsp;&nbsp;&nbsp; UpR, //[右クリック離した瞬間=1]<br>
        &nbsp;&nbsp;&nbsp; X, // 現在のマウス位置<br>
        &nbsp;&nbsp;&nbsp; ReleaseX, // 離した状態のマウス位置(ドラッグ中は開始前位置)<br>
        &nbsp;&nbsp;&nbsp; DownLX, //[左] 押した位置<br>
        &nbsp;&nbsp;&nbsp; DragLX, //[左] ドラッグ中の位置<br>
        &nbsp;&nbsp;&nbsp; UpLX, //[左] 離した位置<br>
        &nbsp;&nbsp;&nbsp; DownRX,//[右] 押した位置<br>
        &nbsp;&nbsp;&nbsp; DragRX, //[右] ドラッグ中の位置<br>
        &nbsp;&nbsp;&nbsp; UpRX, //[右] 離した位置<br>
        &nbsp;&nbsp;&nbsp; Y, // 現在のマウス位置<br>
        &nbsp;&nbsp;&nbsp; ReleaseY, // 離した状態のマウス位置(ドラッグ中は開始前位置)<br>
        &nbsp;&nbsp;&nbsp; DownLY, //[左] 押した位置<br>
        &nbsp;&nbsp;&nbsp; DragLY, //[左] ドラッグ中の位置<br>
        &nbsp;&nbsp;&nbsp; UpLY, //[左] 離した位置<br>
        &nbsp;&nbsp;&nbsp; DownRY,//[右] 押した位置<br>
        &nbsp;&nbsp;&nbsp; DragRY, //[右] ドラッグ中の位置<br>
        &nbsp;&nbsp;&nbsp; UpRY, //[右] 離した位置<br>
        &nbsp;&nbsp;&nbsp; NUM<br>
        };<br>
        <br>
        // 入力クラス<br>
        class Input<br>
        {<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; // ある動作として反応するボタン一覧(ビット論理和「|または」)<br>
        &nbsp;&nbsp;&nbsp; enum Button<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //[反応ボタン一覧定義] https://dixq.net/g/04_05.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 参加ボタン 1=Z 2=X 3=C 4=A 5=S 6=D 7=Q 8=W 9=ESC 10=SPACE<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Join = PAD_INPUT_1 | PAD_INPUT_2 | PAD_INPUT_3 | PAD_INPUT_4<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | PAD_INPUT_5 | PAD_INPUT_6 | PAD_INPUT_7 | PAD_INPUT_8<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | PAD_INPUT_9 | PAD_INPUT_10, //1Z～10SPACEキー全て反応<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; const int MaxPadNum = (int)Pad::Four + 1; // 最大パッド数(Keyぶん+1)<br>
        <br>
        &nbsp;&nbsp;&nbsp; static int prevStates[(int)Pad::NUM]; // 1フレーム前の状態<br>
        &nbsp;&nbsp;&nbsp; static int currentStates[(int)Pad::NUM]; // 現在の状態<br>
        &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;Pad, bool&gt; isJoin; // 参加中のパッド番号辞書<br>
        &nbsp;&nbsp;&nbsp; // 参加中のパッドかどうか?<br>
        &nbsp;&nbsp;&nbsp; static bool IsJoin(Pad pad) { return isJoin.count(pad) &amp;&amp; Input::isJoin[pad]; }<br>
        &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;int, int&gt; padDic; // パッド番号からDXの定義への辞書<br>
        <br>
        &nbsp;&nbsp;&nbsp; static int prevMouse; // 1フレーム前のマウス状態<br>
        &nbsp;&nbsp;&nbsp; static int currentMouse; // 現在のマウス状態<br>
        &nbsp;&nbsp;&nbsp; static int MouseX, MouseY; // 現在のマウス位置<br>
        &nbsp;&nbsp;&nbsp; static int <span style="font-weight: bold;">TopLayerMouseX</span>, <span

          style="font-weight: bold;">TopLayerMouseY</span>; // Subsreenの一番上のレイヤのマウス位置XY(Subscreenクラスで更新)<br>
        &nbsp;&nbsp;&nbsp; static int ClickX, ClickY, MButton, LogType;<br>
        &nbsp;&nbsp;&nbsp; static float MouseWheel; // マウスのホイールの回転<br>
        &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;Mouse, int&gt; Click;//&lt;Mouse⇒int&gt; マウスのクリックXY位置辞書<br>
        <br>
        &nbsp;&nbsp;&nbsp; //[キーボード入力]https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
        &nbsp;&nbsp;&nbsp; static char prevKey[256]; // 1フレーム前のキーボード状態<br>
        &nbsp;&nbsp;&nbsp; static char currentKey[256]; // 現在のキーボード状態<br>
        &nbsp;&nbsp;&nbsp; static std::string KeyString[256];//&lt;キーコード⇒キー文字列&gt;の辞書<br>
        &nbsp;&nbsp;&nbsp; static std::string CapsString[256];//&lt;Caps状態キーコード⇒キー文字列&gt;の辞書<br>
        &nbsp;&nbsp;&nbsp; static bool isCapsLocked;// CapsLock状態か?<br>
        &nbsp;&nbsp;&nbsp; static bool isShifted;// Shiftが押された状態か?<br>
        <br>
        &nbsp;&nbsp;&nbsp; //★【DXコントローラバグ検知】初回プッシュが被ればDXバグで同一コントローラ<br>
        &nbsp;&nbsp;&nbsp; static int firstPushTiming[(int)Pad::NUM - 1]; // マウスのぶんの配列はいらないから-1<br>
        &nbsp;&nbsp;&nbsp; static int timing;// = 0;<br>
        &nbsp;&nbsp;&nbsp; static bool isBugCheckMode;// = false; //バグチェックを開始するか<br>
        <br>
        private:<br>
        &nbsp;&nbsp;&nbsp; // 辞書配列の初期化<br>
        &nbsp;&nbsp;&nbsp; static void InitPadDictionary()<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 辞書配列で対応関係を結び付けておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padDic[(int)Pad::Key] = DX_INPUT_KEY_PAD1; // DX_INPUT_KEY<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padDic[(int)Pad::One] = DX_INPUT_PAD1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padDic[(int)Pad::Two] = DX_INPUT_PAD2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padDic[(int)Pad::Three] = DX_INPUT_PAD3;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padDic[(int)Pad::Four] = DX_INPUT_PAD4;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        public:<br>
        &nbsp;&nbsp;&nbsp; // 初期化。最初に1回だけ呼んでください。<br>
        &nbsp;&nbsp;&nbsp; static void Init()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitPadDictionary(); // 辞書配列の初期化<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitKeyString(); // キーボード辞書配列の初期化<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キー状態をゼロリセット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i] = 0;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitMouse(); // マウスの状態初期化<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitKeyboard(); // キーボードの状態初期化<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timing = 0, isBugCheckMode = false; //バグチェックを開始するか<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; // マウスの状態初期化<br>
        &nbsp;&nbsp;&nbsp; static void InitMouse()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MouseX = -1, MouseY = -1; // 現在のマウス位置を-1で初期状態では画面外として初期化<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClickX = -1, ClickY = -1, MButton = 0, LogType = 0;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::ReleaseX] = -1; Click[Mouse::ReleaseY] = -1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpLX] = -1;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpLY] = -1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpRX] = -1;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpRY] = -1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DownLX] = -1;&nbsp;&nbsp; Click[Mouse::DownLY] = -1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DownRX] = -1;&nbsp;&nbsp; Click[Mouse::DownRY] = -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; // キーボードの状態初期化<br>
        &nbsp;&nbsp;&nbsp; static void InitKeyboard()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キー状態をゼロリセット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 256; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevKey[i] = currentKey[i] = 0;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 最新の入力状況に更新する処理。<br>
        &nbsp;&nbsp;&nbsp; // 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
        &nbsp;&nbsp;&nbsp; static void Update()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::Mouse; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 現在の状態を一つ前の状態として保存してGetJoypad..<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevStates[i] = currentStates[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentStates[i] = GetJoypadInputState(padDic[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateMouse(); // マウス状態を更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateKeyboard(); // キーボード状態を更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isBugCheckMode = true;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timing++; //タイミングのカウントを+1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (timing == INT_MAX) timing = 0; // long型最大値になったら0に戻す<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キーボードの状態を更新する<br>
        &nbsp;&nbsp;&nbsp; static void UpdateKeyboard()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy(prevKey, currentKey, sizeof(prevKey));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードの状態配列を更新する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetHitKeyStateAll(currentKey); // https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetButtonUp(Pad::Keyboard, KEY_INPUT_CAPSLOCK))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCapsLocked = !isCapsLocked; // CapsLock状態を反転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // シフトが押された状態かを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isShifted = (GetButton(Pad::Keyboard, KEY_INPUT_LSHIFT) || GetButton(Pad::Keyboard, KEY_INPUT_RSHIFT));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // マウスの状態を更新する<br>
        &nbsp;&nbsp;&nbsp; static void UpdateMouse()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DownL] = 0; Click[Mouse::DownR] = 0; //Click[Mouse.UpL] = 0; Click[Mouse.UpR] = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::All] = 0; // 状態辞書の0リセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevMouse = currentMouse; // 前フレームの最新のマウス情報を1つ前の情報とする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevStates[(int)Pad::Mouse] = currentMouse;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MouseWheel = GetMouseWheelRotVolF(); // マウスのホイール回転量を更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マウスの位置を取得<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetMousePoint(&amp;MouseX, &amp;MouseY);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TopLayerMouseX = MouseX; TopLayerMouseY = MouseY;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::X] = MouseX; Click[Mouse::Y] = MouseY;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentMouse = GetMouseInput(); // マウス状態を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentStates[(int)Pad::Mouse] = currentMouse; // マウス状態をパッド状態にも併合<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 押してない離した状態のマウス位置を更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (currentMouse == 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::ReleaseX] = MouseX; Click[Mouse::ReleaseY] = MouseY;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else Click[Mouse::All] = 1; // マウスのいずれかのボタンが押されている<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">// 左マウスドラッグ中のXY位置を更新</span><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetButton(Pad::Mouse, MOUSE_INPUT_LEFT) &amp;&amp; !GetButtonDown(Pad::Mouse, MOUSE_INPUT_LEFT))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DragLX] = MouseX; Click[Mouse::DragLY] = MouseY; Click[Mouse::DragL] = 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DragL] = 0;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">// 右マウスドラッグ中のXY位置を更新</span><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetButton(Pad::Mouse, MOUSE_INPUT_RIGHT) &amp;&amp; !GetButtonDown(Pad::Mouse, MOUSE_INPUT_RIGHT))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DragRX] = MouseX; Click[Mouse::DragRY] = MouseY; Click[Mouse::DragR] = 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DragR] = 0;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[マウスクリック検知] https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N40<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マウスのボタンが押されたり離されたりしたかどうかの情報を取得する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetMouseInputLog2(&amp;MButton, &amp;ClickX, &amp;ClickY, &amp;LogType, TRUE) == 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // [左ボタン]が押されたり離されたりしていた<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((MButton &amp; MOUSE_INPUT_LEFT) != 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // クリックされた瞬間と離された瞬間のマウス位置を記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LogType == MOUSE_INPUT_LOG_DOWN)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DownLX] = ClickX; Click[Mouse::DownLY] = ClickY; Click[Mouse::DownL] = 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (LogType == MOUSE_INPUT_LOG_UP)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpLX] = ClickX; Click[Mouse::UpLY] = ClickY; Click[Mouse::UpL] = 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }// [右ボタン]が押されたり離されたりしていた<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((MButton &amp; MOUSE_INPUT_RIGHT) != 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // クリックされた瞬間と離された瞬間のマウス位置を記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LogType == MOUSE_INPUT_LOG_DOWN)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DownRX] = ClickX; Click[Mouse::DownRY] = ClickY; Click[Mouse::DownR] = 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (LogType == MOUSE_INPUT_LOG_UP)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpRX] = ClickX; Click[Mouse::UpRY] = ClickY; Click[Mouse::UpR] = 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ボタンが押されているか？<br>
        &nbsp;&nbsp;&nbsp; static bool GetButton(int buttonId) { return GetButton(Pad::Key, buttonId); }<br>
        &nbsp;&nbsp;&nbsp; static bool GetButton(Pad pad, int buttonId)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //コントローラバグチェック<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ControllerBugCheck(pad, buttonId)) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // GetButtonの中でGetButtonを呼ぶ【再起呼出し】テクニック<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetButton((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::Keyboard) // 今ボタンが押されているかどうかを返却<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (currentKey[buttonId] == 1); //https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今ボタンが押されているかどうかを返却<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (currentStates[(int)pad] &amp; buttonId) != 0;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ボタンが押された瞬間か？<br>
        &nbsp;&nbsp;&nbsp; static bool GetButtonDown(int buttonId) { return GetButtonDown(Pad::Key, buttonId); }<br>
        &nbsp;&nbsp;&nbsp; static bool GetButtonDown(Pad pad, int buttonId)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //コントローラバグチェック<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ControllerBugCheck(pad, buttonId)) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 再起呼出しテクニック<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetButtonDown((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::Keyboard) //https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (currentKey[buttonId] == 1) &amp;&amp; (prevKey[buttonId] != 1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今は押されていて、かつ1フレーム前は押されていない場合はtrueを返却<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((currentStates[(int)pad] &amp; buttonId) &amp; ~(prevStates[(int)pad] &amp; buttonId)) != 0;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ボタンが離された瞬間か？<br>
        &nbsp;&nbsp;&nbsp; static bool GetButtonUp(int buttonId) { return GetButtonDown(Pad::Key, buttonId); }<br>
        &nbsp;&nbsp;&nbsp; static bool GetButtonUp(Pad pad, int buttonId)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //コントローラバグチェック<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ControllerBugCheck(pad, buttonId)) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::None) return false; // Noneなら判別不要<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (pad == Pad::All) // All指定の時は全てのパッド<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 再起呼出しテクニック<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetButtonUp((Pad)i, buttonId))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; //押されているPadを発見！<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 一つも押されていなかった<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::Keyboard) //https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (prevKey[buttonId] == 1) &amp;&amp; (currentKey[buttonId] != 1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1フレーム前は押されていて、かつ今は押されている場合はtrueを返却<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((prevStates[(int)pad] &amp; buttonId) &amp; ~(currentStates[(int)pad] &amp; buttonId)) != 0;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; //コントローラのボタンの初回プッシュを検知し<br>
        &nbsp;&nbsp;&nbsp; //他コントローラと初回タイミングが完全被りかチェック<br>
        &nbsp;&nbsp;&nbsp; //★初回タイミングが完全被りなら【怪しい】重複コントローラとみなし判定処理スルー<br>
        &nbsp;&nbsp;&nbsp; static bool ControllerBugCheck(Pad pad, int buttonId)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::Mouse) return false; // マウスはバグチェック不要<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (pad == Pad::Keyboard) return false; // キーボードはバグチェック不要<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今は押されていて、かつ1フレーム前は押されていない場合<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool buttonDown = ((currentStates[(int)pad] &amp; buttonId) &amp; ~(prevStates[(int)pad] &amp; buttonId)) != 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (isBugCheckMode == false) return false; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //コントローラの初回ボタンプッシュを検知<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (buttonDown &amp;&amp; firstPushTiming[(int)pad] == 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; (int)Pad::NUM - 1; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //全コントローラ初回プッシュ被りがないかチェック完全同時は怪しいので-1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isDown = ((currentStates[i] &amp; buttonId) &amp; ~(prevStates[i] &amp; buttonId)) != 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((Pad)i != pad &amp;&amp; isDown ////初回プッシュ被り検出<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (timing == firstPushTiming[i] || firstPushTiming[i] == 0))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //初回プッシュのタイミング被りは-1フラグを記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstPushTiming[i] = -1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (firstPushTiming[(int)pad] != -1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstPushTiming[(int)pad] = timing;//初回プッシュを記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (firstPushTiming[(int)pad] == -1) return true; //DXのコントローラ被りバグ！<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else return false; //コントローラ被りOK!<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キーボードのキーと文字列の対応関係配列の初期化 https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N2<br>
        &nbsp;&nbsp;&nbsp; static void InitKeyString()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 辞書配列で対応関係を結び付けておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_BACK] = "BackSpace";//"\b";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_TAB] = "\t";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RETURN] = "\n";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LSHIFT] = "ShiftL";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RSHIFT] = "ShiftR";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LCONTROL] = "CtrlL";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RCONTROL] = "CtrlR";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SPACE] = " ";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PGUP] = "PgUp";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PGDN] = "PgDn";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_END] = "End";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_HOME] = "Home";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LEFT] = "Left";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_UP] = "Up";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RIGHT] = "Right";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DOWN] = "Down";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_INSERT] = "Insert";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DELETE] = "Delete";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_MINUS] = "-"; CapsString[KEY_INPUT_MINUS] = "=";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_YEN] = "\\"; CapsString[KEY_INPUT_YEN] = "|";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PREVTRACK] = "^"; CapsString[KEY_INPUT_PREVTRACK] = "~";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PERIOD] = "."; CapsString[KEY_INPUT_PERIOD] = "&gt;";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SLASH] = "/"; CapsString[KEY_INPUT_SLASH] = "?";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LALT] = "AltL";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RALT] = "AltR";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SCROLL] = "Scroll";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SEMICOLON] = ";"; CapsString[KEY_INPUT_SEMICOLON] = "+";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_COLON] = ":"; CapsString[KEY_INPUT_COLON] = "*";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LBRACKET] = "["; CapsString[KEY_INPUT_LBRACKET] = "{";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RBRACKET] = "]"; CapsString[KEY_INPUT_RBRACKET] = "}";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_AT] = "@"; CapsString[KEY_INPUT_AT] = "`";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_BACKSLASH] = "\\"; CapsString[KEY_INPUT_BACKSLASH] = "_";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_COMMA] = ","; CapsString[KEY_INPUT_COMMA] = "&lt;";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_CAPSLOCK] = "CapsLock";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PAUSE] = "Pause";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD0] = "0";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD1] = "1";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD2] = "2";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD3] = "3";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD4] = "4";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD5] = "5";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD6] = "6";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD7] = "7";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD8] = "8";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD9] = "9";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_MULTIPLY] = "*";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_ADD] = "+";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SUBTRACT] = "-";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DECIMAL] = ".";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DIVIDE] = "/";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPADENTER] = "\n";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F1] = "F1";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F2] = "F2";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F3] = "F3";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F4] = "F4";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F5] = "F5";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F6] = "F6";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F7] = "F7";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F8] = "F8";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F9] = "F9";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F10] = "F10";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F11] = "F11";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F12] = "F12";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_A] = "a"; CapsString[KEY_INPUT_A] = "A";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_B] = "b"; CapsString[KEY_INPUT_B] = "B";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_C] = "c"; CapsString[KEY_INPUT_C] = "C";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_D] = "d"; CapsString[KEY_INPUT_D] = "D";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_E] = "e"; CapsString[KEY_INPUT_E] = "E";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F] = "f"; CapsString[KEY_INPUT_F] = "F";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_G] = "g"; CapsString[KEY_INPUT_G] = "G";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_H] = "h"; CapsString[KEY_INPUT_H] = "H";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_I] = "i"; CapsString[KEY_INPUT_I] = "I";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_J] = "j"; CapsString[KEY_INPUT_J] = "J";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_K] = "k"; CapsString[KEY_INPUT_K] = "K";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_L] = "l"; CapsString[KEY_INPUT_L] = "L";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_M] = "m"; CapsString[KEY_INPUT_M] = "M";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_N] = "n"; CapsString[KEY_INPUT_N] = "N";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_O] = "o"; CapsString[KEY_INPUT_O] = "O";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_P] = "p"; CapsString[KEY_INPUT_P] = "P";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_Q] = "q"; CapsString[KEY_INPUT_Q] = "Q";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_R] = "r"; CapsString[KEY_INPUT_R] = "R";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_S] = "s"; CapsString[KEY_INPUT_S] = "S";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_T] = "t"; CapsString[KEY_INPUT_T] = "T";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_U] = "u"; CapsString[KEY_INPUT_U] = "U";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_V] = "v"; CapsString[KEY_INPUT_V] = "V";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_W] = "w"; CapsString[KEY_INPUT_W] = "W";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_X] = "x"; CapsString[KEY_INPUT_X] = "X";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_Y] = "y"; CapsString[KEY_INPUT_Y] = "Y";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_Z] = "z"; CapsString[KEY_INPUT_Z] = "Z";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_0] = "0";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_1] = "1"; CapsString[KEY_INPUT_1] = "!";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_2] = "2"; CapsString[KEY_INPUT_2] = "\"";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_3] = "3"; CapsString[KEY_INPUT_3] = "#";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_4] = "4"; CapsString[KEY_INPUT_4] = "$";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_5] = "5"; CapsString[KEY_INPUT_5] = "%";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_6] = "6"; CapsString[KEY_INPUT_6] = "&amp;";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_7] = "7"; CapsString[KEY_INPUT_7] = "'";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_8] = "8"; CapsString[KEY_INPUT_8] = "(";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_9] = "9"; CapsString[KEY_INPUT_9] = ")";<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        #endif</p>
      <p>&lt;<br>
      </p>
      <p><code>Input.cppを新規作成</code>してドラッグや複数のスクリーンがあるときの一番上のレイヤーを保管する変数 などの static変数を定義しましょう。</p>
      <p class="source">#include "Input.h"<br>
        <br>
        int Input::prevStates[]; // 1フレーム前の状態<br>
        int Input::currentStates[]; // 現在の状態<br>
        // ↑static intのときはこの行書かないとシンボリックエラーになる件(このためだけにcpp書かなきゃならん)<br>
        <br>
        std::unordered_map&lt;Pad, bool&gt; Input::isJoin; // 参加中のパッド番号辞書<br>
        // 参加中のパッドかどうか?<br>
        std::unordered_map&lt;int, int&gt; Input::padDic; // パッド番号からDXの定義への辞書<br>
        <br>
        int Input::prevMouse; // 1フレーム前のマウス状態<br>
        int Input::currentMouse; // 現在のマウス状態<br>
        int Input::MouseX{ -1 }, Input::MouseY{ -1 }; // 現在のマウス位置<br>
        int Input::TopLayerMouseX{ -1 }, Input::TopLayerMouseY{ -1 }; // 現在のマウス位置<br>
        float Input::MouseWheel{ 0 };<br>
        int Input::ClickX{ -1 }, Input::ClickY{ -1 }, Input::MButton{ 0 }, Input::LogType{ 0 };<br>
        std::unordered_map&lt;Mouse, int&gt; Input::Click;//&lt;Mouse⇒int&gt; マウスのクリックXY位置辞書<br>
        <br>
        //[キーボード入力]https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
        char Input::prevKey[256]; // 1フレーム前のキーボード状態<br>
        char Input::currentKey[256]; // 現在のキーボード状態<br>
        std::string Input::KeyString[256];//&lt;キーコード⇒キー文字列&gt;の辞書<br>
        std::string Input::CapsString[256];//&lt;Caps状態キーコード⇒キー文字列&gt;の辞書<br>
        bool Input::isCapsLocked{ false };// CapsLock状態か?<br>
        bool Input::isShifted{ false };// Shiftが押された状態か?<br>
        <br>
        <br>
        //★【DXコントローラバグ検知】初回プッシュが被ればDXバグで同一コントローラ<br>
        int Input::firstPushTiming[(int)Pad::NUM - 1]; // マウスのぶんの配列はいらないから-1<br>
        int Input::timing{ 0 };<br>
        bool Input::isBugCheckMode = false; //バグチェックを開始するか<br>
        <br>
      </p>
      <p><code>Screen.h</code>にWindowsのウィンドウみたいにドラッグできるSubScreenクラスを追加しましょう。</p>
      <p class="source">#ifndef _SCREEN_H<br>
        #define _SCREEN_H<br>
        <br>
        <em>#include &lt;string&gt;<br>
          #include &lt;set&gt; // サブスクリーンをDepth順に並べ替えるのに使う [multisetを使用するのに必要]<br>
          #include &lt;unordered_map&gt; // サブスクリーンをidをキーに保管するのに使う<br>
          #include &lt;memory&gt; // std::shared_ptrに使う</em><br>
        #include "DxLib.h"<br>
        <em><br>
          #include &lt;assert.h&gt; // アサート警告表示用</em><br>
        <br>
        <em>#include "Input.h"</em><br>
        <br>
        // 画面解像度<br>
        class Screen<br>
        {<br>
        public: //publicはC＃と違いpublic:以下にまとめて書かれるスタイル<br>
        &nbsp;&nbsp;&nbsp; static const int Width = 1280; // 幅<br>
        &nbsp;&nbsp;&nbsp; static const int Height = 720; // 高さ C＃と違いstaticクラスではなく個々の【すべての変数にstaticをつけて】staticなクラスとする<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>// X,Yがウィンドウの中にあるか<br>
          &nbsp;&nbsp;&nbsp; static bool IsInsideWindow(int screenX = Input::MouseX, int screenY = Input::MouseY) { return (0 &lt;= screenX &amp;&amp; screenX &lt; Width) &amp;&amp; (0 &lt;= screenY &amp;&amp; screenY &lt; Height); }</em><br>
        };// C＃と違ってクラスの定義も;セミコロンで終わる<br>
        <br>
        <br>
        <em>class SubScreen : public std::enable_shared_from_this&lt;SubScreen&gt;<br>
          {&nbsp;&nbsp;&nbsp; // [std::shared_ptrでthisポインタをつかうためには]↑ https://www.kabuku.co.jp/developers/cpp_enable_shared_from_this<br>
          protected:<br>
          &nbsp;&nbsp;&nbsp; int id; //サブスクリーンの管理ID<br>
          &nbsp;&nbsp;&nbsp; int handle = -1; //サブスクリーンへのハンドル<br>
          &nbsp;&nbsp;&nbsp; int tmpDrawScreen = -1; // DrawStartとDrawEndのあいだDrawStart前のhandleを一時保管する<br>
          &nbsp;&nbsp;&nbsp; int tmpResetSetting = -1; // DrawStartとDrawEndのあいだDrawStart前の設定を一時保管する<br>
          <br>
          &nbsp;&nbsp;&nbsp; static int serialDivID; //= 0 サブスクリーンを新たに生成するときの通し番号(シリアルID)<br>
          <br>
          public:<br>
          &nbsp;&nbsp;&nbsp; int frameWidth = 2;//サブスクリーンの枠の幅<br>
          &nbsp;&nbsp;&nbsp; unsigned int frameColor = DxLib::GetColor(255, 255, 255); //サブスクリーンの枠の色<br>
          &nbsp;&nbsp;&nbsp; float x = 0, y = 0; //サブスクリーンの描画位置<br>
          &nbsp;&nbsp;&nbsp; float zoomRate = 1.0f; // スクリーンに描くズーム率<br>
          &nbsp;&nbsp;&nbsp; float LocalX(float mainScreenX) { return (mainScreenX - x) / zoomRate; } // メインのスクリーンのXからサブスクリーンのローカルなXへ変換<br>
          &nbsp;&nbsp;&nbsp; float LocalY(float mainScreenY) { return (mainScreenY - y) / zoomRate; } // メインのスクリーンのYからサブスクリーンのローカルなYへ変換<br>
          &nbsp;&nbsp;&nbsp; bool IsInside(float mainScreenX, float mainScreenY) { return (x &lt; mainScreenX &amp;&amp; mainScreenX &lt; x + Width * zoomRate) &amp;&amp; (y &lt; mainScreenY &amp;&amp; mainScreenY &lt; y + Height * zoomRate); } // メインのスクリーン上のXとYがサブスクリーンの内側にあるか<br>
          &nbsp;&nbsp;&nbsp; bool IsOnBarFrame(float mainScreenX, float mainScreenY) { return (x - frameWidth - 1 &lt; mainScreenX &amp;&amp; mainScreenX &lt; x + Width * zoomRate + frameWidth + 1) &amp;&amp; (y - frameWidth - 1 - barFrameHeight &lt; mainScreenY &amp;&amp; mainScreenY &lt; y + frameWidth + 1 + Height * zoomRate); } // バーを含むウィンドウの内側にあるか<br>
          &nbsp;&nbsp;&nbsp; bool IsOnBar(float mainScreenX, float mainScreenY) { return (x - frameWidth - 1 &lt; mainScreenX &amp;&amp; mainScreenX &lt; x + Width * zoomRate + frameWidth + 1) &amp;&amp; (y - frameWidth - 1 - barFrameHeight &lt; mainScreenY &amp;&amp; mainScreenY &lt; y + frameWidth + 1); } // バーを含むウィンドウの内側にあるか<br>
          <br>
          &nbsp;&nbsp;&nbsp; float Width = 0, Height = 0; // サブスクリーンの幅と高さ<br>
          &nbsp;&nbsp;&nbsp; int Alpha = 255; // デフォルトは透明じゃない(アルファ不透明度=255)<br>
          &nbsp;&nbsp;&nbsp; float renderX = 0, renderY = 0; //描画オフセット位置(一部だけを抜き出してスクリーンにレンダリングするときに設定)<br>
          &nbsp;&nbsp;&nbsp; float renderWidth = 0; float renderHeight = 0; // 抜き出してスクリーンに描く部位の幅と高さ<br>
          <br>
          &nbsp;&nbsp;&nbsp; int Depth = 0; //[この値が大きいほど手前に割り込んで描かれる] [Unityの描画順を参考に] https://tama-lab.net/2017/07/unity%E3%81%A7%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E6%8F%8F%E7%94%BB%E9%A0%86%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95/<br>
          &nbsp;&nbsp;&nbsp; static bool isDepthLayerChanged; //= false 新しいレイヤが追加されり変更があった時だけ並べ替えるためのフラグ<br>
          <br>
          &nbsp;&nbsp;&nbsp; bool isInitAgain = false; // WidthやHeightやAlphaが変わったらDxLib::MakeScreenのやり直し<br>
          &nbsp;&nbsp;&nbsp; bool isFrameShow = false; // ウィンドウのフレームを描くか<br>
          &nbsp;&nbsp;&nbsp; bool isBarShow = false; // ウィンドウズみたいなウィンドウのバーを描くか<br>
          &nbsp;&nbsp;&nbsp; int barFrameHeight = 15; // ウィンドウのバーの高さ<br>
          &nbsp;&nbsp;&nbsp; int barFrameFontSize = 14; // ウィンドウのバーのnameのフォントサイズ<br>
          &nbsp;&nbsp;&nbsp; unsigned int barColor = DxLib::GetColor(0, 0, 0); //バーの色<br>
          <br>
          &nbsp;&nbsp;&nbsp; unsigned int stringColor = DxLib::GetColor(255, 255, 255); //サブスクリーンの枠の色<br>
          &nbsp;&nbsp;&nbsp; std::string drawString = ""; // デバッグなどのためにスクリーンの左上に表示する文字列(サブスクリーン番号など)<br>
          &nbsp;&nbsp;&nbsp; std::string tag = "";<br>
          &nbsp;&nbsp;&nbsp; std::string name = ""; //サブスクリーン名<br>
          <br>
          &nbsp;&nbsp;&nbsp; int GetID() { return id; } // サブスクリーンの管理ID<br>
          &nbsp;&nbsp;&nbsp; inline static int NewID() { return ++serialDivID; } //スクリーンの通し番号を+1(先に+1するので0はなく1からID割り振り)<br>
          <br>
          &nbsp;&nbsp;&nbsp; static std::shared_ptr&lt;SubScreen&gt; Get(int id) { // ★constは添え字[]読み取りの処理を定義<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (SubScreen::layers.count(id) == 0)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert("指定したIDの分割スクリーンはまだ未生成！Make()関数で新規生成してください" == "");<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return layers[id]; // 読み取り<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          protected:<br>
          &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ペア&lt;Depth, id&gt;<br>
          &nbsp;&nbsp;&nbsp; typedef std::pair&lt;int, int&gt; depth_id_pair;<br>
          &nbsp;&nbsp;&nbsp; static std::multiset&lt;depth_id_pair&gt; depth_id_ordered; // std::multiset[キーの無い版のstd::map(マルチでキーかぶりOK版)] http://alctail.sakura.ne.jp/tip/cplus_kannrenn/cplusplus/stl.shtml#stl2-7<br>
          public:<br>
          &nbsp;&nbsp;&nbsp; // オーダー(並べ替えられた)IDを返す<br>
          &nbsp;&nbsp;&nbsp; static std::vector&lt;int&gt; GetOrderedIDs(bool isDesc = false) { // Desc(降順) 4 3 2 2 1 みたいな降りるid順<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; orderedIDs;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::multiset&lt;depth_id_pair&gt;::iterator ite = depth_id_ordered.begin();<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (ite != depth_id_ordered.end())<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id = ite-&gt;second;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orderedIDs.emplace_back(id); // depth順に追加<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ite++;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isDesc) return orderedIDs;<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[逆順の範囲for文] https://koturn.hatenablog.com/entry/2018/07/21/190000<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; descIDs;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto itr = std::rbegin(orderedIDs); itr != std::rend(orderedIDs); ++itr)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; descIDs.emplace_back(*itr); // 逆順に<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return descIDs;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; class Greater_Depth<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; public: // Depthでソートするために比較用オペレータを定義<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool operator() (SubScreen* left, SubScreen* right) const<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (left-&gt;Depth &gt; right-&gt;Depth); // 不等号 &gt; で比較<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; };<br>
          &nbsp;&nbsp;&nbsp; // Depthでソートするためにオペレータをオーバーロード<br>
          &nbsp;&nbsp;&nbsp; bool operator &lt; (const SubScreen&amp; another) const {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this-&gt;Depth &gt; another.Depth;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; //[protectedなコンストラクタでもstd::make_sharedで呼ぶテク] https://gintenlabo.hatenablog.com/entry/20131211/1386771626<br>
          &nbsp;&nbsp;&nbsp; template&lt;typename ProtectedT&gt;<br>
          &nbsp;&nbsp;&nbsp; struct ProtectedCall : public ProtectedT // ProtectedTをpublicで継承することで ProtectedCallから見てProtectedTのコンストラクタはpublicになるテク<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class... ArgsT&gt; // std::make_sharedはprotectedな継承クラスは呼べないのでそれを回避するテクニック<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; explicit ProtectedCall(ArgsT&amp;&amp;... args)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : ProtectedT(std::forward&lt;ArgsT&gt;(args)...) { } //std::forwardで複数引数を完全転送で引き渡し https://proc-cpuinfo.fixstars.com/2016/03/c-html/<br>
          &nbsp;&nbsp;&nbsp; };<br>
          <br>
          &nbsp;&nbsp;&nbsp; struct Layers : public std::unordered_map&lt;int, std::shared_ptr&lt;SubScreen&gt;&gt; // std::unordered_mapを継承してmake_sharedの機能も追加する<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class TypeT&gt;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;TypeT&gt; make_shared() // この関数経由で新規生成すればNewIDで新しいIDで辞書にemplaceで登録もいっしょにしてくれる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int newID = SubScreen::NewID(); //スクリーンの通し番号を+1(先に+1するので0はなく1からID割り振り)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pNewObj = std::make_shared&lt;ProtectedCall&lt;TypeT&gt;&gt;(); // std::make_sharedで共有状態で新規生成 (ProtectedCall経由でprotectedなコンストラクタも呼べる)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;emplace(newID, pNewObj); //★idはかぶらないはずだからそれをキーに辞書に登録<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::dynamic_pointer_cast&lt;TypeT&gt;(this-&gt;at(newID));// std::shared_ptrのキャスト https://chiku2gonzalez.hatenablog.com/entry/2014/10/23/230011<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; };<br>
          &nbsp;&nbsp;&nbsp; static Layers layers; // 生成したサブスクリーンの高速辞書配列&lt;id,サブスクリーンの共有ポインタ&gt;<br>
          <br>
          protected:<br>
          &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:(外部読み取り不可)にしておくのでCreate()関数で生成してCreate().Set(～)で初期設定して ください<br>
          &nbsp;&nbsp;&nbsp; // [Factoryパターン:生成経路限定工場] https://qiita.com/shoheiyokoyama/items/d752834a6a2e208b90ca<br>
          &nbsp;&nbsp;&nbsp; // Factoryパターンの本質はクラスのユーザーに勝手にnewやmake_sharedで自由にコンストラクタを呼ばせないこと<br>
          &nbsp;&nbsp;&nbsp; // newのかわりにCreate関数を経由して生成を強制することでCreateと同時にIDを振ったり辞書に登録して勝手にnewされて一貫性が崩れるの を防ぐ<br>
          &nbsp;&nbsp;&nbsp; SubScreen() //float x = 0, float y = 0, float Width = 0, float Height = 0, int Alpha = 255, int Depth = 0, std::string name = "")<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // std::enable_shared_from_thisを継承するとコンストラクタ内ではまだthisは未確定なので shared_from_this()を使う関数(例.Set関数)は呼べなくなる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set(x, y, Width, Height, Alpha, Depth, name);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;id = SubScreen::serialDivID; // 通し番号割り振り(ゲーム中は被らない【通し】番号)<br>
          &nbsp;&nbsp;&nbsp; }<br>
          public:<br>
          &nbsp;&nbsp;&nbsp; // 新しくサブスクリーンを生成してそれへの共有ポインタを返す<br>
          &nbsp;&nbsp;&nbsp; static std::shared_ptr&lt;SubScreen&gt; Create()<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isDepthLayerChanged = true; // 新しいレイヤーが増えたので再並べ替えフラグをオンに<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return SubScreen::layers.make_shared&lt;SubScreen&gt;();<br>
          &nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; // サブスクリーンを削除<br>
          &nbsp;&nbsp;&nbsp; static void Erase(int id) { SubScreen::layers.erase(id); isDepthLayerChanged = true; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; virtual ~SubScreen() { if (handle &gt;= 0) DxLib::DeleteGraph(handle); } // 仮想デストラクタ<br>
          <br>
          &nbsp;&nbsp;&nbsp; virtual void InitScreen()<br>
          &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 分割画面を描くためのスクリーンの描画ハンドルを得る<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★複数プレイヤ画面や複数カメラ視点に使える[敵目線カメラサブ画面など]<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (renderWidth &gt;= 1 &amp;&amp; renderHeight &gt;= 1)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [描画スクリーンの紙を用意] https://dxlib.xsrv.jp/function/dxfunc_graph1.html#R3N25<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle = DxLib::MakeScreen((int)renderWidth, (int)renderHeight, (Alpha == 255 ? FALSE : TRUE));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↑[半透明スクリーンも可] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=3650<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitAgain = false; // 再びInitが必要かのフラグをオフに<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetX(float x) { this-&gt;x = x; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetY(float y) { this-&gt;y = y; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetZoomRate(float zoomRate) { this-&gt;zoomRate = (zoomRate &lt; 0.1f) ? 0.1f : zoomRate; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetWidth(float width) { this-&gt;Width = width;&nbsp; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetHeight(float height) { this-&gt;Height = height; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetRenderX(float renderX) { this-&gt;renderX = renderX; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetRenderY(float renderY) { this-&gt;renderY = renderY; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetRenderWidth(float renderWidth) { if (((int)this-&gt;renderWidth) != (int)renderWidth)&nbsp; isInitAgain = true; this-&gt;renderWidth = renderWidth;&nbsp;&nbsp; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetRenderHeight(float renderHeight) { if (((int)this-&gt;renderHeight) != (int)renderHeight) isInitAgain = true; this-&gt;renderHeight = renderHeight; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetAlpha(int alpha) { if (((int)this-&gt;Alpha) != (int)alpha)&nbsp; isInitAgain = true;&nbsp; this-&gt;Alpha = alpha;&nbsp; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetDepth(int depth) { if (this-&gt;Depth != depth) isDepthLayerChanged = true; this-&gt;Depth = depth; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレームに表示出力する文字の設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetDrawString(std::string drawString = "") { this-&gt;drawString = drawString; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレーム枠の幅の設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetFrameWidth(int frameWidth) { this-&gt;frameWidth = frameWidth; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレーム枠の色の設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetFrameColor(unsigned int frameColor) { this-&gt;frameColor = frameColor; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレームとバーを見せるかの設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetIsBarFrameShow(bool isBarShow, bool isFrameShow = true) { this-&gt;isBarShow = isBarShow; this-&gt;isFrameShow = isFrameShow; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレームのバーの高さの設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetBarFrameHeight(int barFrameHeight) { this-&gt;barFrameHeight = barFrameHeight; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレームのバーのnameのフォントのサイズ設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetBarFrameFontSize(int barFrameFontSize) { this-&gt;barFrameFontSize = barFrameFontSize; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレームのバーの背景色設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetBarColor(unsigned int barColor) { this-&gt;barColor = barColor; return shared_from_this(); }<br>
          &nbsp;&nbsp;&nbsp; // フレームの設定<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetFrame(int frameWidth, unsigned int frameColor, bool isBarShow = false, int barFrameHeight = 15) { this-&gt;frameWidth = frameWidth; this-&gt;isFrameShow = (frameWidth&gt;0)?true:false; this-&gt;frameColor = frameColor; this-&gt;isBarShow = isBarShow; this-&gt;barFrameHeight = barFrameHeight; return shared_from_this(); }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 色々セッティングして初回と設定変更があった時だけサブ画面を描くためのスクリーンの描画ハンドルを得る<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; Set(float x = 0, float y = 0, float width = 0, float height = 0, int alpha = 255, int depth = 0, std::string name = "")<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x = x; this-&gt;y = y;<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWidth(width); SetHeight(height); SetRenderWidth(width); SetRenderHeight(height); SetAlpha(alpha);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isInitAgain) InitScreen(); // 変更があるか確認してある時だけInitし直すようにすると早くなる<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;Depth != depth) isDepthLayerChanged = true; // Depthに変更があれば再並べ替えフラグをオンに<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;Depth = depth; this-&gt;name = name;<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return shared_from_this(); // 設定した後の自分自身を返す<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; virtual void Update()<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // なにかUpdateしたいことがあれば処理を追加<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; virtual void Draw()<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawScreen(); // スクリーンをDrawRectExtendGraphを使って描く(ズームやアルファ透明度も反映させる)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawFrame(); // スクリーンのまわりにフレームを描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawBarFrame(); // スクリーンの上にWindowsみたいなバーを描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // デバッグ用の文字表示<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpFontSize = GetFontSize();// 元のフォントサイズを保管<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetFontSize(barFrameFontSize); // 描画する文字列のサイズを設定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString((int)x, (int)y, drawString.c_str(), stringColor); // デバッグ用の文字列をスクリーンの左上(0,0)に描画<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetFontSize(tmpFontSize); // 元のフォントサイズ設定にすぐ戻す<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; virtual void DrawScreen() // スクリーンをDrawRectExtendGraphを使って描く(ズームやアルファ透明度も反映させる)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpBlendMode, tmpBlendParam;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetDrawBlendMode(&amp;tmpBlendMode, &amp;tmpBlendParam); // 現在の描画ブレンドモードを取得しておく<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Alpha != 255) DxLib::SetDrawBlendMode(DX_BLENDMODE_ALPHA, Alpha); // 半透明のスクリーンも描ける https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4978<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 画面ウィンドウに描画されたスクリーン内容を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawRectExtendGraph((int)x, (int)y, (int)(x + Width * zoomRate), (int)(y + Height * zoomRate), renderX, renderY, renderWidth, renderHeight, handle, (Alpha == 255 ? FALSE : TRUE));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Alpha != 255) DxLib::SetDrawBlendMode(tmpBlendMode, tmpBlendParam); // もとのブレンドモードに戻しておく<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; virtual void DrawFrame() // スクリーンのまわりにフレームを描く<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isFrameShow) return; // フレームを描かない設定の場合<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //サブスクリーンの枠の表示<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int f = 1; f &lt;= frameWidth; f++)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)x - f + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)y - 1 + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(x + Width * zoomRate + f) + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(y + Height * zoomRate + f) + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameColor, FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; virtual void DrawBarFrame() // スクリーンの上にWindowsみたいなバーを描く<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isBarShow) return; // バーのフレームを描かない設定の場合<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // バーの背景の地を塗りつぶす<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)x + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)y - barFrameHeight + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(x + Width * zoomRate) + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(y - 1) + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; barColor, TRUE);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マウスが上に乗った時の色はGetColor(255, 0, 0)で赤枠にしている<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int mouseOverColor = (this-&gt;id == topMouseOverID) ? GetColor(255, 0, 0) : frameColor;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int barFrameWidth = (1 &lt; frameWidth) ? 2 : 1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for文でフレームの枠=frameWidthの大きさぶんBoxを複数描いて枠を太くする<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int f = frameWidth - barFrameWidth; f &lt;= frameWidth; f++)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)x - f + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)y - barFrameHeight - f + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(x + Width * zoomRate + f) + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(y + Height * zoomRate + f) + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (f == frameWidth) ? mouseOverColor : frameColor, FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // バーにウィンドウの名前表示(バーの高さがフォントのサイズ以下なら文字サイズをバーの大きさに合わせる)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpFontSize = GetFontSize();// 元のフォントサイズを保管<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetFontSize((barFrameHeight &gt; barFrameFontSize) ? barFrameFontSize : barFrameHeight); // 描画する文字列のサイズを設定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString((int)x, (int)y - barFrameHeight, name.c_str(), frameColor); // バーにnameの文字列を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetFontSize(tmpFontSize); // 元のフォントサイズ設定にすぐ戻す<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          <br>
          &nbsp;&nbsp;&nbsp; static void UpdateScreens() // スクリーンの状態の更新(ドラッグ移動など)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; subScreen : layers)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subScreen.second-&gt;Update();<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //OrderByLayerDepth(); // レイヤーのDepth順に並べ替え→FocusOnClickScreen関数でやる<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FocusOnClickScreen(); // クリックしたスクリーンを一番上にするように並べ替え<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DragScreen();// サブスクリーンをドラッグで移動できるように<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZoomScreens(); // サブスクリーンをマウスホイールでズームインズームアウトできるように<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; static void DrawScreens() // サブスクリーンを全部まとめて描く<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderByLayerDepth(); // レイヤーのDepth順に並べ替え<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //↓並べ変わった順を使ってDepth順にサブスクリーンをDraw<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::multiset&lt;depth_id_pair&gt;::iterator ite = depth_id_ordered.begin();<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (ite != depth_id_ordered.end())<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id = ite-&gt;second;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (layers.count(id) &gt; 0)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; layers[id]-&gt;Draw(); // depth順にDrawでサブスクリーンを複数レイヤーで描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ite++;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // サブスクリーンの描画内容をきれいにクリア<br>
          &nbsp;&nbsp;&nbsp; void ClearDrawScreen()<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (handle &lt; 0) return;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawStart(); // 設定先をサブスクリーンとする<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen(); // 一旦 サブスクリーンをきれいにクリア<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawEnd();<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // ★このStartとEndのあいだの描画処理はサブスクリーンに描かれるようになる<br>
          &nbsp;&nbsp;&nbsp; void DrawStart()<br>
          &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブスクリーンが描画可能状態なら<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (handle &lt; 0) return;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isInitAgain) InitScreen();// 変更があるか確認してある時だけInitでDxLib::MakeScreenをし直す<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpResetSetting = GetUseSetDrawScreenSettingReset(); // 設定を一旦tmpに退避<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetUseSetDrawScreenSettingReset(FALSE); // SetDrawScreen切り替え時に設定をリセットしない(FALSE)(これをやらないとカメラ視点などがリセットされるから)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpDrawScreen = DxLib::GetDrawScreen(); // Endまでのあいだ一旦変更前のhandleを退避<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ゲームを描く先を用意しておいたサブスクリーンに設定(キャンバスを指定する)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawScreen(handle);<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // ★このStartとEndのあいだの描画処理はサブスクリーンに描かれるようになる<br>
          &nbsp;&nbsp;&nbsp; void DrawEnd()<br>
          &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブスクリーンが描画可能状態なら<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (handle &lt; 0) return;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ゲームを描く先をもとのデフォルトに戻しておく<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawScreen((tmpDrawScreen == -1) ? DX_SCREEN_BACK : tmpDrawScreen);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetUseSetDrawScreenSettingReset((tmpResetSetting == -1) ? TRUE : tmpResetSetting); // 設定をすぐに元に戻す<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          <br>
          <br>
          &nbsp;&nbsp;&nbsp; // スタティック機能群(サブスクリーンの辞書やマウスでのドラッグ移動など)<br>
          public:<br>
          &nbsp;&nbsp;&nbsp; static bool isMouseOvered; //= false マウスオーバーしてるレイヤがあるか<br>
          &nbsp;&nbsp;&nbsp; static int topMouseOverID; //= -1 一番上のマウスオーバーしてるレイヤのID<br>
          &nbsp;&nbsp;&nbsp; static int topDepthID; //= -1 一番上のレイヤのID<br>
          &nbsp;&nbsp;&nbsp; static int topDepth; //= -1 一番上のレイヤのDepth<br>
          protected:<br>
          &nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp; static void OrderByLayerDepth() // レイヤーのDepth順に並べ替え<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isDepthLayerChanged) return; // レイヤーのDepthに変化がなければ並べ替えは不要<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; depth_id_ordered.clear(); // 並べ替え前に既存の順序データを一度クリア<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; subScreen : layers)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id = subScreen.first;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int depth = subScreen.second-&gt;Depth;//ペア(左,右)だと左の数字の順に自動で並ぶ<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; depth_id_ordered.insert(std::make_pair(depth, id)); // https://qiita.com/izmktr/items/17e3009041b841b26a34<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } //全部マルチセットに↑入れると自動でdepth順に並べ変わってる<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CheckLayerOrder(); // マウスオーバーしてるレイヤや一番上のレイヤも再び調べる<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; static void CheckLayerOrder() // 一番上のマウスオーバーしてるレイヤを調べる<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::TopLayerMouseX = Input::MouseX; Input::TopLayerMouseY = Input::MouseY; // 一番上のレイヤのTopLayerMouseマウス座標をリセット<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isMouseOvered = false; // ループを回す前にfalseで初期化<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; topMouseOverID = -1; // -1ならマウスオーバーしているレイヤはない<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //↓並べ変わった順を使ってDepth順に調べ、一番上のマウスオーバーしてるレイヤを調べる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::multiset&lt;depth_id_pair&gt;::iterator ite = depth_id_ordered.begin();<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; topDepth = -1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (ite != depth_id_ordered.end())<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id = ite-&gt;second;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto subscreen = layers[id];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool _isMouseOvered = subscreen-&gt;IsOnBarFrame((float)Input::MouseX, (float)Input::MouseY);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_isMouseOvered &amp;&amp; id &gt;= 0) // depth順で一番上のマウスオーバーしてるレイヤを調べる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; topMouseOverID = id; // idが0以上のレイヤしか検知しない<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_isMouseOvered)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isMouseOvered |= _isMouseOvered; // | で[または]のビット演算(1つでもtrueがあれば最終的にtrueに)<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ite-&gt;first &gt;= topDepth)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; topDepthID = id; // マウスが乗ってるかと関係なしに最大Depthも記録<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; topDepth = ite-&gt;first;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ite++;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ite == depth_id_ordered.end() &amp;&amp; topMouseOverID != -1)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto topLayerScreen = layers[topMouseOverID];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 一番上のレイヤーのマウスの「ローカルな」座標を登録しておけば「そのウィンドウ内のマウス位置」を得られる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::TopLayerMouseX = topLayerScreen-&gt;LocalX(Input::MouseX);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::TopLayerMouseY = topLayerScreen-&gt;LocalY(Input::MouseY); // LocalXYならそのウィンドウの左上を(0,0)とした「ウィンドウ内のマウス位置」が求まる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          public:<br>
          &nbsp;&nbsp;&nbsp; static int clickDownID; //= -1 クリックした瞬間のマウスが乗ってるサブウィンドウの番号(マウスを話した瞬間のIDと比べて同じならそのウィンドウにフォーカスする)<br>
          &nbsp;&nbsp;&nbsp; static void FocusOnClickScreen() // クリックしたスクリーンを一番上にするように並べ替え<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderByLayerDepth(); // レイヤーのDepth順に並べ替え<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (topMouseOverID == -1) return;<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(Pad::Mouse, MOUSE_INPUT_LEFT)) // マウスの右ボタンが押された瞬間か？(ドラッグ開始)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // clickDownID = クリックした瞬間(ドラッグ開始時)のマウスが乗ってる一番上のサブウィンドウのID番号<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clickDownID = topMouseOverID;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (Input::GetButtonUp(Pad::Mouse, MOUSE_INPUT_LEFT)) // マウスの右ボタンが離された瞬間か？<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int clickUpID = topMouseOverID; // マウスのクリックを離した瞬間のスクリーンIDは基本はマウスが乗っている一番上のスクリーン<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (topMouseOverID != clickDownID // ↑例外的に、clickDownIDがマウスを離した瞬間のtopMouseOverIDと違うとき<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; layers.count(clickDownID) &gt; 0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; layers[clickDownID]-&gt;Depth &lt; layers[topMouseOverID]-&gt;Depth) // clickDownIDのDepthがマウスを離した瞬間に一番上にあるウィンドウのDepthより小さい<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clickUpID = clickDownID; // clickUpIDをドラッグ中の後ろに隠れているウィンドウに変える<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ドラッグを離した瞬間のスクリーンを一番上のDepthへと書き換えたい<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (layers.count(topDepthID) &gt; 0)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto clickUpScreen = layers[clickUpID]; // マウスを離した瞬間のドラッグ中の一番上のレイヤにしたいスクリーン<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto topDepthScreen = layers[topDepthID]; // Depthが一番大きいスクリーン<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (clickUpScreen-&gt;Depth &lt;= topDepthScreen-&gt;Depth) // Depthが一番大きいスクリーンよりクリックを離したスクリーンのDepthが小さいなら<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int newTopDepth = topDepthScreen-&gt;Depth;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (clickUpScreen-&gt;Depth == newTopDepth &amp;&amp; clickUpID != topDepthID)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newTopDepth++; //&nbsp; マウスを離した瞬間のマウスが乗ってる一番上のレイヤのスクリーンのDepthをtopDepthScreenより+1大きくする<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (clickUpScreen-&gt;Depth != topDepthScreen-&gt;Depth)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; topDepthScreen-&gt;SetDepth(clickUpScreen-&gt;Depth); // 現在の一番上のレイヤのスクリーンとクリックを離したスクリーンのDepthを入れ替え<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clickUpScreen-&gt;SetDepth(newTopDepth); // +1大きくしたDepthをSetする<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderByLayerDepth(); // [再び並べ替え]レイヤーのDepth順に<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; /*static void FocusOnScreen(int id)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 特定のidへフォーカスさせたければ関数を自作してもよいかも<br>
          &nbsp;&nbsp;&nbsp; }*/<br>
          <br>
          &nbsp;&nbsp;&nbsp; static int prevDragX; //= -1 直前のドラッグ中のマウスの位置<br>
          &nbsp;&nbsp;&nbsp; static int prevDragY; //= -1 直前のドラッグ中のマウスの位置<br>
          &nbsp;&nbsp;&nbsp; static bool isDraging() { return (dragingID != -1); }<br>
          &nbsp;&nbsp;&nbsp; static int dragingID; //= -1 ドラッグ中のサブスクリーンのID<br>
          <br>
          &nbsp;&nbsp;&nbsp; static bool DragScreen() // サブスクリーンをドラッグで移動できるように<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int dragID = -1; // ドラッグ移動する一番上のサブスクリーンのID<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dragingID == -1 &amp;&amp; isMouseOvered)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dragID = topMouseOverID;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dragingID != -1)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dragID = dragingID;<br>
          <br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dragID != -1 &amp;&amp; Input::Click[Mouse::DragL] &amp;&amp; Screen::IsInsideWindow())<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto dragScreen = layers[dragID];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dragingID = dragID;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (prevDragX != -1 &amp;&amp; prevDragY != -1)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ★前の位置prevと現在の位置に移動があれば、その差ぶんだけ+=することでドラッグ移動を実現<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragLX])<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dragScreen-&gt;x += (float)(Input::Click[Mouse::DragLX] - prevDragX);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (prevDragY != Input::Click[Mouse::DragLY])<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dragScreen-&gt;y += (float)(Input::Click[Mouse::DragLY] - prevDragY);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevDragX = Input::Click[Mouse::DragLX];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevDragY = Input::Click[Mouse::DragLY];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevDragX = -1; prevDragY = -1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dragingID = -1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // サブスクリーンをバーの上てマウスホイールグリグリするとズームインズームアウトできるように<br>
          &nbsp;&nbsp;&nbsp; static void ZoomScreens(bool isZoomByBar = true)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isMouseOvered) return;<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto zoomScreen = layers[topMouseOverID];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isZoomByBar &amp;&amp; !zoomScreen-&gt;IsOnBar((float)Input::MouseX, (float)Input::MouseY))<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return; // バーの上にカーソルがない<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zoomScreen-&gt;SetZoomRate(zoomScreen-&gt;zoomRate + 0.1f * (Input::MouseWheel));<br>
          &nbsp;&nbsp;&nbsp; }<br>
          };<br>
        </em><br>
        <br>
        #endif<br>
      </p>
      <p><code>Screen.cppを新規作成</code>して static変数を定義しましょう。</p>
      <p class="source">#include "Screen.h"<br>
        <br>
        int SubScreen::serialDivID{ 0 }; // サブスクリーンを新たに生成するときの通し番号(シリアルID)<br>
        bool SubScreen::isDepthLayerChanged{ false }; // 新しいレイヤが追加されり変更があった時だけ並べ替えるためのフラグ<br>
        <br>
        std::multiset&lt;SubScreen::depth_id_pair&gt; SubScreen::depth_id_ordered; // std::multiset[キーの無い版のstd::map(マルチでキーかぶりOK版)]<br>
        <br>
        bool SubScreen::isMouseOvered{ false }; // マウスオーバーしてるレイヤがあるか<br>
        int SubScreen::topMouseOverID{ -1 }; // 一番上のマウスオーバーしてるレイヤのID<br>
        int SubScreen::topDepthID{ -1 }; // 一番上のレイヤのID<br>
        int SubScreen::topDepth{ -1 }; // 一番上のレイヤのDepth<br>
        <br>
        <br>
        SubScreen::Layers SubScreen::layers; // 生成したサブスクリーンの高速辞書配列&lt;id,サブスクリーンの共有ポインタ&gt;<br>
        <br>
        int SubScreen::clickDownID{ -1 }; // クリックした瞬間のマウスが乗ってるサブウィンドウの番号(マウスを話した瞬間のIDと比べて同じならそのウィンドウにフォーカスする)<br>
        <br>
        int SubScreen::prevDragX{ -1 }; // 直前のドラッグ中のマウスの位置<br>
        int SubScreen::prevDragY{ -1 }; // 直前のドラッグ中のマウスの位置<br>
        int SubScreen::dragingID{ -1 }; // ドラッグ中のサブスクリーンのID<br>
      </p>
      <p>ウィンドウのドラッグってどうやってるのって、シンプルにいうなら<br>
        <span style="font-weight: bold; text-decoration: underline;">前の瞬間(prev)と 現在の位置に移動があれば、その差ぶんだけ+=する</span>、というだけなのでベースとなっているアイデア自体は実はシンプルなものです<br>
        (ただレイヤーの並べ替えとか一番上じゃないレイヤーをクリックしたときにフォーカスして一番上にするとか考え出すと結構たいへんですが)<br>
        <br>
      </p>
      <p><code>main.cpp</code>のコードにSubScreenクラスを使ってドラッグできるウィンドウズみたいなサブのスクリーンを表 示させてみましょう。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        <em>#include "Input.h"</em><br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
        &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
        &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
        &nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply", Data); // .plyデータをロード 軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう<br>
        <br>
        &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
        <br>
        &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
        &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
        &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
        <br>
        &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
        &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
        &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
        &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        <br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
        &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 200.0f; keyControlXYZ.y = 200.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
          &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
          &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
          &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
          &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; <u>float subscreenX = 0, subscreenY = 0; // 別描画スクリーンを描く位置<br>
          &nbsp;&nbsp;&nbsp; int subscreenWidth = 600, subscreenHeight = 100;<br>
          &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE); // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドル作成を TRUE:許可<br>
          &nbsp;&nbsp;&nbsp; // [別の描画スクリーンを用意] https://dxlib.xsrv.jp/function/dxfunc_graph1.html#R3N25<br>
          &nbsp;&nbsp;&nbsp; int subscreen = DxLib::MakeScreen(subscreenWidth, subscreenHeight, FALSE);<br>
          &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE); // FLASE:通常のグラフィックハンドルを作成するモードに戻す</u><br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Input::Update(); // マウスのドラッグなどを更新<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens(); // スクリーンの位置やドラッグによる移動を更新する</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>int MouseX, MouseY;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マウスの位置を取得<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetMousePoint(&amp;MouseX, &amp;MouseY);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreenX = MouseX; subscreenY = MouseY; // マウスのポインタの位置を起点にサブのスクリーンを描く</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(50.0f, 50.0f, 50.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>int tmpResetSetting = DxLib::GetUseSetDrawScreenSettingReset(); // 設定を一旦tmpに退避<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseSetDrawScreenSettingReset(FALSE); // SetDrawScreen切り替え時に設定をリセットしない(FALSE)(これをやらないとカメラ視点などがリセットされるから)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpDrawScreen = DxLib::GetDrawScreen(); // 一旦変更前のスクリーンのハンドルを退避<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawScreen(subscreen);// ゲームを描く先を用意しておいたサブスクリーンに設定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // (0,0)位置を起点に別 スクリーンへ文字列を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawScreen((tmpDrawScreen == -1) ? DX_SCREEN_BACK : tmpDrawScreen); // 描く先をもとのデフォルトのスクリーンに戻しておく<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseSetDrawScreenSettingReset((tmpResetSetting == -1) ? TRUE : tmpResetSetting); // 設定を元に戻す<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 画面に別スクリーンの内容を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawRectExtendGraph((int)subscreenX, (int)subscreenY, (int)(subscreenX + subscreenWidth), (int)(subscreenY + subscreenHeight), 0, 0, subscreenWidth, subscreenHeight, subscreen, FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 別スクリーンの枠を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox( (int)((int)subscreenX - 1 + 0.5f),(int)((int)subscreenY - 1 + 0.5f),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)((int)(subscreenX + subscreenWidth + 1) + 0.5f), (int)((int)(subscreenY + subscreenHeight + 1) + 0.5f), GetColor(255,255,255), FALSE);</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 半透明のスクリーンも描ける<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height, GetColor(0, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();</em><br>
        <em><br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); // サブのスクリーンを全部描く</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <p>いかがですか?ウィンドウズっぽいものが自作できたでしょうか?<br>
        ドラッグだけじゃなくバーの上でマウスのホイールをグリグリするとウィンドウがズームできる機能もおまけでついてます<br>
      </p>
      <br>
      <br>
      <br>
    </a><a id="mozTocId0006" class="mozTocH1">
      <h1>エディタを自作して視点カメラを動かせるようにする</h1>
      <br>
      <p><code>Singleton.hを新規作成</code>して Editorクラスが唯一のシングルトンを継承できるように準備する。</p>
      <p class="source">#ifndef SINGLETON_H_<br>
        #define SINGLETON_H_<br>
        <br>
        // テンプレートT型シングルトンSingleton&lt;～&gt; ～になんでも指定して唯一物にできる<br>
        // ★Singleton&lt;T&gt;型は【必ず唯一で複製不可】(使い方:どこからでもアクセスし変数を共有するクラス向き)<br>
        // ★ゲーム内の【どこからアクセスしても統一性が保たれる】(唯一だから)「クラス名と実体が一致」<br>
        template&lt;class T&gt;<br>
        class Singleton<br>
        {<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; // GetInstanceを通して【しか】T型クラスをつくれないうえに、<br>
        &nbsp;&nbsp;&nbsp; // ★作ったものは【かならず唯一で複製不可】<br>
        &nbsp;&nbsp;&nbsp; // それが【シングルトン型】！<br>
        &nbsp;&nbsp;&nbsp; // ゲーム中で唯一で複製不可にしたい【ゲームを一律管理するクラス】などに最適！<br>
        &nbsp;&nbsp;&nbsp; // https://teratail.com/questions/17416<br>
        &nbsp;&nbsp;&nbsp; // http://rudora7.blog81.fc2.com/blog-entry-393.html<br>
        &nbsp;&nbsp;&nbsp; // ②↓同じ関数の定義はプログラム全体で１つだけしか許されません。(static関数名は被らない)<br>
        &nbsp;&nbsp;&nbsp; static inline T&amp; GetInstance()<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //①↓関数の中で定義されたstatic変数は、関数の定義毎に１つ領域が確保されます。<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static T instance; //メモリ上にstatic変数確保(静かに常に待機するinstance)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return instance; //①=(常駐)②=(唯一) ①と②両方満たすinstanceは【メモリ上に唯一】<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        protected:<br>
        &nbsp;&nbsp;&nbsp; Singleton() {} // 外部でのインスタンス作成は禁止(protected:内部公開、外部禁止)<br>
        &nbsp;&nbsp;&nbsp; virtual ~Singleton() {} // 仮想デストラクタ(シングルトンを【継承するためには忘れちゃダメ】)<br>
        <br>
        private:<br>
        &nbsp;&nbsp;&nbsp; void operator=(const Singleton&amp; obj) {} // 代入演算子禁止<br>
        &nbsp;&nbsp;&nbsp; Singleton(const Singleton&amp; obj) {} // コピーコンストラクタ禁止(コピーできない【唯一】)<br>
        &nbsp;&nbsp;&nbsp; static T* instance; // private:だから外部アクセスできない【GetInstance()経由しか無理】<br>
        };<br>
        <br>
        // ふだんcppで書くstatic変数初期化も★【Tテンプレートクラスだからすべて.hヘッダにまとめて書いた】<br>
        template&lt; class T &gt;<br>
        T* Singleton&lt; T &gt;::instance = 0; // static変数はclass内で初期化できないが、class外では = 0できる<br>
        <br>
        #endif<br>
      </p>
      <br>
      <p><code>Editor.hを新規作成</code>して マウスの右ドラッグでカメラを回転、左ドラッグでカメラの視点を移動、<br>
        キーボードのT,Yキーでカメラz軸回転、キーボードのH,Jキーでカメラy軸回転、キーボードのV,Bキーでカメラx軸回転できるようにする。</p>
      <p class="source">#ifndef EDITOR_H_<br>
        #define EDITOR_H_<br>
        <br>
        #include "DxLib.h"<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        <br>
        #include "Singleton.h"<br>
        <br>
        class Editor : public Singleton&lt;Editor&gt;<br>
        {<br>
        public:<br>
        <br>
        &nbsp;&nbsp;&nbsp; struct Camera<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x = 0.f, y = 0.0f, z = -10.0f; // カメラはz軸マイナス位置からz軸プラス向きに原点を見る形で初期化される<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float VRotate = 0.0f, HRotate = 0.0f, TRotate = 0.0f; // X軸 V,Y軸 H,Z軸 T まわりのカメラのオイラー回転の角度<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; inline Camera&amp; operator +=(VECTOR move) { x += move.x; y += move.y; z += move.z; return *this; } // VECTOR型を足したときはカメラを移動させる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float wheelSpeed = 1.0f; // マウスのホイールと連動した際のカメラのスピード<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR GetCameraWorldDirByScreenXY(float screenX = (float)Input::MouseX, float screenY = (float)Input::MouseY)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // スクリーン(X,Y)からマウスの指すワールド座標(X,Y,Z)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR currentPos = DxLib::ConvScreenPosToWorldPos(VGet(screenX, screenY, 0.0f));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラからマウスの指す位置への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return DxLib::VNorm(DxLib::VGet(currentPos.x - x, currentPos.y - y, currentPos.z - z));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; };<br>
        &nbsp;&nbsp;&nbsp; Camera camera;<br>
        <br>
        &nbsp;&nbsp;&nbsp; int prevDragX = -1, prevDragY = -1; // 前フレームでのスクリーン上でのドラッグXY位置<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; bool isInitFinished = false; // 一回でもInitされたかのフラグ<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; void Init()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isInitFinished) return; // 最初の一回だけInit処理をするためのフラグ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitFinished = true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateKeyInput()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_V))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_B))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_H))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_J))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_T))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_Y))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateMouseInput()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!SubScreen::isMouseOvered) // マウスオーバーしているSubscreenがないとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::MouseWheel != 0.0f) // マウスのホイールをグリグリしたとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界の奥への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR camNorm = camera.GetCameraWorldDirByScreenXY((float)Input::MouseX, (float)Input::MouseY);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camSpeed = camera.wheelSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.wheelSpeed *= (camera.wheelSpeed &lt; 100.0f) ? 1.5f : 1.0f; // カメラのズーム速度を加速する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 求めた単位ベクトル×カメラのスピードぶんカメラの位置を移動<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.x += camNorm.x * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.y += camNorm.y * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.z += camNorm.z * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (camera.wheelSpeed &gt; 0.1f) camera.wheelSpeed *= 0.9f; // カメラのズーム速度を減衰する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else camera.wheelSpeed = 0.1f; // カメラのズーム速度を減衰して最小0.1にすることで繊細なズーム調整もできるようにする<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((Input::Click[Mouse::DragL] || Input::Click[Mouse::DragR]) &amp;&amp; Screen::IsInsideWindow())<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != -1 &amp;&amp; prevDragY != -1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 前の位置prevと現在の位置に移動があれば、その差ぶんだけ+=することでドラッグ移動を実現<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragL]) // マウス左クリック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragLX] || prevDragY != Input::Click[Mouse::DragLY])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // マウスポインタがある画面上の座標に該当する３Ｄ空間上の座標を取得 https://dxlib.xsrv.jp/function/dxfunc_3d_camera.html#R12N11<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float positionRatio = 0.9f;// 奥行の位置 Near 面 0.0f ～ 1.0f Far 面<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR start = DxLib::ConvScreenPosToWorldPos(VGet((float)prevDragX, (float)prevDragY, positionRatio));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR end = DxLib::ConvScreenPosToWorldPos(VGet((float)Input::Click[Mouse::DragLX], (float)Input::Click[Mouse::DragLY], positionRatio));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camSpeed = 400; // ドラッグに対するカメラの移動速度<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.x -= (end.x - start.x) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.y -= (end.y - start.y) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.z -= (end.z - start.z) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragR]) // マウス右クリック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // カメラの角度を変更<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragRX])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate += (float)(Input::Click[Mouse::DragRX] - prevDragX);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragY != Input::Click[Mouse::DragRY])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate += (float)(Input::Click[Mouse::DragRY] - prevDragY);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ±360度を超えたら割り算の余りを設定して 例.365度 → 5度に戻してやる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (camera.HRotate &gt; 360.0f || camera.HRotate &lt; -360.0f) camera.HRotate = std::fmodf(camera.HRotate, 360.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (camera.VRotate &gt; 360.0f || camera.VRotate &lt; -360.0f) camera.VRotate = std::fmodf(camera.VRotate, 360.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragX = (Input::Click[Mouse::DragL]) ? Input::Click[Mouse::DragLX] : Input::Click[Mouse::DragRX];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragY = (Input::Click[Mouse::DragL]) ? Input::Click[Mouse::DragLY] : Input::Click[Mouse::DragRY];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragX = -1; prevDragY = -1; // マウスのドラッグがないときはリセット<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateCamera()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラの位置と回転値をセット、カメラの位置は原点<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">DxLib::SetCameraPositionAndAngle</span>(<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::VGet(camera.x, camera.y, camera.z),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate * DX_PI_F / 180.0f, camera.HRotate * DX_PI_F / 180.0f, camera.TRotate * DX_PI_F / 180.0f);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // まとめてUpdateしたいときはUpdateを使い、個別にUIやKeyやMouseを別々にタイミングを取りながらUpdateしたいときは Updateは呼ばない<br>
        &nbsp;&nbsp;&nbsp; void Update()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateKeyInput();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateMouseInput();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateCamera();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void Draw()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 原点からx軸(R:赤) y軸(G:緑) z軸(B:青)をライン表示する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(1.0f * 5.0f, 0.0f * 5.0f, 0.0f * 5.0f), GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(0.0f * 5.0f, 1.0f * 5.0f, 0.0f * 5.0f), GetColor(0, 255, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(0.0f * 5.0f, 0.0f * 5.0f, 1.0f * 5.0f), GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 画面に回転量を描画<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, DxLib::GetColor(255, 255, 255), "Cam(x:%f y:%f z:%f)", camera.x, camera.y, camera.z);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 20, DxLib::GetColor(255, 255, 255), "Rot(V:%f H:%f T:%f)", camera.VRotate, camera.HRotate, camera.TRotate);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        #endif<br>
      </p>
      <br>
      <p><code>main.cpp</code>のコードにEditorクラスを使ってカメラの視点を移動、回転させてみま しょう。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        <br>
        <em>#include "Editor.h"</em><br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
        &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
        &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
        &nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply", Data); // .plyデータをロード 軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう<br>
        <br>
        &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
        <br>
        &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
        &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
        &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
        <br>
        &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
        &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
        &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
        &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        <br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
        &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = <em>0.0f</em>; keyControlXYZ.y = <em>0.0f</em>; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>//奥行0.1～5000までをカメラの描画範囲とする<br>
          &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens(); // スクリーンの位置やドラッグによる移動を更新する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画像のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(<em>1.0f, 1.0f, 1.0f</em>); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0<em></em><em></em>, <em>100</em>, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 半透明のスクリーンも描ける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); // サブのスクリーンを全部描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>editor.Draw(); // エディタのDraw処理</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      <br>
      <p>いかがでしょうか？カメラの視点の位置をマウスの左ドラッグで移動、右ドラッグで回転、<br>
        キーボードのT,Yキーでカメラz軸回転、キーボードのH,Jキーでカメラy軸回転、キーボードのV,Bキーでカメラx軸回転できるようになりましたか？<br>
        <br>
        <br>
        <br>
        <br>
      </p>
    </a><a id="mozTocId0007" class="mozTocH1">
      <h1>キーボードのWSキーでカメラ視点を手前や奥に移動でき るようにする</h1>
      <p><code>Editor.h</code>を変更してキーボードのWSキーでカメラ視点を手前や奥に移動できるようにします。</p>
      <p class="source">#ifndef EDITOR_H_<br>
        #define EDITOR_H_<br>
        <br>
        #include "DxLib.h"<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        <br>
        #include "Singleton.h"<br>
        <br>
        class Editor : public Singleton&lt;Editor&gt;<br>
        {<br>
        public:<br>
        <br>
        &nbsp;&nbsp;&nbsp; struct Camera<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x = 0.f, y = 0.0f, z = -10.0f; // カメラはz軸マイナス位置からz軸プラス向きに原点を見る形で初期化される<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; inline Camera&amp; operator +=(VECTOR move) { x += move.x; y += move.y; z += move.z; return *this; } // VECTOR型を足したときはカメラを移動させる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float VRotate = 0.0f, HRotate = 0.0f, TRotate = 0.0f; // X軸 V,Y軸 H,Z軸 T まわりのカメラのオイラー回転の角度<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float wheelSpeed = 1.0f; // マウスのホイールと連動した際のカメラのスピード<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // <span style="font-weight: bold;">スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向の単位ベクトル(ノルム) を求める</span><br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR <span style="font-weight: bold;">GetCameraWorldDirByScreenXY</span>(float screenX = (float)Input::MouseX, float screenY = (float)Input::MouseY)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // スクリーン(X,Y)からマウスの指すワールド座標(X,Y,Z)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR currentPos = <span

          style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet(screenX, screenY, 0.0f));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラからマウスの指す位置への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return DxLib::VNorm(DxLib::VGet(currentPos.x - x, currentPos.y - y, currentPos.z - z));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; };<br>
        &nbsp;&nbsp;&nbsp; Camera camera;<br>
        <br>
        &nbsp;&nbsp;&nbsp; int prevDragX = -1, prevDragY = -1; // 前フレームでのスクリーン上でのドラッグXY位置<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; bool isInitFinished = false; // 一回でもInitされたかのフラグ<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; void Init()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isInitFinished) return; // 最初の一回だけInit処理をするためのフラグ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitFinished = true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateKeyInput()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>float camXYZSpeed = 1.0f;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向のの単位ベクトル(ノルム)を求める<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR camNorm = camera.GetCameraWorldDirByScreenXY((float)Input::MouseX, (float)Input::MouseY);<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // キーボードのWSキーでカメラ視点を手前や奥に移動できるようにする<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_W))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(camNorm.x * camXYZSpeed, camNorm.y * camXYZSpeed, camNorm.z * camXYZSpeed);<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_S))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(-camNorm.x * camXYZSpeed, -camNorm.y * camXYZSpeed, -camNorm.z * camXYZSpeed);</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_V))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_B))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_H))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_J))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_T))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_Y))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateMouseInput()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!SubScreen::isMouseOvered) // マウスオーバーしているSubscreenがないとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::MouseWheel != 0.0f) // マウスのホイールをグリグリしたとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界の奥への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR camNorm = camera.<span

          style="font-weight: bold;">GetCameraWorldDirByScreenXY</span>((float)Input::MouseX, (float)Input::MouseY);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camSpeed = camera.wheelSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.wheelSpeed *= (camera.wheelSpeed &lt; 100.0f) ? 1.5f : 1.0f; // カメラのズーム速度を加速する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 求めた単位ベクトル×カメラのスピードぶんカメラの位置を移動<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.x += camNorm.x * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.y += camNorm.y * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.z += camNorm.z * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (camera.wheelSpeed &gt; 0.1f) camera.wheelSpeed *= 0.9f; // カメラのズーム速度を減衰する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else camera.wheelSpeed = 0.1f; // カメラのズーム速度を減衰して最小0.1にすることで繊細なズーム調整もできるようにする<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((Input::Click[Mouse::DragL] || Input::Click[Mouse::DragR]) &amp;&amp; Screen::IsInsideWindow())<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != -1 &amp;&amp; prevDragY != -1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 前の位置prevと現在の位置に移動があれば、その差ぶんだけ+=することでドラッグ移動を実現<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragL]) // マウス左クリック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragLX] || prevDragY != Input::Click[Mouse::DragLY])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // マウスポインタがある画面上の座標に該当する３Ｄ空間上の座標を取得 https://dxlib.xsrv.jp/function/dxfunc_3d_camera.html#R12N11<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float positionRatio = 0.9f;// 奥行の位置 Near 面 0.0f ～ 1.0f Far 面<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR start = <span

          style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet((float)prevDragX, (float)prevDragY, positionRatio));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR end = <span

          style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet((float)Input::Click[Mouse::DragLX], (float)Input::Click[Mouse::DragLY], positionRatio));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camSpeed = 400; // ドラッグに対するカメラの移動速度<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.x -= (end.x - start.x) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.y -= (end.y - start.y) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.z -= (end.z - start.z) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragR]) // マウス右クリック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // カメラの角度を変更<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragRX])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate += (float)(Input::Click[Mouse::DragRX] - prevDragX);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragY != Input::Click[Mouse::DragRY])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate += (float)(Input::Click[Mouse::DragRY] - prevDragY);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ±360度を超えたら割り算の余りを設定して 例.365度 → 5度に戻してやる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (camera.HRotate &gt; 360.0f || camera.HRotate &lt; -360.0f) camera.HRotate = std::fmodf(camera.HRotate, 360.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (camera.VRotate &gt; 360.0f || camera.VRotate &lt; -360.0f) camera.VRotate = std::fmodf(camera.VRotate, 360.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragX = (Input::Click[Mouse::DragL]) ? Input::Click[Mouse::DragLX] : Input::Click[Mouse::DragRX];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragY = (Input::Click[Mouse::DragL]) ? Input::Click[Mouse::DragLY] : Input::Click[Mouse::DragRY];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragX = -1; prevDragY = -1; // マウスのドラッグがないときはリセット<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateCamera()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラの位置と回転値をセット、カメラの位置は原点<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngle(<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::VGet(camera.x, camera.y, camera.z),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate * DX_PI_F / 180.0f, camera.HRotate * DX_PI_F / 180.0f, camera.TRotate * DX_PI_F / 180.0f);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // まとめてUpdateしたいときはUpdateを使い、個別にUIやKeyやMouseを別々にタイミングを取りながらUpdateしたいときは Updateは呼ばない<br>
        &nbsp;&nbsp;&nbsp; void Update()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateKeyInput();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateMouseInput();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateCamera();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void Draw()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 原点からx軸(R:赤) y軸(G:緑) z軸(B:青)をライン表示する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(1.0f * 5.0f, 0.0f * 5.0f, 0.0f * 5.0f), GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(0.0f * 5.0f, 1.0f * 5.0f, 0.0f * 5.0f), GetColor(0, 255, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(0.0f * 5.0f, 0.0f * 5.0f, 1.0f * 5.0f), GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 画面に回転量を描画<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, DxLib::GetColor(255, 255, 255), "Cam(x:%f y:%f z:%f)", camera.x, camera.y, camera.z);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 20, DxLib::GetColor(255, 255, 255), "Rot(V:%f H:%f T:%f)", camera.VRotate, camera.HRotate, camera.TRotate);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        #endif<br>
      </p>
      <p>いかがでしょうか？カメラの視点の位置をキーボードのWSキーでカメラ視点を手前や奥に移動できるようになりましたか？<br>
        重要なのはGetCameraWorldDirByScreenXY関数でカメラ画面の視界(ワールド座標)の奥への方向のの単位ベクトル(ノルム)を求めることです<br>
        カメラの視点を移動するときはXYZ軸に対して+1するようなシンプルな計算ではうまくいきません<br>
        <span style="text-decoration: underline;">あてになるのは「カメラから見た奥行方向」の大きさ1の単位ベクトル</span>です。このベクトルを+1方向で奥、-1方向で手前にカメラを移動できます<br>
        GetCameraWorldDirByScreenXY関数の中では DxLib::ConvScreenPosToWorldPos を使って <br>
        スクリーンの2D(X,Y)からマウスの指すワールド座標3D(X,Y,Z)を求めています<br>
        <span style="text-decoration: underline;">スクリーンの2D位置からワールドの3D位置を変換する処理が</span>重 要なキーとなっているのでこの関数の存在は知っておきましょう<br>
      </p>
      <br>
      <br>
      <br>
    </a><a id="mozTocId0008" class="mozTocH1">
      <h1>キーボードのDAキーとEQキーでカメラ視点を左右や上 下に移動できるようにする</h1>
      <p><code>Editor.h</code>を変更してキーボードのDAキーとEQキーでカメラ視点を左右や上下に移動できるようにします。</p>
      <p class="source">#ifndef EDITOR_H_<br>
        #define EDITOR_H_<br>
        <br>
        #include "DxLib.h"<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        <br>
        #include "Singleton.h"<br>
        <br>
        class Editor : public Singleton&lt;Editor&gt;<br>
        {<br>
        public:<br>
        <br>
        &nbsp;&nbsp;&nbsp; struct Camera<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x = 0.f, y = 0.0f, z = -10.0f; // カメラはz軸マイナス位置からz軸プラス向きに原点を見る形で初期化される<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; inline Camera&amp; operator +=(VECTOR move) { x += move.x; y += move.y; z += move.z; return *this; } // VECTOR型を足したときはカメラを移動させる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float VRotate = 0.0f, HRotate = 0.0f, TRotate = 0.0f; // X軸 V,Y軸 H,Z軸 T まわりのカメラのオイラー回転の角度<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float wheelSpeed = 1.0f; // マウスのホイールと連動した際のカメラのスピード<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR GetCameraWorldDirByScreenXY(float screenX = (float)Input::MouseX, float screenY = (float)Input::MouseY)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // スクリーン(X,Y)からマウスの指すワールド座標(X,Y,Z)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR currentPos = <span

          style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet(screenX, screenY, 0.0f));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラからマウスの指す位置への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return DxLib::VNorm(DxLib::VGet(currentPos.x - x, currentPos.y - y, currentPos.z - z));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// スクリーンの2Dの start位置XY から end位置XY の方向 が ワールド座標3D においてどんなベクトルになるかを求める<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR GetWorldDirByCameraScreenXYDir(float screenStartX = (float)Input::MouseX, float screenStartY = (float)Input::MouseY,<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float screenEndX = (float)(Input::MouseX + 1), float screenEndY = (float)(Input::MouseY + 1))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // スクリーン(X,Y)からマウスの指すワールド座標(X,Y,Z)を求める<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR startPos = <span

            style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet(screenStartX, screenStartY, 0.0f));<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR endPos = <span

            style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet(screenEndX, screenEndY, 0.0f));<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ワールド座標におけるstartからendへ向かう方向のベクトルを求める<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return DxLib::VGet(endPos.x - startPos.x, endPos.y - startPos.y, endPos.z - startPos.z);<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</em><br>
        &nbsp;&nbsp;&nbsp; };<br>
        &nbsp;&nbsp;&nbsp; Camera camera;<br>
        <br>
        &nbsp;&nbsp;&nbsp; int prevDragX = -1, prevDragY = -1; // 前フレームでのスクリーン上でのドラッグXY位置<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; bool isInitFinished = false; // 一回でもInitされたかのフラグ<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; void Init()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isInitFinished) return; // 最初の一回だけInit処理をするためのフラグ<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitFinished = true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateKeyInput()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camXYZSpeed = 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向のの単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR camNorm = camera.GetCameraWorldDirByScreenXY((float)Input::MouseX, (float)Input::MouseY);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // キーボードのWSキーでカメラ視点を手前や奥に移動できるようにする<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_W))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(camNorm.x * camXYZSpeed, camNorm.y * camXYZSpeed, camNorm.z * camXYZSpeed);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_S))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(-camNorm.x * camXYZSpeed, -camNorm.y * camXYZSpeed, -camNorm.z * camXYZSpeed);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// スクリーンの 2D上のX方向 が ワールド座標 3D ではどんな方向ベクトルになるかを求める<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR xCamDir = VNorm(camera.GetWorldDirByCameraScreenXYDir((float)Input::MouseX, (float)Input::MouseY, (float)(Input::MouseX + 10), (float)Input::MouseY));<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_D))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(xCamDir.x * camXYZSpeed, xCamDir.y * camXYZSpeed, xCamDir.z * camXYZSpeed);<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_A))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(-xCamDir.x * camXYZSpeed, -xCamDir.y * camXYZSpeed, -xCamDir.z * camXYZSpeed);</em><br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// スクリーンの 2D上のY方向 が ワールド座標 3D ではどんな方向ベクトルになるかを求める<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR yCamDir = VNorm(camera.GetWorldDirByCameraScreenXYDir((float)Input::MouseX, (float)Input::MouseY, (float)Input::MouseX, (float)(Input::MouseY + 10)));<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_Q))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(yCamDir.x * camXYZSpeed, yCamDir.y * camXYZSpeed, yCamDir.z * camXYZSpeed);<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_E))<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera += VGet(-yCamDir.x * camXYZSpeed, -yCamDir.y * camXYZSpeed, -yCamDir.z * camXYZSpeed);</em><br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_V))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_B))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_H))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_J))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_T))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate -= 1.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_Y))<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate += 1.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateMouseInput()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!SubScreen::isMouseOvered) // マウスオーバーしているSubscreenがないとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::MouseWheel != 0.0f) // マウスのホイールをグリグリしたとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界の奥への方向の単位ベクトル(ノルム)を求める<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR camNorm = camera.<span

          style="font-weight: bold;">GetCameraWorldDirByScreenXY</span>((float)Input::MouseX, (float)Input::MouseY);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camSpeed = camera.wheelSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.wheelSpeed *= (camera.wheelSpeed &lt; 100.0f) ? 1.5f : 1.0f; // カメラのズーム速度を加速する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 求めた単位ベクトル×カメラのスピードぶんカメラの位置を移動<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.x += camNorm.x * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.y += camNorm.y * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.z += camNorm.z * Input::MouseWheel * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (camera.wheelSpeed &gt; 0.1f) camera.wheelSpeed *= 0.9f; // カメラのズーム速度を減衰する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else camera.wheelSpeed = 0.1f; // カメラのズーム速度を減衰して最小0.1にすることで繊細なズーム調整もできるようにする<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ((Input::Click[Mouse::DragL] || Input::Click[Mouse::DragR]) &amp;&amp; Screen::IsInsideWindow())<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != -1 &amp;&amp; prevDragY != -1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 前の位置prevと現在の位置に移動があれば、その差ぶんだけ+=することでドラッグ移動を実現<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragL]) // マウス左クリック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragLX] || prevDragY != Input::Click[Mouse::DragLY])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // マウスポインタがある画面上の座標に該当する３Ｄ空間上の座標を取得 https://dxlib.xsrv.jp/function/dxfunc_3d_camera.html#R12N11<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float positionRatio = 0.9f;// 奥行の位置 Near 面 0.0f ～ 1.0f Far 面<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR start = <span

          style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet((float)prevDragX, (float)prevDragY, positionRatio));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR end = <span

          style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet((float)Input::Click[Mouse::DragLX], (float)Input::Click[Mouse::DragLY], positionRatio));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camSpeed = 400; // ドラッグに対するカメラの移動速度<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.x -= (end.x - start.x) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.y -= (end.y - start.y) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.z -= (end.z - start.z) * camSpeed;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragR]) // マウス右クリック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // カメラの角度を変更<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX != Input::Click[Mouse::DragRX])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate += (float)(Input::Click[Mouse::DragRX] - prevDragX);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragY != Input::Click[Mouse::DragRY])<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate += (float)(Input::Click[Mouse::DragRY] - prevDragY);<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ±360度を超えたら割り算の余りを設定して 例.365度 → 5度に戻してやる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (camera.HRotate &gt; 360.0f || camera.HRotate &lt; -360.0f) camera.HRotate = std::fmodf(camera.HRotate, 360.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (camera.VRotate &gt; 360.0f || camera.VRotate &lt; -360.0f) camera.VRotate = std::fmodf(camera.VRotate, 360.0f);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragX = (Input::Click[Mouse::DragL]) ? Input::Click[Mouse::DragLX] : Input::Click[Mouse::DragRX];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragY = (Input::Click[Mouse::DragL]) ? Input::Click[Mouse::DragLY] : Input::Click[Mouse::DragRY];<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prevDragX = -1; prevDragY = -1; // マウスのドラッグがないときはリセット<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void UpdateCamera()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラの位置と回転値をセット、カメラの位置は原点<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngle(<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::VGet(camera.x, camera.y, camera.z),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate * DX_PI_F / 180.0f, camera.HRotate * DX_PI_F / 180.0f, camera.TRotate * DX_PI_F / 180.0f);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // まとめてUpdateしたいときはUpdateを使い、個別にUIやKeyやMouseを別々にタイミングを取りながらUpdateしたいときは Updateは呼ばない<br>
        &nbsp;&nbsp;&nbsp; void Update()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateKeyInput();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateMouseInput();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateCamera();<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void Draw()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 原点からx軸(R:赤) y軸(G:緑) z軸(B:青)をライン表示する<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(1.0f * 5.0f, 0.0f * 5.0f, 0.0f * 5.0f), GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(0.0f * 5.0f, 1.0f * 5.0f, 0.0f * 5.0f), GetColor(0, 255, 0));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0), VGet(0.0f * 5.0f, 0.0f * 5.0f, 1.0f * 5.0f), GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 画面に回転量を描画<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0, DxLib::GetColor(255, 255, 255), "Cam(x:%f y:%f z:%f)", camera.x, camera.y, camera.z);<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 20, DxLib::GetColor(255, 255, 255), "Rot(V:%f H:%f T:%f)", camera.VRotate, camera.HRotate, camera.TRotate);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        #endif<br>
      </p>
      <p>いかがでしょう?キーボードのDAキーとEQキーでカメラ視点を左 右や上下に移動できるようになりましたか?<br>
        カメラの上下左右方向でも重要なのは 2Dのスクリーン から 3Dのワールド座標 での方向のベクトルを求めることです<br>
        GetWorldDirByCameraScreenXYDir関数の中でもDxLib::ConvScreenPosToWorldPos関数を使って 2D → 3D座標 への変換を行っています<br>
        カメラの左右移動方向は<span style="text-decoration: underline;">「スクリーンの枠」の左右方向</span>、 カメラの上下移動方向は<span

          style="text-decoration: underline;">「スクリーンの枠」の上下方向</span>と 平行になるベクトルです<br>
      </p>
      <br>
      <br>
      <br>
    </a><a id="mozTocId0009" class="mozTocH1">
      <h1>Unityのアセットストアからとってきたテクスチャ1 枚のシンプルな3DモデルをDXのモデルビューアで.mv1形式に変換して表示させてみる</h1>
    </a>
    <p><a id="mozTocId0009" class="mozTocH1">複雑な3Dモデルだとテクスチャリンクつけなおしやボーンが崩れた りして大変なので下記リンクのシンプルな無料3DモデルをUnityにインポートします<br>
      </a><a href="https://assetstore.unity.com/packages/3d/characters/humanoids/fantasy/devil-animated-character-60777?locale=ja-JP&amp;srsltid=AfmBOor53ggeWTlrD6CMx0iQtZj3gZrHiPBdYgzpG2Ljhm4FIBT912Q3">https://assetstore.unity.com/packages/3d/characters/humanoids/fantasy/devil-animated-character-60777?locale=ja-JP&amp;srsltid=AfmBOor53ggeWTlrD6CMx0iQtZj3gZrHiPBdYgzpG2Ljhm4FIBT912Q3</a> <br>
    </p>
    <p>Unityの[Window]→[Package Manager]を開いて、取得したデビルのキャラのアセットを[Download]<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset1.png" alt=""><br>
    </p>
    <p><br>
      Unityへ[Import]ボタンでインポートする<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset2.png" alt=""><br>
    </p>
    <p><br>
      Assetフォルダ→Devilフォルダ→Animationsフォルダの「devil@fly」を[右クリック]→ [Show in Explorer]で3DのモデルのあるフォルダをWindowsで開く<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset3.png" alt=""><br>
    </p>
    <p><br>
      Unityのアセットフォルダの3DモデルをコピーしてDXのプロジェクトのImgaeフォルダへコピペする<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset4.png" alt=""><br>
    </p>
    <p><br>
      DXライブラリをインストールしたフォルダの中のToolフォルダにDXモデルビューアがあるので起動する<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset5.png" alt=""><br>
    </p>
    <p><br>
      [マテリアル]→[lambert1(ランバート反射マテリアル)]→[拡散光(ディフーズ反射)]→[ディフーズマッ プ]のテクスチャリンクの[参照]先にファイルがないので<br>
      3Dモデルが灰色で表示されてしまう<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset6.png" alt=""><br>
    </p>
    <p><br>
      Unityの[Assetsフォルダ]→[Devilフォルダ]→[Textureフォルダ]のテクスチャを[右クリッ ク]→[Show in Explorer]でWindowsのフォルダ上で画像ファイルを見つける<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset7.png" alt=""><br>
    </p>
    <p><br>
      DXのプロジェクトのImageフォルダへテクスチャ画像をコピペする<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset8.png" alt=""><br>
    </p>
    <p><br>
      DXのモデルビューアで3Dモデルを開きなおすか、<br>
      [マテリアル]→[lambert1]→[拡散光]→[ディフーズマップ]のテクスチャリンクの[参照]を押してコピペし た画像に参照を貼りなおすと<br>
      3Dモデル表面にテクスチャ画像が反映される<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset9.png" alt=""><br>
      <br>
    </p>
    <p>[ファイル]→[名前を付けて保存]でDXのプロジェクトのImageフォルダに.mv1形式(DXで扱える3Dモデル形式)で保存する<br>
    </p>
    <p> <img src="image/mv1_from_unity_asset10.png" alt=""><br>
    </p>
    <p><br>
    </p>
    <p><code>main.cpp</code>のコードに.mv1形式の3Dモデルをロードして、描画表示させるプログラムを追加してみましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
      #include "Input.h"<br>
      #include "Screen.h"<br>
      #include "Ply.h"<br>
      <br>
      #include "Editor.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;&nbsp; <em>int devil3DModel = DxLib::MV1LoadModel("Image/devil@fly.mv1"); // 3Dモデルをmv1形式で読込み</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
      &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
      &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
      &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
      &nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply", Data); // .plyデータをロード 軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう<br>
      <br>
      &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
      &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
      &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
      <br>
      &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
      &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
      &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
      &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      <br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
      &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
      &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f; keyControlXYZ.z = 0;<br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
      <br>
      &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens(); // スクリーンの位置やドラッグによる移動を更新する<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f, 1.0f, 1.0f); // 拡大縮小スケール<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0<em></em><em></em>, 100, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 半透明のスクリーンも描ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height, GetColor(0, 255, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); // サブのスクリーンを全部描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); // エディタのDraw処理<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょうか?MV1形式の3Dモデルがちゃんと表示されたでしょうか?<br>
    Unityのアセットは基本100倍のスケールで制作されているのでマウスをぐりぐりさせてズームアウトさせないとデカすぎて見えないはずです。<br>
    こういうトラブルを回避するために事前にエディタの直感的な操作を準備しておいたのです。<br>
    <p> <img src="image/mv1_from_unity_asset11.png" alt=""><br>
      <br>
    </p>
    <p><span style="font-weight: bold;">[練習問題]</span> .plyのときに DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] <br>
      したのと同じように.mv1形式の3Dモデルにもスケールや回転や移動の行列を反映させてみよ<br>
    </p>
    <br>
    <br>
    <br>
    <a id="mozTocId0010" class="mozTocH1">
      <h1>MV1形式の3Dモデルをアニメーション描画する</h1>
      <br>
      <p><code>main.cpp</code>のコードに.mv1形式の3Dモデルにデフォルトでアニメがついていたら、そのアニメをモデルにアタッチしてアニメーションさせるプログラムを追加してみましょう。</p>
    </a>
    <p class="source"><a id="mozTocId0010" class="mozTocH1">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        <br>
        #include "Editor.h"<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; int devil3DModel = DxLib::MV1LoadModel("Image/devil@fly.mv1"); // 3Dモデルをmv1形式で読込み<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>float animTime = 0.0f; // アニメの現在時刻<br>
          &nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
          &nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
          &nbsp;&nbsp;&nbsp; int DefalutAnimNum = DxLib::<span style="font-weight: bold;">MV1GetAnimNum</span>(devil3DModel); // 3Dモデル内のアニメの数<br>
          &nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, int&gt; animNameToIndex; // アニメ名からアニメのインデックス番号への辞書<br>
          &nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, float&gt; animNameToTotalTime; // アニメ名からアニメの総再生時間への辞書<br>
          &nbsp;&nbsp;&nbsp; for (int index = 0; index &lt; DefalutAnimNum; ++index)<br>
          &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // アニメの数ぶん順番にアタッチを設定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* animName = DxLib::MV1GetAnimName(devil3DModel, index); // アニメーション名を取得<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アニメ名からインデックス番号を得るために辞書に登録しておく<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">animNameToIndex</span>[animName] = DxLib::<span

            style="font-weight: bold;">MV1AttachAnim</span>(devil3DModel, index); // アニメをアタッチして、その番号を辞書に登録<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">animNameToTotalTime</span>[animName] = DxLib::<span

            style="font-weight: bold;">MV1GetAttachAnimTotalTime</span>(devil3DModel, index); // アニメをループさせるためにアニメの総再生時間を辞書に記録しておく<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        &nbsp;&nbsp;&nbsp; </a><a id="mozTocId0009" class="mozTocH1"><br>
        &nbsp;&nbsp;&nbsp; int texImage = -1;<br>
        &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
        &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
        &nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply", Data); // .plyデータをロード 軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう<br>
        <br>
        &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
        <br>
        &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
        &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
        &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
        <br>
        &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
        &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
        &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
        &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        <br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
        &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
        <br>
        &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens(); // スクリーンの位置やドラッグによる移動を更新する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth; float height = imgHeight; // テクスチャ画僧のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f, 1.0f, 1.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0<em></em><em></em>, 100, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>std::string <span

            style="font-weight: bold;">animName</span> = "Take 001"; // アニメ名:DXモデルビューアでアニメ名をきちんと確認したほうがよい↓<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(animNameToTotalTime.count(animName) &gt; 0 &amp;&amp; "指定されたアニメ名のアニメはMV1に付属していませんでした");<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime += animStepTime * animSpeed; // 1.0×2倍 なら2倍速でアニメ時刻が進む<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animTime &gt; <span

            style="font-weight: bold;">animNameToTotalTime</span>[<span

            style="font-weight: bold;">animName</span>])<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime = 0.0f; // 0秒目へとアニメをループさせる<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 再生時間をセットする<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::<span style="font-weight: bold;">MV1SetAttachAnimTime</span>(devil3DModel, <span

            style="font-weight: bold;">animNameToIndex</span>[<span style="font-weight: bold;">animName</span>], animTime);</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 半透明のスクリーンも描ける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); // サブのスクリーンを全部描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); // エディタのDraw処理<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</a></p>
    <br>
    アニメ名をDXモデルビューアーの[アニメ]から確認<br>
    <p> <img src="image/mv1_from_unity_asset12.png" alt=""><br>
    </p>
    <p><br>
      アニメの総再生時間とアニメのインデックス番号はここ<br>
    </p>
    <p><img src="image/mv1_from_unity_asset13.png" alt=""><br>
    </p>
    <p>いかがですか?3Dキャラがアニメーションしたでしょうか?<br>
      アニメーションの時刻を進めるプログラムを書くには<br>
      アニメーション番号(No.)かアニメーション名(例.Take 001)を使う必要があるのでDXモデルビューアーで確認して間違わないようにしましょう<br>
    </p>
    <br>
    <a id="mozTocId0011" class="mozTocH1">
      <h1>複数の3DモデルやアニメをResourceクラスで2 重ロード しないよう読み込んで複数アニメを切替えする</h1>
      <p><code>Resource.hを新規作成</code>してResourceクラスで画像やテクスチャや3Dモデルなどのリソースを 2重にロー ドしないよう読み込んだときにstd::unordered_mapのfiles辞書に登録する機能を準備する。</p>
      <p class="source">#ifndef RESOURCE_H_<br>
        #define RESOURCE_H_<br>
        <br>
        #include "DxLib.h"<br>
        <br>
        #include &lt;vector&gt;<br>
        #include &lt;string&gt;<br>
        #include &lt;memory&gt; // 共有ポインタstd::shared_ptrを使う<br>
        #include &lt;unordered_map&gt; // 高速辞書&lt;ファイルパス, 共有リソース&gt;で一度読み込んだファイルはかぶらないように(2重ロード防止)する<br>
        #include &lt;assert.h&gt;<br>
        <br>
        struct Resource : public std::enable_shared_from_this&lt;Resource&gt;<br>
        {&nbsp;&nbsp;&nbsp; // [std::shared_ptrでthisポインタをつかうためには]↑ https://www.kabuku.co.jp/developers/cpp_enable_shared_from_this<br>
        &nbsp;&nbsp;&nbsp; enum class Type { None, MV1, Ply, Texture, Sound, SE };<br>
        &nbsp;&nbsp;&nbsp; Type m_type{ Type::None }; // データの種類<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; m_handles; // ロードしたリソースのハンドル番号<br>
        &nbsp;&nbsp;&nbsp; inline operator int() { return (m_handles.size() &gt; 0) ? m_handles[0] : -1; } // intでキャストした場合には先頭の0個目のハンドル番号を返す<br>
        &nbsp;&nbsp;&nbsp; std::string m_FilePath{ "" }; // ロードしたリソースのファイルパス<br>
        &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;std::string, std::shared_ptr&lt;Resource&gt;&gt; files; // ロード済みのリソースファイルを保管する辞書<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual ~Resource() {}<br>
        <br>
        protected: // コンストラクタ経由の生成経路を隠蔽してMakeShared関数経由でしか生成できないようにする<br>
        &nbsp;&nbsp;&nbsp; Resource(const std::string&amp; filePath = "", Type type = Type::None) : m_FilePath{ filePath }, m_type{ type } {}<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; //[protectedなコンストラクタでもstd::make_sharedで呼ぶテク] https://gintenlabo.hatenablog.com/entry/20131211/1386771626<br>
        &nbsp;&nbsp;&nbsp; template&lt;typename ResourceT&gt;<br>
        &nbsp;&nbsp;&nbsp; struct ProtectedCall : public ResourceT<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; template&lt;class... ArgsT&gt; // std::make_sharedはprotectedな継承クラスは呼べないのでそれを回避するテクニック<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; explicit ProtectedCall(ArgsT&amp;&amp;... args)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : ResourceT(std::forward&lt;ArgsT&gt;(args)...) { } //std::forwardで複数引数を完全転送で引き渡し https://proc-cpuinfo.fixstars.com/2016/03/c-html/<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタをprotected:にしてあるのでこのMakeShared関数経由でしかResourceの新規生成はできないように縛ってある<br>
        &nbsp;&nbsp;&nbsp; template&lt;typename ResourceT, typename... ArgsT&gt;<br>
        &nbsp;&nbsp;&nbsp; static std::shared_ptr&lt;ResourceT&gt; MakeShared(const std::string&amp; filePath = "", ArgsT... args)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (files.find(filePath) == files.end()) // 辞書に未登録のファイルの場合は<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; files[filePath] = std::make_shared&lt;ProtectedCall&lt;ResourceT&gt;&gt;(filePath, std::forward&lt;ArgsT&gt;(args)...); // 辞書へ登録<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return std::dynamic_pointer_cast&lt;ResourceT&gt;(files[filePath]); //[共有ポインタの派生先へのダウンキャスト] https://cdecrement.blog.fc2.com/blog-entry-15.html<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; template&lt;typename ResourceT&gt; // 指定されたfilepathのデータをResourceT型の共有ポインタとして返す<br>
        &nbsp;&nbsp;&nbsp; static std::shared_ptr&lt;ResourceT&gt; at(const std::string&amp; filepath)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(files.count(filepath) &gt; 0 &amp;&amp; "指定されたファイル名のファイルは未生成です。MakeShared関数で生成してからアクセスしてください");<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return std::dynamic_pointer_cast&lt;ResourceT&gt;(files.at(filepath)); //[共有ポインタの派生先へのダウンキャスト] https://komorinfo.com/blog/cast-of-smart-pointers/ <br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; static size_t count(const std::string&amp; filepath) { return files.count(filepath); }<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual int Load(const std::string&amp; filePath = "") = 0; //[ = 0 純粋仮想関数] ロード関数をoverrideして色んな種類のファイルのロードを実装する<br>
        };<br>
        <br>
        struct Texture : public Resource<br>
        {<br>
        protected: // ファクトリーパターンでコンストラクタ経由の生成経路をprotected隠蔽(ResourceクラスのMakeShared関数経由でしか新規生成は できない)<br>
        &nbsp;&nbsp;&nbsp; Texture(const std::string&amp; filePath = "", int m_XNum = 1, int m_YNum = 1, int m_XSize = 1, int m_YSize = 1)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : Resource(filePath, Type::Texture), m_XNum{ m_XNum }, m_YNum{ m_YNum }, m_XSize{ m_XSize }, m_YSize{ m_YSize } {}<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; int m_XNum = 1, m_YNum = 1, m_XSize = 1, m_YSize = 1; // XNum,YNumはx,y方向の分割画像の数 XSize,YSizeは画像の横×縦のサイズ(pixel数)<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline int operator[](std::size_t index) const { //constは変更できないから添え字[]の 読み取り専用処理<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return m_handles[index]; // 読み取り専用(returnの型が &amp;参照ついてないので書き換え不可能)<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // すでにロードしてあるハンドルをDeleteGraphで破棄する<br>
        &nbsp;&nbsp;&nbsp; virtual ~Texture() { DeleteGraph(); }<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual int DeleteGraph() // すでにロードしてあるハンドルをDxLib::DeleteGraphで破棄する<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int result = 0;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int handle : m_handles)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; result = (result == -1) ? -1 : DxLib::DeleteGraph(handle); // 一つでもDeleteに失敗したら-1<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::vector&lt;int&gt;().swap(m_handles); // ハンドルの配列を完全に消去<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return result;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual int Load(const std::string&amp; filePath = "") override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (filePath == "" &amp;&amp; m_FilePath == "") return -1;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (files.count(filePath) &gt; 0 &amp;&amp; m_handles.size() &gt; 0) return files[filePath]-&gt;m_handles[0]; // すでに辞書にロード済みハンドルがあった<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (filePath != "" &amp;&amp; m_FilePath == "") m_FilePath = filePath; // 読み出しファイルパスを記録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (m_XNum &gt; 1 || m_YNum &gt; 1) return LoadDivGraph(m_FilePath, m_XNum, m_YNum, m_XSize, m_YSize); // 分割画像としてロード<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int loadHandle = DxLib::LoadGraph(m_FilePath.c_str()); // ファイルをロードする<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(loadHandle != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (loadHandle == -1) return -1; // ロード失敗<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_handles.emplace_back(loadHandle); // ロード成功ならハンドル番号を記録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // [std::shared_ptrへthis↓ポインタをつかうためには] https://cpprefjp.github.io/reference/memory/enable_shared_from_this.html<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; files.emplace(m_FilePath, shared_from_this()); // 辞書へ登録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::GetGraphSize(loadHandle, &amp;m_XSize, &amp;m_YSize); // 横XSize×縦YSizeを得る<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return loadHandle;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual int LoadDivGraph(const std::string&amp; filePath = "", int XNum = -1, int YNum = -1, int XSize = -1, int YSize = -1)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (files.count(filePath) &gt; 0 &amp;&amp; m_handles.size() &gt; 0) return files[filePath]-&gt;m_handles[0]; // すでに辞書にロード済みのファイルのとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (filePath == "") return -1;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (filePath == "" &amp;&amp; m_FilePath == "") return -1;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (filePath != "" &amp;&amp; m_FilePath == "") m_FilePath = filePath; // 読み出しファイルパスを記録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (XNum &gt; 0) m_XNum = XNum; // 数値を設定<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (YNum &gt; 0) m_YNum = YNum;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (XSize &gt; 0) m_XSize = XSize;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (YSize &gt; 0) m_YSize = YSize;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_handles.resize(m_XNum * m_YNum); // XNum×YNum個ぶんの配列を事前確保しておく<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int result = DxLib::LoadDivGraph(m_FilePath.c_str(), m_XNum * m_YNum, m_XNum, m_YNum, m_XSize, m_YSize, m_handles.data());<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(result != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int handle : m_handles) assert(handle != -1); // 画像読込失敗、たてやよこのサイズの指定がおかしいのかも<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // [std::shared_ptrへthis↓ポインタをつかうためには] https://cpprefjp.github.io/reference/memory/enable_shared_from_this.html<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; files.emplace(m_FilePath, shared_from_this()); // 辞書へ登録<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return m_handles[0]; // とりあえずは先頭配列を返す<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        #endif<br>
      </p>
      <br>
      <p><code>DataMV1.hを新規作成</code>してResourceクラスを継承して3Dモデルのロードやアニメをアタッチして管理する機能を追加する。</p>
      <p class="source">#ifndef DATAMV1_H_<br>
        #define DATAMV1_H_<br>
        <br>
        #include "DxLib.h"<br>
        <br>
        #include "Resource.h"<br>
        <br>
        #include &lt;unordered_map&gt; // 高速辞書配列<br>
        <br>
        struct DataMV1 : public Resource<br>
        {<br>
        protected: // ファクトリーパターンでコンストラクタ経由の生成経路をprotected隠蔽(ResourceクラスのMakeShared関数経由でしか新規生成は できない)<br>
        &nbsp;&nbsp;&nbsp; DataMV1(std::string filePath = "")<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Resource(filePath, Type::MV1) {}<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; int m_DefalutAnimNum = -1; // 3Dモデル内のデフォルトのアニメの数<br>
        &nbsp;&nbsp;&nbsp; int m_AttachAnimNum = 0; // この3Dモデルにアタッチされたアニメの数(デフォルトのアニメに加えて追加アタッチされたアニメの数も含む)<br>
        <br>
        &nbsp;&nbsp;&nbsp; struct AnimInfo // アニメに関する情報<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int index = -1; // アニメのインデックス番号<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float endTime = 0.0f; // アニメの終了時刻(総再生時間):超えるとループかストップさせる<br>
        &nbsp;&nbsp;&nbsp; };<br>
        &nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, AnimInfo&gt; m_AnimInfo; // 「ファイルパス + ":" + アニメ名」 から アニメの情報への辞書<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ["devil@fly.fbx:Take 00"]のように m_FilePath + ":" + animName の形式にして<br>
        &nbsp;&nbsp;&nbsp; //&nbsp; ファイル1とファイル2で両方"Take 00"というアニメ名を使っていたときに辞書がかぶっちゃうことを予防する必要がある<br>
        &nbsp;&nbsp;&nbsp; AnimInfo&amp; operator [] (const std::string&amp; animPathName)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_AnimInfo.at(animPathName);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; size_t count(const std::string&amp; animPathName) { return m_AnimInfo.count(animPathName); }<br>
        <br>
        &nbsp;&nbsp;&nbsp; bool isInitialized = false; //[継承2重ロード対策]ロード済みになったらtrueに falseのときにLoadするとリロード<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual ~DataMV1()<br>
        &nbsp;&nbsp;&nbsp; {// 仮想デストラクタ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear();// データのお掃除<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual int DeleteModels() // すでにロードしてあるハンドルをDxLib::MV1DeleteModelで破棄する<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int result = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int handle : m_handles)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = (result == -1) ? -1 : DxLib::MV1DeleteModel(handle); // 一つでもDeleteに失敗したら-1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt;().swap(m_handles); // ハンドルの配列を完全に消去<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, AnimInfo&gt;().swap(m_AnimInfo); // アニメの辞書をクリア<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // データをクリアしてメモリを節約する<br>
        &nbsp;&nbsp;&nbsp; virtual void clear()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteModels(); // すでにロードしてあるハンドルをDxLib::MV1DeleteModelで破棄する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = false; //ロード済みフラグをOFF<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ３Ｄアニメのアタッチ、DXライブラリの機能をラッピング<br>
        &nbsp;&nbsp;&nbsp; // https://dxlib.xsrv.jp/function/dxfunc_3d_model_1.html#R4N1<br>
        &nbsp;&nbsp;&nbsp; virtual void AttachAnim(DataMV1&amp; otherMV1Anim)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // モデルに含まれるアニメーションの数を取得する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int Num = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_handles[0] == otherMV1Anim.m_handles[0])<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Num = m_AttachAnimNum = DxLib::MV1GetAnimNum(m_handles[0]); // 3Dモデル内のアニメ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // 追加の別mv1ファイルのアニメのアタッチのとき↓は Num = 追加側のアニメ数, m_AttachAnimNum = Num + m_AttachAnimNumを格納<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_AttachAnimNum += (Num = DxLib::MV1GetAnimNum(otherMV1Anim.m_handles[0])); // アニメの追加アタッチ数だけ総アニメ数を加算 <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; Num; i++)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // アニメの数ぶん順番にアタッチを設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* animName = DxLib::MV1GetAnimName(otherMV1Anim.m_handles[0], i); // アニメーション名を取得<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int animSrcHandle = (m_handles[0] == otherMV1Anim.m_handles[0]) ? -1 : otherMV1Anim.m_handles[0]; // 3Dモデル内アニメ(-1) or 追加アタッチアニメ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int attachedIndex = m_AnimInfo[otherMV1Anim.m_FilePath + ":" + animName].index = DxLib::MV1AttachAnim(m_handles[0], i, animSrcHandle, FALSE); // アタッチとその番号を辞書に登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //アニメ総時間の取得と登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (attachedIndex != -1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_AnimInfo[otherMV1Anim.m_FilePath + ":" + animName].endTime = DxLib::MV1GetAttachAnimTotalTime(m_handles[0], attachedIndex);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_AnimInfo[otherMV1Anim.m_FilePath + ":" + animName].endTime = 0.0f; //アニメアタッチ失敗時はアニメ進行を0.0に<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ファイルの読み込み<br>
        &nbsp;&nbsp;&nbsp; virtual int Load(const std::string&amp; filePath = "") override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (filePath == "" &amp;&amp; m_FilePath == "") return -1; //ファイル名がない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (files.count(filePath) &gt; 0 &amp;&amp; isInitialized) return 0; // すでに辞書にロード済みファイルがあった<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (filePath != "" &amp;&amp; m_FilePath == "") m_FilePath = filePath; // 読み出しファイルパスを記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear(); //データを一旦クリア<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int loadHandle = DxLib::MV1LoadModel(m_FilePath.c_str()); // 3Dモデルモデル読込み<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (loadHandle == -1) assert("3Dモデルファイル見つからず読込み失敗！" == "");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (loadHandle == -1) return -1; // ロード失敗<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_handles.emplace_back(loadHandle); // ロード成功ならハンドル番号を記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [std::shared_ptrへthis↓ポインタをつかうためには] https://cpprefjp.github.io/reference/memory/enable_shared_from_this.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; files.emplace(m_FilePath, shared_from_this()); // 辞書へ登録<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_DefalutAnimNum = DxLib::MV1GetAnimNum(m_handles[0]); // 3Dモデル内にデフォルトでついていたアニメの数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int index = 0; index &lt; m_DefalutAnimNum; ++index)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // アニメの数ぶん順番にアタッチを設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* animName = DxLib::MV1GetAnimName(m_handles[0], index); // アニメーション名を取得<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アニメ名からアニメのインデックス番号を得るために辞書に登録しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アニメのアタッチする前の大元のファイルパス + アニメ名"例.Take 00"など を組み合わせないと<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ファイル1とファイル2で両方"Take 00"というアニメ名を使っていたときに辞書がかぶっちゃって唯一性が保てない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_AnimInfo[m_FilePath + ":" + animName].index = DxLib::MV1AttachAnim(m_handles[0], index); // アニメをアタッチして、その番号を辞書に登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アニメをループさせるためにアニメの総再生時間を辞書に記録しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_AnimInfo[m_FilePath + ":" + animName].endTime = DxLib::MV1GetAttachAnimTotalTime(m_handles[0], index);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++m_AttachAnimNum; // アニメの数を +1 カウントする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = true;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        #endif<br>
      </p>
      <br>
      devilのデータをMV1形式に変換するにあたって、Blenderを通してリグ付けをしたいのだが、<br>
      Blenderで読み込めないバージョンのFBXとして書き出されたFBXモデル(devil)を、一旦UnityのFBXエクスポータで保存しなおして<br>
      FBXの保存バージョンを変えてしまうことでBlenderで読み込めるようにします。<br>
      <p><img src="image/mv1_from_unity_fbx_exporter1.png" alt="" style=""><br>
      </p>
      <p><br>
        UnityにFBXエクスポーターをインストールすると、<br>
        変換したいモデルをアセットのフォルダから選択した状態で[GameObject]→[Export To FBX]ができるようになっているので<br>
        クリックして出てきたウィンドウの[Export]ボタンをクリックします<br>
      </p>
      <p><img src="image/mv1_from_unity_fbx_exporter2.png" alt="" style=""><br>
      </p>
      <p><br>
        デフォルトの保存先はUnityのアセットフォルダと違って<br>
        /ユーザー の /My projectフォルダ の中の /Assetsフォルダ の中<br>
        になっていて混乱しやすいのでUnityウィンドウの左下に表示された Successfully exported: C:○○○ ～ を注意深く見て、<br>
        エクスポータから出力されたファイルの保存先をたどって、出力されたFBXファイルをDXのImageフォルダにコピーしておきます<br>
      </p>
      <p><img src="image/mv1_from_unity_fbx_exporter3.png" alt="" style=""><br>
      </p>
      <p><br>
      </p>
    </a>
    <p><a id="mozTocId0011" class="mozTocH1">mixamoのサイトにアクセスして、<br>
      </a><a href="https://www.adobe.com/products/substance3d/plugins/mixamo-in-blender.html">https://www.adobe.com/products/substance3d/plugins/mixamo-in-blender.html</a> <br>
      Blender上でmixamoに対応したリグを3Dモデルに自動で入れてくれる「Mixamo Blender add-on」をダウンロードしておいてから、<br>
      Blenderを開いて、[編集]→[プリファレンス]から[アドオン]を開いて[インストール]ボタンを押して、mixamoのサイトからダ ウンロードしたファイルを開きます。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter4.png" alt="" style=""><br>
    </p>
    <p><br>
      [アドオンをインストール]すると[プリファレンス]から[アドオン]でMixamo Rigで検索すると<br>
      (Blenderのバージョンが3.0台であれば)「アニメーション:Mixamo Rig」にチェックが入れられるようになっています。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter5.png" alt="" style=""><br>
    </p>
    <p><br>
      [ファイル]から[インポート]で[FBX(.fbx)]からUnityのFBXエクスポータから書き出したdevilのFBXモデルを読み込んでから、<br>
      画面の右上のXYZ軸の横にある「 &lt; 」をクリックするとMixamoのタブを出すことができます。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter6.png" alt="" style=""><br>
    </p>
    <p><br>
      Mixamoのadd-onを使うと[Create Control Rig]を押せば自動でMixamo向けに対応したアニメのモーション用のリグを3Dモデルに埋め込んでくれます。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter7.png" alt="" style=""><br>
    </p>
    <p><br>
      Mixamo向けのリグを埋め込んでから[ファイル]→[エクスポート]→[FBX(.fbx)]から「Mixamo対応リグの入っ たFBXモデル」を保存書き出しします。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter8.png" alt="" style=""><br>
    </p>
    <p><br>
      保存するファイル名は他のファイルとごっちゃになって混乱しないように「devil@mixamo_addon.fbx」など区別しやすい名前を付けて保 存しておきます。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter9.png" alt="" style=""><br>
    </p>
    <p><br>
    </p>
    <p>mixamoのモーションをいれるサイトにアクセスして<br>
      <a href="https://www.mixamo.com/#/?page=1&amp;type=Motion%2CMotionPack">https://www.mixamo.com/#/?page=1&amp;type=Motion%2CMotionPack</a> <br>
      右端の[UPLOAD CHARACTER]ボタンを押して出てきたウィンドウに先ほど書き出した「devil@mixamo_addon.fbx」ファイルをドラッ グ&amp;ドロップします。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter10.png" alt="" style=""><br>
    </p>
    <p><br>
      Mixamo対応リグが入ったFBXモデルならばアップロードが成功してキャラクターが動いている画面が出てくるので[NEXT]を押します。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter11.png" alt="" style=""><br>
    </p>
    <p><br>
      左側から好きなモーションを選択して、[DOWNLOAD]ボタンを押すと好きなモーションを付けたキャラをダウンロードできるようになります。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter12.png" alt="" style=""><br>
    </p>
    <p><br>
      Format(ダウンロードするFBXのフォーマット)やSkin(3Dポリゴンの表面データも付属したデータか)などを設定して[DOWNLOAD]ボ タンでダウンロードします。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter13.png" alt="" style=""><br>
    </p>
    <p><br>
      どのモーションを付けたかわかりやすいようにdevil@kick.fbxなどのファイル名に変えてから、DXのImageフォルダへコピーします。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter14.png" alt="" style=""><br>
    </p>
    <p><br>
      DXのモデルビューワーから[ファイル]→[開く]で「devil@kick.fbx」を読み込んで、<br>
      [アニメーション]でmixamo.comのアニメがついていることを確認したら、<br>
      [ファイル]→[名前を付けて保存]から「devil@kick.mv1」というファイル名でMV1形式の3Dモデルを変換書き出しします。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter15.png" alt="" style=""><br>
    </p>
    <p><br>
      複数のモーションの切替を試すためにキックのモーションだけでなく、ジャンプなどのモーションも「devil@jump.mv1」としてDXのImage フォルダに書き出しておきます。<br>
    </p>
    <p><img src="image/mv1_from_unity_fbx_exporter16.png" alt="" style=""><br>
    </p>
    書き出したMV1形式の3Dモデルをプログラム上で切り替えられるようにしてキーボードの「0」キーと「1」キーで切り替えられるようにしていきましょ う。<br>
    <br>
    <p><code>main.cpp</code>のコードにMV1形式のファイルを複数ロードしてキーボードの 0 1 などの数字キーでアニメを切替えできる機能を追加する。</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
      #include "Input.h"<br>
      #include "Screen.h"<br>
      #include "Ply.h"<br>
      <em>#include "DataMV1.h"</em><br>
      <br>
      #include "Editor.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      &nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<u><br>
        &nbsp;&nbsp;&nbsp; int devil3DModel = DxLib::MV1LoadModel("Image/devil@fly.mv1"); // 3Dモデルをmv1形式で読込み<br>
        <br>
        &nbsp;&nbsp;&nbsp; float animTime = 0.0f; // アニメの現在時刻 &nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
        &nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
        &nbsp;&nbsp;&nbsp; int DefalutAnimNum = DxLib::MV1GetAnimNum(devil3DModel); // 3Dモデル内のアニメの数<br>
        &nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, int&gt; animNameToIndex; // アニメ名からアニメのインデックス番号への辞書<br>
        &nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, float&gt; animNameToTotalTime; // アニメ名からアニメの総再生時間への辞書<br>
        &nbsp;&nbsp;&nbsp; for (int index = 0; index &lt; DefalutAnimNum; ++index)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // アニメの数ぶん順番にアタッチを設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* animName = DxLib::MV1GetAnimName(devil3DModel, index); // アニメーション名を取得<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アニメ名からインデックス番号を得るために辞書に登録しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animNameToIndex[animName] = DxLib::MV1AttachAnim(devil3DModel, index); // アニメをアタッチして、その番号を辞書に登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animNameToTotalTime[animName] = DxLib::MV1GetAttachAnimTotalTime(devil3DModel, index); // アニメをループさせるためにアニメの総再生時間を辞書に記録しておく<br>
        &nbsp;&nbsp;&nbsp; }</u><br>
      &nbsp;&nbsp;&nbsp; <em>float animTime = 0.0f; // アニメの現在時刻<br>
        &nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
        &nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@kick.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;Load(); // 3Dモデルをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilAttackAnimData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@jump.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilAttackAnimData-&gt;Load(); // 3Dの追加アニメデータをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;AttachAnim(*pDevilAttackAnimData); // アニメを追加でflyのほうをベースとしたモデルにアタッチ<br>
        &nbsp;&nbsp;&nbsp; int <span style="font-weight: bold;">animeButton</span> = 0; // ボタンでアニメを切り替えられるようにする</em><br>
      <br>
      <u>&nbsp;&nbsp;&nbsp; int texImage = -1;<br>
        &nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        &nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
        &nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth, &amp;imgHeight); // テクスチャ画像のサイズを得る&nbsp;</u> <br>
      &nbsp;&nbsp;&nbsp; <em>std::shared_ptr&lt;Texture&gt; pTexImage = Resource::MakeShared&lt;Texture&gt;("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; pTexImage-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; assert((int)*pTexImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
      &nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply", Data); // .plyデータをロード 軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう<br>
      <br>
      &nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
      &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
      &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
      <br>
      &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
      &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
      &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
      &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
      &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
      <br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
      &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
      &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
      &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f; keyControlXYZ.z = 0;<br>
      &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
      <br>
      &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens(); // スクリーンの位置やドラッグによる移動を更新する<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// キーボードの 0 1 キーで3Dアニメを切り替えられるようにする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_0))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_1))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 1;</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width =&nbsp; <em>pTexImage-&gt;m_XSize</em>; float height =&nbsp; <em>pTexImage-&gt;m_YSize</em>; // テクスチャ画像のサイズ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f, 1.0f, 1.0f); // 拡大縮小スケール<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(), Index.data(), numIndex / 3, <em>(int)*pTexImage</em>, FALSE); // 三角形ポリゴンをたくさん描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0<em></em><em></em>, 100, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// ファイルのパス + ":" + アニメ名でアクセス</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string <em><span

          style="font-weight: bold;">animPathName</span></em> = <em>(<span

          style="font-weight: bold;">animeButton </span>== 0) ? "Image/devil@kick.mv1:mixamo.com" : "Image/devil@jump.mv1:mixamo.com";<br>
      </em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(<em>pDevilData-&gt;count(<span

          style="font-weight: bold;">animPathName</span>)</em> &gt; 0 &amp;&amp; "指定されたアニメ名のアニメはMV1に付属していませんでした");<em><br>
      </em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime += animStepTime * animSpeed; // 1.0×2倍 なら2倍速でアニメ時刻が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animTime &gt; (*pDevilData)[<em><span

          style="font-weight: bold;">animPathName</span></em>].endTime)<em><br>
      </em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime = 0.0f; // 0秒目へとアニメをループさせる<em><br>
        <br>
      </em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 再生時間をセットする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1SetAttachAnimTime(<em>(int)*pDevilData, (*pDevilData)[<span

          style="font-weight: bold;">animPathName</span>].index</em>, animTime);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 半透明のスクリーンも描ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height, GetColor(0, 255, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); // サブのスクリーンを全部描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); // エディタのDraw処理<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    いかがでしょう?キーボードの0キーと1キーでキャラのモーションを切替えできるようになりましたか?<br>
    0と1キー以外にもいろんなモーションを付けてみて切り替えられるか試してみましょう。<br>
    <br>
    <br>
    <br>
    <br>
    <a id="mozTocId0012" class="mozTocH1">
      <h1>.ply形式の3DモデルデータをResourceクラスを継承したDataPly構造体で読み込む</h1>
      <p><code>DataPly.hを新規作成</code>し てResourceクラスを継承して .ply形式の3Dモデルデータを読み込む機能を追加してmain.cppのコードをすっきりさせてしまいましょう。</p>
      <p class="source">#ifndef DATAPLY_H_<br>
        #define DATAPLY_H_<br>
        <br>
        #include "Dxlib.h"<br>
        <br>
        #include &lt;memory&gt;<br>
        #include &lt;vector&gt;<br>
        #include &lt;string&gt;<br>
        <br>
        #include &lt;assert.h&gt; // 読込み失敗表示用<br>
        <br>
        #include "Ply.h"<br>
        <br>
        #include "Resource.h"<br>
        <br>
        // .ply形式の3Dモデルデータを読み込む構造体<br>
        struct DataPly : public Resource<br>
        {<br>
        protected: // ファクトリーパターンでコンストラクタ経由の生成経路をprotected隠蔽(ResourceクラスのMakeShared関数経由でしか新規生成は できない)<br>
        &nbsp;&nbsp;&nbsp; DataPly(std::string filePath = "", bool isGPUBufferRendering = false)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Resource(filePath, Type::Ply), isGPUBufferRendering{ isGPUBufferRendering } {}<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; size_t numIndex = 0;<br>
        &nbsp;&nbsp;&nbsp; int VertexBufHandle{ -1 }; // GPU側の頂点バッファへのハンドル番号<br>
        &nbsp;&nbsp;&nbsp; int IndexBufHandle{ -1 }; // GPU側のインデックスバッファへのハンドル番号<br>
        &nbsp;&nbsp;&nbsp; bool isSendDataToGPU = false; // GPUへデータを転送済みか<br>
        &nbsp;&nbsp;&nbsp; bool isGPUBufferRendering; // GPUバッファにVertexとIndexデータを送ってCPU側にはデータをもたないようにするか?<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3DSHADER&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
        <br>
        &nbsp;&nbsp;&nbsp; Ply::Data Data; //.plyのデータ<br>
        <br>
        &nbsp;&nbsp;&nbsp; bool isInitialized = false; //[継承2重ロード対策]ロード済みになったらtrueに falseのときにLoadするとリロード<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual ~DataPly()<br>
        &nbsp;&nbsp;&nbsp; {// 仮想デストラクタ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear();// 2次元配列データのお掃除<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual void clearCPUData() // CPU上の配列データをクリアする<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // [確実にメモリを空にするには] http://vivi.dyndns.org/tech/cpp/vector.html#shrink_to_fit<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3DSHADER&gt;().swap(Vertex); // 空のテンポラリオブジェクトでリセット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;unsigned int&gt;().swap(Index); // 空のテンポラリオブジェクトでリセット<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual void clearGPUData() // GPU上のバッファデータをクリアする<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteVertexBuffer(VertexBufHandle); // GPUの頂点バッファを削除する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteIndexBuffer(IndexBufHandle); // GPUのインデックスバッファを削除する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VertexBufHandle = -1; IndexBufHandle = -1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSendDataToGPU = false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGPUBufferRendering = false;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // データをクリアしてメモリを節約する<br>
        &nbsp;&nbsp;&nbsp; virtual void clear()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data.clear();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clearCPUData(); // CPU上の配列データをクリアする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clearGPUData(); // GPUのインデックスバッファを削除する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = false; //ロード済みフラグをOFF<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ファイルの読み込み<br>
        &nbsp;&nbsp;&nbsp; virtual int Load(const std::string&amp; filePath = "") override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (filePath == "" &amp;&amp; m_FilePath == "") return -1; //ファイル名がない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (files.count(filePath) &gt; 0 &amp;&amp; isInitialized) return 0; // すでに辞書にロード済みファイルがあった<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (filePath != "" &amp;&amp; m_FilePath == "") m_FilePath = filePath; // 読み出しファイルパスを記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear(); //データを一旦クリア<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ply::load(m_FilePath, Data); // .plyデータをロード<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [std::shared_ptrへthis↓ポインタをつかうためには] https://www.kabuku.co.jp/developers/cpp_enable_shared_from_this<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; files.emplace(m_FilePath, shared_from_this()); // リソースの辞書へ登録 https://cpprefjp.github.io/reference/memory/enable_shared_from_this.html<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報]https://jp.mathworks.com/help/vision/ug/the-ply- format.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float* face_uv = (Data["face"]-&gt;properties.has_key("texcoord")) ? Data["face"]-&gt;properties["texcoord"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)// i + face_index-&gt;listCounts[nFace], ++nFace)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //size_t count = face_index-&gt;listCounts[nFace]; // ポリゴンならインデックス数は3 四角形ならインデックス数は4 .. 5 .. 6<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //size_t nPolygon = count - 2; // 三角ポリゴンの数 = インデックスの数 - 2 (例) 3 - 2 = 1ポリゴン , 4 - 2 = 2ポリゴン ..<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t n = 0; n &lt; nPolygon; ++n)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Vertex[index].su != -1.0f) // su sv の suが初期値-1でなく設定済なら頂点の被りとして新しいnewIndexとして新規Index番号で点を新規登録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int newIndex = Vertex.size();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex.emplace_back(Vertex[index]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index = newIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index.push_back(newIndex);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index].su = 0.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (face_uv != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index].u = face_uv[uvIndex];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index].v = 1.0f - face_uv[uvIndex + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isGPUBufferRendering)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendDataToGPU(); // GPUのバッファへVertexとIndexデータ配列を送信<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = true;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; void SendDataToGPU() // GPUのバッファへVertexとIndexデータ配列を送信<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int result = false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VertexBufHandle = DxLib::CreateVertexBuffer(Vertex.size(), DX_VERTEX_TYPE_SHADER_3D); // 頂点バッファを作成<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = DxLib::SetVertexBufferData(0, Vertex.data(), Vertex.size(), VertexBufHandle); // 頂点バッファに頂点データを転送する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //UpdateVertexBuffer(VertexBufHandle, UpdateStartIndex, UpdateVertexNum); // 頂点バッファハンドルの頂点バッファへの変更を適用する( GetBufferVertexBuffer で取得したバッファへの変更を反映する )<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result == -1) return;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexBufHandle = DxLib::CreateIndexBuffer(Index.size(), DX_INDEX_TYPE_32BIT); // インデックスバッファを作成<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = DxLib::SetIndexBufferData(0, Index.data(), Index.size(), IndexBufHandle); // インデックスバッファにインデックスデータを転送する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result == -1) return;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGPUBufferRendering = true;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSendDataToGPU = true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        #endif<br>
      </p>
      <br>
      <p><code>main.cpp</code>のコードを.ply形式の3DデータをDataPly構造体経由で読み込む形に変更する。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        #include "DataMV1.h"<br>
        <em>#include "DataPly.h"</em><br>
        <br>
        #include "Editor.h"<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; float animTime = 0.0f; // アニメの現在時刻<br>
        &nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
        &nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@kick.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;Load(); // 3Dモデルをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilAttackAnimData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@jump.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilAttackAnimData-&gt;Load(); // 3Dの追加アニメデータをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;AttachAnim(*pDevilAttackAnimData); // アニメを追加でflyのほうをベースとしたモデルにアタッチ<br>
        &nbsp;&nbsp;&nbsp; int animeButton = 0; // ボタンでアニメを切り替えられるようにする<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; pTexImage = Resource::MakeShared&lt;Texture&gt;("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; pTexImage-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; assert((int)*pTexImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>std::shared_ptr&lt;DataPly&gt; pPlyData = Resource::MakeShared&lt;DataPly&gt;("Image/dice.ply");<br>
          &nbsp;&nbsp;&nbsp; pPlyData-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)</em><br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; <u>Ply::Data Data; // .plyのデータのクラス<br>
          &nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply", Data); // .plyデータをロード 軸を変えてdice1.plyや dice2.plyなどいろいろ試してみよう</u><br>
        <br>
        &nbsp;&nbsp;&nbsp; <u>size_t numIndex = 0; // インデックスの数<br>
          &nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; // 3Dモデルのポリゴンのインデックス配列<br>
          &nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; // 3Dモデルのポリゴンの頂点配列<br>
          <br>
          &nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
          &nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp; "Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
          &nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
          <br>
          &nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報] https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
          &nbsp;&nbsp;&nbsp; const float* p_x = vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
          &nbsp;&nbsp;&nbsp; const float* p_y = vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
          &nbsp;&nbsp;&nbsp; const float* p_z = vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
          &nbsp;&nbsp;&nbsp; const float* p_nx = (vertex-&gt;properties.has_key("nx")) ? vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
          &nbsp;&nbsp;&nbsp; const float* p_ny = (vertex-&gt;properties.has_key("ny")) ? vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
          &nbsp;&nbsp;&nbsp; const float* p_nz = (vertex-&gt;properties.has_key("nz")) ? vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
          &nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr || p_nz == nullptr);<br>
          &nbsp;&nbsp;&nbsp; const float* p_s = (vertex-&gt;properties.has_key("s")) ? vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; // Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
          &nbsp;&nbsp;&nbsp; const float* p_t = (vertex-&gt;properties.has_key("t")) ? vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
          <br>
          &nbsp;&nbsp;&nbsp; const unsigned char* p_R = (vertex-&gt;properties.has_key("red")) ? vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("r")) ? vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
          &nbsp;&nbsp;&nbsp; const unsigned char* p_G = (vertex-&gt;properties.has_key("green")) ? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("g")) ? vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
          &nbsp;&nbsp;&nbsp; const unsigned char* p_B = (vertex-&gt;properties.has_key("blue")) ? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("b")) ? vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
          &nbsp;&nbsp;&nbsp; const unsigned char* p_A = (vertex-&gt;properties.has_key("alpha")) ? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (vertex-&gt;properties.has_key("a")) ? vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
          &nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr || p_B == nullptr || p_A == nullptr);<br>
          <br>
          &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt; iEnd; i += 1)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧 https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos = VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm = (has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手Z↑→左手Y↑系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm) ? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color) ? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255, 255, 255);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc = GetColorU8(255, 255, 255, 255);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s == nullptr) ? 0.0f : p_s[i];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t == nullptr) ? 0.0f : 1 - p_t[i];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; const auto&amp; face_index = Data["face"]-&gt;properties["vertex_indices"];<br>
          &nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
          <br>
          &nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(), nFace = 0; i &lt; iEnd; i += 3)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt; 3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1 &gt; 0; --j) // 左手系(裏面は反時計回り) http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z == 0.0f)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index0 = Index[i];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index1 = Index[i + 1];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned int index2 = Index[i + 2];<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 外積 a×b cross_a_b を求める https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR a = VSub(Vertex[index1].pos, Vertex[index0].pos);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR b = VSub(Vertex[index2].pos, Vertex[index0].pos);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR cross1_2 = VCross(a, b);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手系(表面は反時計回り)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR cross2_1 = VCross(b, a);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 単位ベクトル(ノルム)に直す [単位ベクトル]は√(x*x + y*y + z*z) = 1となる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const VECTOR norm1_2 = VNorm(cross1_2);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //const VECTOR norm2_1 = VNorm(cross2_1);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[index0].norm = norm1_2; Vertex[index1].norm = norm1_2; Vertex[index2].norm = norm1_2;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[index0].norm = norm2_1; Vertex[index1].norm = norm2_1; Vertex[index2].norm = norm2_1; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++numIndex;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }</u><br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens(); // スクリーンの位置やドラッグによる移動を更新する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードの 0 1 キーで3Dアニメを切り替えられるようにする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_0))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_1))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 1;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width =&nbsp; pTexImage-&gt;m_XSize; float height =&nbsp; pTexImage-&gt;m_YSize; // テクスチャ画像のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f, 1.0f, 1.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(<em>pPlyData-&gt;</em>Vertex.data(), <em>pPlyData-&gt;</em>Vertex.size(), <em>pPlyData-&gt;</em>Index.data(), <em>pPlyData-&gt;</em>numIndex / 3, (int)*pTexImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 100, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ファイルのパス + ":" + アニメ名でアクセス<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string animPathName = (animeButton == 0) ? "Image/devil@kick.mv1:mixamo.com" : "Image/devil@jump.mv1:mixamo.com";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(pDevilData-&gt;count(animPathName) &gt; 0 &amp;&amp; "指定されたアニメ名のアニメはMV1に付属していませんでした");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime += animStepTime * animSpeed; // 1.0×2倍 なら2倍速でアニメ時刻が進む<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animTime &gt; (*pDevilData)[animPathName].endTime)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime = 0.0f; // 0秒目へとアニメをループさせる<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 再生時間をセットする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1SetAttachAnimTime((int)*pDevilData, (*pDevilData)[animPathName].index, animTime);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 半透明のスクリーンも描ける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); // サブのスクリーンを全部描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); // エディタのDraw処理<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう? devilのデータに隠れて見えにくいですが、ダイスの.ply形式のデータが今まで通り表示されていますでしょうか? <br>
      <br>
      <br>
    </a><a id="mozTocId0013" class="mozTocH1">
      <h1>Vector3に色々な関数を用意して3D空間の当たり判定をする</h1>
      <br>
      <p><code>Vector3.hを新規作成</code>してxyzの3D座標を取り扱えるようにして、さらに様々な当たり判定に使うための関数(線などとの最短距離を計算する)もセットで導入しておきましょう。</p>
      <p class="source">#ifndef VECTOR3_H_<br>
        #define VECTOR3_H_<br>
        <br>
        #include "DxLib.h"<br>
        <br>
        #include &lt;array&gt; //vector配列と基本同じだが【有限】の個数である違いがあるxyzなど3つ固定の個数ならstd::vectorよりstd::array型がよい<br>
        #include &lt;cmath&gt;<br>
        #include &lt;limits&gt; // 無限大などをstd::numeric_limits&lt;float&gt;::infinity()で取得<br>
        #include &lt;float.h&gt; // FLT_EPSILONでfloat型のとりうる最小の極小値を得る<br>
        <br>
        #ifndef GET_CLAMP // GET_CLAMPマクロの定義がなかったら定義して使う<br>
        // a と b 小さい方の値を求める<br>
        #define&nbsp;&nbsp;&nbsp; GET_MIN( a, b )&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ( ( (a) &lt; (b) ) ? (a) : (b) )<br>
        // a と b 大きい方の値を求める<br>
        #define&nbsp;&nbsp;&nbsp; GET_MAX( a , b )&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ( ( (a) &gt; (b) ) ? (a) : (b) )<br>
        // aを min から max の値に留める<br>
        #define&nbsp;&nbsp;&nbsp; GET_CLAMP( a, min, max )&nbsp;&nbsp;&nbsp; GET_MAX( min, GET_MIN( a, max ) )<br>
        #endif<br>
        <br>
        // 軸のタイプ X軸:Axis3D::X, Y軸:Axis3D::Y, Z軸:Axis3D::Z<br>
        enum class Axis3D { X = 0, Y, Z };<br>
        <br>
        //★【UnityのVector演算コード】<br>
        // https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
        <br>
        // 3変数x,y,zを持つ構造体。3つの数字をまとめて扱うならXYZ座標以外にも使える。x,y,z別々に足したり引いたり面倒なときこそ<br>
        struct Vector3<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // struct型はpublic:がなくてもデフォルトがpublic:&nbsp; private:を書けばプライベートにもできる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //float x = 0; // x座標<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //float y = 0; // y座標<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //float z = 0; // z座標 3つの定義をunionで配列xyzと共用することでxyz[1]=5.5f;とすると yも5.5となる【運命共用体】(メモリ上は同じ位置になる)<br>
        <br>
        &nbsp;&nbsp;&nbsp; union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x;// x座標<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float y;// y座標<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float z;// z座標<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }; //[匿名共用体とは] https://zenn.dev/block/articles/beda29f11f05afc147ef<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float r, g, b; }; // 赤緑青のRGB成分としてつかいたいとき<br>
        &nbsp;&nbsp;&nbsp; }; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(float*)キャストすればx,y,zデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator float* () const { return (float*)this; }<br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(const float*)キャストすればx,y,zデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator const float* () const { return (const float*)this; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ 初期化 z = 0.fでzのデフォルト値があるので2Dとしても使える<br>
        &nbsp;&nbsp;&nbsp; Vector3(float x = 0.0f, float y = 0.0f, float z = 0.0f)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;xyz = { x,y,z };// たった1行で書ける<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; //仮想デストラクタ<br>
        &nbsp;&nbsp;&nbsp; virtual ~Vector3() {}<br>
        <br>
        &nbsp;&nbsp;&nbsp; // Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 zero;// = { 0.f, 0.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 one; // = { 1.f, 1.f, 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 forward;// = { 0.f, 0.f, 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 back; // = { 0.f, 0.f, -1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 up; // = { 0.f, 1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 down;// = { 0.f, -1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 left; // = {-1.f, 0.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 right;// = { 1.f, 0.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; //[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 negativeInfinity;<br>
        &nbsp;&nbsp;&nbsp; //[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector3 positiveInfinity;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // destArrayにデータを保管しておく<br>
        &nbsp;&nbsp;&nbsp; Vector3&amp; copyToArray(std::array&lt;float, 3&gt;&amp; destArray)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destArray = this-&gt;xyz;//配列としてコピー<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; // sourceArray配列からVector3データを生成<br>
        &nbsp;&nbsp;&nbsp; Vector3 fromArray(std::array&lt;float, 3&gt;&amp; sourceArray) const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Vector3{ sourceArray[0], sourceArray[1], sourceArray[2] }; //配列から初期化<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; // ベクトルの長さ(原点0から点(x,y,z)までの距離)<br>
        &nbsp;&nbsp;&nbsp; inline float magnitude() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::sqrt(x * x + y * y + z * z); // √(x*x + y*y + z*z)<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)<br>
        &nbsp;&nbsp;&nbsp; inline float sqrMagnitude() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x * x + y * y + z * z; // x*x + y*y + z*z<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; // 正規化したベクトルを返す<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 normalized() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float mag = magnitude();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mag &lt; 0.00001f) // ほぼ0ベクトルか？<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Vector3{ x / mag, y / mag, z / mag }; // x / |x|, y / |y|, z / |z|<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; /*-----　演算子オーバーロード　-----*/<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 逆ベクトル<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 operator - () const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Vector3(-this-&gt;x, -this-&gt;y, -this-&gt;z);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // Vectorをそのまま足し合わせる<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 operator + () const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Vector3&amp; operator += (const Vector3&amp; add_v3)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x += add_v3.x;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;y += add_v3.y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;z += add_v3.z;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this; //[関数連鎖] *thisを返すことで v1 + v2 + v3見たく数珠繋ぎできる<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Vector3&amp; operator -= (const Vector3&amp; minus_v3)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x -= minus_v3.x;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;y -= minus_v3.y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;z -= minus_v3.z;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Vector3&amp; operator *= (float multiply_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x *= multiply_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;y *= multiply_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;z *= multiply_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 0.fで割ったときは±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; inline Vector3&amp; operator /= (float divide_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (divide_num == 0.0f) // 0で割ったら±無限大を返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *this = Vector3{ ((this-&gt;x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((this-&gt;y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((this-&gt;z &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x /= divide_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;y /= divide_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;z /= divide_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 代入演算子 x,y,zを全部 change_numに変える<br>
        &nbsp;&nbsp;&nbsp; inline Vector3&amp; operator = (float change_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x = change_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;y = change_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;z = change_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 一致演算子 x,y,zが全部一致するか 一つでも違えばfalse<br>
        &nbsp;&nbsp;&nbsp; inline bool operator == (const Vector3&amp; v3_other) const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;x != v3_other.x) return false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;y != v3_other.y) return false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;z != v3_other.z) return false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 不一致演算子<br>
        &nbsp;&nbsp;&nbsp; inline bool operator != (const Vector3&amp; v3_other) const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(*this == v3_other);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; /*---- 以下 DXライブラリ向けにVector3とDX版Vectorの変換方法を用意 ---------------*/<br>
        <br>
        &nbsp; // DXlibを#includeしていればDX_LIB_Hも定義済みなので下記関数も定義される VECTORの定義はDXライブラリ版のVector3<br>
        #ifdef DX_LIB_H<br>
        &nbsp; // Vector3からDxLibのVECTORへの変換<br>
        &nbsp;&nbsp;&nbsp; inline VECTOR Vec3ToVec()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR Result;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result.x = this-&gt;x;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result.y = this-&gt;y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result.z = this-&gt;z;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Result;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 左辺値がDXのVECTOR型のときの=代入対応<br>
        &nbsp;&nbsp;&nbsp; inline operator VECTOR() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR Result;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result.x = this-&gt;x;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result.y = this-&gt;y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result.z = this-&gt;z;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Result;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 右辺値がDXのVECTOR型のときの=代入対応<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 operator = (const VECTOR&amp; other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x = other.x;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;y = other.y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;z = other.z;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ DXのVECTOR型から = 初期化できるように<br>
        &nbsp;&nbsp;&nbsp; inline Vector3(VECTOR other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x = other.x;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;y = other.y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;z = other.z;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        #endif<br>
        <br>
        };<br>
        <br>
        <br>
        // Vector3どうしの足し算 割り算 掛け算 割り算などの 基本演算の グローバル定義<br>
        <br>
        <br>
        // Vector同士の足し算 x,y,z個別に足し合わせる<br>
        inline Vector3 operator + (const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 v3; //注意 vec1 = vec1 + vec2のとき vec1の数値が書き変わったら嫌だからv3を新たに用意<br>
        &nbsp;&nbsp;&nbsp; v3.x = left.x + right.x; //[コレはダメ] left.x = left.x + right.x;<br>
        &nbsp;&nbsp;&nbsp; v3.y = left.y + right.y;<br>
        &nbsp;&nbsp;&nbsp; v3.z = left.z + right.z;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v3;<br>
        }<br>
        <br>
        // Vector同士の引き算 x,y,z個別に足し合わせる<br>
        inline Vector3 operator - (const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 v3; //注意 vec1 = vec1 - vec2のとき vec1の数値が書き変わったら嫌だからv3を新たに用意<br>
        &nbsp;&nbsp;&nbsp; v3.x = left.x - right.x; //[コレはダメ] left.x = left.x - right.x;<br>
        &nbsp;&nbsp;&nbsp; v3.y = left.y - right.y;<br>
        &nbsp;&nbsp;&nbsp; v3.z = left.z - right.z;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v3;<br>
        }<br>
        <br>
        // Vectorと数値の掛け算 x,y,z個別に掛け合わせる<br>
        inline Vector3 operator * (const Vector3&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 v3;<br>
        &nbsp;&nbsp;&nbsp; v3.x = left.x * right;<br>
        &nbsp;&nbsp;&nbsp; v3.y = left.y * right;<br>
        &nbsp;&nbsp;&nbsp; v3.z = left.z * right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v3;<br>
        }<br>
        <br>
        <br>
        // 数値とVectorの掛け算 x,y,z個別に掛け合わせる<br>
        inline Vector3 operator * (float left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 v3;<br>
        &nbsp;&nbsp;&nbsp; v3.x = left * right.x;<br>
        &nbsp;&nbsp;&nbsp; v3.y = left * right.y;<br>
        &nbsp;&nbsp;&nbsp; v3.z = left * right.z;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v3;<br>
        }<br>
        <br>
        // Vectorと数値の割り算 x,y,z個別に割り合わせる<br>
        // 0.fで割ると±無限大を返す<br>
        inline Vector3 operator / (const Vector3&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (right == 0.0f) // 0で割ったら±無限大を返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Vector3{ ((left.x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((left.y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((left.z &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector3 v3;<br>
        &nbsp;&nbsp;&nbsp; v3.x = left.x / right;<br>
        &nbsp;&nbsp;&nbsp; v3.y = left.y / right;<br>
        &nbsp;&nbsp;&nbsp; v3.z = left.z / right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v3;<br>
        }<br>
        <br>
        // 比較不等号 &lt; 演算子<br>
        inline bool operator &lt; (const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &lt; right.x;<br>
        &nbsp;&nbsp;&nbsp; if (left.y != right.y) return left.y &lt; right.y;<br>
        &nbsp;&nbsp;&nbsp; return left.z &lt; right.z;<br>
        }<br>
        <br>
        // 比較不等号 &gt; 演算子<br>
        inline bool operator &gt; (const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &gt; right.x;<br>
        &nbsp;&nbsp;&nbsp; if (left.y != right.y) return left.y &gt; right.y;<br>
        &nbsp;&nbsp;&nbsp; return left.z &gt; right.z;<br>
        }<br>
        <br>
        // 比較不等号 &lt;= 演算子<br>
        inline bool operator &lt;= (const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &gt; right);<br>
        }<br>
        <br>
        // 比較不等号 &gt;= 演算子<br>
        inline bool operator &gt;= (const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &lt; right);<br>
        }<br>
        <br>
        // 2つのベクトルの内積<br>
        inline float dot(const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return left.x * right.x + left.y * right.y + left.z * right.z; //普通にx同士,y同士,z同士掛けるだけ<br>
        }<br>
        <br>
        // 2つのベクトルの外積<br>
        inline Vector3 cross(const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return Vector3{<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left.y * right.z - left.z * right.y, // x = 左y * 右z - 左z * 右y<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left.z * right.x - left.x * right.z, // y = 左z * 右x - 左x * 右z<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left.x * right.y - left.y * right.x };// z = 左x * 右y - 左y * 右x //行列独特の特殊な掛け方<br>
        }<br>
        <br>
        // ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)<br>
        inline float sqrMagnitude(const Vector3&amp; vec)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return vec.x * vec.x + vec.y * vec.y + vec.z * vec.z; // x*x + y*y + z*z<br>
        }<br>
        <br>
        // ベクトルの長さ(原点0から点(x,y,z)までの距離)<br>
        inline float magnitude(const Vector3&amp; vec)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return std::sqrt(sqrMagnitude(vec)); // √x*x + y*y + z*z<br>
        }<br>
        <br>
        // start と end の間の距離<br>
        inline float distance(const Vector3&amp; start, const Vector3&amp; end)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return (start - end).magnitude();<br>
        }<br>
        <br>
        // 直線上にある2つのベクトル間を補間(start:開始位置&nbsp; end:終了位置&nbsp; t = 補間の割合 tは0～1の範囲にクランプしない)<br>
        inline Vector3 lerpUnclamped(const Vector3&amp; start, const Vector3&amp; end, float t)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return start + (end - start) * t;<br>
        }<br>
        <br>
        // 線形補間する start:開始位置&nbsp; end:終了位置&nbsp; t = 補間の割合（start側が100%&nbsp; 0.0～1.0&nbsp; end側が100% でブレンド) tは0～1の範囲にクランプする<br>
        inline Vector3 lerp(const Vector3&amp; start, const Vector3&amp; end, float t)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return lerpUnclamped(start,end, GET_CLAMP(t, 0.0f, 1.0f) );<br>
        }<br>
        <br>
        // max マクロと min マクロを#undef<br>
        #undef max<br>
        #undef min<br>
        <br>
        // 2つのベクトルで各成分の一番大きな値を使用してベクトルを作成(例えば8分木などのエリア判定に使える)<br>
        inline Vector3 max(const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return Vector3{ std::max(left.x, right.x), std::max(left.y, right.y), std::max(left.z, right.z) };<br>
        }<br>
        <br>
        // 2つのベクトルで各成分の一番小さな値を使用してベクトルを作成(例えば8分木などのエリア判定に使える)<br>
        inline Vector3 min(const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return Vector3{ std::min(left.x, right.x), std::min(left.y, right.y), std::min(left.z, right.z) };<br>
        }<br>
        <br>
        // 2次補間する start:開始位置 mid:中間制御点 end:終了位置&nbsp; t = 補間の割合（start側が100%&nbsp; 0.0～1.0&nbsp; end側が100% でブレンド)<br>
        inline Vector3 quadratic(const Vector3&amp; start, const Vector3&amp; mid, const Vector3&amp; end, float t)<br>
        {&nbsp;&nbsp;&nbsp; //[ベジェ曲線補間の3点ver.] https://ja.javascript.info/bezier-curve<br>
        &nbsp;&nbsp;&nbsp; return start * (1.0f - t) * (1.0f - t) + 2 * mid * t * (1.0f - t) + end * t * t;<br>
        }<br>
        <br>
        <br>
        // ベジェ曲線の補間をする start:開始位置 mid1:中間制御点1&nbsp; mid2:中間制御点2 end:終了位置&nbsp; t = 補間の割合（start側が100%&nbsp; 0.0～1.0&nbsp; end側が100%)<br>
        inline Vector3 bezier(const Vector3&amp; start, const Vector3&amp; mid1, const Vector3&amp; mid2, const Vector3&amp; end, float t)<br>
        {&nbsp;&nbsp;&nbsp; //[ベジェ曲線補間の4点ver.] https://ja.javascript.info/bezier-curve<br>
        &nbsp;&nbsp;&nbsp; Vector3 vec;<br>
        &nbsp;&nbsp;&nbsp; vec.x = start.x * (1.0f - t) * (1.0f - t) * (1.0f - t) + 3 * (1.0f - t) * (1.0f - t) * t * mid1.x + 3 * (1.0f - t) * t * t * mid2.x + t * t * t * end.x;<br>
        &nbsp;&nbsp;&nbsp; vec.y = start.y * (1.0f - t) * (1.0f - t) * (1.0f - t) + 3 * (1.0f - t) * (1.0f - t) * t * mid1.y + 3 * (1.0f - t) * t * t * mid2.y + t * t * t * end.y;<br>
        &nbsp;&nbsp;&nbsp; vec.z = start.z * (1.0f - t) * (1.0f - t) * (1.0f - t) + 3 * (1.0f - t) * (1.0f - t) * t * mid1.z + 3 * (1.0f - t) * t * t * mid2.z + t * t * t * end.z;<br>
        &nbsp;&nbsp;&nbsp; return vec;<br>
        }<br>
        <br>
        <br>
        // 2つのベクトルの各成分をかけ算<br>
        inline Vector3 scale(const Vector3&amp; left, const Vector3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return Vector3{ left.x * right.x, left.y * right.y, left.z * right.z };<br>
        }<br>
        <br>
        // ベクトルを別のベクトルに投影<br>
        inline Vector3 project(const Vector3&amp; vector, const Vector3&amp; on_normal)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float sqrMag = on_normal.sqrMagnitude();<br>
        &nbsp;&nbsp;&nbsp; if (sqrMag &lt; 0.00001f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Vector3::zero;<br>
        &nbsp;&nbsp;&nbsp; return on_normal * dot(vector, on_normal) / sqrMag;<br>
        }<br>
        <br>
        // 平面に垂直な法線ベクトルにより定義される平面上にベクトルを射影<br>
        inline Vector3 projectOnPlane(const Vector3&amp; vector, const Vector3&amp; planeNormal)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return vector - project(vector, planeNormal);<br>
        }<br>
        <br>
        // 2つのベクトルの角度θを求める(単位:ラジアン)<br>
        inline float radAngle(const Vector3&amp; start, const Vector3&amp; end)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float cos_theta = dot(start, end) / (start.magnitude() * end.magnitude());<br>
        &nbsp;&nbsp;&nbsp; return std::acos( GET_CLAMP(cos_theta, -1.0f, 1.0f) );<br>
        }<br>
        <br>
        // 三角ポリゴンの面法線を求める p0,p1,p2:三角ポリゴンの3点の位置ベクトル<br>
        inline Vector3 polygonNorm(const Vector3&amp; p0, const Vector3&amp; p1, const Vector3&amp; p2)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 直線p1p0 と 直線p2p1 の外積を求めて、それを単位ベクトルNorm化する<br>
        &nbsp;&nbsp;&nbsp; return cross(p0 - p1, p1 - p2).normalized();<br>
        }<br>
        <br>
        // 反射ベクトルを求める input:入射ベクトル&nbsp; norm:法線ベクトル<br>
        inline Vector3 reflection(const Vector3&amp; input, const Vector3&amp; norm)<br>
        {&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内積↓<br>
        &nbsp;&nbsp;&nbsp; // [計算式]反射ベクトル = 2 * ( -入射・法線 ) * 法線 + 入射<br>
        &nbsp;&nbsp;&nbsp; return 2 * dot(-input, norm) * norm + input;<br>
        }<br>
        <br>
        // 屈折ベクトルを求める input:入射ベクトル norm:法線ベクトル 屈折比率: n = n1 / n2 (入射角度:θ1 屈折角度:θ2)<br>
        inline Vector3 refraction(const Vector3&amp; input, const Vector3&amp; norm, float n)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; //[ベクトルの屈折] https://tyfkda.github.io/blog/2009/07/19/refraction.html<br>
        &nbsp;&nbsp;&nbsp; Vector3 inverse = -input; // 逆ベクトル<br>
        &nbsp;&nbsp;&nbsp; float cos_theta1 = dot(inverse, norm); // cosθ1 = -入射ベクトル・法線ベクトル<br>
        &nbsp;&nbsp;&nbsp; float cosT2 = 1.0f - n * n * (1.0f - cos_theta1 * cos_theta1); // <br>
        &nbsp;&nbsp;&nbsp; if (cosT2 &lt;= 0.0f) return Vector3{ 0.0f, 0.0f, 0.0f }; // 屈折光はでてこない<br>
        &nbsp;&nbsp;&nbsp; float abs_cosT2 = (cosT2 &lt; 0) ? -cosT2 : cosT2;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 屈折比率: n = n1 / n2 (入射角度:θ1 屈折角度:θ2)<br>
        &nbsp;&nbsp;&nbsp; // 屈折ベクトル = n * -入射 + 法線 * (n * cosθ1 - √(1 - n * n * (1 - cosθ1 * cosθ1) )<br>
        &nbsp;&nbsp;&nbsp; return n * inverse + norm * (n * cos_theta1 - std::sqrt(abs_cosT2));<br>
        }<br>
        <br>
        // 円周率×2<br>
        #define PI_2 3.14159265358979323846264f * 2<br>
        <br>
        // ラジアン: 0～2π (0°～ 360°)の範囲に変換<br>
        #define RAD_NORMALIZE( rad ) ( ( rad &gt;= 0.0f ) ? std::fmod( rad, PI_2 ): std::fmod( rad, PI_2 ) + PI_2 )<br>
        <br>
        // ベクトルから Pitch(ピッチ) を求める https://watako-lab.com/2019/01/23/roll_pitch_yaw/<br>
        inline float pitch(const Vector3&amp; vec)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float length = vec.magnitude();<br>
        &nbsp;&nbsp;&nbsp; if (length == 0) return 0.0f; // ベクトルの長さが0のときは0°<br>
        <br>
        &nbsp;&nbsp;&nbsp; // こたえを 0～2π (0°～ 360°)の範囲に変換してreturn<br>
        &nbsp;&nbsp;&nbsp; return RAD_NORMALIZE( std::asin(-vec.y / length) );<br>
        }<br>
        <br>
        // ベクトルから Yaw(ヨー) を求める https://watako-lab.com/2019/01/23/roll_pitch_yaw/<br>
        inline float yaw(const Vector3&amp; vec)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float length = vec.magnitude();<br>
        &nbsp;&nbsp;&nbsp; if (length == 0) return 0.0f; // ベクトルの長さが0のときは0°<br>
        <br>
        &nbsp;&nbsp;&nbsp; return RAD_NORMALIZE( std::atan2(vec.x / length, vec.z / length) );<br>
        }<br>
        <br>
        // 一時定義したマクロを #undef で未定義に戻す<br>
        #undef PI_2<br>
        #undef RAD_NORMALIZE<br>
        <br>
        // 重心座標を求める 点 p0:重心座標を求めたい位置 三角形の点: p1 p2 p3 https://zellij.hatenablog.com/entry/20131207/p1<br>
        inline Vector3 barycentric(const Vector3&amp; p0, const Vector3&amp; p1, const Vector3&amp; p2, const Vector3&amp; p3)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 v2 = p2 - p1;<br>
        &nbsp;&nbsp;&nbsp; Vector3 v3 = p3 - p1;<br>
        &nbsp;&nbsp;&nbsp; Vector3 v0 = p0 - p1;<br>
        &nbsp;&nbsp;&nbsp; float d22 = dot(v2, v2);<br>
        &nbsp;&nbsp;&nbsp; float d23 = dot(v2, v3);<br>
        &nbsp;&nbsp;&nbsp; float d33 = dot(v3, v3);<br>
        &nbsp;&nbsp;&nbsp; float d02 = dot(v0, v2);<br>
        &nbsp;&nbsp;&nbsp; float d03 = dot(v0, v3);<br>
        &nbsp;&nbsp;&nbsp; float denom = d22 * d33 - d23 * d23;<br>
        &nbsp;&nbsp;&nbsp; float v = (d33 * d02 - d23 * d03) / denom;<br>
        &nbsp;&nbsp;&nbsp; float w = (d22 * d03 - d23 * d02) / denom;<br>
        &nbsp;&nbsp;&nbsp; return&nbsp; p1 * (1.0f - v - w) + p2 * v + p3 * w;<br>
        }<br>
        <br>
        // 調べたい点point から一番近い直線上の点を求める linePos: 線の起点 lineVec:線のベクトル isInfinite:無限に延びる線か? result_t:接点までの直線パラメータ t<br>
        inline Vector3 nearestPointOnLine(const Vector3&amp; point, const Vector3&amp; lineStart, const Vector3&amp; lineDir, bool isInfinite = true, float* result_t = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float t; // 直線のパラメータ t (tが0だと始点startの位置、tが増えると始点からより遠くに延長された位置になる)<br>
        &nbsp;&nbsp;&nbsp; float lineLengthSq = lineDir.sqrMagnitude();<br>
        &nbsp;&nbsp;&nbsp; if (lineLengthSq &lt; FLT_EPSILON) // 線分のベクトルの長さがほぼ0なら<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result_t != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result_t = 0.0f; // 直線パラメータ t は起点の位置だから 0 の位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return lineStart; // 線分の始点が最も近い<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; linePosToPoint = point - lineStart; // 線の起点linePos から 調べたい点pointへのベクトル<br>
        <br>
        &nbsp;&nbsp;&nbsp; t = dot(lineDir, linePosToPoint) / lineLengthSq; // 調べたい座標に最も近い lineVec線上の座標 への直線パラメータ t を計算<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (isInfinite == false) // 有限線分のとき (線が無限に延びてないタイプのとき)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = GET_CLAMP(t, 0.0f, 1.0f); // 有限の線だから GET_CLAMP でtの値を 0.0f～1.0fの間に限定する<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result_t != nullptr) // result_tがnullptrじゃなければ 直線パラメータ t もついでに計算結果を返却しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result_t = t;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return lineDir * t + lineStart; // lineVecの方向をt倍のばして一番近い直線上の点の位置を求める<br>
        }<br>
        <br>
        <br>
        // 平行で交わらない線分line0 と 線分line1 の一番近い点を求める isInfinite:無限の長さの線かどうか result0:line0上の最も近い点 result1:line1上の最も近い点 <br>
        inline void nearestPointOfParallelLine(const Vector3&amp; line0Start, const Vector3&amp; line0End, const Vector3&amp; line1Start, const Vector3&amp; line1End,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isInfinite = false, Vector3* result0 = nullptr, Vector3* result1 = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float t0, t1, t; // 直線のパラメータを求める<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector3 answer0 = nearestPointOnLine(line1Start, line0Start, line0End - line0Start, true, &amp;t0); // 始点line1Start から一番近い直線line0上の点を求める<br>
        &nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入して返す<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (isInfinite == true) // 無限の長さの線ならば<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer1 = line1Start; // line1の起点が一番近い<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1; // resultがnullptrじゃなければ答えを代入して返す<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; tmpPoint = nearestPointOnLine(line1End, line0Start, line0End - line0Start, true, &amp;t1); // 終点line1end から一番近い直線line0上の点を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((t0 &lt; 0.0f) &amp;&amp; (t1 &lt; 0.0f)) // 最も近い点 が line0もline1も両方【始点】より外側の延長線上にあるとき<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer0 = line0Start; // 始点が答え(最も近い点)になる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer1 = (t0 &lt; t1) ? line1End : line1Start;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入して返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((t0 &gt; 1.0f) &amp;&amp; (t1 &gt; 1.0f)) // 最も近い点 が line0もline1も両方【終点】より外側の延長線上にあるとき<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer0 = line0End; // 終点が答え(最も近い点)になる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer1 = (t0 &lt; t1) ? line1Start : line1End;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入して返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = 0.5f * (GET_CLAMP(t0, 0.0f, 1.0f) + GET_CLAMP(t1, 0.0f, 1.0f)); <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer0 = (line0End - line0Start) * t + line0Start; // line0の方向をt倍のばして一番近い直線上の点の位置を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer1 = nearestPointOnLine(answer0, line1Start, line1End - line1Start, true); // 点answer0 から一番近い直線line1上の点を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入して返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        }<br>
        <br>
        // 線分line0 と 線分line1 の【有限の線上範囲内】での一番近い点を求める result0:line0上に収まる最も近い点 result1:line1上に収まる最も近い点 <br>
        inline void nearestPointsOnFiniteLines(const Vector3&amp; line0Start, const Vector3&amp; line0End, const Vector3&amp; line1Start, const Vector3&amp; line1End, <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t0, float t1, Vector3&amp; result0, Vector3&amp; result1)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 v0 = line0End - line0Start; // line0 の start点 から end点 へ向かう ベクトル<br>
        &nbsp;&nbsp;&nbsp; Vector3 v1 = line1End - line1Start; // line1 の start点 から end点 へ向かう ベクトル<br>
        &nbsp;&nbsp;&nbsp; if ( (t0 &lt; 0.0f || 1.0f &lt; t0) &amp;&amp; (t1 &lt; 0.0f || 1.0f &lt; t1) ) // t0 も t1 も両方 0～1.0の範囲外(line0とline1の始点から終点の範囲内におさまってない)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = GET_CLAMP(t0, 0.0f, 1.0f); // まず t0 を 0～1.0以内に収める(0以下 や 1以上 でも 0 や 1 にする)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer0 = v0 * t0 + line0Start; // v0の方向を t0倍 のばした直線line0上 の 範囲内の点 の位置を一旦、求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer1 = nearestPointOnLine(answer0, line1Start, v1, true, &amp;t1); // 範囲内の点↑answer0 から 一番近い 直線line1(無限長)上の点 を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (t1 &lt; 0.0f || 1.0f &lt; t1) // t1が 直線line1 の 始点0 ～ 終点1.0 の↑範囲外ならば t1を0～1.0の範囲に収めてさらに再計算<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = GET_CLAMP(t1, 0.0f, 1.0f); // t1 = 0～1.0以内に収めて再計算<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer1 = v1 * t1 + line1Start; // v1の方向を t1倍 のばして一番近い直線上の点の位置を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer0 = nearestPointOnLine(answer1, line0Start, v0, false); // 点answer1 から 一番近い 直線line0(有限)上の点 を求めなおす<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer1 = nearestPointOnLine(answer0, line1Start, v1, false); // 点answer0 から 一番近い 直線line1(有限)上の点 を求めなおす<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result0 = answer0; // 求めたanswer で 結果 result を確定して関数外へ返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (t0 &lt; 0.0f || 1.0f &lt; t0) // t0 が 0～1.0の範囲におさまっていない(line0の始点から終点の範囲内におさまってない)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = GET_CLAMP(t0, 0.0f, 1.0f); // t0 を 0～1.0以内に収める(0以下 や 1以上 でも 0 や 1 にする)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer0 = v0 * t0 + line0Start; // v0の方向を t0倍 のばした直線line0上 の 範囲内の点 の位置を一旦、求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer1 = nearestPointOnLine(answer0, line1Start, v1, false); // 点answer0 から 一番近い 直線line1(有限)上の点 を求める<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result0 = answer0; // 求めたanswer で 結果 result を確定して関数外へ返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (t1 &lt; 0.0f || 1.0f &lt; t1) // t1 が 0～1.0の範囲におさまっていない(line1の始点から終点の範囲内におさまってない)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = GET_CLAMP(t1, 0.0f, 1.0f); // t1 を 0～1.0以内に収める(0以下 や 1以上 でも 0 や 1 にする)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer1 = v1 * t1 + line1Start; // v0の方向を t0倍 のばした直線line0上 の 範囲内の点 の位置を一旦、求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 answer0 = nearestPointOnLine(answer1, line0Start, v0, false); // 点answer1 から 一番近い 直線line0(有限)上の点 を求める<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result0 = answer0; // 求めたanswer で 結果 result を確定して関数外へ返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        }<br>
        <br>
        // 点:point と box:AABB(軸並行境界ボックス：Axis-Aligned Bounding Box)の最短距離 http://marupeke296.com/COL_3D_No11_AABBvsPoint.html<br>
        inline float nearestLengthPoint_AABB(const Vector3&amp; point, const Vector3&amp; boxMin, const Vector3&amp; boxMax)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float sqLength = 0.0f; // 長さのべき乗の値を足していく<br>
        &nbsp;&nbsp;&nbsp; for (auto i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 各軸で点が最小値以下もしくは最大値以上ならば、差を考慮<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (point.xyz[i] &lt; boxMin.xyz[i])&nbsp; // i=0:X,,i=1:Y, i=2はZの意味です<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqLength += (point.xyz[i] - boxMin.xyz[i]) * (point.xyz[i] - boxMin.xyz[i]); // 距離の2乗<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (point.xyz[i] &gt; boxMax.xyz[i])<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqLength += (point.xyz[i] - boxMax.xyz[i]) * (point.xyz[i] - boxMax.xyz[i]); // 距離の2乗<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return std::sqrtf(sqLength); //&nbsp; // 距離の2乗を足していった合計の√を取る<br>
        }<br>
        <br>
        #endif<br>
      </p>
      <br>
      <p><code>Vector3.cppを新規作成</code>してstatic変数の初期化コードを実装します。</p>
      <p class="source">#include "Vector3.h"<br>
        <br>
        // Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
        Vector3 const Vector3::zero = Vector3(0.f, 0.f, 0.f);<br>
        Vector3 const Vector3::one = Vector3(1.f, 1.f, 1.f);<br>
        Vector3 const Vector3::forward = Vector3(0.f, 0.f, 1.f);<br>
        Vector3 const Vector3::back = Vector3(0.f, 0.f, -1.f);<br>
        Vector3 const Vector3::up = Vector3(0.f, 1.f, 0.f);<br>
        Vector3 const Vector3::down = Vector3(0.f, -1.f, 0.f);<br>
        Vector3 const Vector3::left = Vector3(-1.f, 0.f, 0.f);<br>
        Vector3 const Vector3::right = Vector3(1.f, 0.f, 0.f);<br>
        //[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
        Vector3 const Vector3::negativeInfinity = Vector3(-std::numeric_limits&lt;float&gt;::infinity(), -std::numeric_limits&lt;float&gt;::infinity(), -std::numeric_limits&lt;float&gt;::infinity());<br>
        //[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
        Vector3 const Vector3::positiveInfinity = Vector3(std::numeric_limits&lt;float&gt;::infinity(), std::numeric_limits&lt;float&gt;::infinity(), std::numeric_limits&lt;float&gt;::infinity());<br>
      </p>
      <br>
      つぎにVector3を使って、平面を表現するPlane4.hを準備します。<br>
      実は平面(無限)は、驚くことにデータ的には、 <b>原点からの距離:dist と 平面に垂直な法線ベクトル:n のたった2つだけの要素で確定</b>できてしまいます。<br>
      <p><img src="image/plane_polygon_collision.png" alt="" style=""><br>
      </p>
      <p><code>Plane4.hを新規作成</code>して原点からの距離:dist と 平面に垂直な法線ベクトル:n である無限の平面を数学的に表現する準備をします。</p>
      <p class="source">#ifndef PLANE_H_<br>
        #define PLANE_H_<br>
        <br>
        #include "Vector3.h"<br>
        #include &lt;cmath&gt;<br>
        #include &lt;float.h&gt; // 極小値ε FLT_EPSILON を使う<br>
        <br>
        //[UnityのPlane平面の例] https://docs.unity3d.com/ja/2022.3/ScriptReference/Plane.html<br>
        // 内部的には内積や外積だけで計算処理が実装されている<br>
        <br>
        struct Plane4 // 数学的な平面(無限)の定義 Plane4の4はVector3のような float型を4つ持つという意味<br>
        {<br>
        &nbsp;&nbsp;&nbsp; union // 共用体unionで法線struct{nx, ny, nz} と 法線nを同じメモリ上の位置にする つまり nx = n.x, ny = n.y, nz = n.zになる<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; struct { float nx, ny, nz; }; // 面法線x,y,z成分<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; n{0.0f,0.0f,0.0f};&nbsp;&nbsp;&nbsp; // 面から出る法線ベクトル<br>
        &nbsp;&nbsp;&nbsp; };<br>
        &nbsp;&nbsp;&nbsp; float dist = 0.0f; // 原点からの距離<br>
        <br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(float*)キャストすればnx,ny,nz,distデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator float* () const { return (float*)this; }<br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(const float*)キャストすればnx,ny,nz,distデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator const float* () const { return (const float*)this; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Plane4(const Plane4&amp; other) : n{ other.n }, dist{ other.dist } {} // コピーコンストラクタ return *thisを使うため<br>
        <br>
        &nbsp;&nbsp;&nbsp; Plane4(float normX = 0.0f, float normY = 0.0f, float normZ = 0.0f, float distance = 0.0f) : nx{ normX }, ny{ normY }, nz{ normZ }, dist{ distance } {}<br>
        &nbsp;&nbsp;&nbsp; Plane4(const Vector3&amp; norm, float distance) : n{ norm }, dist{ distance } {}<br>
        &nbsp;&nbsp;&nbsp; // 平面上の点point と 平面の法線ペクトルnorm から 平面方程式パラメータdist(原点からの距離)をdotで計算して 平面を生成する <br>
        &nbsp;&nbsp;&nbsp; Plane4(const Vector3&amp; point, const Vector3&amp; norm) : n{ norm }, dist{ -dot(norm, point) } {}<br>
        &nbsp;&nbsp;&nbsp; // 三角ポリゴン 3点p0,p1,p2 から平面を確定させて生成 dist(原点からの距離) は 法線normal と 点p0 から計算<br>
        &nbsp;&nbsp;&nbsp; Plane4(const Vector3&amp; p0, const Vector3&amp; p1, const Vector3&amp; p2) : n{ polygonNorm(p0, p1, p2) }, dist{ -dot(n, p0) } {}<br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual ~Plane4() {}<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 平面を正規化する (平面の法線を単位ベクトル化する)<br>
        &nbsp;&nbsp;&nbsp; inline Plane4 normalized() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float mag = n.magnitude();<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (mag &lt; 0.00001f) // ほぼ0ベクトルか？<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Plane4{ n / mag, dist / mag};<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 原点から一番近い平面上の点を求める 法線ベクトルにマイナス方向のdist(原点からの距離)を掛けることで原点から一番近い平面上の1点になる<br>
        &nbsp;&nbsp;&nbsp; inline Vector3 nearestFromOrigin() { return n * -dist; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 平面 から 点point までの距離を求める<br>
        &nbsp;&nbsp;&nbsp; inline float distance(const Vector3&amp; point) const { return dot(n, point) + dist; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 位置はそのままに表裏をひっくり返す https://nekojara.city/unity-plane-struct<br>
        &nbsp;&nbsp;&nbsp; inline Plane4&amp; flip() { n = -n; dist = -dist; return *this; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 位置はそのままに表裏をひっくり返した平面を複製する(もとのPlane4はかわらない) https://nekojara.city/unity-plane-struct<br>
        &nbsp;&nbsp;&nbsp; inline Plane4 flipedCopy() { return Plane4(-n, -dist); }<br>
        <br>
        &nbsp;&nbsp;&nbsp; /*-----　演算子オーバーロード　-----*/<br>
        <br>
        &nbsp;&nbsp;&nbsp; // + 演算子のオペレータ<br>
        &nbsp;&nbsp;&nbsp; inline Plane4 operator + () const { return *this; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // - 逆向き平面 (法線ベクトルが逆向き)<br>
        &nbsp;&nbsp;&nbsp; inline Plane4 operator - () const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Plane4(-n, -dist);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; enum class Side<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; OnPlane, // 平面上にある<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; InterPlane, // 平面を横切る<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Front, // 平面から見て前面にある<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Behind, // 平面から見て背面にある<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 点point が平面上、前面、背面側のどこにあるかを返し、resultDistにはその距離を返す<br>
        &nbsp;&nbsp;&nbsp; inline Side pointSide(const Vector3&amp; point, float* resultDist = nullptr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float answerDist = this-&gt;distance(point); // 平面 から pointへの距離<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (resultDist != nullptr) *resultDist = answerDist; // 答え(距離)を返す<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (answerDist &gt; FLT_EPSILON) return Side::Front; // 平面の前面の側に点pointがある<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (answerDist &lt; FLT_EPSILON) return Side::Behind; // 平面の背面の側に点pointがある<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Side::OnPlane; // 点point が平面上にある<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 球(中心:center,半径:Radius) が 平面上、前面、背面側のどこにあるかを返し、resultDistにはその距離を返す<br>
        &nbsp;&nbsp;&nbsp; inline Side sphereSide(const Vector3&amp; center, const float Radius, float* resultDist = nullptr) const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float answerDist = distance(center); // 平面 から 球の中心:center の距離<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (resultDist != nullptr) *resultDist = answerDist; // 答え(距離)を返す<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float absDist = (answerDist &lt; 0) ? -answerDist : answerDist;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (absDist &lt; Radius) return Side::OnPlane; // 球 が平面上にある<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (answerDist &gt;= Radius)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Side::Front; // 平面の前面の側に 球 がある<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Side::Behind; // 平面の背面の側に 球 がある<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        <br>
        // 一致 == 演算子オペレータ 法線ベクトルnorm と 距離 distが一致する<br>
        inline bool operator == (const Plane4&amp; left, const Plane4&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; (left.n == right.n &amp;&amp; left.dist == right.dist);<br>
        }<br>
        <br>
        // 不一致 != 演算子オペレータ 法線ベクトルnorm か 距離 distが一致しない<br>
        inline bool operator != (const Plane4&amp; left, const Plane4&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left == right);<br>
        }<br>
        <br>
        // 平面 と ベクトルの内積 (平面の法線ベクトル と 他のベクトルの内積)<br>
        inline float dot(const Plane4&amp; plane, const Vector3&amp; rightVec)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return plane.nx * rightVec.x + plane.ny * rightVec.y + plane.nz * rightVec.z; //普通にx同士,y同士,z同士掛けるだけ<br>
        }<br>
        <br>
        // 線形補間する start:開始位置&nbsp; end:終了位置&nbsp; t = 補間の割合（start側が100%&nbsp; 0.0～1.0&nbsp; end側が100% でブレンド)<br>
        inline Plane4 lerp(const Plane4&amp; start, const Plane4&amp; end, float t)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Plane4 plane;<br>
        &nbsp;&nbsp;&nbsp; plane.n = start.n * (1.0f - t) + end.n * t; // startを始点に tの割合ぶんendへ近づける<br>
        &nbsp;&nbsp;&nbsp; plane.n = plane.n.normalized(); // 法線を単位ベクトル化(大きさ1)する<br>
        &nbsp;&nbsp;&nbsp; plane.dist = start.dist * (1.0f - t) + end.dist * t;<br>
        &nbsp;&nbsp;&nbsp; return plane;<br>
        }<br>
        <br>
        // 2次補間する start:開始位置 mid:中間制御点 end:終了位置&nbsp; t = 補間の割合（start側が100%&nbsp; 0.0～1.0&nbsp; end側が100% でブレンド)<br>
        inline Plane4 quadratic(const Plane4&amp; start, const Plane4&amp; mid, const Plane4&amp; end, float t)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Plane4 plane;<br>
        &nbsp;&nbsp;&nbsp; plane.n = start.n * (1.0f - t) * (1.0f - t) + 2 * mid.n * t * (1.0f - t) + end.n * t * t;<br>
        &nbsp;&nbsp;&nbsp; plane.n = plane.n.normalized(); // 法線を単位ベクトル化(大きさ1)する<br>
        &nbsp;&nbsp;&nbsp; plane.dist = start.dist * (1.0f - t) * (1.0f - t) + 2 * mid.dist * t * (1.0f - t) + end.dist * t * t;<br>
        &nbsp;&nbsp;&nbsp; return plane;<br>
        }<br>
        <br>
        #endif<br>
      </p>
      <br>
      そして、次はこのVector3.hとPlane4.hを駆使して、3D空間での当たり判定をする関数を定義するCollision3D.hを準備します。<br>
      <br>
      <p><code>Collision3D.hを新規作成</code>して球、円柱、カプセル、線、三角ポリゴン、平面などや光線(レイ)との当たり判定をするためのisCollision系関数群を準備します。</p>
      <p class="source">#ifndef COLLISION3D_H_<br>
        #define COLLISION3D_H_<br>
        <br>
        #include "Vector3.h"<br>
        #include "Plane4.h"<br>
        <br>
        //-------------- 球、円柱、線分(レイ)、カプセル、ポリゴンのエッジなどの当たり判定---------------------------<br>
        <br>
        // 点:point と box:AABB(軸並行境界ボックス：Axis-Aligned Bounding Box)の当たり判定 http://marupeke296.com/COL_3D_No11_AABBvsPoint.html<br>
        inline bool isCollisionPoint_AABB(const Vector3&amp; point, const Vector3&amp; leftTop, const Vector3&amp; rightBottom)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return nearestLengthPoint_AABB(point, leftTop, rightBottom) &gt; 0; // 最短距離が0以上なら当たっている<br>
        }<br>
        <br>
        <br>
        // 球体と球体の衝突判定<br>
        inline bool isCollisionSphere_Sphere(const Vector3&amp; center0, float Radius0, const Vector3&amp; center1, float Radius1)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return (center1 - center0).sqrMagnitude() &lt;= (Radius0 + Radius1) * (Radius0 + Radius1);<br>
        }<br>
        <br>
        // 球体とレイ(光線)の当たり判定 rayPos:レイの起点 rayDir:レイの方向 result0:球体とレイの衝突開始点 result1:球体とレイの衝突終了点 <br>
        inline bool isCollisionSphere_Ray(const Vector3&amp; center, float Radius, const Vector3&amp; rayPos, const Vector3&amp; rayDir, Vector3* result0 = nullptr, Vector3* result1 = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; centerToRayPos = rayPos - center; // 球体の中心からレイの起点までを結ぶベクトル<br>
        &nbsp;&nbsp;&nbsp; // 球体とレイの交差判定を行う<br>
        &nbsp;&nbsp;&nbsp; float rayDistSq = rayDir.sqrMagnitude(); // レイの方向ベクトル大きさの2乗<br>
        &nbsp;&nbsp;&nbsp; float rayDirDot = dot(centerToRayPos, rayDir); // レイと球の中心を結ぶ線とレイの方向の内積(レイの方向へ直角に下したベクトル)<br>
        &nbsp;&nbsp;&nbsp; float rayToSphereSq = centerToRayPos.sqrMagnitude() - Radius * Radius; // レイ起点から球の表面までの距離の2乗<br>
        &nbsp;&nbsp;&nbsp; float dif = rayDirDot * rayDirDot - rayDistSq * rayToSphereSq;<br>
        &nbsp;&nbsp;&nbsp; if (dif &lt; 0.0f) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result0 != nullptr || result1 != nullptr) // resultがnullptrじゃないときには球体とレイの交点も求める<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float sqrt_dif = std::sqrt(dif);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t0 = (-rayDirDot - sqrt_dif) / rayDistSq; // 交点までt0倍のばせば球体とレイの衝突開始点になる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result0 = rayDir * t0 + rayPos; // レイの方向をt0倍のばして球体との交点の位置を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t1 = (-rayDirDot + sqrt_dif) / rayDistSq; // 交点までt1倍のばせば球体とレイの衝突終了点になる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result1 = rayDir * t1 + rayPos; // レイの方向をt1倍のばして球体との交点の位置を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return true;<br>
        }<br>
        <br>
        // 無限円柱(シリンダー)がレイ(起点:rayPos 方向ベクトル:rayDir)と衝突するか? result0:円柱とレイが衝突した貫通開始点&nbsp; result1:円柱とレイが衝突した貫通終了点 <br>
        inline bool isCollisionCilinderInf_Ray(const Vector3&amp; cilinderStart, const Vector3&amp; cilinderEnd, float cilinderRadius, const Vector3&amp; rayPos, const Vector3&amp; rayDir, Vector3* result0 = nullptr, Vector3* result1 = nullptr)<br>
        {&nbsp;&nbsp; //[円柱とレイの当たり判定] http://marupeke296.com/COL_3D_No25_RayToSilinder.html<br>
        &nbsp;&nbsp;&nbsp; Vector3 p1 = cilinderStart - rayPos; // レイの起点からシリンダーの 始点 に向かうベクトル<br>
        &nbsp;&nbsp;&nbsp; //Vector3 p2 = cilinderEnd - rayPos; // レイの起点からシリンダーの 終点 に向かうベクトル<br>
        &nbsp;&nbsp;&nbsp; Vector3 s = cilinderEnd - cilinderStart; // シリンダーの軸に沿うベクトル<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 各種内積値 v = rayDirとして考える<br>
        &nbsp;&nbsp;&nbsp; float Dvv = rayDir.sqrMagnitude();<br>
        &nbsp;&nbsp;&nbsp; float Dsv = dot(s, rayDir);<br>
        &nbsp;&nbsp;&nbsp; float Dpv = dot(p1, rayDir);<br>
        &nbsp;&nbsp;&nbsp; float Dss = s.sqrMagnitude();<br>
        &nbsp;&nbsp;&nbsp; float Dps = dot(p1, s);<br>
        &nbsp;&nbsp;&nbsp; float Dpp = p1.sqrMagnitude();<br>
        &nbsp;&nbsp;&nbsp; float rr = cilinderRadius * cilinderRadius;<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (Dss == 0.0f) return false; // 円柱が定義されない<br>
        <br>
        &nbsp;&nbsp;&nbsp; float A = Dvv - Dsv * Dsv / Dss;<br>
        &nbsp;&nbsp;&nbsp; float B = Dpv - Dps * Dsv / Dss;<br>
        &nbsp;&nbsp;&nbsp; float C = Dpp - Dps * Dps / Dss - rr;<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (A == 0.0f) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp; float d = B * B - A * C;<br>
        &nbsp;&nbsp;&nbsp; if (d &lt; 0.0f) return false; // レイが円柱と衝突していない<br>
        &nbsp;&nbsp;&nbsp; d = std::sqrtf(d);<br>
        <br>
        &nbsp;&nbsp;&nbsp; float a1 = (B - d) / A;<br>
        &nbsp;&nbsp;&nbsp; float a2 = (B + d) / A;<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result0 != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result0 = rayPos + a1 * rayDir;<br>
        &nbsp;&nbsp;&nbsp; if (result1 != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result1 = rayPos + a2 * rayDir;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return true;<br>
        }<br>
        <br>
        // カプセルがレイ(起点:rayPos 方向ベクトル:rayDir)と衝突するか? result0:カプセルとレイが衝突した貫通開始点&nbsp; result1:カプセルとレイが衝突した貫通終了点 <br>
        inline bool isCollisionCapsule_Ray(const Vector3&amp; capsuleStart0, const Vector3&amp; capsuleEnd1, float capsuleRadius,<br>
        &nbsp;&nbsp;&nbsp; const Vector3&amp; rayPos, const Vector3&amp; rayDir, Vector3* result0 = nullptr, Vector3* result1 = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; //[カプセルとレイの当たり判定] http://marupeke296.com/COL_3D_No26_RayToCapsule.html<br>
        &nbsp;&nbsp;&nbsp; bool result0inSphere0 = false;<br>
        &nbsp;&nbsp;&nbsp; bool result0inSphere1 = false;<br>
        &nbsp;&nbsp;&nbsp; bool result0inCilinder01 = false;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // Q1の検査<br>
        &nbsp;&nbsp;&nbsp; if (isCollisionSphere_Ray(capsuleStart0, capsuleRadius, rayPos, rayDir, result0, result1) &amp;&amp; dot(capsuleEnd1 - capsuleStart0, *result0 - capsuleStart0) &lt;= 0.0f)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result0inSphere0 = true; // result0は球面上(capsuleStart0が中心の球)にある<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (isCollisionSphere_Ray(capsuleEnd1, capsuleRadius, rayPos, rayDir, result0, result1) &amp;&amp; dot(capsuleStart0 - capsuleEnd1, *result0 - capsuleEnd1) &lt;= 0.0f)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result0inSphere1 = true; // result0は球面上(capsuleEnd1が中心の球)にある<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (isCollisionCilinderInf_Ray(capsuleStart0, capsuleEnd1, capsuleRadius, rayPos, rayDir, result0, result1)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; dot(capsuleEnd1 - capsuleStart0, *result0 - capsuleStart0) &gt; 0.0f<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; dot(capsuleStart0 - capsuleEnd1, *result0 - capsuleEnd1) &gt; 0.0f)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result0inCilinder01 = true; // result0は円柱面にある<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // レイは衝突していない<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result1 != nullptr)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // result1の検査<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float tx, ty, tz; // ダミー<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0inSphere0 &amp;&amp; dot(capsuleEnd1 - capsuleStart0, *result1 - capsuleStart0) &lt;= 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // result0、result1 両方 球面上(capsuleStart0が中心の球)にある<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (result0inSphere1 &amp;&amp; dot(capsuleStart0 - capsuleEnd1, *result1 - capsuleEnd1) &lt;= 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // result0、result1 両方 球面上(capsuleEnd1が中心の球)にある<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (result0inCilinder01<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; dot(capsuleEnd1 - capsuleStart0, *result1 - capsuleStart0) &gt; 0.0f<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; dot(capsuleStart0 - capsuleEnd1, *result1 - capsuleEnd1) &gt; 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // result0、result1 両方 円柱面にある<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionSphere_Ray(capsuleStart0, capsuleRadius, rayPos, rayDir, nullptr, result1) &amp;&amp; dot(capsuleEnd1 - capsuleStart0, *result1 - capsuleStart0) &lt;= 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // result1 は 球面上(capsulStart0が中心の球)にある<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionSphere_Ray(capsuleEnd1, capsuleRadius, rayPos, rayDir, nullptr, result1) &amp;&amp; dot(capsuleStart0 - capsuleEnd1, *result1 - capsuleEnd1) &lt;= 0.0f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // result1 は 球面上(capsuleEnd1が中心の球)にある<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // result1 が円柱上にある事が確定したのでresult1を計算<br>
        &nbsp;&nbsp;&nbsp; isCollisionCilinderInf_Ray(capsuleStart0, capsuleEnd1, capsuleRadius, rayPos, rayDir, nullptr, result1);<br>
        &nbsp;&nbsp;&nbsp; return true; // result1 が円柱上にある<br>
        }<br>
        <br>
        <br>
        // 球体と有限の線分との当たり判定 lineStart:線の起点 lineEnd:線の終点 result:球体と線分の交点<br>
        inline bool isCollisionSphere_Line(const Vector3&amp; center, float Radius, const Vector3&amp; lineStart, const Vector3&amp; lineEnd, Vector3* result = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; lineVec = lineEnd - lineStart; // endからstartを引いて有限の線分のベクトルを求める<br>
        &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; nearestPoint = nearestPointOnLine(center, lineStart, lineVec, false); // 点center から一番近い直線lineVec上の点を求める<br>
        <br>
        &nbsp;&nbsp;&nbsp; float distSq = (center - nearestPoint).sqrMagnitude(); // 球体の中心と lineVec線上 の一番近い点の距離の2乗を求める<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (distSq &gt; Radius * Radius) return false; // 距離の2乗が球体の半径の2乗よりも長い場合は球と線は衝突していない<br>
        &nbsp;&nbsp;&nbsp; // ↑有限の線なので半径との距離を比べてしまえばあとは 球体とレイ(無限の線)の判定と変わらない<br>
        &nbsp;&nbsp;&nbsp; return isCollisionSphere_Ray(center, Radius, lineStart, lineVec.normalized(), result); // 球体とレイ(光線)の当たり判定<br>
        }<br>
        <br>
        // 線分line0 と 線分line1 の当たり判定 isInfinite:無限の長さの線かどうか epsilon:判定の精度 result0:line0上の最も近い点 result1:line1上の最も近い点 <br>
        inline bool isCollisionLine_Line(const Vector3&amp; line0Start, const Vector3&amp; line0End, const Vector3&amp; line1Start, const Vector3&amp; line1End,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isInfinite = false, float epsilon = 0.001f, Vector3* result0 = nullptr, Vector3* result1 = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float t0, t1;<br>
        &nbsp;&nbsp;&nbsp; Vector3 answer0, answer1; // answer0:line0上の最も近い点 answer1:line1上の最も近い点<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector3 v0 = line0End - line0Start; // line0 のベクトル<br>
        &nbsp;&nbsp;&nbsp; Vector3 v1 = line1End - line1Start; // line1 のベクトル<br>
        &nbsp;&nbsp;&nbsp; float lengthSq0 = v0.sqrMagnitude(); // ベクトルの大きさ(長さ)の2乗<br>
        &nbsp;&nbsp;&nbsp; float lengthSq1 = v1.sqrMagnitude(); // ベクトルの大きさ(長さ)の2乗<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (lengthSq0 &lt; FLT_EPSILON) // 線分のベクトルの長さがほぼ0なら 実質、点line0Start と 線line1 との当たり判定でよい<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer0 = line0Start; // line0の起点が一番近い<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer1 = nearestPointOnLine(line0Start, line1Start, v1, isInfinite); // 点line0Start から一番近い直線line1上の点を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (lengthSq1 &lt; FLT_EPSILON)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer1 = line1Start; // line1の起点が一番近い<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer0 = nearestPointOnLine(line1Start, line0Start, v0, isInfinite); // 点line1Start から一番近い直線line0上の点を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else // line0 と line1 の大きさが 0 よりは充分に大きい なら 線どうしの当たり判定とみなして計算してもよい<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[参考動画:直線と直線の最短距離] https://youtu.be/b3fwHCKkro0?t=196<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // この動画の式を変形して dif01判定を事前分離し 0 での割り算を回避<br>
        #if 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dv0v1 = -dot(v0, v1);// = dot(v0, -v1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dv1v1 = lengthSq1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dv0v0 = lengthSq0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; v01 = line1Start - line0Start;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _t1 = (dv0v1 * dot(v0, v01) - dv0v0 * dot(v1, v01)) / (dv1v1 * dv0v0 - dv0v1 * dv1v0);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (dv1v0 * dot(v0, v01) - lengthSq0 * dot(v1, v01)) / (lengthSq1 * lengthSq0 - dv0v1 * dv0v1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _dif01 = lengthSq0 * lengthSq1 - dv0v1 * dv0v1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _dot_v0v01 = -dot(v0, v01); // = dot(v0, -v01);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _dot_v1v01 = dot(v1, v01); // = -dot(v1, -v01);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float ___t1 = (dv0v1 * dot(v0, -v01) - lengthSq0 * dot(v1, -v01)) / dif01;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (-dv0v1 * _dot_v1v01 + lengthSq0 * _dot_v1v01) / dif01;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _t0 = dot(v0, (line1Start + (-v1) * t1 - line0Start)) / lengthSq0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = dot(v0, (v01 - v1 * t1)) / lengthSq0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (dot_v0v01 - dot_v0v1 * t1) / lengthSq0; // ムズイけど出た<br>
        #endif<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dot_v0v1 = -dot(v0, v1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // aとbが同じ向きで平行なら |a||b| - a・b = 0に近づく https://www.nekonecode.com/math-lab/pages/collision2/point-and-segment/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dif01 = lengthSq0 * lengthSq1 - dot_v0v1 * dot_v0v1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float absDif01 = (dif01 &lt; 0) ? -dif01 : dif01; // dif01の絶対値<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (absDif01 &lt; FLT_EPSILON) // 線が交差しないとき(最小誤差ε以内のとき)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 交差しない線どうしの最も近い点を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearestPointOfParallelLine(line0Start, line0End, line1Start, line1End, isInfinite, &amp;answer0, &amp;answer1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入して関数の外に返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // 線が交差するとき(最小誤差εを超えるとき)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 交差する線分の同士の最も近い点を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; v01 = line1Start - line0Start;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dot_v0v01 = dot(v0, v01);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dot_v1v01 = -dot(v1, v01);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = (lengthSq0 * dot_v1v01 - dot_v0v01 * dot_v0v1) / dif01;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = (dot_v0v01 - dot_v0v1 * t1) / lengthSq0;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer0 = v0 * t0 + line0Start; // v0の方向をt0倍のばして一番近い直線上の点の位置を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer1 = v1 * t1 + line1Start; // v1の方向をt1倍のばして一番近い直線上の点の位置を求める<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 有限の線の場合で、線を超えた位置(0～1.0の範囲外)に最も近い点が見つかった場合<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((isInfinite == false) &amp;&amp; (t0 &lt; 0.0f || 1.0f &lt; t0 || t1 &lt; 0.0f || 1.0f &lt; t1))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 線分line0 と 線分line1 の【有限の線上範囲内】での一番近い点を求めなおす(0～1の範囲内に収まるもっとも近い点を求めなおす) <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearestPointsOnFiniteLines(line0Start, line0End, line1Start, line1End, t0, t1, answer0, answer1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0; // resultがnullptrじゃなければ答えを代入して関数の外に返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 最も近い点どうしの距離の2乗 が epsilon(精度の2乗) 以下なら線どうしは衝突と判定<br>
        &nbsp;&nbsp;&nbsp; if ((answer1 - answer0).sqrMagnitude() &lt;= epsilon * epsilon) return true;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; false;<br>
        }<br>
        <br>
        // カプセル0 capsule0 と カプセル1 capsule1 の当たり判定 result0:カプセル0の芯line0線上のline1に最も近い点 result1:カプセル1の芯line1線上のline0に最も近い点 <br>
        inline bool isCollisionCapsule_Capsule(const Vector3&amp; capsule0Start, const Vector3&amp; capsule0End, float capsule0Radius,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Vector3&amp; capsule1Start, const Vector3&amp; capsule1End, float capsule1Radius,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3* result0 = nullptr, Vector3* result1 = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 nearest0;<br>
        &nbsp;&nbsp;&nbsp; Vector3 nearest1;<br>
        &nbsp;&nbsp;&nbsp; // カプセルどうしの当たり判定は、実質、線(有限)どうしの当たり判定(線の 距離epsilon が カプセル0半径 + カプセル1半径↓)<br>
        &nbsp;&nbsp;&nbsp; bool isCollision = isCollisionLine_Line(capsule0Start, capsule0End, capsule1Start, capsule1End, false, capsule0Radius + capsule1Radius, &amp;nearest0, &amp;nearest1);&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; // カプセル軸上の最短距離をむすぶ 法線ベクトル:norm と 距離:mag を求める<br>
        &nbsp;&nbsp;&nbsp; Vector3 v01 = nearest1 - nearest0; // 最短距離の2点 nearest0 から nearest1 へ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp; float mag01 = v01.magnitude(); // nearest0とnearest1の距離<br>
        &nbsp;&nbsp;&nbsp; Vector3 norm01 = v01.normalized(); // 正規化normalizeする<br>
        &nbsp;&nbsp;&nbsp; if (mag01 == 0.0f) // カプセルの軸が交差しているときはnearest0とnearest1が同じ点になっちゃう<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 center0 = (capsule0Start + capsule0End) / 2.0f; // カプセル0の中心点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 center1 = (capsule1Start + capsule1End) / 2.0f; // カプセル1の中心点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; norm01 = (center1 - center0).normalized(); // 中心同士の差ベクトルを法線に<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (center0 == center1) // 中心位置が完全一致するときは<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; norm01 = Vector3{ 1.0f,0.0f,0.0f }; // 仕方ないからx軸方向に引き離す(2DでもつじつまあうようにX軸で)<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector3 answer0 = nearest0 + norm01 * capsule0Radius; // nearest0からnearest1の方向へ、カプセル半径0の半径 進んだ位置が衝突点<br>
        &nbsp;&nbsp;&nbsp; Vector3 answer1 = nearest1 - norm01 * capsule1Radius; // nearest1からnearest0の方向へ、カプセル半径1の半径 進んだ位置が衝突点<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result0 != nullptr) *result0 = answer0;<br>
        &nbsp;&nbsp;&nbsp; if (result1 != nullptr) *result1 = answer1;<br>
        &nbsp;&nbsp;&nbsp; return isCollision;<br>
        }<br>
        <br>
        // point がポリゴンpPolygonの内側にあるか判定 numVertices:ポリゴンの頂点の数 percent:99% の精度でポリゴンの内部<br>
        inline bool isInsidePolygon(const Vector3&amp; point, const Vector3* pPoly, unsigned int numVertices, float percent = 0.99f)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float cos_theta, length1, length2;<br>
        &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; v1, v2;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ポリゴンの各頂点とpPointとの間の角度の合計が2πに近ければpPointはポリゴンの内部にある<br>
        &nbsp;&nbsp;&nbsp; float angle = 0.0f;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; numVertices; i++)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v1 = pPoly[i] - point; // pointとi番目のポリゴンの頂点を結ぶベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v2 = pPoly[(i + 1) % numVertices] - point; // pPointとi+1番目の頂点を結ぶベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length1 = v1.magnitude();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length2 = v2.magnitude();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点と交点の距離が 0.0001f以下ならポリゴンの内部と判定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (length1 &lt; 0.0001f || length2 &lt; 0.0001f)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; true;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 二つのベクトルのあいだのcosθ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos_theta = dot(v1, v2) / (length1 * length2);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 角度の合計を足して合計を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle += std::acos(GET_CLAMP(cos_theta, -1.0f, 1.0f));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; constexpr float pi2 = 2 * 3.14159265359; // 2π = 360°<br>
        &nbsp;&nbsp;&nbsp; if (angle &gt;= percent * pi2) return true; // 角度の合計が 2π×0.99f 以上ならばポリゴンの内部判定<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; false;<br>
        }<br>
        <br>
        // ポリゴン pPolyのエッジ と 球(中心:center 半径:Radius) が当たっているか? result0:ポリゴンに当たらない位置へ球を押し戻すベクトル<br>
        inline bool isCollisionPolyEdge_Sphere(const Vector3* pPoly, int numVertices, const Vector3&amp; center, float Radius, Vector3* result0 = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; numVertices; i++) // 全てのポリゴンの点について調べる<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 球体の中心座標とポリゴンを結ぶ線分上の最も近い座標を求める */<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 polyEdgeVec = pPoly[(i + 1) % numVertices] - pPoly[i]; // ポリゴンの2点をつなぐ線(エッジ)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 nearest = nearestPointOnLine(center, pPoly[i], polyEdgeVec, false); // 球の中心から最も近いポリゴン線上の 点nearset<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 線分上の座標と球体の中心座標の距離を求める */<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float nearestDistSq = (nearest - center).sqrMagnitude(); // 球の中心 から 点nearset までの距離の2乗<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 球体から 1番近いポリゴン線上の点 と 球体中心 の距離 が球の半径以下なら当たっている<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nearestDistSq &lt; Radius * Radius)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ポリゴンと球体とが当たっているときは result0に ポリゴンに当たらないように球体を 押し戻すベクトル を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result0 != NULL) // 一番近い点から球中心へのベクトルを norm(単位化) して それを (半径 - 半径から一番近い点)倍すればあたらない位置になる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result0 = (center - nearest).normalized() * (Radius - std::sqrt(nearestDistSq));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; true; // 当たっている<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; return false; // 当たっていない<br>
        }<br>
        <br>
        <br>
        //-------------- 平面に関する当たり判定---------------------------<br>
        <br>
        <br>
        // 平面plane が レイ(起点:rayPos 方向ベクトル:rayDir) と 衝突するか result:平面とレイが衝突した場合の交点<br>
        inline bool isCollisionPlane_Ray(const Plane4&amp; plane, const Vector3&amp; rayPos, const Vector3&amp; rayDir, Vector3* result = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3 rayDirNorm = rayDir.normalized();<br>
        &nbsp;&nbsp;&nbsp; float dot_Plane_RayNorm = dot(plane, rayDirNorm);<br>
        &nbsp;&nbsp;&nbsp; if (dot_Plane_RayNorm == 0.0f) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (result != nullptr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t = plane.distance(rayPos) / dot_Plane_RayNorm;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = rayDirNorm * t + rayPos; // t倍にレイの方向を延長して 平面との交点を求める<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return true;<br>
        }<br>
        <br>
        // 平面 plane と 線(始点lineStart と 終点lineEnd を結ぶ線) が 接触するか<br>
        inline bool isCollisionPlane_Line(const Plane4&amp; plane, const Vector3&amp; lineStart, const Vector3&amp; lineEnd, Vector3* result = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 線の始点から平面までの距離 と 線の終点から平面までの距離 の符号が 両方+ または 両方- なら<br>
        &nbsp;&nbsp;&nbsp; if (plane.distance(lineStart) * plane.distance(lineEnd) &gt; 0)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 始点も終点も平面から見て 同じ サイドにあるので 線 と 平面はクロス しない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 始点と終点が平面から見て&nbsp; 逆&nbsp; サイドにあるので 線 と 平面はクロス する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面plane が レイ(起点:lineStart 方向ベクトル:lineEnd - lineStart) と 衝突するか<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return isCollisionPlane_Ray(plane, lineStart, lineEnd - lineStart, result); // resultに交点が求まる<br>
        &nbsp;&nbsp;&nbsp; }<br>
        }<br>
        <br>
        // 三角ポリゴン pPoly(頂点数:numVertices 平面:plane上に存在) が 線分(始点:lineStart 終点:lineEnd) と 交わるか result:ポリゴンと線分の交点<br>
        inline bool isCollisionPoly_Line(const Vector3* pPoly, unsigned int numVertices, const Plane4&amp; plane, const Vector3&amp; lineStart, const Vector3&amp; lineEnd, Vector3* result = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; answer; // 面と線分の交点<br>
        &nbsp;&nbsp;&nbsp; // 面と線分の交点をまず求める<br>
        &nbsp;&nbsp;&nbsp; if (isCollisionPlane_Line(plane, lineStart, lineEnd, &amp;answer) == false) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (isInsidePolygon(answer, pPoly, numVertices)) // 面と線の交わる交点 が ポリゴン内に存在する点なのかチェック<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result != nullptr) *result = answer; // result に こたえ(ポリゴンと線分の交点) を設定し返す<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // 交点がポリゴン内部にあった<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return false; // 面と線が交わらない&nbsp;&nbsp; もしくは&nbsp;&nbsp; 交わったとしても 交点がポリゴン内部になかった<br>
        }<br>
        <br>
        // 三角ポリゴン pPoly(頂点数:numVertices 平面:plane上に存在) が レイ(始点:rayPos 方向:rayDir) と 交わるか result:ポリゴンとレイの交点<br>
        inline bool isCollisionPoly_Ray(const Vector3* pPoly, unsigned int numVertices, const Plane4&amp; plane, const Vector3&amp; rayPos, const Vector3&amp; rayDir, Vector3* result = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector3&nbsp;&nbsp;&nbsp; answer; // 面と線分の交点<br>
        &nbsp;&nbsp;&nbsp; // 面とレイの交点をまず求める<br>
        &nbsp;&nbsp;&nbsp; if (isCollisionPlane_Ray(plane, rayPos, rayDir, &amp;answer) == false) return false;<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (isInsidePolygon(answer, pPoly, numVertices)) // 面と線の交わる交点 が ポリゴン内に存在する点なのかチェック<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result != nullptr) *result = answer; // result に こたえ(ポリゴンと線分の交点) を設定し返す<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // 交点がポリゴン内部にあった<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return false; // 面と線が交わらない&nbsp;&nbsp; もしくは&nbsp;&nbsp; 交わったとしても 交点がポリゴン内部になかった<br>
        }<br>
        <br>
        // 三角ポリゴン pPoly(頂点数:numVertices 平面:plane上に存在) が レイ(始点:rayPos 方向:rayDir) と 交わるか result:ポリゴンとレイの交点<br>
        inline bool isCollisionPoly_Sphere(const Vector3* pPoly, unsigned int numVertices, const Plane4&amp; plane, const Vector3&amp; center, float Radius, Vector3* result = nullptr)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float distance;<br>
        &nbsp;&nbsp;&nbsp; // まず、球とポリゴンのある平面が交差するかを求め、球の中心までの距離 distance をもとめる<br>
        &nbsp;&nbsp;&nbsp; if (plane.sphereSide(center, Radius, &amp;distance) != Plane4::Side::InterPlane) return false; // 交差していない<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector3 point = center - plane.n * distance; // 球の中心 - 面法線 * 距離 でポリゴン上の交点<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (isInsidePolygon(point, pPoly, numVertices)) // 交点point が ポリゴン内に存在する点なのかチェック<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float overDist = Radius - distance; // めり込みすぎた距離<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (distance &lt; 0) overDist = -overDist; // めり込みすぎた距離がマイナス方向の場合<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = plane.n * overDist; // result に こたえ(ポリゴンにめり込みすぎを押し戻すベクトル) を設定し返す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // 交点がポリゴン内部にあった<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return isCollisionPolyEdge_Sphere(pPoly, numVertices, center, Radius, result); // ポリゴンのエッジ部分が球体と交差しているか<br>
        }<br>
        <br>
        #endif<br>
      </p>
      <br>
      <br>
      <br>
      では、準備したVector3.hとCollision3D.hを使って、3D空間の当たり判定を試してみましょう。<br>
      <p><code>main.cpp</code>のコードにCollision3D.hのisCollision系関数を使って、3D空間の当たり判定をする処理を追加してみます。</p>
      <p class="source">#include "DxLib.h"<br>
        #include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
        #include "Input.h"<br>
        #include "Screen.h"<br>
        #include "Ply.h"<br>
        #include "DataMV1.h"<br>
        #include "DataPly.h"<br>
        <em>#include "Collision3D.h"</em><br>
        <br>
        #include "Editor.h"<br>
        <br>
        // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain からプログラムが開始する<br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間 違ってるかも<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
        &nbsp;&nbsp;&nbsp; float animTime = 0.0f; // アニメの現在時刻<br>
        &nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
        &nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@kick.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;Load(); // 3Dモデルをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilAttackAnimData = Resource::MakeShared&lt;DataMV1&gt;("Image/devil@jump.mv1");<br>
        &nbsp;&nbsp;&nbsp; pDevilAttackAnimData-&gt;Load(); // 3Dの追加アニメデータをmv1形式で読込み<br>
        &nbsp;&nbsp;&nbsp; pDevilData-&gt;AttachAnim(*pDevilAttackAnimData); // アニメを追加でflyのほうをベースとしたモデルにアタッチ<br>
        &nbsp;&nbsp;&nbsp; int animeButton = 0; // ボタンでアニメを切り替えられるようにする<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; pTexImage = Resource::MakeShared&lt;Texture&gt;("Image/dice.png");<br>
        &nbsp;&nbsp;&nbsp; pTexImage-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; assert((int)*pTexImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataPly&gt; pPlyData = Resource::MakeShared&lt;DataPly&gt;("Image/dice.ply");<br>
        &nbsp;&nbsp;&nbsp; pPlyData-&gt;Load(); // MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
        &nbsp;&nbsp;&nbsp; <br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
        &nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f; keyControlXYZ.z = 0;<br>
        &nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 = SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0, "サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 = SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1, "サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 = SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1, "サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0, 255));<br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 = SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
        <br>
        &nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); // エディタのシングルトン参照を得る<br>
        <br>
        &nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // マウスのドラッグなどを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens(); // スクリーンの位置やドラッグによる移動を更新する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput(); // エディタのキーのインプットを更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput(); // エディタのマウスのインプットを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); // エディタのカメラを更新<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードの 0 1 キーで3Dアニメを切り替えられるようにする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_0))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_1))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animeButton = 1;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput = GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -= speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp; PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position = VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width =&nbsp; pTexImage-&gt;m_XSize; float height =&nbsp; pTexImage-&gt;m_YSize; // テクスチャ画像のサイズ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f, 1.0f, 1.0f); // 拡大縮小スケール<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_A) keyControlAngle.x += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_B) keyControlAngle.y += speed;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp; PAD_INPUT_C) keyControlAngle.z += speed;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad = DX_PI_F / 180.0f; // 角度(単位:°度)からラジアン(単位:rad)へ変換する係数<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate = keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z * Deg2Rad;<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp; matWorldDefault; // デフォルトのワールド行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); // デフォルトのワールド行列を記憶しておく<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX mat; // モデルのスケール×回転×移動を行列計算で設定する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[スケール]拡大縮小のスケール行列を得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [勉強]↓スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y; mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] = 0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp; mat.m[3][3] = 1.0f;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[回転]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matRot;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::CreateIdentityMatrix(&amp;matRot);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★MMultは行列の乗算【乗算した順にz軸回転→x軸回転→y軸回転→平行移動】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotZ(zRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotX(xRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matRot = MMult(matRot, MGetRotY(yRotate));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matRot); //スケール × 回転<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[移動]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX matTrans = MGetTranslate(VGet(position.x, position.y, position.z)); // 位置positionをここで設定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat = MMult(mat, matTrans); //スケール×回転×移動<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawPolygon32bitIndexed3D(pPlyData-&gt;Vertex.data(), pPlyData-&gt;Vertex.size(), pPlyData-&gt;Index.data(), pPlyData-&gt;numIndex / 3, (int)*pTexImage, FALSE); // 三角形ポリゴンをたくさん描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 100, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x, position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ファイルのパス + ":" + アニメ名でアクセス<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string animPathName = (animeButton == 0) ? "Image/devil@kick.mv1:mixamo.com" : "Image/devil@jump.mv1:mixamo.com";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(pDevilData-&gt;count(animPathName) &gt; 0 &amp;&amp; "指定されたアニメ名のアニメはMV1に付属していませんでした");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime += animStepTime * animSpeed; // 1.0×2倍 なら2倍速でアニメ時刻が進む<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animTime &gt; (*pDevilData)[animPathName].endTime)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime = 0.0f; // 0秒目へとアニメをループさせる<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 画面奥へ向かう光線レイを求める<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 rayStart = DxLib::ConvScreenPosToWorldPos(VGet(Input::MouseX, Input::MouseY, 0.0f));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 rayEnd = DxLib::ConvScreenPosToWorldPos(VGet(Input::MouseX, Input::MouseY, 1.0f));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(rayStart, rayEnd, GetColor(255, 255, 0));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 球0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 sphere0Center{ 10,10,10 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float sphere0Radius = 10;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 collision0;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision0 = isCollisionSphere_Line(sphere0Center, sphere0Radius, rayStart, rayEnd, &amp;collision0); // 球と光線(レイ)の当たり判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(sphere0Center, sphere0Radius, 16, (isCollision0) ? GetColor(255, 0, 0) : GetColor(255, 255, 255), GetColor(255, 255, 255), FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision0) DxLib::DrawSphere3D(collision0, 0.5, 16, GetColor(255, 0, 0), GetColor(255, 255, 255), TRUE); // レイと当たった部分に赤い球を表示<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 球1<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 sphere1Center{ 10,-10,10 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float sphere1Radius = 10;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 collision1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision1 = isCollisionSphere_Ray(sphere1Center, sphere1Radius, rayStart, rayEnd - rayStart, &amp;collision1); // 球と光線(レイ)の当たり判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(sphere1Center, sphere1Radius, 16, (isCollision1) ? GetColor(0, 255, 0) : GetColor(255, 255, 255), GetColor(255, 255, 255), FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision1) DxLib::DrawSphere3D(collision1, 0.5, 16, GetColor(0, 255, 0), GetColor(255, 255, 255), TRUE); // レイと当たった部分に緑の球を表示</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 再生時間をセットする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::MV1SetAttachAnimTime((int)*pDevilData, (*pDevilData)[animPathName].index, animTime);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 半透明のスクリーンも描ける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart(); // このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); // サブのスクリーンを全部描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); // エディタのDraw処理<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう? レイと球の当たり判定が表示されたでしょうか? <br>
      <br>
      <br>
    </a>
  </body>
</html>
