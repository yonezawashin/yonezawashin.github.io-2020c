<!DOCTYPE HTML>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>[C++]3D描画エンジン</title>
  <link rel="stylesheet" href="style.css">
  <style>
      
    </style>
</head>
<body>
<p class="title">[C++]3D描画エンジン1</p>
<ol id="mozToc">
<!--mozToc h1 1-->
  <li><a href="#mozTocId0001">試しにポリゴンを表示してみる</a></li>
  <li><a href="#mozTocId0002">ポリゴンの光の色表示の基礎となっている「拡散反射光:ディフューズ値」の値を変更してみ
る</a></li>
  <li><a href="#mozTocId0003">シンプルな.ply形式の3Dデータフォーマットを読み取ってポリゴン表示してみる</a></li>
  <li><a href="#mozTocId0004">別の描画スクリーンを作って、Windowsみたいなサブのウィンドウを描く</a></li>
  <li><a href="#mozTocId0005">エディタを自作して視点カメラを動かせるようにする</a></li>
  <li><a href="#mozTocId0006">キーボードのWSキーでカメラ視点を手前や奥に移動できるようにする</a></li>
  <li><a href="#mozTocId0007">キーボードのDAキーとEQキーでカメラ視点を左右や上下に移動できるようにする</a></li>
  <li><a href="#mozTocId0008">Unityのアセットストアからとってきたテクスチャ1枚のシンプルな3DモデルをDXの
モデルビューアで.mv1形式に変換して表示させてみる</a></li>
  <li><a href="#mozTocId0009">MV1形式の3Dモデルをアニメーション描画する</a></li>
  <li><a href="#mozTocId0010">複数の3DモデルやアニメをResourceクラスで2重ロードしないよう読み込んで複数
アニメを切替えする</a></li>
</ol>
<br>
<h2><a id="mozTocId0001" class="mozTocH1"></a>試しにポリゴンを表示してみる</h2>
<p><code>main.cpp</code>にプログラムを追加し、ポリゴン画像が正しく表示できるかテストします。<br>
(DXの<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId0002">プロジェクトとScreen.hはシューティングの別記事を参考</a>に作っておいてください、<span
 style="font-weight: bold; text-decoration: underline;">画像ファイルは<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId0003">シューティングの別記事を参考</a>にImage/boss1.pngで保管</span>されている前提で進めます)</p>
<p class="source">#include
"DxLib.h"<br>
#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
#include "Screen.h"<br>
<br>
//
設定画面の【リンカー】&rarr;【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain
からプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR
lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
&nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32 ) ;
// 画面サイズWidth&times;Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);//
ウィンドウサイズWidth&times;Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;&nbsp;
SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間
違ってるかも<br>
<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
&nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return -1;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
&nbsp;&nbsp;&nbsp; int texImage = -1;<br>
&nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/boss1.png");<br>
&nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
&nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
&nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth,
&amp;imgHeight); // テクスチャ画像のサイズを得る<br>
<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
&nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0; keyControlXYZ.y =
Screen::Height; keyControlXYZ.z = 0;<br>
&nbsp;&nbsp;&nbsp; float keyControlAngle = 0.0f; // 回転<br>
&nbsp;&nbsp;&nbsp; int animTime = 0; // アニメーションの時刻カウンタ<br>
<br>
&nbsp;&nbsp;&nbsp; ScreenFlip();<br>
<br>
&nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0) <br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ProcessMessage() ==
0になるのは&times;ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ClearDrawScreen();//
一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput =
GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -=
speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y
+= speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x = keyControlXYZ.x;
float y = keyControlXYZ.y; float z = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth;
float height = imgHeight; // テクスチャ画僧のサイズ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float scaleX = 0.5f; float
scaleY = 0.5f; // 拡大縮小スケール<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
キーボードのzキー(A)とxキー(B)でz軸(画面奥方向)まわりに画像を回転<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_A)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlAngle += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_B) keyControlAngle -= speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad =
DX_PI_F / 180.0f; // 角度(単位:&deg;度)からラジアン(単位:rad)へ変換する係数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = 0 *
Deg2Rad;&nbsp; const float yRotate = 0 * Deg2Rad; const float zRotate =
keyControlAngle * Deg2Rad;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u0 = 0.0f; const
float v0 = 0.0f; // テクスチャのUV切り出し起点(u:0～1.0, v:0～1.0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u1 = 1.0f; const
float v1 = 1.0f; // テクスチャのUV切り出し終点 1.0は画像の右下を表す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerX = x + width *
scaleX / 2; // 四角形の中心(x+width/2,y-height/2,z)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerY = y - height *
scaleY / 2;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityのxyz方向と回転]
https://gametukurikata.com/basic/xyzaxis<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityの回転ZXYの順で適用したもの]
https://light11.hatenadiary.com/entry/2019/01/24/223705<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX TransformMatrix =
MGetTranslate(VGet(-centerX, -centerY, -z)); // 四角形の中心を
原点(0,0,0)に一旦移動させてから回転させる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
★MMultは行列の乗算【乗算した順にz軸回転&rarr;x軸回転&rarr;y軸回転&rarr;平行移動】<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix =
MMult(TransformMatrix, MGetRotZ(zRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix =
MMult(TransformMatrix, MGetRotX(xRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix =
MMult(TransformMatrix, MGetRotY(yRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix =
MMult(TransformMatrix, MGetTranslate(VGet(centerX, centerY, z))); //
四角形の中心ぶんだけ平行移動させて戻す<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 四角ポリゴンのインデックス順<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(時計回りが表面)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &darr;(x,y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 0-1 4 &larr;(x +
width * scale, y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; |/ /|<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 2 3-5 &larr;(x +
width * scale, y - height * scale)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &uarr;(x, y - height *
scale)&nbsp;&nbsp;&nbsp;&nbsp;
&uarr;[UIのy方向は下だが3D空間上は上が+方向なのでheightを-1方向に]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt;
rectVertex;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex.resize(4);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;unsigned
int&gt; rectIndex;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex.resize(6);&nbsp;
// 4頂点のうち 右上(1と4)と左下(2と3)は同位置に2つ頂点を使う(三角形2つぶんのため) 4頂点 + 2被り = 6<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4頂点分のデータをセット<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左上(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].pos =
VTransform(VGet(x, y, z), TransformMatrix);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].norm =
VGet(0.0f, 0.0f, -1.0f); // 法線ベクトル(面の反射方向:z方向-1.0のベクトルなら光がzマイナス方向に反射)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].dif =
GetColorU8(255, 255, 255, 255); // 拡散反射光の色<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].spc =
GetColorU8(255, 255, 255, 255); // 鏡面反射光の色<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].u = u0; //
テクスチャ切り出し点 U(横方向)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].v = v0; //
テクスチャ切り出し点 V(縦方向)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].su = 0.0f; //
補助テクスチャのUV(いまはない)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].sv = 0.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右上(1と4)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].pos =
VTransform(VGet(x + width * scaleX, y, z), TransformMatrix);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].norm =
VGet(0.0f, 0.0f, -1.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].dif =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].u = u1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].v = v0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].su = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].sv = 0.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左下(2と3)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].pos =
VTransform(VGet(x, y - height * scaleY, z), TransformMatrix);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].norm =
VGet(0.0f, 0.0f, -1.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].dif =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].u = u0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].v = v1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].su = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].sv = 0.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右下(5)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].pos =
VTransform(VGet(x + width * scaleX, y - height * scaleY, z),
TransformMatrix);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].norm =
VGet(0.0f, 0.0f, -1.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].dif =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].u = u1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].v = v1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].su = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].sv = 0.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2ポリゴン分のインデックス順データをセット<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[0] = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[1] = 1; // 0-1 4<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[2] = 2; // |/
/|&nbsp;&nbsp; 0,1,2で左上ポリゴンを 3,4,5で右下ポリゴンを描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[3] = 2; // 2 3-5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[4] = 1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[5] = 3;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++animTime;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isDrawPolygon =
animTime % 60 &gt; 30; // 30フレームに1回三角ポリゴン(1個)と四角(2個)を描くのを切り替える&darr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::<span
 style="font-weight: bold;">DrawPolygon32bitIndexed3D</span>(rectVertex.data(),
rectVertex.size(),
rectIndex.data(),
(isDrawPolygon)
?
1
:
2,
texImage,
FALSE);
// 三角形ポリゴン2枚を描画<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(VGet(x,
y, z), 4.0f, 8, GetColor(255, 255, 0), GetColor(255, 255, 0),TRUE); //
左上に黄色の3D球を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0,
0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f", x, y, keyControlAngle);<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ScreenFlip();
//隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
&nbsp;&nbsp;&nbsp; WaitKey();<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
&nbsp;&nbsp;&nbsp; DxLib_End();<br>
&nbsp;&nbsp;&nbsp; // ソフトの終了<br>
&nbsp;&nbsp;&nbsp; return 0;<br>
}</p>
<p></p>
<p><code>main.cpp</code>のプログラムを変更し、ポリゴンのインデックスの順番がポリゴンの表(時計回
り)と裏(反時計回り)に
影響を与えることを確認しましょう。</p>
<p class="source">#include
"DxLib.h"<br>
#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
#include "Screen.h"<br>
// ＃includeで別ファイルのヘッダファイル.hをこのコード内に読み込む<br>
<br>
//
設定画面の【リンカー】&rarr;【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain
からプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR
lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
&nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32 ) ;
// 画面サイズWidth&times;Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);//
ウィンドウサイズWidth&times;Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;&nbsp;
SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間
違ってるかも<br>
<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
&nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return -1;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
&nbsp;&nbsp;&nbsp; int texImage = -1;<br>
&nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/boss1.png");<br>
&nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
&nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
&nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth,
&amp;imgHeight); // テクスチャ画像のサイズを得る<br>
<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
&nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0; keyControlXYZ.y =
Screen::Height; keyControlXYZ.z = 0;<br>
&nbsp;&nbsp;&nbsp; float keyControlAngle = 0.0f; // 回転<br>
&nbsp;&nbsp;&nbsp; int animTime = 0; // アニメーションの時刻カウンタ<br>
<br>
&nbsp;&nbsp;&nbsp; <em>// バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
&nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);</em><br>
<br>
&nbsp;&nbsp;&nbsp; ScreenFlip();<br>
<br>
&nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0) <br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ProcessMessage() ==
0になるのは&times;ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ClearDrawScreen();//
一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput =
GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -=
speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y
+= speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x = keyControlXYZ.x;
float y = keyControlXYZ.y; float z = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth;
float height = imgHeight; // テクスチャ画僧のサイズ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float scaleX = 0.5f; float
scaleY = 0.5f; // 拡大縮小スケール<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
キーボードのzキー(A)とxキー(B)でz軸(画面奥方向)まわりに画像を回転<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_A)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlAngle += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_B) keyControlAngle -= speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad =
DX_PI_F / 180.0f; // 角度(単位:&deg;度)からラジアン(単位:rad)へ変換する係数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = 0 *
Deg2Rad;&nbsp; const float yRotate = <em>keyControlAngle</em> *
Deg2Rad; const float zRotate = <em>0</em> * Deg2Rad;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u0 = 0.0f; const
float v0 = 0.0f; // テクスチャのUV切り出し起点(u:0～1.0, v:0～1.0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u1 = 1.0f; const
float v1 = 1.0f; // テクスチャのUV切り出し終点 1.0は画像の右下を表す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerX = x + width *
scaleX / 2; // 四角形の中心(x+width/2,y-height/2,z)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerY = y - height *
scaleY / 2;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityのxyz方向と回転]
https://gametukurikata.com/basic/xyzaxis<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityの回転ZXYの順で適用したもの]
https://light11.hatenadiary.com/entry/2019/01/24/223705<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX TransformMatrix =
MGetTranslate(VGet(-centerX, -centerY, -z)); // 四角形の中心を
原点(0,0,0)に一旦移動させてから回転させる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
★MMultは行列の乗算【乗算した順にz軸回転&rarr;x軸回転&rarr;y軸回転&rarr;平行移動】<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix =
MMult(TransformMatrix, MGetRotZ(zRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix =
MMult(TransformMatrix, MGetRotX(xRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix =
MMult(TransformMatrix, MGetRotY(yRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix =
MMult(TransformMatrix, MGetTranslate(VGet(centerX, centerY, z))); //
四角形の中心ぶんだけ平行移動させて戻す<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 四角ポリゴンのインデックス順<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(時計回りが表面)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &darr;(x,y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 0-1 4 &larr;(x +
width * scale, y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; |/ /|<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 2 3-5 &larr;(x +
width * scale, y - height * scale)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &uarr;(x, y - height *
scale)&nbsp;&nbsp;&nbsp;&nbsp;
&uarr;[UIのy方向は下だが3D空間上は上が+方向なのでheightを-1方向に]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt;
rectVertex;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex.resize(4);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;unsigned
int&gt; rectIndex;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex.resize(6);&nbsp;
// 4頂点のうち 右上(1と4)と左下(2と3)は同位置に2つ頂点を使う(三角形2つぶんのため) 4頂点 + 2被り = 6<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4頂点分のデータをセット<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左上(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].pos =
VTransform(VGet(x, y, z), TransformMatrix);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].norm =
VGet(0.0f, 0.0f, -1.0f); // 法線ベクトル(面の反射方向:z方向-1.0のベクトルなら光がzマイナス方向に反射)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].dif =
GetColorU8(255, 255, 255, 255); // 拡散反射光の色<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].spc =
GetColorU8(255, 255, 255, 255); // 鏡面反射光の色<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].u = u0; //
テクスチャ切り出し点 U(横方向)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].v = v0; //
テクスチャ切り出し点 V(縦方向)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].su = 0.0f; //
補助テクスチャのUV(いまはない)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].sv = 0.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右上(1と4)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].pos =
VTransform(VGet(x + width * scaleX, y, z), TransformMatrix);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].norm =
VGet(0.0f, 0.0f, -1.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].dif =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].u = u1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].v = v0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].su = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].sv = 0.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左下(2と3)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].pos =
VTransform(VGet(x, y - height * scaleY, z), TransformMatrix);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].norm =
VGet(0.0f, 0.0f, -1.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].dif =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].u = u0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].v = v1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].su = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].sv = 0.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右下(5)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].pos =
VTransform(VGet(x + width * scaleX, y - height * scaleY, z),
TransformMatrix);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].norm =
VGet(0.0f, 0.0f, -1.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].dif =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].u = u1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].v = v1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].su = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].sv = 0.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2ポリゴン分のインデックス順データをセット<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[0] = <em>2</em>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[1] = 1; // 0-1 4<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[2] = <em>0</em>;
// |/ /|&nbsp;&nbsp; 0,1,2で左上ポリゴンを 3,4,5で右下ポリゴンを描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[3] = 2; // 2 3-5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[4] = 1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[5] = 3;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++animTime;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isDrawPolygon =
animTime % 60 &gt; 30; // 30フレームに1回三角ポリゴン(1個)と四角(2個)を描くのを切り替える&darr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawPolygon32bitIndexed3D(rectVertex.data(), rectVertex.size(),
rectIndex.data(), (isDrawPolygon) ? 1 : 2, texImage, FALSE); //
三角形ポリゴン2枚を描画<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(VGet(x,
y, z), 4.0f, 8, GetColor(255, 255, 0), GetColor(255, 255, 0),TRUE); //
左上に黄色の3D球を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0,
0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f", x, y, keyControlAngle);<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ScreenFlip();
//隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
&nbsp;&nbsp;&nbsp; WaitKey();<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
&nbsp;&nbsp;&nbsp; DxLib_End();<br>
&nbsp;&nbsp;&nbsp; // ソフトの終了<br>
&nbsp;&nbsp;&nbsp; return 0;<br>
}</p>
<p>いかがですか？キーボードのzキーとxキーでポリゴンをまわしてみ
てポリゴンを裏から見ると表示されることが確認できましたか?<br>
</p>
<br>
<br>
<br>
<h2><a id="mozTocId0002" class="mozTocH1"></a>ポリゴンの光の色表示の基礎となっている「拡散反射光:
ディ
フューズ値」の値を変更してみる</h2>
<p><code>main.cpp</code>のプログラムを変更し、ポリゴンの<span
 style="text-decoration: underline;">difの値(拡散反射光:ディフューズ値)</span>がポリゴンの反射
する色に影響を与えることを確認しましょう。</p>
<p class="source">#include
"DxLib.h"<br>
#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
#include "Screen.h"<br>
// ＃includeで別ファイルのヘッダファイル.hをこのコード内に読み込む<br>
<br>
//
設定画面の【リンカー】&rarr;【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain
からプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR
lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
&nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32 ) ;
// 画面サイズWidth&times;Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);//
ウィンドウサイズWidth&times;Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;&nbsp;
SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間
違ってるかも<br>
<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
&nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return -1;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
&nbsp;&nbsp;&nbsp; int texImage = -1;<br>
&nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/boss1.png");<br>
&nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
&nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
&nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth,
&amp;imgHeight); // テクスチャ画像のサイズを得る<br>
<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
&nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0; keyControlXYZ.y =
Screen::Height; keyControlXYZ.z = 0;<br>
&nbsp;&nbsp;&nbsp; float keyControlAngle = 0.0f; // 回転<br>
&nbsp;&nbsp;&nbsp; int animTime = 0; // アニメーションの時刻カウンタ<br>
<br>
&nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
&nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
<br>
&nbsp;&nbsp;&nbsp; ScreenFlip();<br>
<br>
&nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0) <br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // ProcessMessage() ==
0になるのは&times;ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ClearDrawScreen();//
一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput =
GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -=
speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y
+= speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x = keyControlXYZ.x;
float y = keyControlXYZ.y; float z = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth;
float height = imgHeight; // テクスチャ画僧のサイズ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float scaleX = 0.5f; float
scaleY = 0.5f; // 拡大縮小スケール<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
キーボードのzキー(A)とxキー(B)でz軸(画面奥方向)まわりに画像を回転<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_A)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlAngle += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_B) keyControlAngle -= speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad =
DX_PI_F / 180.0f; // 角度(単位:&deg;度)からラジアン(単位:rad)へ変換する係数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate = 0 *
Deg2Rad;&nbsp; const float yRotate = <em>0</em> * Deg2Rad; const float
zRotate = <em>keyControlAngle</em><em></em> * Deg2Rad;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u0 = 0.0f; const
float v0 = 0.0f; // テクスチャのUV切り出し起点(u:0～1.0, v:0～1.0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float u1 = 1.0f; const
float v1 = 1.0f; // テクスチャのUV切り出し終点 1.0は画像の右下を表す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerX = x + width *
scaleX / 2; // 四角形の中心(x+width/2,y-height/2,z)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float centerY = y - height *
scaleY / 2;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityのxyz方向と回転]
https://gametukurikata.com/basic/xyzaxis<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [Unityの回転ZXYの順で適用したもの]
https://light11.hatenadiary.com/entry/2019/01/24/223705<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX TransformMatrix =
MGetTranslate(VGet(-centerX, -centerY, -z)); // 四角形の中心を
原点(0,0,0)に一旦移動させてから回転させる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
★MMultは行列の乗算【乗算した順にz軸回転&rarr;x軸回転&rarr;y軸回転&rarr;平行移動】<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix =
MMult(TransformMatrix, MGetRotZ(zRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix =
MMult(TransformMatrix, MGetRotX(xRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix =
MMult(TransformMatrix, MGetRotY(yRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix =
MMult(TransformMatrix, MGetTranslate(VGet(centerX, centerY, z))); //
四角形の中心ぶんだけ平行移動させて戻す<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 四角ポリゴンのインデックス順<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左手系(時計回りが表面)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &darr;(x,y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 0-1 4 &larr;(x +
width * scale, y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; |/ /|<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 2 3-5 &larr;(x +
width * scale, y - height * scale)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &uarr;(x, y - height *
scale)&nbsp;&nbsp;&nbsp;&nbsp;
&uarr;[UIのy方向は下だが3D空間上は上が+方向なのでheightを-1方向に]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt;
rectVertex;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex.resize(4);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;unsigned
int&gt; rectIndex;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex.resize(6);&nbsp;
// 4頂点のうち 右上(1と4)と左下(2と3)は同位置に2つ頂点を使う(三角形2つぶんのため) 4頂点 + 2被り = 6<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4頂点分のデータをセット<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左上(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].pos =
VTransform(VGet(x, y, z), TransformMatrix);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].norm =
VGet(0.0f, 0.0f, -1.0f); // 法線ベクトル(面の反射方向:z方向-1.0のベクトルなら光がzマイナス方向に反射)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].dif =
GetColorU8(255, <em>0</em>, <em>0</em>, 255); // 拡散反射光の色<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].spc =
GetColorU8(255, 255, 255, 255); // 鏡面反射光の色<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].u = u0; //
テクスチャ切り出し点 U(横方向)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].v = v0; //
テクスチャ切り出し点 V(縦方向)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].su = 0.0f; //
補助テクスチャのUV(いまはない)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[0].sv = 0.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右上(1と4)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].pos =
VTransform(VGet(x + width * scaleX, y, z), TransformMatrix);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].norm =
VGet(0.0f, 0.0f, -1.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].dif =
GetColorU8(<em>0</em>, <em>0</em>, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].u = u1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].v = v0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].su = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[1].sv = 0.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左下(2と3)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].pos =
VTransform(VGet(x, y - height * scaleY, z), TransformMatrix);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].norm =
VGet(0.0f, 0.0f, -1.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].dif =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].u = u0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].v = v1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].su = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[2].sv = 0.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右下(5)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].pos =
VTransform(VGet(x + width * scaleX, y - height * scaleY, z),
TransformMatrix);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].norm =
VGet(0.0f, 0.0f, -1.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].dif =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].u = u1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].v = v1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].su = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectVertex[3].sv = 0.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2ポリゴン分のインデックス順データをセット<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[0] = <em>0</em>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[1] = 1; // 0-1 4<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[2] = <em>2</em>;
// |/ /|&nbsp;&nbsp; 0,1,2で左上ポリゴンを 3,4,5で右下ポリゴンを描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[3] = 2; // 2 3-5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[4] = 1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectIndex[5] = 3;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++animTime;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isDrawPolygon =
animTime % 60 &gt; 30; // 30フレームに1回三角ポリゴン(1個)と四角(2個)を描くのを切り替える&darr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawPolygon32bitIndexed3D(rectVertex.data(), rectVertex.size(),
rectIndex.data(), (isDrawPolygon) ? 1 : 2, texImage, FALSE); //
三角形ポリゴン2枚を描画<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(VGet(x,
y, z), 4.0f, 8, GetColor(255, 255, 0), GetColor(255, 255, 0),TRUE); //
左上に黄色の3D球を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0,
0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f", x, y, keyControlAngle);<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ScreenFlip();
//隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
&nbsp;&nbsp;&nbsp; WaitKey();<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
&nbsp;&nbsp;&nbsp; DxLib_End();<br>
&nbsp;&nbsp;&nbsp; // ソフトの終了<br>
&nbsp;&nbsp;&nbsp; return 0;<br>
}</p>
<br>
<br>
<br>
<h2><a id="mozTocId0003" class="mozTocH1"></a>シンプルな.ply形式の3Dデータフォーマットを読み
取ってポ
リゴン表示してみる</h2>
<p><code>メモ帳を開いて下記データをコピペして
dicetest.plyという名前でImageフォルダに保存</code><a id="mozTocId0003"
 class="mozTocH1">しましょう。</a></p>
<p class="source"><a id="mozTocId0003" class="mozTocH1">ply<br>
format ascii 1.0<br>
comment Created by Blender 3.5.1 - www.blender.org<br>
element vertex 14<br>
property float x<br>
property float y<br>
property float z<br>
property float nx<br>
property float ny<br>
property float nz<br>
property float s<br>
property float t<br>
element face 12<br>
property list uchar uint vertex_indices<br>
end_header<br>
-1.000000 1.000000 1.000000 0.000000 0.000000 1.000000 0.875000 0.500000<br>
1.000000 -1.000000 1.000000 0.577350 -0.577350 0.577350 0.625000
0.750000<br>
1.000000 1.000000 1.000000 0.577350 0.577350 0.577350 0.625000 0.500000<br>
-1.000000 -1.000000 -1.000000 0.000000 -1.000000 0.000000 0.375000
1.000000<br>
1.000000 -1.000000 -1.000000 0.577350 -0.577350 -0.577350 0.375000
0.750000<br>
-1.000000 -1.000000 1.000000 -1.000000 0.000000 0.000000 0.625000
0.000000<br>
-1.000000 1.000000 -1.000000 -0.707107 0.707107 0.000000 0.375000
0.250000<br>
-1.000000 -1.000000 -1.000000 -1.000000 0.000000 0.000000 0.375000
0.000000<br>
1.000000 1.000000 -1.000000 0.577350 0.577350 -0.577350 0.375000
0.500000<br>
-1.000000 -1.000000 -1.000000 0.000000 0.000000 -1.000000 0.125000
0.750000<br>
-1.000000 1.000000 -1.000000 0.000000 0.000000 -1.000000 0.125000
0.500000<br>
-1.000000 1.000000 1.000000 -0.707107 0.707107 0.000000 0.625000
0.250000<br>
-1.000000 -1.000000 1.000000 0.000000 0.000000 1.000000 0.875000
0.750000<br>
-1.000000 -1.000000 1.000000 0.000000 -1.000000 0.000000 0.625000
1.000000<br>
3 0 1 2<br>
3 1 3 4<br>
3 5 6 7<br>
3 8 9 10<br>
3 2 4 8<br>
3 8 11 2<br>
3 0 12 1<br>
3 1 13 3<br>
3 5 11 6<br>
3 8 4 9<br>
3 2 1 4<br>
3 8 6 11<br>
</a></p>
<a id="mozTocId0003" class="mozTocH1"><br>
</a>
<p><code><a id="mozTocId0003" class="mozTocH1">Ply.hを新規作成</a></code><a
 id="mozTocId0003" class="mozTocH1">して、ファイルから.ply形式の3Dフォーマットを読み取るための処理を準
備しましょう。</a></p>
<p class="source"><a id="mozTocId0003" class="mozTocH1">#ifndef PLY_H_<br>
#define PLY_H_<br>
<br>
#include &lt;assert.h&gt; // 読込み失敗表示用<br>
#include &lt;string&gt;<br>
#include &lt;vector&gt;<br>
#include &lt;memory&gt;<br>
#include &lt;utility&gt; // ペア型std::pairを使う<br>
#include &lt;typeindex&gt; //
std::type_indexを使えばunordered_mapの辞書のキーにfloatなどのタイプの型を指定できるようになる<br>
#include &lt;unordered_map&gt;<br>
#include &lt;fstream&gt; // ファイル読み出しifstreamに必要<br>
#include &lt;sstream&gt; // 文字列ストリームに必要<br>
#include &lt;functional&gt; // std::functionでラムダ式を関数の引数にできる<br>
<br>
namespace Ply
//[.ply形式の3Dデータを読みだす]https://ja.wikipedia.org/wiki/PLY_(%E3%83%95%E3%82
%A1%E3%82%A4%E3%83%AB%E5%BD%A2%E5%BC%8F)<br>
{<br>
&nbsp;&nbsp; &nbsp;enum class FileFormat { ASCII, BINARY };<br>
<br>
&nbsp;&nbsp; &nbsp;const std::type_index CHAR =
std::type_index(typeid(int8_t));<br>
&nbsp;&nbsp; &nbsp;const std::type_index UCHAR =
std::type_index(typeid(uint8_t));<br>
&nbsp;&nbsp; &nbsp;const std::type_index SHORT =
std::type_index(typeid(int16_t));<br>
&nbsp;&nbsp; &nbsp;const std::type_index USHORT =
std::type_index(typeid(uint16_t));<br>
&nbsp;&nbsp; &nbsp;const std::type_index INT =
std::type_index(typeid(int32_t));<br>
&nbsp;&nbsp; &nbsp;const std::type_index UINT =
std::type_index(typeid(uint32_t));<br>
&nbsp;&nbsp; &nbsp;const std::type_index FLOAT =
std::type_index(typeid(float));<br>
&nbsp;&nbsp; &nbsp;const std::type_index DOUBLE =
std::type_index(typeid(double));<br>
<br>
&nbsp;&nbsp; &nbsp;// ビックエンディアン方式でメモリに数値が格納される環境かチェック
https://qiita.com/nia_tn1012/items/340a1f0ad71bf6085f7f<br>
&nbsp;&nbsp; &nbsp;static bool isBigEndian()<br>
&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 0x01020304 という 4バイト数値 が メモリ上に
0x01 0x02 0x03 0x04 と上位バイトから順に格納する方式ならビッグエンディアンと判定<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const uint32_t i = 0x01020304;
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&uarr;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return reinterpret_cast&lt;const
uint8_t*&gt;(&amp;i)[0] == 1;<br>
&nbsp;&nbsp; &nbsp;}<br>
<br>
&nbsp;&nbsp; &nbsp;const std::unordered_map&lt;std::type_index, int&gt;
dataTypeByteSize // データタイプFLOATなど から そのステップサイズ(データ量)=4バイト への変換辞書<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { CHAR, sizeof(char) }, //
sizeof(char) = 1バイト<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { UCHAR, sizeof(unsigned char) },
// sizeof(unsigned char) = 1バイト<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { SHORT, sizeof(int16_t) }, //
sizeof(int16_t) = 2バイト<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { USHORT, sizeof(uint16_t) }, //
sizeof(uint16_t) = 2バイト<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { INT, sizeof(int32_t) }, //
sizeof(int32_t) = 4バイト<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { UINT, sizeof(uint32_t) }, //
sizeof(uint32_t) = 4バイト<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { FLOAT, sizeof(float) }, //
sizeof(float) = 4バイト<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { DOUBLE, sizeof(double) } //
sizeof(double) = 8バイト<br>
&nbsp;&nbsp; &nbsp;};<br>
<br>
&nbsp;&nbsp; &nbsp;static_assert(sizeof(char) == 1, "sizeof(char) =
1バイトじゃないので何かおかしい");<br>
&nbsp;&nbsp; &nbsp;static_assert(sizeof(unsigned char) == 1,
"sizeof(unsigned char) = 1バイトじゃないので何かおかしい");<br>
&nbsp;&nbsp; &nbsp;static_assert(sizeof(int16_t) == 2, "sizeof(int16_t)
= 2バイトじゃないので何かおかしい");<br>
&nbsp;&nbsp; &nbsp;static_assert(sizeof(uint16_t) == 2,
"sizeof(uint16_t) = 2バイトじゃないので何かおかしい");<br>
&nbsp;&nbsp; &nbsp;static_assert(sizeof(int32_t) == 4, "sizeof(int32_t)
= 4バイトじゃないので何かおかしい");<br>
&nbsp;&nbsp; &nbsp;static_assert(sizeof(uint32_t) == 4,
"sizeof(uint32_t) = 4バイトじゃないので何かおかしい");<br>
&nbsp;&nbsp; &nbsp;static_assert(sizeof(float) == 4, "sizeof(float) =
4バイトじゃないので何かおかしい");<br>
&nbsp;&nbsp; &nbsp;static_assert(sizeof(double) == 8, "sizeof(double) =
8バイトじゃないので何かおかしい");<br>
<br>
&nbsp;&nbsp; &nbsp;const std::unordered_map&lt;std::string,
std::type_index&gt; strToDataType // "int32"などの文字列 &rarr;
INTなどそのタイプ(std::type_index)への変換辞書<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { "char", CHAR }, { "uchar",
UCHAR }, { "uint8", UCHAR },<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { "short", SHORT }, { "ushort",
USHORT }, { "uint16", USHORT },<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { "int", INT }, { "int32", INT },
{ "uint", UINT }, { "uint32", UINT },<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { "float", FLOAT }, { "float32",
FLOAT },<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { "double", DOUBLE }, {
"float64", DOUBLE }<br>
&nbsp;&nbsp; &nbsp;};<br>
<br>
&nbsp;&nbsp; &nbsp;const std::unordered_map&lt;std::type_index,
std::string&gt; dataTypeToStr // INTなどそのタイプ から "int32"など文字列への変換辞書<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { CHAR, "char" }, { UCHAR,
"uchar" },<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { SHORT, "short" }, { USHORT,
"ushort" },<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { INT, "int" }, { UINT, "uint" },<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; { FLOAT, "float" }, { DOUBLE,
"double" },<br>
&nbsp;&nbsp; &nbsp;};<br>
<br>
&nbsp;&nbsp; &nbsp;// std::type_index(typeid(float)) などのタイプから
そのステップバイト数=4バイト に変換<br>
&nbsp;&nbsp; &nbsp;static size_t dataTypeToStepSize(const
std::type_index&amp; type)<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; auto it =
dataTypeByteSize.find(type);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; assert(it !=
dataTypeByteSize.end() &amp;&amp; "指定された type は plyのヘッダで未定義です");<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return it-&gt;second;<br>
&nbsp;&nbsp; &nbsp;}<br>
<br>
&nbsp;&nbsp; &nbsp;// "int" や "float32"などを
std::type_index(typeid(float)) など std::type_index型に変換<br>
&nbsp;&nbsp; &nbsp;static std::type_index parseDataType(const
std::string&amp; type_name)<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const auto&amp; it =
strToDataType.find(type_name);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (it != strToDataType.end())
return it-&gt;second;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else throw
std::exception(std::string("よくわからん定義してないタイプ名が来た:" + type_name).c_str());<br>
&nbsp;&nbsp; &nbsp;}<br>
<br>
&nbsp;&nbsp; &nbsp;template&lt;typename Key, typename Value&gt;<br>
&nbsp;&nbsp; &nbsp;struct IndexList<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;private:<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; typedef typename
std::pair&lt;Key, std::shared_ptr&lt;Value&gt;&gt; KeyValue;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;KeyValue&gt; data;
// data配列にはキー"x" "y"などとバリュー(PropertyやElementなど)の"x"の型の情報(Property)が入る<br>
&nbsp;&nbsp; &nbsp;public:<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Value&gt;
operator[] (const Key&amp; key)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto it =
std::find_if(begin(), end(), [&amp;key](const KeyValue&amp; keyVal) {
return keyVal.first == key; });<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(it !=
end() &amp;&amp; "未登録のキーに[]でアクセスしようとしました");<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return
it-&gt;second;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // ["x"] や
["vertex"]のようにプロパティやエレメントに[]オペレータでアクセスできる<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const std::shared_ptr&lt;const
Value&gt; operator[] (const Key&amp; key) const<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; &nbsp;// keyに "x"
が入ってきたらdata配列のbegin()からend()までkeyが "x"になるKeyValueを探す<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto it =
std::find_if(begin(), end(), [&amp;key](const KeyValue&amp; keyVal) {
return keyVal.first == key; });<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(it !=
end() &amp;&amp; "未登録のキーに[]でアクセスしようとしました");<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return
it-&gt;second; // "x" のsecondがfloat型ならばfloat型のデータへの共有ポインタのアクセスを返す<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; bool has_key(const Key&amp; key)
// xやredなどキーが.plyのヘッダで例.property float x などのように宣言されているか<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto it =
std::find_if(begin(), end(), [&amp;key](const KeyValue&amp; keyVal) {
return keyVal.first == key; });<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (it !=
end()) return true;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
else&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; return
false;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; void emplace_back(const Key&amp;
key, const std::shared_ptr&lt;Value&gt;&amp; value)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
data.emplace_back(key, value);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; void clear() { data.clear(); }<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; typedef typename
std::vector&lt;std::pair&lt;Key,
std::shared_ptr&lt;Value&gt;&gt;&gt;::iterator iterator;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; typedef typename
std::vector&lt;std::pair&lt;Key,
std::shared_ptr&lt;Value&gt;&gt;&gt;::const_iterator const_iterator;<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //
範囲for文のためのイテレータの先頭beginと終端endを定義<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; iterator begin() { return
data.begin(); };<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const_iterator begin() const {
return data.begin(); };<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; iterator end() { return
data.end(); };<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const_iterator end() const {
return data.end(); };<br>
&nbsp;&nbsp; &nbsp;};<br>
<br>
&nbsp;&nbsp; &nbsp;class Property // プロパティの例. property float x なら "x" は
std::vector&lt;unsigned char&gt; dataにfloat型4バイト枠data[][][][]にまたがって保管<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;public:<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // ※unsigned
char型の1バイト配列として定義してあるが実際に格納されるデータは2バイトなら箱2つ[ ][ ]で[ ]をまたいで格納される<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;unsigned char&gt;
data; // 読みだしたプロパティのデータの書き込み先配列<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const std::type_index type; //
プロパティのタイプ 例. property float x なら floatのstd::type_index<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const unsigned int stepSize; //
プロパティのデータのステップサイズ数 例. floatやint = 4バイト stepSize = 4<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const bool isList = false; // 例.
property list uchar uint vertex_indices なら isList = true<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const size_t elementSize = 0; //
エレメントのサイズ<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //std::vector&lt;unsigned
char&gt; listCounts;<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Property(const std::type_index
type, const size_t size, const bool isList = false, const size_t
elementSize = 0)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : type{ type
}, isList{ isList }, stepSize{ (unsigned
int)Ply::dataTypeToStepSize(type) }, elementSize{ elementSize }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
this-&gt;data.resize(size * this-&gt;stepSize); //
データの書き込み先配列のメモリを事前確保しておく<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; template&lt;typename T&gt; //
TがPropertyのタイプと一致するか判定<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; bool isType() const { return
(type == std::type_index(typeid(T))); }<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; template&lt;typename T&gt; //
T型としてdata配列の先頭への T型のポインタを得る(const不変縛り)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const T* ptr() const {
assert(isType&lt;T&gt;()); return reinterpret_cast&lt;const
T*&gt;(&amp;data[0]); }<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; template&lt;typename T&gt; //
T型としてdata配列の先頭への T型のポインタを得る<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; T* ptr() {
assert(isType&lt;T&gt;()); return
reinterpret_cast&lt;T*&gt;(data.data()); }<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //
data配列のサイズをPropertyのステップサイズで割ることで配列の要素数を得られる<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const size_t size() const {
assert(data.size() % stepSize == 0); return data.size() / stepSize; }<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; template&lt;typename T&gt;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; const T&amp; at(const size_t i)
const<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
assert(isType&lt;T&gt;());<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert((i + 1)
* stepSize &lt;= data.size()); //&darr; [ ]をまたいで格納しているぶん i * stepSizeで<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return&nbsp;
*reinterpret_cast&lt;const T*&gt;(&amp;data[i * stepSize]); //
2バイトなら箱2つ[ ][ ] i&times;2ぶんずらしたアドレスを返す<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; template&lt;typename T&gt;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; T&amp; at(const size_t i)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
assert(isType&lt;T&gt;());<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert((i + 1)
* stepSize &lt;= data.size()); //&darr; [ ]をまたいで格納しているぶん i * stepSizeで<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return&nbsp;
*reinterpret_cast&lt;T*&gt;(&amp;data[i * stepSize]); // 2バイトなら箱2つ[ ][
] i&times;2ぶんずらしたアドレスを返す<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;};<br>
<br>
&nbsp;&nbsp; &nbsp;class Elements // .plyの各elementを表す 例. element face
12 = ポリゴンが size = 12面ぶんありdata["face"]でアクセスできる<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; size_t size_;<br>
&nbsp;&nbsp; &nbsp;public:<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Elements(const size_t size) :
size_(size) {}<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; IndexList&lt;std::string,
Property&gt; properties; // elementにぶらさがっている property float x などのリスト<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; size_t size() const { return
size_; }<br>
&nbsp;&nbsp; &nbsp;};<br>
<br>
<br>
&nbsp;&nbsp; &nbsp;typedef IndexList&lt;std::string, Elements&gt; Data;
//　["x"] や["vertex"]のようにプロパティやエレメントに[]オペレータでアクセスして使う<br>
<br>
&nbsp;&nbsp; &nbsp;// Windowsで作成されたファイルは改行コード \n に \r がついたcarrige
return形式になっているので除去してstd::getlineできる関数<br>
&nbsp;&nbsp; &nbsp;inline void
getline_carriage_return(std::ifstream&amp; inputfile, std::string&amp;
line)<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::getline(inputfile, line); //
ファイルから1行をstd::getlineで取得<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // Windowsで作成されたファイルは改行コード \n に
\r がついたcarrige return形式になっているので除去<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (!line.empty() &amp;&amp;
line.back() == '\r')<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
line.pop_back();<br>
&nbsp;&nbsp; &nbsp;}<br>
<br>
&nbsp;&nbsp; &nbsp;// " "スペース区切りでresult配列に出力する<br>
&nbsp;&nbsp; &nbsp;inline void split_space(const std::string&amp;
input, std::vector&lt;std::string&gt;&amp; result)<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; result.clear();<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::stringstream ss(input);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; while (true)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string
elem;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ss &gt;&gt;
elem; // ssで&gt;&gt;するたびに" "スペースで区切られてelemに文字列が読みだされていく<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (ss.fail())
break;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
result.push_back(elem);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp; &nbsp;}<br>
<br>
&nbsp;&nbsp; &nbsp;inline size_t str_to_size_t(const std::string&amp;
input) // 文字列をstd::stringstreamの &gt;&gt; でsize_t型の数値に変換<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::stringstream ss(input);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; size_t val; // size_t型はunsigned
long long型64bit<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; ss &gt;&gt; val; // 文字列を &gt;&gt;
で 数値型に変換<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (ss.fail()) throw
std::exception("std::stringstream で 数値型(size_t型)に変換できない文字列がありました");<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return val;<br>
&nbsp;&nbsp; &nbsp;}<br>
<br>
&nbsp;&nbsp; &nbsp;// テキストASCII形式のデータを読みだしてpWriteAddressへ書き込んで保管する<br>
&nbsp;&nbsp; &nbsp;inline void readASCIIValue(std::ifstream&amp; fin,
unsigned char* const pWriteAddress, const std::type_index&amp; type)<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (type == Ply::CHAR)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int temp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fin &gt;&gt;
temp; // 一旦 int型に変換してから8ビットにキャストして書き込む必要がある<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
*reinterpret_cast&lt;int8_t*&gt;(pWriteAddress) =
static_cast&lt;int8_t&gt;(temp);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::UCHAR)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int temp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fin &gt;&gt;
temp; // 一旦 int型に変換してから8ビットにキャストして書き込む必要がある<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
*reinterpret_cast&lt;uint8_t*&gt;(pWriteAddress) =
static_cast&lt;uint8_t&gt;(temp);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type ==
Ply::SHORT)&nbsp; fin &gt;&gt;
*reinterpret_cast&lt;int16_t*&gt;(pWriteAddress);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::USHORT) fin
&gt;&gt; *reinterpret_cast&lt;uint16_t*&gt;(pWriteAddress);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type ==
Ply::INT)&nbsp;&nbsp;&nbsp; fin &gt;&gt;
*reinterpret_cast&lt;int32_t*&gt;(pWriteAddress);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type ==
Ply::UINT)&nbsp;&nbsp; fin &gt;&gt;
*reinterpret_cast&lt;uint32_t*&gt;(pWriteAddress);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type ==
Ply::FLOAT)&nbsp; fin &gt;&gt;
*reinterpret_cast&lt;float*&gt;(pWriteAddress);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else if (type == Ply::DOUBLE) fin
&gt;&gt; *reinterpret_cast&lt;double*&gt;(pWriteAddress);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else throw
std::exception("なんか知らない未知のtype型が来たのでおかしい");<br>
&nbsp;&nbsp; &nbsp;}<br>
<br>
&nbsp;&nbsp; &nbsp;// .plyデータのヘッダではなく本体データをヘッダのプロパティのステップサイズに沿って読みだす<br>
&nbsp;&nbsp; &nbsp;template &lt;Ply::FileFormat format&gt;<br>
&nbsp;&nbsp; &nbsp;void readDataContent(std::ifstream&amp; fin,
Ply::Data&amp; loadingData)//, std::function&lt;void()&gt; onVetexFunc,
std::function&lt;void()&gt; onIndexFunc)<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;
//Property型の内部のstd::vector&lt;unsigned char&gt;
data;の配列の先頭アドレスへの辞書を作ってデータ書き込み先へのリンクを保持しておく<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::unordered_map&lt;Property*,
unsigned char*&gt; writingPlace; // データ書込先の配列先頭アドレスを表す辞書<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; elementsKeyVal :
loadingData) // elementsのキー("vertex"など)とバリュー(elements自体)のペアをループ<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (auto&amp;
propertyKeyVal : elementsKeyVal.second-&gt;properties) //
propertyのキー("x"や"red"など)とバリュー(property自体)のペアをループ<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; auto&amp; pProperty = propertyKeyVal.second;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; writingPlace[pProperty.get()] =
pProperty-&gt;data.data(); // std::vector型のdata()を呼び出すと配列の先頭アドレスが得られる<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //uint8_t max_count = 3;
//property list uchar uint vertex_indices のインデックスの数は3固定だが4とかに対応するなら工夫が必要<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; elementsKeyVal :
loadingData) // 各エレメントをループ<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp;
pElements = elementsKeyVal.second;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const size_t
elementsSize = pElements-&gt;size();<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (size_t i
= 0; i &lt; elementsSize; ++i) // 各エレメントのサイズぶんだけループ<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; for (auto&amp; propertyKeyVal :
pElements-&gt;properties) // 各エレメントの全プロパティをループ<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; pProperty =
propertyKeyVal.second;<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!pProperty-&gt;isList) //
リストじゃないとき 例. property float x など<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp;
pWriteAddress = writingPlace[pProperty.get()]; // 読み込んだデータの書き込み先アドレスを得る<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
assert(pWriteAddress &gt;= pProperty-&gt;data.data() &amp;&amp;
"書き込み先アドレスが事前確保したプロパティの内部配列の書き込み可能位置ではない");<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
//assert(ptData + prop-&gt;stepSize &lt;= prop-&gt;data.data() +
prop-&gt;data.size());<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (format ==
FileFormat::ASCII)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; readASCIIValue(fin, pWriteAddress,
pProperty-&gt;type); // テキストASCII形式をstd::ifstreamの &gt;&gt; 演算子で変換して読取<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
fin.read(reinterpret_cast&lt;char*&gt;(pWriteAddress),
pProperty-&gt;stepSize); // バイナリ形式をstd::ifstreamのreadで読取<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pWriteAddress
+= pProperty-&gt;stepSize; // 読取先アドレスをプロパティのステップサイズぶん先に進める<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else // リストのとき 例. property list
uchar uint vertex_indices など<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Read count<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; uint8_t
indexCount;<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (format ==
FileFormat::ASCII)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; int temp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; fin &gt;&gt; temp; // 一旦 int型に変換してから8ビットunsigned
charにキャストして読み込む必要がある<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; indexCount = static_cast&lt;unsigned char&gt;(temp);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else
fin.read(reinterpret_cast&lt;char*&gt;(&amp;indexCount),
sizeof(indexCount));<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(fin.fail()) throw std::exception("property listは 3(三角ポリゴンインデックス) か
6(テクスチャ3点&times;uv 2値 = 6)のみサポート");<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //property
list uchar uint vertex_indices のインデックスの数は3固定だが4とかに対応するなら工夫が必要<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /*if (count
&gt; max_count &amp;&amp; count != 3 &amp;&amp; count != 6)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; max_count = count;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; size_t newSize = count * prop-&gt;elementSize *
prop-&gt;stepSize;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if (prop-&gt;data.size() &lt; newSize)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; prop-&gt;data.resize(newSize);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }*/<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
//prop-&gt;listCounts.push_back(count); // save each counts<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Read data<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp;
pWriteAddress = writingPlace[pProperty.get()]; // 読み込んだデータの書き込み先アドレスを得る<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const size_t
chunkSize = indexCount * pProperty-&gt;stepSize; // 読み出すチャンクの塊のサイズ<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
assert(pWriteAddress &gt;= pProperty-&gt;data.data() &amp;&amp;
"書き込み先アドレスが事前確保したプロパティの内部配列の書き込み可能位置ではない");<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
//assert(ptData + chunkSize &lt;= prop-&gt;data.data() +
prop-&gt;data.size());<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (format ==
Ply::FileFormat::ASCII)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; for (size_t n = 0; n &lt; indexCount; ++n) //
インデックスの数だけループ<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; readASCIIValue(fin,
pWriteAddress, pProperty-&gt;type);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pWriteAddress +=
pProperty-&gt;stepSize; // 読取先アドレスをステップサイズぶん先に進める<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;
&nbsp;// バイナリ形式ならチャンクの塊サイズ = chunkSize ぶんまとめて高速読み出し<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
fin.read(reinterpret_cast&lt;char*&gt;(pWriteAddress), chunkSize);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; pWriteAddress += chunkSize; //
読取先アドレスをチャンクのサイズぶん先に進める<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;}<br>
<br>
&nbsp;&nbsp; &nbsp;// PLY形式のデータをロードする<br>
&nbsp;&nbsp; &nbsp;inline void load(const std::string&amp; filepath,
Ply::Data&amp; loadingData)//, std::function&lt;void()&gt; onVetexFunc,
std::function&lt;void()&gt; onIndexFunc)<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::string format; //
.plyファイルのヘッダの format<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::string version; //
.plyファイルのヘッダの version<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::ifstream fin(filepath,
std::ios::binary); // バイナリ形式で読み込み<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (!fin.is_open())<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw
std::exception((std::string("指定された ply ファイルが開けませんでした") +
filepath).c_str());<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::string line; // 読み出し1行ライン<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Ply::getline_carriage_return(fin,
line);<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;
std::shared_ptr&lt;Ply::Elements&gt; currentElement = nullptr;<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (line != "ply") throw
std::exception(".plyファイルヘッダの先頭に ""ply"" がなかったのでフォーマットがおかしいです");<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; while (line != "end_header") //
.plyファイルのヘッダーの終わりを表す end_header になるまでwhileループで読取<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
Ply::getline_carriage_return(fin, line);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(fin.fail()) throw std::exception(".plyファイルヘッダーの読取に失敗");<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
std::vector&lt;std::string&gt; lineContent;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
Ply::split_space(line, lineContent);<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(lineContent.size() == 3 &amp;&amp; lineContent[0] == "format")<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; format = lineContent[1]; // スペース区切りの2つめ<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; version = lineContent[2]; // スペース区切りの3つめ<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(lineContent.size() == 3 &amp;&amp; lineContent[0] == "element")<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const std::string&amp; name = lineContent[1]; //
elementの名前 例.element vertex 14 なら"vertex"<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const size_t elementSize =
Ply::str_to_size_t(lineContent[2]); // elementの数 &uarr;14
つまり3Dのvertex(点)が14個<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; currentElement.reset(new
Ply::Elements(elementSize)); // 今から読みだすエレメントのステップするサイズが確定<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; loadingData.emplace_back(name, currentElement); //
elementをデータ構造に登録<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if
(lineContent.size() == 3 &amp;&amp; lineContent[0] == "property") //例.
property float x などの行を受け取る<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if (!currentElement)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw
std::exception("elementが読まれてないのにpropertyが先に来ちゃったら何バイト飛ばしのステップで読みだして良いかわか
らない");<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const std::type_index dataType =
Ply::parseDataType(lineContent[1]); // "int"
"char"や"float32"などのデータタイプがlineContent[1]に入ってる<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const std::string&amp; name = lineContent[2]; // x y
z や red green blue など&uarr;のintやfloatが表す数値の名前(使われ方)が入っている<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Ply::Property&gt; newProperty(new
Ply::Property(dataType, currentElement-&gt;size()));<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; currentElement-&gt;properties.emplace_back(name,
newProperty); // currentElementに property float x などのプロパティ情報(name="x"
float)を登録<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if
(lineContent.size() == 5 &amp;&amp; lineContent[0] == "property"
&amp;&amp; lineContent[1] == "list") //例.property list uchar uint
vertex_indices などの行<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if (!currentElement)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw
std::exception("elementが読まれてないのにpropertyが先に来ちゃったら何バイト飛ばしのステップで読みだして良いかわか
らない");<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const std::type_index indexCountType =
Ply::parseDataType(lineContent[2]); //
"uchar"などのインデックスの数を表す型がlineContent[2]に入ってる<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const std::type_index dataType =
Ply::parseDataType(lineContent[3]); // "int"
"char"や"float32"などのデータタイプがlineContent[3]に入ってる<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const std::string&amp; name = lineContent[4]; //
vertex_indices や texcoord などのインデックス数値の名前(使われ方)が入っている<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if (indexCountType != Ply::UCHAR)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw std::exception("property
listでは uchar 型しか インデックスの数を表す型にはつかえない 例. property list uchar uint
vertex_indices");<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // ポリゴンindexの数は 3
固定で決め打ちしている&darr;のでblenderなどで「メッシュの三角面化」にチェックを入れてエクスポートする必要がある<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; size_t lineDataNum = (name == "texcoord") ? 6 : 3;
// テクスチャUV(st)座標 は 6つ 点1(u,v),点2(u,v),点3(u,v) = 6つの u v<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Ply::Property&gt; newProperty(new
Ply::Property(dataType, lineDataNum * currentElement-&gt;size(), true,
currentElement-&gt;size()));<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; currentElement-&gt;properties.emplace_back(name,
newProperty); // currentElementに
登
録&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
isList
=
true&uarr;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (fin.fail()) throw
std::exception(".plyファイルのヘッダを読み取ったあとの本データを読取る前にファイルエラーが出た");<br>
<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // ヘッダのプロパティ形式を元に本データを読み取る<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (format == "ascii") //
テキストのASCII形式の場合<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
.plyデータの本体データをヘッダのプロパティのステップサイスに沿って読みだす<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
Ply::readDataContent&lt;Ply::FileFormat::ASCII&gt;(fin,
loadingData);//, onVetexFunc, onIndexFunc);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(fin.fail()) throw std::exception(".plyのアスキー形式のデータ読み出しに失敗しました");<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; else // 本体データがバイナリ形式の場合<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const bool
isBigEndian = Ply::isBigEndian();<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (format !=
"binary_little_endian" &amp;&amp; format != "binary_big_endian")<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; throw std::exception(".plyのヘッダのformat部分が
binary_little_endian でも binary_big_endian でもない");<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
((isBigEndian &amp;&amp; format != "binary_big_endian") ||
(!isBigEndian &amp;&amp; format != "binary_little_endian"))<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; throw std::exception(".plyのformat と
お使いのPC環境のビックエンディアンorリトルエンディアン環境が合致していない");<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
.plyデータの本体データをヘッダのプロパティのステップサイスに沿って読みだす<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
Ply::readDataContent&lt;Ply::FileFormat::BINARY&gt;(fin,
loadingData);//, onVetexFunc, onIndexFunc);<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(fin.fail()) throw std::exception(".plyのバイナリ形式のデータ読み出しに失敗しました");<br>
<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; char
endOfFileCheck; // ファイルの終わりにchar1バイト余分に読みだしてみてちゃんとファイルの終わりまでロードできたかチェック<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
fin.read(&amp;endOfFileCheck, 1);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(!fin.eof()) throw
std::exception("ファイルの終わりに1バイト余分に読みだしたけどファイルに続きがあるのでちゃんと完全に読みだせてない");<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;}<br>
}<br>
<br>
#endif</a></p>
<p><a id="mozTocId0003" class="mozTocH1"><br>
</a></p>
<p><code><a id="mozTocId0003" class="mozTocH1">main.cppを一旦まっさらにリセットしてから</a></code><a
 id="mozTocId0003" class="mozTocH1">下記のプログラムで、.ply形式のファイルをロードしてポリゴンで
サイコロ型の3Dモデルが表示できるかテストします。</a></p>
<p class="source"><a id="mozTocId0003" class="mozTocH1">#include
"DxLib.h"<br>
#include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
#include "Screen.h"<br>
<span style="font-weight: bold;">#include "Ply.h"</span><br>
<br>
//
設定画面の【リンカー】&rarr;【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain
からプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR
lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
&nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); //
画面サイズWidth&times;Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);//
ウィンドウサイズWidth&times;Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;&nbsp;
SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間
違ってるかも<br>
<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
&nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
&nbsp;&nbsp;&nbsp; int texImage = -1;<br>
&nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/boss1.png");<br>
&nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
&nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
&nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth,
&amp;imgHeight); // テクスチャ画像のサイズを得る<br>
<br>
&nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
&nbsp;&nbsp;&nbsp; Ply::load("Image/<span style="font-weight: bold;">dicetest.ply</span>",
Data);
//
.plyデータをロード<br>
<br>
&nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; //
3Dモデルのポリゴンのインデックス配列<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; //
3Dモデルのポリゴンの頂点配列<br>
<br>
&nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
&nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp;
"Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
&nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
<br>
&nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報]
https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
&nbsp;&nbsp;&nbsp; const float* p_x =
vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_y =
vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_z =
vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_nx =
(vertex-&gt;properties.has_key("nx")) ?
vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_ny =
(vertex-&gt;properties.has_key("ny")) ?
vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_nz =
(vertex-&gt;properties.has_key("nz")) ?
vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr
|| p_nz == nullptr);<br>
&nbsp;&nbsp;&nbsp; const float* p_s =
(vertex-&gt;properties.has_key("s")) ?
vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; //
Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
&nbsp;&nbsp;&nbsp; const float* p_t =
(vertex-&gt;properties.has_key("t")) ?
vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_R =
(vertex-&gt;properties.has_key("red")) ?
vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("r")) ?
vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_G =
(vertex-&gt;properties.has_key("green")) ?
vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("g")) ?
vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_B =
(vertex-&gt;properties.has_key("blue")) ?
vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("b")) ?
vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_A =
(vertex-&gt;properties.has_key("alpha")) ?
vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("a")) ?
vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr
|| p_B == nullptr || p_A == nullptr);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt;
iEnd; i += 1)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧
https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り)
https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], -p_y[i], p_z[i]); // 右手Y&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm =
(has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f,
0.0f);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
右手Z&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos =
VGet(-(p_y[i]), p_z[i], p_x[i]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm)
? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f, 0.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color)
? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255,
255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s ==
nullptr) ? 0.0f : p_s[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t ==
nullptr) ? 0.0f : 1 - p_t[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; const auto&amp; face_index =
Data["face"]-&gt;properties["vertex_indices"];<br>
&nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(),
nFace = 0; i &lt; iEnd; i += 3)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt;
3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1
&gt; 0; --j) // 左手系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(j == 0 &amp;&amp; !has_norm &amp;&amp; Vertex[index].norm.x == 0.0f
&amp;&amp; Vertex[index].norm.y == 0.0f &amp;&amp; Vertex[index].norm.z
== 0.0f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index0
=
Index[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index1
=
Index[i
+
1];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index2
=
Index[i
+
2];<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
外積 a&times;b cross_a_b を求める
https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
a
=
VSub(Vertex[index1].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
b
=
VSub(Vertex[index2].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
cross1_2
=
VCross(a,
b);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
右手系(表面は反時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
cross2_1
=
VCross(b,
a);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
単位ベクトル(ノルム)に直す [単位ベクトル]は&radic;(x*x + y*y + z*z) = 1となる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
norm1_2
=
VNorm(cross1_2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
norm2_1
=
VNorm(cross2_1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Vertex[index0].norm
=
norm1_2;
Vertex[index1].norm
=
norm1_2;
Vertex[index2].norm
=
norm1_2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Vertex[index0].norm
=
norm2_1;
Vertex[index1].norm
=
norm2_1;
Vertex[index2].norm
=
norm2_1;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
++numIndex;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
&nbsp;&nbsp;&nbsp; keyControlXYZ.x = 200.0f; keyControlXYZ.y = 200.0f;
keyControlXYZ.z = 0;<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
<br>
&nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
&nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
<br>
&nbsp;&nbsp;&nbsp; ScreenFlip();<br>
<br>
&nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
&nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは&times;ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();//
一旦キャンバスをきれいにまっさらに<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput =
GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -=
speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y
+= speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position =
VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth;
float height = imgHeight; // テクスチャ画僧のサイズ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(100.0f,
100.0f, 100.0f); // 拡大縮小スケール<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_A) keyControlAngle.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_B) keyControlAngle.y += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_C) keyControlAngle.z += speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad =
DX_PI_F / 180.0f; // 角度(単位:&deg;度)からラジアン(単位:rad)へ変換する係数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate =
keyControlAngle.x * Deg2Rad;&nbsp; const float yRotate =
keyControlAngle.y * Deg2Rad; const float zRotate = keyControlAngle.z *
Deg2Rad;<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp;
matWorldDefault; // デフォルトのワールド行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); //
デフォルトのワールド行列を記憶しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX mat; // モデルのスケール&times;回転&times;移動を行列計算で設定する<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[スケール]拡大縮小のスケール行列を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
[勉強]&darr;スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp;
mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y;
mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp;
mat.m[3][3] = 1.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[回転]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matRot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::CreateIdentityMatrix(&amp;matRot);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
★MMultは行列の乗算【乗算した順にz軸回転&rarr;x軸回転&rarr;y軸回転&rarr;平行移動】<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotZ(zRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotX(xRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotY(yRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matRot); //スケール &times; 回転<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[移動]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matTrans = MGetTranslate(VGet(position.x, position.y,
position.z)); // 位置positionをここで設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matTrans); //スケール&times;回転&times;移動<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定]
https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawPolygon32bitIndexed3D(Vertex.data(), Vertex.size(),
Index.data(), numIndex / 3, texImage, FALSE); // 三角形ポリゴンを描画<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0,
0, GetColor(255, 255, 0), "x:%f y:%f Angle:%f %f %f", position.x,
position.y, keyControlAngle.x, keyControlAngle.y, keyControlAngle.z);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip();
//隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
&nbsp;&nbsp;&nbsp; WaitKey();<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
&nbsp;&nbsp;&nbsp; DxLib_End();<br>
&nbsp;&nbsp;&nbsp; // ソフトの終了<br>
&nbsp;&nbsp;&nbsp; return 0;<br>
}</a></p>
<a id="mozTocId0003" class="mozTocH1"><br>
<br>
<br>
</a>
<h2><a id="mozTocId0003" class="mozTocH1">Blenderをインストールして3Dのサイコロとテクスチャ画
像を書き出してXYZ軸を見極める</a></h2>
<p><a id="mozTocId0003" class="mozTocH1">Blenderを下記サイトを参考にインストールしましょう。<br>
</a><a href="https://www.blender.jp/install">https://www.blender.jp/install</a>
<br>
</p>
Blenderを開いて、上部のメニューバーから[テクスチャペイント]をクリックし[+新規]をクリックしてdiceと名前をつけてテクスチャ画像を生
成します。<br>
<p> <img src="image/blender_dice1.png" alt=""></p>
テクスチャ画像が生成されたら黒地に白で筆の半径50pxほどのサイコロの目を描いてみましょう。<br>
<p> <img src="image/blender_dice2.png" alt=""></p>
上部のメニューバーから[シェーディング]をクリックして下画面のノード画面で右クリックして[+追加]&rarr;[テクスチャ]&rarr;[画像テ
クスチャ]のノードを生成
<p> <img src="image/blender_dice3.png" alt=""></p>
画像テクスチャノードの画像として先ほどペイントしたdiceを選びます<br>
<p> <img src="image/blender_dice4.png" alt=""></p>
画像テクスチャノードの[カラー]からプリンシプルBSDFノードの[ベースカラー]へと線を引っ張ってつなげるとサイコロのテクスチャ画像がでます<br>
<p> <img src="image/blender_dice5.png" alt=""></p>
[テクスチャペイント]をクリックして、[画像]から[名前をつけて保存]を選び、テクスチャ画像をDXのプロジェクトのImageフォルダに
dice.pngとして保存<br>
<p> <img src="image/blender_dice6.png" alt=""></p>
メニューバーの[ファイル]&rarr;[エクスポート]&rarr;[Stanford
PLY(.ply)]を選び、DXのプロジェクトのImageフォルダにdice.plyとしてエクスポート保存します。
<p> <img src="image/blender_dice7.png" alt=""></p>
エクスポートする際の[前方の軸][上向きの軸]はDXのmain.cppで読み取る際に対応関係があるので色んな軸の設定の仕方で実験してみましょう<br>
<p> <img src="image/blender_dice8.png" alt=""></p>
<p><code>main.cpp</code>のコードで読み込む.plyファイルをBlenderで作成したファイルに変えて、書き出す際のxyz
軸を変えながら試行錯誤してみましょう。</p>
<p class="source">#include "DxLib.h"<br>
#include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
#include "Screen.h"<br>
#include "Ply.h"<br>
<br>
//
設定画面の【リンカー】&rarr;【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain
からプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR
lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
&nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); //
画面サイズWidth&times;Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);//
ウィンドウサイズWidth&times;Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;&nbsp;
SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間
違ってるかも<br>
<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
&nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
&nbsp;&nbsp;&nbsp; int texImage = -1;<br>
&nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/<span
 style="font-weight: bold;">dice.png</span>");<br>
&nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
&nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
&nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth,
&amp;imgHeight); // テクスチャ画像のサイズを得る<br>
<br>
&nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
&nbsp;&nbsp;&nbsp; Ply::load("Image/<span style="font-weight: bold;">dice.ply</span>",
Data);
//
.plyデータをロード <span style="font-weight: bold;">軸を変えてdice1.plyや
dice2.plyなどいろいろ試してみよう</span><br>
<br>
&nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; //
3Dモデルのポリゴンのインデックス配列<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; //
3Dモデルのポリゴンの頂点配列<br>
<br>
&nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
&nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp;
"Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
&nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
<br>
&nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報]
https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
&nbsp;&nbsp;&nbsp; const float* p_x =
vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_y =
vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_z =
vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_nx =
(vertex-&gt;properties.has_key("nx")) ?
vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_ny =
(vertex-&gt;properties.has_key("ny")) ?
vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_nz =
(vertex-&gt;properties.has_key("nz")) ?
vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr
|| p_nz == nullptr);<br>
&nbsp;&nbsp;&nbsp; const float* p_s =
(vertex-&gt;properties.has_key("s")) ?
vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; //
Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
&nbsp;&nbsp;&nbsp; const float* p_t =
(vertex-&gt;properties.has_key("t")) ?
vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_R =
(vertex-&gt;properties.has_key("red")) ?
vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("r")) ?
vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_G =
(vertex-&gt;properties.has_key("green"))
? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("g")) ?
vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_B =
(vertex-&gt;properties.has_key("blue"))
? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("b")) ?
vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_A =
(vertex-&gt;properties.has_key("alpha"))
? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("a")) ?
vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr
|| p_B == nullptr || p_A == nullptr);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt;
iEnd; i += 1)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧
https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り)
https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], -p_y[i], p_z[i]); //
右手Y&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm =
(has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f,
0.0f);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
右手Z&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos = VGet(<em>-(p_y[i]),
p_z[i],
p_x[i]</em>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm)
? VNorm(VGet(<em>-p_ny[i], p_nz[i], p_nx[i]</em>)) : VGet(0.0f, 0.0f,
0.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color)
? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255,
255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s ==
nullptr) ? 0.0f : p_s[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t ==
nullptr) ? 0.0f : 1 - p_t[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; const auto&amp; face_index =
Data["face"]-&gt;properties["vertex_indices"];<br>
&nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(),
nFace = 0; i &lt; iEnd; i += 3)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt;
3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1
&gt; 0; --j) // 左手系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(j == 0 &amp;&amp; !has_norm &amp;&amp;
Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f
&amp;&amp; Vertex[index].norm.z == 0.0f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index0
=
Index[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index1
=
Index[i
+
1];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index2
=
Index[i
+
2];<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
外積 a&times;b cross_a_b を求める
https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
a
=
VSub(Vertex[index1].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
b
=
VSub(Vertex[index2].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
cross1_2
=
VCross(a,
b);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
右手系(表面は反時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
cross2_1
=
VCross(b,
a);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
単位ベクトル(ノルム)に直す [単位ベクトル]は&radic;(x*x + y*y + z*z) = 1となる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
norm1_2
=
VNorm(cross1_2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
norm2_1
=
VNorm(cross2_1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Vertex[index0].norm
=
norm1_2;
Vertex[index1].norm
=
norm1_2;
Vertex[index2].norm
=
norm1_2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Vertex[index0].norm
=
norm2_1;
Vertex[index1].norm
=
norm2_1;
Vertex[index2].norm
=
norm2_1;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
++numIndex;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
&nbsp;&nbsp;&nbsp; keyControlXYZ.x = 200.0f; keyControlXYZ.y = 200.0f;
keyControlXYZ.z = 0;<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
<br>
&nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
&nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
<br>
&nbsp;&nbsp;&nbsp; ScreenFlip();<br>
<br>
&nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
&nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは&times;ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();//
一旦キャンバスをきれいにまっさらに<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput =
GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -=
speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y
+= speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position =
VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth;
float height = imgHeight; // テクスチャ画僧のサイズ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(<em>50.0f,
50.0f,
50.0f</em>); // 拡大縮小スケール<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_A) keyControlAngle.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_B) keyControlAngle.y += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_C) keyControlAngle.z += speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad =
DX_PI_F / 180.0f; // 角度(単位:&deg;度)からラジアン(単位:rad)へ変換する係数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate =
keyControlAngle.x * Deg2Rad;&nbsp; const float
yRotate = keyControlAngle.y * Deg2Rad; const float zRotate =
keyControlAngle.z * Deg2Rad;<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp;
matWorldDefault; // デフォルトのワールド行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); //
デフォルトのワールド行列を記憶しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX mat; // モデルのスケール&times;回転&times;移動を行列計算で設定する<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[スケール]拡大縮小のスケール行列を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
[勉強]&darr;スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp;
mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y;
mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp;
mat.m[3][3] = 1.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[回転]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matRot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::CreateIdentityMatrix(&amp;matRot);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
★MMultは行列の乗算【乗算した順にz軸回転&rarr;x軸回転&rarr;y軸回転&rarr;平行移動】<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotZ(zRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotX(xRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotY(yRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matRot); //スケール &times; 回転<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[移動]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matTrans = MGetTranslate(VGet(position.x, position.y,
position.z)); // 位置positionをここで設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matTrans); //スケール&times;回転&times;移動<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定]
https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawPolygon32bitIndexed3D(Vertex.data(),
Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); //
三角形ポリゴンをたくさん描画<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0,
0, GetColor(255, 255, 0), "x:%f y:%f
Angle:%f %f %f", position.x, position.y, keyControlAngle.x,
keyControlAngle.y, keyControlAngle.z);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip();
//隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
&nbsp;&nbsp;&nbsp; WaitKey();<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
&nbsp;&nbsp;&nbsp; DxLib_End();<br>
&nbsp;&nbsp;&nbsp; // ソフトの終了<br>
&nbsp;&nbsp;&nbsp; return 0;<br>
}</p>
<br>
<br>
<br>
<h2><a id="mozTocId0004" class="mozTocH1">別の描画スクリーンを作って、Windowsみたいなサブのウィ
ンドウを描く</a></h2>
<a id="mozTocId0004" class="mozTocH1"><br>
</a>
<p><code><a id="mozTocId0004" class="mozTocH1">main.cpp</a></code><a
 id="mozTocId0004" class="mozTocH1">のコードにMakeScreen関数を使って別の描画先スクリーンを作って描
画先スクリーンをスイッチ
する方法をテストしてみましょう。</a></p>
<p class="source"><a id="mozTocId0004" class="mozTocH1">#include
"DxLib.h"<br>
#include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
#include "Screen.h"<br>
#include "Ply.h"<br>
<br>
//
設定画面の【リンカー】&rarr;【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain
からプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR
lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
&nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); //
画面サイズWidth&times;Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);//
ウィンドウサイズWidth&times;Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;&nbsp;
SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間
違ってるかも<br>
<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
&nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
&nbsp;&nbsp;&nbsp; int texImage = -1;<br>
&nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
&nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
&nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
&nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth,
&amp;imgHeight); // テクスチャ画像のサイズを得る<br>
<br>
&nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
&nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply",
Data); // .plyデータをロード 軸を変えてdice1.plyや
dice2.plyなどいろいろ試してみよう<br>
<br>
&nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; //
3Dモデルのポリゴンのインデックス配列<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; //
3Dモデルのポリゴンの頂点配列<br>
<br>
&nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
&nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp;
"Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
&nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
<br>
&nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報]
https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
&nbsp;&nbsp;&nbsp; const float* p_x =
vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_y =
vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_z =
vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_nx =
(vertex-&gt;properties.has_key("nx")) ?
vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_ny =
(vertex-&gt;properties.has_key("ny")) ?
vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_nz =
(vertex-&gt;properties.has_key("nz")) ?
vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr
|| p_nz == nullptr);<br>
&nbsp;&nbsp;&nbsp; const float* p_s =
(vertex-&gt;properties.has_key("s")) ?
vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; //
Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
&nbsp;&nbsp;&nbsp; const float* p_t =
(vertex-&gt;properties.has_key("t")) ?
vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_R =
(vertex-&gt;properties.has_key("red")) ?
vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("r")) ?
vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_G =
(vertex-&gt;properties.has_key("green"))
? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("g")) ?
vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_B =
(vertex-&gt;properties.has_key("blue"))
? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("b")) ?
vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_A =
(vertex-&gt;properties.has_key("alpha"))
? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("a")) ?
vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr
|| p_B == nullptr || p_A == nullptr);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt;
iEnd; i += 1)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧
https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り)
https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], -p_y[i], p_z[i]); //
右手Y&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm =
(has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f,
0.0f);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
右手Z&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos =
VGet(-(p_y[i]),
p_z[i], p_x[i]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm)
? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f,
0.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color)
? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255,
255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s ==
nullptr) ? 0.0f : p_s[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t ==
nullptr) ? 0.0f : 1 - p_t[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; const auto&amp; face_index =
Data["face"]-&gt;properties["vertex_indices"];<br>
&nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(),
nFace = 0; i &lt; iEnd; i += 3)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt;
3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1
&gt; 0; --j) // 左手系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(j == 0 &amp;&amp; !has_norm &amp;&amp;
Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f
&amp;&amp; Vertex[index].norm.z == 0.0f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index0
=
Index[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index1
=
Index[i
+
1];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index2
=
Index[i
+
2];<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
外積 a&times;b cross_a_b を求める
https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
a
=
VSub(Vertex[index1].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
b
=
VSub(Vertex[index2].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
cross1_2
=
VCross(a,
b);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
右手系(表面は反時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
cross2_1
=
VCross(b,
a);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
単位ベクトル(ノルム)に直す [単位ベクトル]は&radic;(x*x + y*y + z*z) = 1となる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
norm1_2
=
VNorm(cross1_2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
norm2_1
=
VNorm(cross2_1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Vertex[index0].norm
=
norm1_2;
Vertex[index1].norm
=
norm1_2;
Vertex[index2].norm
=
norm1_2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Vertex[index0].norm
=
norm2_1;
Vertex[index1].norm
=
norm2_1;
Vertex[index2].norm
=
norm2_1;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
++numIndex;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
&nbsp;&nbsp;&nbsp; keyControlXYZ.x = 200.0f; keyControlXYZ.y = 200.0f;
keyControlXYZ.z = 0;<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
<br>
&nbsp;&nbsp;&nbsp; <em>float subscreenX = 0, subscreenY = 0; //
別描画スクリーンを描く位置<br>
&nbsp;&nbsp;&nbsp; int subscreenWidth = 600, subscreenHeight = 100;<br>
&nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE); //
SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドル作成を TRUE:許可<br>
&nbsp;&nbsp;&nbsp; // [別の描画スクリーンを用意]
https://dxlib.xsrv.jp/function/dxfunc_graph1.html#R3N25<br>
&nbsp;&nbsp;&nbsp; int subscreen = DxLib::MakeScreen(subscreenWidth,
subscreenHeight, FALSE);<br>
&nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE); //
FLASE:通常のグラフィックハンドルを作成するモードに戻す</em><br>
<br>
&nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
&nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
<br>
&nbsp;&nbsp;&nbsp; ScreenFlip();<br>
<br>
&nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
&nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは&times;ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();//
一旦キャンバスをきれいにまっさらに<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>int MouseX, MouseY;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マウスの位置を取得<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetMousePoint(&amp;MouseX,
&amp;MouseY);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreenX = MouseX;
subscreenY = MouseY; // マウスのポインタの位置を起点にサブのスクリーンを描く</em><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput =
GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -=
speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y
+= speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position =
VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth;
float height = imgHeight; // テクスチャ画僧のサイズ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(50.0f,
50.0f, 50.0f); // 拡大縮小スケール<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_A) keyControlAngle.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_B) keyControlAngle.y += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_C) keyControlAngle.z += speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad =
DX_PI_F / 180.0f; // 角度(単位:&deg;度)からラジアン(単位:rad)へ変換する係数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate =
keyControlAngle.x * Deg2Rad;&nbsp; const float
yRotate = keyControlAngle.y * Deg2Rad; const float zRotate =
keyControlAngle.z * Deg2Rad;<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp;
matWorldDefault; // デフォルトのワールド行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); //
デフォルトのワールド行列を記憶しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX mat; // モデルのスケール&times;回転&times;移動を行列計算で設定する<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[スケール]拡大縮小のスケール行列を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
[勉強]&darr;スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp;
mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y;
mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp;
mat.m[3][3] = 1.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[回転]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matRot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::CreateIdentityMatrix(&amp;matRot);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
★MMultは行列の乗算【乗算した順にz軸回転&rarr;x軸回転&rarr;y軸回転&rarr;平行移動】<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotZ(zRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotX(xRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotY(yRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matRot); //スケール &times; 回転<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[移動]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matTrans = MGetTranslate(VGet(position.x, position.y,
position.z)); // 位置positionをここで設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matTrans); //スケール&times;回転&times;移動<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定]
https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawPolygon32bitIndexed3D(Vertex.data(),
Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); //
三角形ポリゴンをたくさん描画<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0,
0, GetColor(255, 255, 0), "x:%f y:%f
Angle:%f %f %f", position.x, position.y, keyControlAngle.x,
keyControlAngle.y, keyControlAngle.z);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>int tmpResetSetting =
DxLib::GetUseSetDrawScreenSettingReset(); // 設定を一旦tmpに退避<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetUseSetDrawScreenSettingReset(FALSE); //
SetDrawScreen切り替え時に設定をリセットしない(FALSE)(これをやらないとカメラ視点などがリセットされるから)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpDrawScreen =
DxLib::GetDrawScreen(); // 一旦変更前のスクリーンのハンドルを退避<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetDrawScreen(subscreen);// ゲームを描く先を用意しておいたサブスクリーンに設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // (0,0)位置を起点に</em><em>別
スクリーン</em><em>へ文字列を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる",
GetColor(255, 255, 255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetDrawScreen((tmpDrawScreen == -1) ? DX_SCREEN_BACK :
tmpDrawScreen); // 描く先をもとのデフォルトのスクリーンに戻しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetUseSetDrawScreenSettingReset((tmpResetSetting == -1) ? TRUE :
tmpResetSetting); // 設定を元に戻す<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 画面に別スクリーンの内容を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawRectExtendGraph((int)subscreenX, (int)subscreenY,
(int)(subscreenX + subscreenWidth), (int)(subscreenY +
subscreenHeight), 0, 0, subscreenWidth, subscreenHeight, subscreen,
FALSE);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 別スクリーンの枠を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(
(int)((int)subscreenX - 1 + 0.5f),(int)((int)subscreenY - 1 + 0.5f),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(int)((int)(subscreenX
+
subscreenWidth
+
1)
+
0.5f),
(int)((int)(subscreenY
+ subscreenHeight + 1) + 0.5f),
GetColor(255,255,255), FALSE);</em><br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip();
//隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
&nbsp;&nbsp;&nbsp; WaitKey();<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
&nbsp;&nbsp;&nbsp; DxLib_End();<br>
&nbsp;&nbsp;&nbsp; // ソフトの終了<br>
&nbsp;&nbsp;&nbsp; return 0;<br>
}</a></p>
<p><a id="mozTocId0004" class="mozTocH1">このサブのスクリーンの機能をこてこてに魔改造するとウィンドウズ
のようなドラッグできるウィンドウをつくることもできます。<br>
</a></p>
<p><code><a id="mozTocId0004" class="mozTocH1">Input.hを新規作成</a></code><a
 id="mozTocId0004" class="mozTocH1">してドラッグや複数のスクリーンがあるときの一番上のレイヤーを保管する変数
やマウスのドラッ
グを取れるようにしましょう。</a></p>
<p class="source"><a id="mozTocId0004" class="mozTocH1">#ifndef INPUT_H_<br>
#define INPUT_H_<br>
<br>
#include &lt;climits&gt; //int型の最大値2147483647につかう<br>
#include &lt;unordered_map&gt; //【高速辞書配列】<br>
#include &lt;string&gt; // キーボード押下の文字列出力につかう<br>
<br>
#include "DxLib.h"<br>
<br>
// パッド番号<br>
enum class Pad<br>
{<br>
&nbsp;&nbsp;&nbsp; Keyboard = -3, // キーボード入力を得る<br>
&nbsp;&nbsp;&nbsp; All = -2, // すべてのうちどれか1つでも押されたとき(マウス除く)<br>
&nbsp;&nbsp;&nbsp; None = -1, // パッド割当て無(やられたり待機中のプレイヤに)<br>
&nbsp;&nbsp;&nbsp; Key = 0,<br>
&nbsp;&nbsp;&nbsp; One,<br>
&nbsp;&nbsp;&nbsp; Two,<br>
&nbsp;&nbsp;&nbsp; Three,<br>
&nbsp;&nbsp;&nbsp; Four,<br>
&nbsp;&nbsp;&nbsp; Mouse, // マウスのボタン判定に<br>
&nbsp;&nbsp;&nbsp; NUM,&nbsp; // コントローラの数=6(マウス込み)<br>
};<br>
<br>
enum class Mouse<br>
{<br>
&nbsp;&nbsp;&nbsp; All = -2, // すべてのうちどれか1つでも押されたとき<br>
&nbsp;&nbsp;&nbsp; None = -1,<br>
&nbsp;&nbsp;&nbsp; DownL, //[左クリック押した瞬間=1]<br>
&nbsp;&nbsp;&nbsp; DragL, //[左ドラッグ中=1]<br>
&nbsp;&nbsp;&nbsp; UpL, //[左クリック離した瞬間=1]<br>
&nbsp;&nbsp;&nbsp; DownR, //[右クリック押した瞬間=1]<br>
&nbsp;&nbsp;&nbsp; DragR, //[右ドラッグ中=1]<br>
&nbsp;&nbsp;&nbsp; UpR, //[右クリック離した瞬間=1]<br>
&nbsp;&nbsp;&nbsp; X, // 現在のマウス位置<br>
&nbsp;&nbsp;&nbsp; ReleaseX, // 離した状態のマウス位置(ドラッグ中は開始前位置)<br>
&nbsp;&nbsp;&nbsp; DownLX, //[左] 押した位置<br>
&nbsp;&nbsp;&nbsp; DragLX, //[左] ドラッグ中の位置<br>
&nbsp;&nbsp;&nbsp; UpLX, //[左] 離した位置<br>
&nbsp;&nbsp;&nbsp; DownRX,//[右] 押した位置<br>
&nbsp;&nbsp;&nbsp; DragRX, //[右] ドラッグ中の位置<br>
&nbsp;&nbsp;&nbsp; UpRX, //[右] 離した位置<br>
&nbsp;&nbsp;&nbsp; Y, // 現在のマウス位置<br>
&nbsp;&nbsp;&nbsp; ReleaseY, // 離した状態のマウス位置(ドラッグ中は開始前位置)<br>
&nbsp;&nbsp;&nbsp; DownLY, //[左] 押した位置<br>
&nbsp;&nbsp;&nbsp; DragLY, //[左] ドラッグ中の位置<br>
&nbsp;&nbsp;&nbsp; UpLY, //[左] 離した位置<br>
&nbsp;&nbsp;&nbsp; DownRY,//[右] 押した位置<br>
&nbsp;&nbsp;&nbsp; DragRY, //[右] ドラッグ中の位置<br>
&nbsp;&nbsp;&nbsp; UpRY, //[右] 離した位置<br>
&nbsp;&nbsp;&nbsp; NUM<br>
};<br>
<br>
// 入力クラス<br>
class Input<br>
{<br>
public:<br>
&nbsp;&nbsp;&nbsp; // ある動作として反応するボタン一覧(ビット論理和「|または」)<br>
&nbsp;&nbsp;&nbsp; enum Button<br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //[反応ボタン一覧定義]
https://dixq.net/g/04_05.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 参加ボタン 1=Z 2=X 3=C 4=A 5=S
6=D 7=Q 8=W 9=ESC 10=SPACE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Join = PAD_INPUT_1 |
PAD_INPUT_2 | PAD_INPUT_3 | PAD_INPUT_4<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | PAD_INPUT_5 | PAD_INPUT_6
| PAD_INPUT_7 | PAD_INPUT_8<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | PAD_INPUT_9 |
PAD_INPUT_10, //1Z～10SPACEキー全て反応<br>
&nbsp;&nbsp;&nbsp; };<br>
<br>
&nbsp;&nbsp;&nbsp; const int MaxPadNum = (int)Pad::Four + 1; //
最大パッド数(Keyぶん+1)<br>
<br>
&nbsp;&nbsp;&nbsp; static int prevStates[(int)Pad::NUM]; // 1フレーム前の状態<br>
&nbsp;&nbsp;&nbsp; static int currentStates[(int)Pad::NUM]; // 現在の状態<br>
&nbsp;&nbsp;&nbsp; static std::unordered_map&lt;Pad, bool&gt; isJoin;
// 参加中のパッド番号辞書<br>
&nbsp;&nbsp;&nbsp; // 参加中のパッドかどうか?<br>
&nbsp;&nbsp;&nbsp; static bool IsJoin(Pad pad) { return
isJoin.count(pad) &amp;&amp; Input::isJoin[pad]; }<br>
&nbsp;&nbsp;&nbsp; static std::unordered_map&lt;int, int&gt; padDic; //
パッド番号からDXの定義への辞書<br>
<br>
&nbsp;&nbsp;&nbsp; static int prevMouse; // 1フレーム前のマウス状態<br>
&nbsp;&nbsp;&nbsp; static int currentMouse; // 現在のマウス状態<br>
&nbsp;&nbsp;&nbsp; static int MouseX, MouseY; // 現在のマウス位置<br>
&nbsp;&nbsp;&nbsp; static int <span style="font-weight: bold;">TopLayerMouseX</span>,
<span style="font-weight: bold;">TopLayerMouseY</span>; //
Subsreenの一番上のレイヤのマウス位置XY(Subscreenクラスで更新)<br>
&nbsp;&nbsp;&nbsp; static int ClickX, ClickY, MButton, LogType;<br>
&nbsp;&nbsp;&nbsp; static float MouseWheel; // マウスのホイールの回転<br>
&nbsp;&nbsp;&nbsp; static std::unordered_map&lt;Mouse, int&gt;
Click;//&lt;Mouse&rArr;int&gt; マウスのクリックXY位置辞書<br>
<br>
&nbsp;&nbsp;&nbsp;
//[キーボード入力]https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
&nbsp;&nbsp;&nbsp; static char prevKey[256]; // 1フレーム前のキーボード状態<br>
&nbsp;&nbsp;&nbsp; static char currentKey[256]; // 現在のキーボード状態<br>
&nbsp;&nbsp;&nbsp; static std::string
KeyString[256];//&lt;キーコード&rArr;キー文字列&gt;の辞書<br>
&nbsp;&nbsp;&nbsp; static std::string
CapsString[256];//&lt;Caps状態キーコード&rArr;キー文字列&gt;の辞書<br>
&nbsp;&nbsp;&nbsp; static bool isCapsLocked;// CapsLock状態か?<br>
&nbsp;&nbsp;&nbsp; static bool isShifted;// Shiftが押された状態か?<br>
<br>
&nbsp;&nbsp;&nbsp; //★【DXコントローラバグ検知】初回プッシュが被ればDXバグで同一コントローラ<br>
&nbsp;&nbsp;&nbsp; static int firstPushTiming[(int)Pad::NUM - 1]; //
マウスのぶんの配列はいらないから-1<br>
&nbsp;&nbsp;&nbsp; static int timing;// = 0;<br>
&nbsp;&nbsp;&nbsp; static bool isBugCheckMode;// = false; //バグチェックを開始するか<br>
<br>
private:<br>
&nbsp;&nbsp;&nbsp; // 辞書配列の初期化<br>
&nbsp;&nbsp;&nbsp; static void InitPadDictionary()<br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 辞書配列で対応関係を結び付けておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padDic[(int)Pad::Key] =
DX_INPUT_KEY_PAD1; // DX_INPUT_KEY<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padDic[(int)Pad::One] =
DX_INPUT_PAD1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padDic[(int)Pad::Two] =
DX_INPUT_PAD2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padDic[(int)Pad::Three] =
DX_INPUT_PAD3;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padDic[(int)Pad::Four] =
DX_INPUT_PAD4;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
public:<br>
&nbsp;&nbsp;&nbsp; // 初期化。最初に1回だけ呼んでください。<br>
&nbsp;&nbsp;&nbsp; static void Init()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitPadDictionary(); //
辞書配列の初期化<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitKeyString(); //
キーボード辞書配列の初期化<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キー状態をゼロリセット<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt;
(int)Pad::NUM; i++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prevStates[i] = currentStates[i] = 0;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitMouse(); // マウスの状態初期化<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitKeyboard(); //
キーボードの状態初期化<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timing = 0, isBugCheckMode =
false; //バグチェックを開始するか<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; // マウスの状態初期化<br>
&nbsp;&nbsp;&nbsp; static void InitMouse()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MouseX = -1, MouseY = -1; //
現在のマウス位置を-1で初期状態では画面外として初期化<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClickX = -1, ClickY = -1,
MButton = 0, LogType = 0;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::ReleaseX] = -1;
Click[Mouse::ReleaseY] = -1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpLX] =
-1;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpLY] = -1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpRX] =
-1;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::UpRY] = -1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DownLX] =
-1;&nbsp;&nbsp; Click[Mouse::DownLY] = -1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DownRX] =
-1;&nbsp;&nbsp; Click[Mouse::DownRY] = -1;<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; // キーボードの状態初期化<br>
&nbsp;&nbsp;&nbsp; static void InitKeyboard()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キー状態をゼロリセット<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 256;
i++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prevKey[i] = currentKey[i] = 0;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // 最新の入力状況に更新する処理。<br>
&nbsp;&nbsp;&nbsp; // 毎フレームの最初に（ゲームの処理より先に）呼んでください。<br>
&nbsp;&nbsp;&nbsp; static void Update()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt;
(int)Pad::Mouse; i++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //
現在の状態を一つ前の状態として保存してGetJoypad..<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prevStates[i] = currentStates[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
currentStates[i] = GetJoypadInputState(padDic[i]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateMouse(); // マウス状態を更新<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateKeyboard(); //
キーボード状態を更新<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isBugCheckMode = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timing++; //タイミングのカウントを+1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (timing == INT_MAX)
timing = 0; // long型最大値になったら0に戻す<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // キーボードの状態を更新する<br>
&nbsp;&nbsp;&nbsp; static void UpdateKeyboard()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy(prevKey, currentKey,
sizeof(prevKey));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // キーボードの状態配列を更新する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GetHitKeyStateAll(currentKey); //
https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(GetButtonUp(Pad::Keyboard, KEY_INPUT_CAPSLOCK))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
isCapsLocked = !isCapsLocked; // CapsLock状態を反転<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // シフトが押された状態かを更新<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isShifted =
(GetButton(Pad::Keyboard, KEY_INPUT_LSHIFT) || GetButton(Pad::Keyboard,
KEY_INPUT_RSHIFT));<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // マウスの状態を更新する<br>
&nbsp;&nbsp;&nbsp; static void UpdateMouse()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::DownL] = 0;
Click[Mouse::DownR] = 0; //Click[Mouse.UpL] = 0; Click[Mouse.UpR] = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::All] = 0; //
状態辞書の0リセット<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevMouse = currentMouse; //
前フレームの最新のマウス情報を1つ前の情報とする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevStates[(int)Pad::Mouse]
= currentMouse;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MouseWheel =
GetMouseWheelRotVolF(); // マウスのホイール回転量を更新<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マウスの位置を取得<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetMousePoint(&amp;MouseX,
&amp;MouseY);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TopLayerMouseX = MouseX;
TopLayerMouseY = MouseY;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Click[Mouse::X] = MouseX;
Click[Mouse::Y] = MouseY;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentMouse =
GetMouseInput(); // マウス状態を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
currentStates[(int)Pad::Mouse] = currentMouse; // マウス状態をパッド状態にも併合<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 押してない離した状態のマウス位置を更新<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (currentMouse == 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Click[Mouse::ReleaseX] = MouseX; Click[Mouse::ReleaseY] = MouseY;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else Click[Mouse::All] = 1;
// マウスのいずれかのボタンが押されている<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
 style="font-weight: bold;">// 左マウスドラッグ中のXY位置を更新</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetButton(Pad::Mouse,
MOUSE_INPUT_LEFT) &amp;&amp; !GetButtonDown(Pad::Mouse,
MOUSE_INPUT_LEFT))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Click[Mouse::DragLX] = MouseX; Click[Mouse::DragLY] = MouseY;
Click[Mouse::DragL] = 1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Click[Mouse::DragL] = 0;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
 style="font-weight: bold;">// 右マウスドラッグ中のXY位置を更新</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetButton(Pad::Mouse,
MOUSE_INPUT_RIGHT) &amp;&amp; !GetButtonDown(Pad::Mouse,
MOUSE_INPUT_RIGHT))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Click[Mouse::DragRX] = MouseX; Click[Mouse::DragRY] = MouseY;
Click[Mouse::DragR] = 1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Click[Mouse::DragR] = 0;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[マウスクリック検知]
https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N40<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
マウスのボタンが押されたり離されたりしたかどうかの情報を取得する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(GetMouseInputLog2(&amp;MButton, &amp;ClickX, &amp;ClickY,
&amp;LogType, TRUE) == 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
[左ボタン]が押されたり離されたりしていた<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
((MButton &amp; MOUSE_INPUT_LEFT) != 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{&nbsp;&nbsp; // クリックされた瞬間と離された瞬間のマウス位置を記録<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if
(LogType
==
MOUSE_INPUT_LOG_DOWN)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Click[Mouse::DownLX]
=
ClickX;
Click[Mouse::DownLY]
=
ClickY;
Click[Mouse::DownL]
=
1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else
if
(LogType
==
MOUSE_INPUT_LOG_UP)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Click[Mouse::UpLX]
=
ClickX;
Click[Mouse::UpLY]
=
ClickY;
Click[Mouse::UpL]
=
1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//
[右ボタン]が押されたり離されたりしていた<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
if ((MButton &amp; MOUSE_INPUT_RIGHT) != 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{&nbsp;&nbsp; // クリックされた瞬間と離された瞬間のマウス位置を記録<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if
(LogType
==
MOUSE_INPUT_LOG_DOWN)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Click[Mouse::DownRX]
=
ClickX;
Click[Mouse::DownRY]
=
ClickY;
Click[Mouse::DownR]
=
1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else
if
(LogType
==
MOUSE_INPUT_LOG_UP)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Click[Mouse::UpRX]
=
ClickX;
Click[Mouse::UpRY]
=
ClickY;
Click[Mouse::UpR]
=
1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // ボタンが押されているか？<br>
&nbsp;&nbsp;&nbsp; static bool GetButton(int buttonId) { return
GetButton(Pad::Key, buttonId); }<br>
&nbsp;&nbsp;&nbsp; static bool GetButton(Pad pad, int buttonId)<br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //コントローラバグチェック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ControllerBugCheck(pad,
buttonId)) return false;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::None) return
false; // Noneなら判別不要<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (pad == Pad::All) //
All指定の時は全てのパッド<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //
GetButtonの中でGetButtonを呼ぶ【再起呼出し】テクニック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for
(int i = 0; i &lt; (int)Pad::NUM; i++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if
(GetButton((Pad)i,
buttonId))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return
true;
//押されているPadを発見！<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return false; // 一つも押されていなかった<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::Keyboard) //
今ボタンが押されているかどうかを返却<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return (currentKey[buttonId] == 1);
//https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 今ボタンが押されているかどうかを返却<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
(currentStates[(int)pad] &amp; buttonId) != 0;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // ボタンが押された瞬間か？<br>
&nbsp;&nbsp;&nbsp; static bool GetButtonDown(int buttonId) { return
GetButtonDown(Pad::Key, buttonId); }<br>
&nbsp;&nbsp;&nbsp; static bool GetButtonDown(Pad pad, int buttonId)<br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //コントローラバグチェック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ControllerBugCheck(pad,
buttonId)) return false;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::None) return
false; // Noneなら判別不要<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (pad == Pad::All) //
All指定の時は全てのパッド<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //
再起呼出しテクニック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for
(int i = 0; i &lt; (int)Pad::NUM; i++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if
(GetButtonDown((Pad)i,
buttonId))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return
true;
//押されているPadを発見！<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return false; // 一つも押されていなかった<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::Keyboard)
//https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return (currentKey[buttonId] == 1) &amp;&amp; (prevKey[buttonId] != 1);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
今は押されていて、かつ1フレーム前は押されていない場合はtrueを返却<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
((currentStates[(int)pad] &amp; buttonId) &amp; ~(prevStates[(int)pad]
&amp; buttonId)) != 0;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // ボタンが離された瞬間か？<br>
&nbsp;&nbsp;&nbsp; static bool GetButtonUp(int buttonId) { return
GetButtonDown(Pad::Key, buttonId); }<br>
&nbsp;&nbsp;&nbsp; static bool GetButtonUp(Pad pad, int buttonId)<br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //コントローラバグチェック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ControllerBugCheck(pad,
buttonId)) return false;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::None) return
false; // Noneなら判別不要<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (pad == Pad::All) //
All指定の時は全てのパッド<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //
再起呼出しテクニック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for
(int i = 0; i &lt; (int)Pad::NUM; i++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if
(GetButtonUp((Pad)i,
buttonId))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return
true;
//押されているPadを発見！<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return false; // 一つも押されていなかった<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::Keyboard)
//https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return (prevKey[buttonId] == 1) &amp;&amp; (currentKey[buttonId] != 1);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
1フレーム前は押されていて、かつ今は押されている場合はtrueを返却<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
((prevStates[(int)pad] &amp; buttonId) &amp; ~(currentStates[(int)pad]
&amp; buttonId)) != 0;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
<br>
&nbsp;&nbsp;&nbsp; //コントローラのボタンの初回プッシュを検知し<br>
&nbsp;&nbsp;&nbsp; //他コントローラと初回タイミングが完全被りかチェック<br>
&nbsp;&nbsp;&nbsp; //★初回タイミングが完全被りなら【怪しい】重複コントローラとみなし判定処理スルー<br>
&nbsp;&nbsp;&nbsp; static bool ControllerBugCheck(Pad pad, int buttonId)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pad == Pad::Mouse)
return false; // マウスはバグチェック不要<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (pad ==
Pad::Keyboard) return false; // キーボードはバグチェック不要<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
今は押されていて、かつ1フレーム前は押されていない場合<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool buttonDown =
((currentStates[(int)pad] &amp; buttonId) &amp; ~(prevStates[(int)pad]
&amp; buttonId)) != 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (isBugCheckMode ==
false) return false; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //コントローラの初回ボタンプッシュを検知<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (buttonDown &amp;&amp;
firstPushTiming[(int)pad] == 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for
(int i = 0; i &lt; (int)Pad::NUM - 1; i++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{&nbsp;&nbsp; //全コントローラ初回プッシュ被りがないかチェック完全同時は怪しいので-1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
bool
isDown
=
((currentStates[i]
&amp;
buttonId)
&amp;
~(prevStates[i]
&amp; buttonId)) != 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if
((Pad)i
!=
pad
&amp;&amp;
isDown
////初回プッシュ被り検出<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;&amp;
(timing
==
firstPushTiming[i]
||
firstPushTiming[i]
==
0))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{&nbsp;&nbsp;
//初回プッシュのタイミング被りは-1フラグを記録<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
firstPushTiming[i]
=
-1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(firstPushTiming[(int)pad] != -1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
firstPushTiming[(int)pad]
=
timing;//初回プッシュを記録<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(firstPushTiming[(int)pad] == -1) return true; //DXのコントローラ被りバグ！<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else return false;
//コントローラ被りOK!<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // キーボードのキーと文字列の対応関係配列の初期化
https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N2<br>
&nbsp;&nbsp;&nbsp; static void InitKeyString()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 辞書配列で対応関係を結び付けておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_BACK] =
"BackSpace";//"\b";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_TAB] =
"\t";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RETURN]
= "\n";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LSHIFT]
= "ShiftL";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RSHIFT]
= "ShiftR";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
KeyString[KEY_INPUT_LCONTROL] = "CtrlL";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
KeyString[KEY_INPUT_RCONTROL] = "CtrlR";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SPACE] =
" ";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PGUP] =
"PgUp";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PGDN] =
"PgDn";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_END] =
"End";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_HOME] =
"Home";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LEFT] =
"Left";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_UP] =
"Up";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RIGHT] =
"Right";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DOWN] =
"Down";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_INSERT]
= "Insert";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DELETE]
= "Delete";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_MINUS] =
"-"; CapsString[KEY_INPUT_MINUS] = "=";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_YEN] =
"\\"; CapsString[KEY_INPUT_YEN] = "|";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
KeyString[KEY_INPUT_PREVTRACK] = "^"; CapsString[KEY_INPUT_PREVTRACK] =
"~";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PERIOD]
= "."; CapsString[KEY_INPUT_PERIOD] = "&gt;";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SLASH] =
"/"; CapsString[KEY_INPUT_SLASH] = "?";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_LALT] =
"AltL";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_RALT] =
"AltR";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_SCROLL]
= "Scroll";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
KeyString[KEY_INPUT_SEMICOLON] = ";"; CapsString[KEY_INPUT_SEMICOLON] =
"+";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_COLON] =
":"; CapsString[KEY_INPUT_COLON] = "*";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
KeyString[KEY_INPUT_LBRACKET] = "["; CapsString[KEY_INPUT_LBRACKET] =
"{";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
KeyString[KEY_INPUT_RBRACKET] = "]"; CapsString[KEY_INPUT_RBRACKET] =
"}";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_AT] =
"@"; CapsString[KEY_INPUT_AT] = "`";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
KeyString[KEY_INPUT_BACKSLASH] = "\\"; CapsString[KEY_INPUT_BACKSLASH]
= "_";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_COMMA] =
","; CapsString[KEY_INPUT_COMMA] = "&lt;";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
KeyString[KEY_INPUT_CAPSLOCK] = "CapsLock";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_PAUSE] =
"Pause";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD0]
= "0";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD1]
= "1";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD2]
= "2";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD3]
= "3";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD4]
= "4";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD5]
= "5";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD6]
= "6";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD7]
= "7";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD8]
= "8";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_NUMPAD9]
= "9";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
KeyString[KEY_INPUT_MULTIPLY] = "*";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_ADD] =
"+";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
KeyString[KEY_INPUT_SUBTRACT] = "-";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DECIMAL]
= ".";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_DIVIDE]
= "/";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
KeyString[KEY_INPUT_NUMPADENTER] = "\n";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F1] =
"F1";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F2] =
"F2";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F3] =
"F3";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F4] =
"F4";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F5] =
"F5";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F6] =
"F6";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F7] =
"F7";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F8] =
"F8";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F9] =
"F9";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F10] =
"F10";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F11] =
"F11";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F12] =
"F12";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_A] =
"a"; CapsString[KEY_INPUT_A] = "A";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_B] =
"b"; CapsString[KEY_INPUT_B] = "B";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_C] =
"c"; CapsString[KEY_INPUT_C] = "C";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_D] =
"d"; CapsString[KEY_INPUT_D] = "D";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_E] =
"e"; CapsString[KEY_INPUT_E] = "E";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_F] =
"f"; CapsString[KEY_INPUT_F] = "F";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_G] =
"g"; CapsString[KEY_INPUT_G] = "G";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_H] =
"h"; CapsString[KEY_INPUT_H] = "H";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_I] =
"i"; CapsString[KEY_INPUT_I] = "I";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_J] =
"j"; CapsString[KEY_INPUT_J] = "J";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_K] =
"k"; CapsString[KEY_INPUT_K] = "K";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_L] =
"l"; CapsString[KEY_INPUT_L] = "L";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_M] =
"m"; CapsString[KEY_INPUT_M] = "M";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_N] =
"n"; CapsString[KEY_INPUT_N] = "N";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_O] =
"o"; CapsString[KEY_INPUT_O] = "O";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_P] =
"p"; CapsString[KEY_INPUT_P] = "P";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_Q] =
"q"; CapsString[KEY_INPUT_Q] = "Q";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_R] =
"r"; CapsString[KEY_INPUT_R] = "R";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_S] =
"s"; CapsString[KEY_INPUT_S] = "S";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_T] =
"t"; CapsString[KEY_INPUT_T] = "T";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_U] =
"u"; CapsString[KEY_INPUT_U] = "U";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_V] =
"v"; CapsString[KEY_INPUT_V] = "V";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_W] =
"w"; CapsString[KEY_INPUT_W] = "W";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_X] =
"x"; CapsString[KEY_INPUT_X] = "X";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_Y] =
"y"; CapsString[KEY_INPUT_Y] = "Y";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_Z] =
"z"; CapsString[KEY_INPUT_Z] = "Z";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_0] = "0";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_1] =
"1"; CapsString[KEY_INPUT_1] = "!";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_2] =
"2"; CapsString[KEY_INPUT_2] = "\"";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_3] =
"3"; CapsString[KEY_INPUT_3] = "#";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_4] =
"4"; CapsString[KEY_INPUT_4] = "$";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_5] =
"5"; CapsString[KEY_INPUT_5] = "%";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_6] =
"6"; CapsString[KEY_INPUT_6] = "&amp;";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_7] =
"7"; CapsString[KEY_INPUT_7] = "'";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_8] =
"8"; CapsString[KEY_INPUT_8] = "(";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyString[KEY_INPUT_9] =
"9"; CapsString[KEY_INPUT_9] = ")";<br>
&nbsp;&nbsp;&nbsp; }<br>
};<br>
<br>
#endif</a></p>
<p><a id="mozTocId0004" class="mozTocH1"><br>
</a></p>
<p><code><a id="mozTocId0004" class="mozTocH1">Input.cppを新規作成</a></code><a
 id="mozTocId0004" class="mozTocH1">してドラッグや複数のスクリーンがあるときの一番上のレイヤーを保管する変数
などの
static変数を定義しましょう。</a></p>
<p class="source"><a id="mozTocId0004" class="mozTocH1">#include
"Input.h"<br>
<br>
int Input::prevStates[]; // 1フレーム前の状態<br>
int Input::currentStates[]; // 現在の状態<br>
// &uarr;static intのときはこの行書かないとシンボリックエラーになる件(このためだけにcpp書かなきゃならん)<br>
<br>
std::unordered_map&lt;Pad, bool&gt; Input::isJoin; // 参加中のパッド番号辞書<br>
// 参加中のパッドかどうか?<br>
std::unordered_map&lt;int, int&gt; Input::padDic; // パッド番号からDXの定義への辞書<br>
<br>
int Input::prevMouse; // 1フレーム前のマウス状態<br>
int Input::currentMouse; // 現在のマウス状態<br>
int Input::MouseX{ -1 }, Input::MouseY{ -1 }; // 現在のマウス位置<br>
int Input::TopLayerMouseX{ -1 }, Input::TopLayerMouseY{ -1 }; //
現在のマウス位置<br>
float Input::MouseWheel{ 0 };<br>
int Input::ClickX{ -1 }, Input::ClickY{ -1 }, Input::MButton{ 0 },
Input::LogType{ 0 };<br>
std::unordered_map&lt;Mouse, int&gt;
Input::Click;//&lt;Mouse&rArr;int&gt; マウスのクリックXY位置辞書<br>
<br>
//[キーボード入力]https://dxlib.xsrv.jp/function/dxfunc_input.html#R5N28<br>
char Input::prevKey[256]; // 1フレーム前のキーボード状態<br>
char Input::currentKey[256]; // 現在のキーボード状態<br>
std::string Input::KeyString[256];//&lt;キーコード&rArr;キー文字列&gt;の辞書<br>
std::string Input::CapsString[256];//&lt;Caps状態キーコード&rArr;キー文字列&gt;の辞書<br>
bool Input::isCapsLocked{ false };// CapsLock状態か?<br>
bool Input::isShifted{ false };// Shiftが押された状態か?<br>
<br>
<br>
//★【DXコントローラバグ検知】初回プッシュが被ればDXバグで同一コントローラ<br>
int Input::firstPushTiming[(int)Pad::NUM - 1]; // マウスのぶんの配列はいらないから-1<br>
int Input::timing{ 0 };<br>
bool Input::isBugCheckMode = false; //バグチェックを開始するか<br>
</a></p>
<p><a id="mozTocId0004" class="mozTocH1"><br>
</a></p>
<p><code><a id="mozTocId0004" class="mozTocH1">Screen.h</a></code><a
 id="mozTocId0004" class="mozTocH1">にWindowsのウィンドウみたいにドラッグできるSubScreenクラ
スを追加しましょう。</a></p>
<p class="source"><a id="mozTocId0004" class="mozTocH1">#ifndef
_SCREEN_H<br>
#define _SCREEN_H<br>
<br>
<em>#include &lt;string&gt;<br>
#include &lt;set&gt; // サブスクリーンをDepth順に並べ替えるのに使う [multisetを使用するのに必要]<br>
#include &lt;unordered_map&gt; // サブスクリーンをidをキーに保管するのに使う<br>
#include &lt;memory&gt; // std::shared_ptrに使う</em><br>
#include "DxLib.h"<br>
<em><br>
#include &lt;assert.h&gt; // アサート警告表示用</em><br>
<br>
<em>#include "Input.h"</em><br>
<br>
// 画面解像度<br>
class Screen<br>
{<br>
public: //publicはC＃と違いpublic:以下にまとめて書かれるスタイル<br>
&nbsp;&nbsp;&nbsp; static const int Width = 1280; // 幅<br>
&nbsp;&nbsp;&nbsp; static const int Height = 720; // 高さ
C＃と違いstaticクラスではなく個々の【すべての変数にstaticをつけて】staticなクラスとする<br>
<br>
&nbsp;&nbsp;&nbsp; <em>// X,Yがウィンドウの中にあるか<br>
&nbsp;&nbsp;&nbsp; static bool IsInsideWindow(int screenX =
Input::MouseX, int screenY = Input::MouseY) { return (0 &lt;= screenX
&amp;&amp; screenX &lt; Width) &amp;&amp; (0 &lt;= screenY &amp;&amp;
screenY &lt; Height); }</em><br>
};// C＃と違ってクラスの定義も;セミコロンで終わる<br>
<br>
<br>
<em>class SubScreen : public
std::enable_shared_from_this&lt;SubScreen&gt;<br>
{&nbsp;&nbsp;&nbsp; // [std::shared_ptrでthisポインタをつかうためには]&uarr;
https://www.kabuku.co.jp/developers/cpp_enable_shared_from_this<br>
protected:<br>
&nbsp;&nbsp;&nbsp; int id; //サブスクリーンの管理ID<br>
&nbsp;&nbsp;&nbsp; int handle = -1; //サブスクリーンへのハンドル<br>
&nbsp;&nbsp;&nbsp; int tmpDrawScreen = -1; //
DrawStartとDrawEndのあいだDrawStart前のhandleを一時保管する<br>
&nbsp;&nbsp;&nbsp; int tmpResetSetting = -1; //
DrawStartとDrawEndのあいだDrawStart前の設定を一時保管する<br>
<br>
&nbsp;&nbsp;&nbsp; static int serialDivID; //= 0
サブスクリーンを新たに生成するときの通し番号(シリアルID)<br>
<br>
public:<br>
&nbsp;&nbsp;&nbsp; int frameWidth = 2;//サブスクリーンの枠の幅<br>
&nbsp;&nbsp;&nbsp; unsigned int frameColor = DxLib::GetColor(255, 255,
255); //サブスクリーンの枠の色<br>
&nbsp;&nbsp;&nbsp; float x = 0, y = 0; //サブスクリーンの描画位置<br>
&nbsp;&nbsp;&nbsp; float zoomRate = 1.0f; // スクリーンに描くズーム率<br>
&nbsp;&nbsp;&nbsp; float LocalX(float mainScreenX) { return
(mainScreenX - x) / zoomRate; } // メインのスクリーンのXからサブスクリーンのローカルなXへ変換<br>
&nbsp;&nbsp;&nbsp; float LocalY(float mainScreenY) { return
(mainScreenY - y) / zoomRate; } // メインのスクリーンのYからサブスクリーンのローカルなYへ変換<br>
&nbsp;&nbsp;&nbsp; bool IsInside(float mainScreenX, float mainScreenY)
{ return (x &lt; mainScreenX &amp;&amp; mainScreenX &lt; x + Width *
zoomRate) &amp;&amp; (y &lt; mainScreenY &amp;&amp; mainScreenY &lt; y
+ Height * zoomRate); } // メインのスクリーン上のXとYがサブスクリーンの内側にあるか<br>
&nbsp;&nbsp;&nbsp; bool IsOnBarFrame(float mainScreenX, float
mainScreenY) { return (x - frameWidth - 1 &lt; mainScreenX &amp;&amp;
mainScreenX &lt; x + Width * zoomRate + frameWidth + 1) &amp;&amp; (y -
frameWidth - 1 - barFrameHeight &lt; mainScreenY &amp;&amp; mainScreenY
&lt; y + frameWidth + 1 + Height * zoomRate); } // バーを含むウィンドウの内側にあるか<br>
&nbsp;&nbsp;&nbsp; bool IsOnBar(float mainScreenX, float mainScreenY) {
return (x - frameWidth - 1 &lt; mainScreenX &amp;&amp; mainScreenX &lt;
x + Width * zoomRate + frameWidth + 1) &amp;&amp; (y - frameWidth - 1 -
barFrameHeight &lt; mainScreenY &amp;&amp; mainScreenY &lt; y +
frameWidth + 1); } // バーを含むウィンドウの内側にあるか<br>
<br>
&nbsp;&nbsp;&nbsp; float Width = 0, Height = 0; // サブスクリーンの幅と高さ<br>
&nbsp;&nbsp;&nbsp; int Alpha = 255; // デフォルトは透明じゃない(アルファ不透明度=255)<br>
&nbsp;&nbsp;&nbsp; float renderX = 0, renderY = 0;
//描画オフセット位置(一部だけを抜き出してスクリーンにレンダリングするときに設定)<br>
&nbsp;&nbsp;&nbsp; float renderWidth = 0; float renderHeight = 0; //
抜き出してスクリーンに描く部位の幅と高さ<br>
<br>
&nbsp;&nbsp;&nbsp; int Depth = 0; //[この値が大きいほど手前に割り込んで描かれる]
[Unityの描画順を参考に]
https://tama-lab.net/2017/07/unity%E3%81%A7%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E6%8F%8F%E7%94%BB%E9%A0%86%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95/<br>
&nbsp;&nbsp;&nbsp; static bool isDepthLayerChanged; //= false
新しいレイヤが追加されり変更があった時だけ並べ替えるためのフラグ<br>
<br>
&nbsp;&nbsp;&nbsp; bool isInitAgain = false; //
WidthやHeightやAlphaが変わったらDxLib::MakeScreenのやり直し<br>
&nbsp;&nbsp;&nbsp; bool isFrameShow = false; // ウィンドウのフレームを描くか<br>
&nbsp;&nbsp;&nbsp; bool isBarShow = false; // ウィンドウズみたいなウィンドウのバーを描くか<br>
&nbsp;&nbsp;&nbsp; int barFrameHeight = 15; // ウィンドウのバーの高さ<br>
&nbsp;&nbsp;&nbsp; int barFrameFontSize = 14; // ウィンドウのバーのnameのフォントサイズ<br>
&nbsp;&nbsp;&nbsp; unsigned int barColor = DxLib::GetColor(0, 0, 0);
//バーの色<br>
<br>
&nbsp;&nbsp;&nbsp; unsigned int stringColor = DxLib::GetColor(255, 255,
255); //サブスクリーンの枠の色<br>
&nbsp;&nbsp;&nbsp; std::string drawString = ""; //
デバッグなどのためにスクリーンの左上に表示する文字列(サブスクリーン番号など)<br>
&nbsp;&nbsp;&nbsp; std::string tag = "";<br>
&nbsp;&nbsp;&nbsp; std::string name = ""; //サブスクリーン名<br>
<br>
&nbsp;&nbsp;&nbsp; int GetID() { return id; } // サブスクリーンの管理ID<br>
&nbsp;&nbsp;&nbsp; inline static int NewID() { return ++serialDivID; }
//スクリーンの通し番号を+1(先に+1するので0はなく1からID割り振り)<br>
<br>
&nbsp;&nbsp;&nbsp; static std::shared_ptr&lt;SubScreen&gt; Get(int id)
{ // ★constは添え字[]読み取りの処理を定義<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(SubScreen::layers.count(id) == 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
assert("指定したIDの分割スクリーンはまだ未生成！Make()関数で新規生成してください" == "");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return layers[id]; // 読み取り<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
protected:<br>
&nbsp;&nbsp;&nbsp;
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ペア&lt;Depth,
id&gt;<br>
&nbsp;&nbsp;&nbsp; typedef std::pair&lt;int, int&gt; depth_id_pair;<br>
&nbsp;&nbsp;&nbsp; static std::multiset&lt;depth_id_pair&gt;
depth_id_ordered; // std::multiset[キーの無い版のstd::map(マルチでキーかぶりOK版)]
http://alctail.sakura.ne.jp/tip/cplus_kannrenn/cplusplus/stl.shtml#stl2-7<br>
public:<br>
&nbsp;&nbsp;&nbsp; // オーダー(並べ替えられた)IDを返す<br>
&nbsp;&nbsp;&nbsp; static std::vector&lt;int&gt; GetOrderedIDs(bool
isDesc = false) { // Desc(降順) 4 3 2 2 1 みたいな降りるid順<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt;
orderedIDs;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
std::multiset&lt;depth_id_pair&gt;::iterator ite =
depth_id_ordered.begin();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (ite !=
depth_id_ordered.end())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
id = ite-&gt;second;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
orderedIDs.emplace_back(id); // depth順に追加<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ite++;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isDesc) return
orderedIDs;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[逆順の範囲for文]
https://koturn.hatenablog.com/entry/2018/07/21/190000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt;
descIDs;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto itr =
std::rbegin(orderedIDs); itr != std::rend(orderedIDs); ++itr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
descIDs.emplace_back(*itr); // 逆順に<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return descIDs;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; class Greater_Depth<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; public: // Depthでソートするために比較用オペレータを定義<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool operator() (SubScreen*
left, SubScreen* right) const<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return (left-&gt;Depth &gt; right-&gt;Depth); // 不等号 &gt; で比較<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; };<br>
&nbsp;&nbsp;&nbsp; // Depthでソートするためにオペレータをオーバーロード<br>
&nbsp;&nbsp;&nbsp; bool operator &lt; (const SubScreen&amp; another)
const {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this-&gt;Depth &gt;
another.Depth;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //[protectedなコンストラクタでもstd::make_sharedで呼ぶテク]
https://gintenlabo.hatenablog.com/entry/20131211/1386771626<br>
&nbsp;&nbsp;&nbsp; template&lt;typename ProtectedT&gt;<br>
&nbsp;&nbsp;&nbsp; struct ProtectedCall : public ProtectedT //
ProtectedTをpublicで継承することで
ProtectedCallから見てProtectedTのコンストラクタはpublicになるテク<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class...
ArgsT&gt; // std::make_sharedはprotectedな継承クラスは呼べないのでそれを回避するテクニック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; explicit
ProtectedCall(ArgsT&amp;&amp;... args)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
ProtectedT(std::forward&lt;ArgsT&gt;(args)...) { }
//std::forwardで複数引数を完全転送で引き渡し
https://proc-cpuinfo.fixstars.com/2016/03/c-html/<br>
&nbsp;&nbsp;&nbsp; };<br>
<br>
&nbsp;&nbsp;&nbsp; struct Layers : public std::unordered_map&lt;int,
std::shared_ptr&lt;SubScreen&gt;&gt; //
std::unordered_mapを継承してmake_sharedの機能も追加する<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class TypeT&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;TypeT&gt;
make_shared() // この関数経由で新規生成すればNewIDで新しいIDで辞書にemplaceで登録もいっしょにしてくれる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
newID = SubScreen::NewID(); //スクリーンの通し番号を+1(先に+1するので0はなく1からID割り振り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto
pNewObj = std::make_shared&lt;ProtectedCall&lt;TypeT&gt;&gt;(); //
std::make_sharedで共有状態で新規生成 (ProtectedCall経由でprotectedなコンストラクタも呼べる)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
this-&gt;emplace(newID, pNewObj); //★idはかぶらないはずだからそれをキーに辞書に登録<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return std::dynamic_pointer_cast&lt;TypeT&gt;(this-&gt;at(newID));//
std::shared_ptrのキャスト
https://chiku2gonzalez.hatenablog.com/entry/2014/10/23/230011<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; };<br>
&nbsp;&nbsp;&nbsp; static Layers layers; //
生成したサブスクリーンの高速辞書配列&lt;id,サブスクリーンの共有ポインタ&gt;<br>
<br>
protected:<br>
&nbsp;&nbsp;&nbsp; //
コンストラクタはprotected:(外部読み取り不可)にしておくのでCreate()関数で生成してCreate().Set(～)で初期設定して
ください<br>
&nbsp;&nbsp;&nbsp; // [Factoryパターン:生成経路限定工場]
https://qiita.com/shoheiyokoyama/items/d752834a6a2e208b90ca<br>
&nbsp;&nbsp;&nbsp; //
Factoryパターンの本質はクラスのユーザーに勝手にnewやmake_sharedで自由にコンストラクタを呼ばせないこと<br>
&nbsp;&nbsp;&nbsp; //
newのかわりにCreate関数を経由して生成を強制することでCreateと同時にIDを振ったり辞書に登録して勝手にnewされて一貫性が崩れるの
を防ぐ<br>
&nbsp;&nbsp;&nbsp; SubScreen() //float x = 0, float y = 0, float Width
= 0, float Height = 0, int Alpha = 255, int Depth = 0, std::string name
= "")<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
std::enable_shared_from_thisを継承するとコンストラクタ内ではまだthisは未確定なので
shared_from_this()を使う関数(例.Set関数)は呼べなくなる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set(x, y, Width, Height,
Alpha, Depth, name);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;id =
SubScreen::serialDivID; // 通し番号割り振り(ゲーム中は被らない【通し】番号)<br>
&nbsp;&nbsp;&nbsp; }<br>
public:<br>
&nbsp;&nbsp;&nbsp; // 新しくサブスクリーンを生成してそれへの共有ポインタを返す<br>
&nbsp;&nbsp;&nbsp; static std::shared_ptr&lt;SubScreen&gt; Create()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isDepthLayerChanged = true;
// 新しいレイヤーが増えたので再並べ替えフラグをオンに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
SubScreen::layers.make_shared&lt;SubScreen&gt;();<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; // サブスクリーンを削除<br>
&nbsp;&nbsp;&nbsp; static void Erase(int id) {
SubScreen::layers.erase(id); isDepthLayerChanged = true; }<br>
<br>
&nbsp;&nbsp;&nbsp; virtual ~SubScreen() { if (handle &gt;= 0)
DxLib::DeleteGraph(handle); } // 仮想デストラクタ<br>
<br>
&nbsp;&nbsp;&nbsp; virtual void InitScreen()<br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 分割画面を描くためのスクリーンの描画ハンドルを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
★複数プレイヤ画面や複数カメラ視点に使える[敵目線カメラサブ画面など]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (renderWidth &gt;= 1
&amp;&amp; renderHeight &gt;= 1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する(
TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
[描画スクリーンの紙を用意] https://dxlib.xsrv.jp/function/dxfunc_graph1.html#R3N25<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
handle = DxLib::MakeScreen((int)renderWidth, (int)renderHeight, (Alpha
== 255 ? FALSE : TRUE));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
&uarr;[半透明スクリーンも可]
https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=3650<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
スクリーンを作成したらデフォルト設定に戻しておかないと<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
isInitAgain = false; // 再びInitが必要かのフラグをオフに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetX(float x) {
this-&gt;x = x; return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetY(float y) {
this-&gt;y = y; return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetZoomRate(float
zoomRate) { this-&gt;zoomRate = (zoomRate &lt; 0.1f) ? 0.1f : zoomRate;
return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetWidth(float
width) { this-&gt;Width = width;&nbsp; return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetHeight(float
height) { this-&gt;Height = height; return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetRenderX(float
renderX) { this-&gt;renderX = renderX; return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetRenderY(float
renderY) { this-&gt;renderY = renderY; return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt;
SetRenderWidth(float renderWidth) { if (((int)this-&gt;renderWidth) !=
(int)renderWidth)&nbsp; isInitAgain = true; this-&gt;renderWidth =
renderWidth;&nbsp;&nbsp; return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt;
SetRenderHeight(float renderHeight) { if (((int)this-&gt;renderHeight)
!= (int)renderHeight) isInitAgain = true; this-&gt;renderHeight =
renderHeight; return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetAlpha(int alpha)
{ if (((int)this-&gt;Alpha) != (int)alpha)&nbsp; isInitAgain =
true;&nbsp; this-&gt;Alpha = alpha;&nbsp; return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetDepth(int depth)
{ if (this-&gt;Depth != depth) isDepthLayerChanged = true;
this-&gt;Depth = depth; return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; // フレームに表示出力する文字の設定<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt;
SetDrawString(std::string drawString = "") { this-&gt;drawString =
drawString; return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; // フレーム枠の幅の設定<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetFrameWidth(int
frameWidth) { this-&gt;frameWidth = frameWidth; return
shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; // フレーム枠の色の設定<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt;
SetFrameColor(unsigned int frameColor) { this-&gt;frameColor =
frameColor; return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; // フレームとバーを見せるかの設定<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt;
SetIsBarFrameShow(bool isBarShow, bool isFrameShow = true) {
this-&gt;isBarShow = isBarShow; this-&gt;isFrameShow = isFrameShow;
return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; // フレームのバーの高さの設定<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt;
SetBarFrameHeight(int barFrameHeight) { this-&gt;barFrameHeight =
barFrameHeight; return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; // フレームのバーのnameのフォントのサイズ設定<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt;
SetBarFrameFontSize(int barFrameFontSize) { this-&gt;barFrameFontSize =
barFrameFontSize; return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; // フレームのバーの背景色設定<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt;
SetBarColor(unsigned int barColor) { this-&gt;barColor = barColor;
return shared_from_this(); }<br>
&nbsp;&nbsp;&nbsp; // フレームの設定<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; SetFrame(int
frameWidth, unsigned int frameColor, bool isBarShow = false, int
barFrameHeight = 15) { this-&gt;frameWidth = frameWidth;
this-&gt;isFrameShow = (frameWidth&gt;0)?true:false;
this-&gt;frameColor = frameColor; this-&gt;isBarShow = isBarShow;
this-&gt;barFrameHeight = barFrameHeight; return shared_from_this(); }<br>
<br>
&nbsp;&nbsp;&nbsp; // 色々セッティングして初回と設定変更があった時だけサブ画面を描くためのスクリーンの描画ハンドルを得る<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; Set(float x = 0,
float y = 0, float width = 0, float height = 0, int alpha = 255, int
depth = 0, std::string name = "")<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;x = x; this-&gt;y =
y;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetWidth(width);
SetHeight(height); SetRenderWidth(width); SetRenderHeight(height);
SetAlpha(alpha);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isInitAgain)
InitScreen(); // 変更があるか確認してある時だけInitし直すようにすると早くなる<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;Depth != depth)
isDepthLayerChanged = true; // Depthに変更があれば再並べ替えフラグをオンに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;Depth = depth;
this-&gt;name = name;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return shared_from_this();
// 設定した後の自分自身を返す<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; virtual void Update()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // なにかUpdateしたいことがあれば処理を追加<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; virtual void Draw()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawScreen(); //
スクリーンをDrawRectExtendGraphを使って描く(ズームやアルファ透明度も反映させる)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawFrame(); //
スクリーンのまわりにフレームを描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawBarFrame(); //
スクリーンの上にWindowsみたいなバーを描く<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // デバッグ用の文字表示<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpFontSize =
GetFontSize();// 元のフォントサイズを保管<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetFontSize(barFrameFontSize); // 描画する文字列のサイズを設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString((int)x, (int)y, drawString.c_str(), stringColor); //
デバッグ用の文字列をスクリーンの左上(0,0)に描画<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetFontSize(tmpFontSize); // 元のフォントサイズ設定にすぐ戻す<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; virtual void DrawScreen() //
スクリーンをDrawRectExtendGraphを使って描く(ズームやアルファ透明度も反映させる)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpBlendMode,
tmpBlendParam;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::GetDrawBlendMode(&amp;tmpBlendMode, &amp;tmpBlendParam); //
現在の描画ブレンドモードを取得しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Alpha != 255)
DxLib::SetDrawBlendMode(DX_BLENDMODE_ALPHA, Alpha); // 半透明のスクリーンも描ける
https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4978<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
画面ウィンドウに描画されたスクリーン内容を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawRectExtendGraph((int)x, (int)y, (int)(x + Width * zoomRate),
(int)(y + Height * zoomRate), renderX, renderY, renderWidth,
renderHeight, handle, (Alpha == 255 ? FALSE : TRUE));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Alpha != 255)
DxLib::SetDrawBlendMode(tmpBlendMode, tmpBlendParam); //
もとのブレンドモードに戻しておく<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; virtual void DrawFrame() // スクリーンのまわりにフレームを描く<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isFrameShow) return; //
フレームを描かない設定の場合<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //サブスクリーンの枠の表示<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int f = 1; f &lt;=
frameWidth; f++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawBox(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(int)((int)x
-
f
+
0.5f),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(int)((int)y
-
1
+
0.5f),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(int)((int)(x
+
Width
*
zoomRate
+
f) + 0.5f),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(int)((int)(y
+
Height
*
zoomRate
+
f) + 0.5f),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
frameColor,
FALSE);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; virtual void DrawBarFrame() //
スクリーンの上にWindowsみたいなバーを描く<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isBarShow) return; //
バーのフレームを描かない設定の場合<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // バーの背景の地を塗りつぶす<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(int)((int)x + 0.5f),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(int)((int)y - barFrameHeight + 0.5f),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(int)((int)(x + Width * zoomRate) + 0.5f),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(int)((int)(y - 1) + 0.5f),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
barColor, TRUE);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
マウスが上に乗った時の色はGetColor(255, 0, 0)で赤枠にしている<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int mouseOverColor
= (this-&gt;id == topMouseOverID) ? GetColor(255, 0, 0) : frameColor;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int barFrameWidth = (1 &lt;
frameWidth) ? 2 : 1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
for文でフレームの枠=frameWidthの大きさぶんBoxを複数描いて枠を太くする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int f = frameWidth -
barFrameWidth; f &lt;= frameWidth; f++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawBox(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(int)((int)x
-
f
+
0.5f),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(int)((int)y
-
barFrameHeight
-
f
+
0.5f),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(int)((int)(x
+
Width
*
zoomRate
+
f) + 0.5f),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(int)((int)(y
+
Height
*
zoomRate
+
f) + 0.5f),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(f
==
frameWidth)
?
mouseOverColor
:
frameColor, FALSE);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
バーにウィンドウの名前表示(バーの高さがフォントのサイズ以下なら文字サイズをバーの大きさに合わせる)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpFontSize =
GetFontSize();// 元のフォントサイズを保管<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetFontSize((barFrameHeight &gt; barFrameFontSize) ?
barFrameFontSize : barFrameHeight); // 描画する文字列のサイズを設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString((int)x, (int)y - barFrameHeight, name.c_str(),
frameColor); // バーにnameの文字列を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetFontSize(tmpFontSize); // 元のフォントサイズ設定にすぐ戻す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
<br>
&nbsp;&nbsp;&nbsp; static void UpdateScreens() // スクリーンの状態の更新(ドラッグ移動など)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp;
subScreen : layers)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
subScreen.second-&gt;Update();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //OrderByLayerDepth(); //
レイヤーのDepth順に並べ替え&rarr;FocusOnClickScreen関数でやる<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FocusOnClickScreen(); //
クリックしたスクリーンを一番上にするように並べ替え<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DragScreen();//
サブスクリーンをドラッグで移動できるように<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZoomScreens(); //
サブスクリーンをマウスホイールでズームインズームアウトできるように<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; static void DrawScreens() // サブスクリーンを全部まとめて描く<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderByLayerDepth(); //
レイヤーのDepth順に並べ替え<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//&darr;並べ変わった順を使ってDepth順にサブスクリーンをDraw<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
std::multiset&lt;depth_id_pair&gt;::iterator ite =
depth_id_ordered.begin();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (ite !=
depth_id_ordered.end())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
id = ite-&gt;second;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(layers.count(id) &gt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
layers[id]-&gt;Draw();
//
depth順にDrawでサブスクリーンを複数レイヤーで描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ite++;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // サブスクリーンの描画内容をきれいにクリア<br>
&nbsp;&nbsp;&nbsp; void ClearDrawScreen()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (handle &lt; 0) return;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawStart(); //
設定先をサブスクリーンとする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen(); //
一旦 サブスクリーンをきれいにクリア<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawEnd();<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // ★このStartとEndのあいだの描画処理はサブスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp; void DrawStart()<br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブスクリーンが描画可能状態なら<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (handle &lt; 0) return;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isInitAgain)
InitScreen();// 変更があるか確認してある時だけInitでDxLib::MakeScreenをし直す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpResetSetting =
GetUseSetDrawScreenSettingReset(); // 設定を一旦tmpに退避<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SetUseSetDrawScreenSettingReset(FALSE); //
SetDrawScreen切り替え時に設定をリセットしない(FALSE)(これをやらないとカメラ視点などがリセットされるから)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpDrawScreen =
DxLib::GetDrawScreen(); // Endまでのあいだ一旦変更前のhandleを退避<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
ゲームを描く先を用意しておいたサブスクリーンに設定(キャンバスを指定する)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawScreen(handle);<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // ★このStartとEndのあいだの描画処理はサブスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp; void DrawEnd()<br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // サブスクリーンが描画可能状態なら<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (handle &lt; 0) return;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ゲームを描く先をもとのデフォルトに戻しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetDrawScreen((tmpDrawScreen == -1) ? DX_SCREEN_BACK :
tmpDrawScreen);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SetUseSetDrawScreenSettingReset((tmpResetSetting == -1) ? TRUE :
tmpResetSetting); // 設定をすぐに元に戻す<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp; // スタティック機能群(サブスクリーンの辞書やマウスでのドラッグ移動など)<br>
public:<br>
&nbsp;&nbsp;&nbsp; static bool isMouseOvered; //= false
マウスオーバーしてるレイヤがあるか<br>
&nbsp;&nbsp;&nbsp; static int topMouseOverID; //= -1
一番上のマウスオーバーしてるレイヤのID<br>
&nbsp;&nbsp;&nbsp; static int topDepthID; //= -1 一番上のレイヤのID<br>
&nbsp;&nbsp;&nbsp; static int topDepth; //= -1 一番上のレイヤのDepth<br>
protected:<br>
&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; static void OrderByLayerDepth() // レイヤーのDepth順に並べ替え<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isDepthLayerChanged)
return; // レイヤーのDepthに変化がなければ並べ替えは不要<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; depth_id_ordered.clear(); //
並べ替え前に既存の順序データを一度クリア<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp;
subScreen : layers)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
id = subScreen.first;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
depth = subScreen.second-&gt;Depth;//ペア(左,右)だと左の数字の順に自動で並ぶ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
depth_id_ordered.insert(std::make_pair(depth, id)); //
https://qiita.com/izmktr/items/17e3009041b841b26a34<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
//全部マルチセットに&uarr;入れると自動でdepth順に並べ変わってる<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CheckLayerOrder(); //
マウスオーバーしてるレイヤや一番上のレイヤも再び調べる<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; static void CheckLayerOrder() //
一番上のマウスオーバーしてるレイヤを調べる<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::TopLayerMouseX =
Input::MouseX; Input::TopLayerMouseY = Input::MouseY; //
一番上のレイヤのTopLayerMouseマウス座標をリセット<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isMouseOvered = false; //
ループを回す前にfalseで初期化<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; topMouseOverID = -1; //
-1ならマウスオーバーしているレイヤはない<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//&darr;並べ変わった順を使ってDepth順に調べ、一番上のマウスオーバーしてるレイヤを調べる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
std::multiset&lt;depth_id_pair&gt;::iterator ite =
depth_id_ordered.begin();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; topDepth = -1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (ite !=
depth_id_ordered.end())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
id = ite-&gt;second;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto
subscreen = layers[id];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool
_isMouseOvered = subscreen-&gt;IsOnBarFrame((float)Input::MouseX,
(float)Input::MouseY);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(_isMouseOvered &amp;&amp; id &gt;= 0) // depth順で一番上のマウスオーバーしてるレイヤを調べる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
topMouseOverID
=
id;
//
idが0以上のレイヤしか検知しない<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(_isMouseOvered)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
isMouseOvered
|=
_isMouseOvered;
//
|
で[または]のビット演算(1つでもtrueがあれば最終的にtrueに)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(ite-&gt;first &gt;= topDepth)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
topDepthID
=
id;
//
マウスが乗ってるかと関係なしに最大Depthも記録<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
topDepth = ite-&gt;first;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ite++;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(ite == depth_id_ordered.end() &amp;&amp; topMouseOverID != -1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
auto
topLayerScreen
=
layers[topMouseOverID];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
一番上のレイヤーのマウスの「ローカルな」座標を登録しておけば「そのウィンドウ内のマウス位置」を得られる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Input::TopLayerMouseX
=
topLayerScreen-&gt;LocalX(Input::MouseX);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Input::TopLayerMouseY
=
topLayerScreen-&gt;LocalY(Input::MouseY);
//
LocalXYならそのウィンドウの左上を(0,0)とした「ウィンドウ内のマウス位置」が求まる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
public:<br>
&nbsp;&nbsp;&nbsp; static int clickDownID; //= -1
クリックした瞬間のマウスが乗ってるサブウィンドウの番号(マウスを話した瞬間のIDと比べて同じならそのウィンドウにフォーカスする)<br>
&nbsp;&nbsp;&nbsp; static void FocusOnClickScreen() //
クリックしたスクリーンを一番上にするように並べ替え<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderByLayerDepth(); //
レイヤーのDepth順に並べ替え<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (topMouseOverID == -1)
return;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(Input::GetButtonDown(Pad::Mouse, MOUSE_INPUT_LEFT)) //
マウスの右ボタンが押された瞬間か？(ドラッグ開始)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // clickDownID
= クリックした瞬間(ドラッグ開始時)のマウスが乗ってる一番上のサブウィンドウのID番号<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
clickDownID = topMouseOverID;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
(Input::GetButtonUp(Pad::Mouse, MOUSE_INPUT_LEFT)) // マウスの右ボタンが離された瞬間か？<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
clickUpID = topMouseOverID; //
マウスのクリックを離した瞬間のスクリーンIDは基本はマウスが乗っている一番上のスクリーン<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(topMouseOverID != clickDownID //
&uarr;例外的に、clickDownIDがマウスを離した瞬間のtopMouseOverIDと違うとき<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;&amp;
layers.count(clickDownID)
&gt;
0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;&amp;
layers[clickDownID]-&gt;Depth
&lt;
layers[topMouseOverID]-&gt;Depth)
//
clickDownIDのDepthがマウスを離した瞬間に一番上にあるウィンドウのDepthより小さい<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
clickUpID
=
clickDownID;
//
clickUpIDをドラッグ中の後ろに隠れているウィンドウに変える<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
ドラッグを離した瞬間のスクリーンを一番上のDepthへと書き換えたい<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(layers.count(topDepthID) &gt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
auto
clickUpScreen
=
layers[clickUpID];
//
マウスを離した瞬間のドラッグ中の一番上のレイヤにしたいスクリーン<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
auto
topDepthScreen
=
layers[topDepthID];
//
Depthが一番大きいスクリーン<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if
(clickUpScreen-&gt;Depth
&lt;=
topDepthScreen-&gt;Depth)
//
Depthが一番大きいスクリーンよりクリックを離したスクリーンのDepthが小さいなら<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int
newTopDepth
=
topDepthScreen-&gt;Depth;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if
(clickUpScreen-&gt;Depth
==
newTopDepth
&amp;&amp;
clickUpID
!=
topDepthID)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
newTopDepth++;
//&nbsp;
マウスを離した瞬間のマウスが乗ってる一番上のレイヤのスクリーンのDepthをtopDepthScreenより+1大きくする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//if
(clickUpScreen-&gt;Depth
!=
topDepthScreen-&gt;Depth)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;&nbsp;&nbsp;
topDepthScreen-&gt;SetDepth(clickUpScreen-&gt;Depth);
//
現在の一番上のレイヤのスクリーンとクリックを離したスクリーンのDepthを入れ替え<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
clickUpScreen-&gt;SetDepth(newTopDepth);
//
+1大きくしたDepthをSetする<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
OrderByLayerDepth();
//
[再び並べ替え]レイヤーのDepth順に<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; /*static void FocusOnScreen(int id)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
特定のidへフォーカスさせたければ関数を自作してもよいかも<br>
&nbsp;&nbsp;&nbsp; }*/<br>
<br>
&nbsp;&nbsp;&nbsp; static int prevDragX; //= -1 直前のドラッグ中のマウスの位置<br>
&nbsp;&nbsp;&nbsp; static int prevDragY; //= -1 直前のドラッグ中のマウスの位置<br>
&nbsp;&nbsp;&nbsp; static bool isDraging() { return (dragingID != -1); }<br>
&nbsp;&nbsp;&nbsp; static int dragingID; //= -1 ドラッグ中のサブスクリーンのID<br>
<br>
&nbsp;&nbsp;&nbsp; static bool DragScreen() // サブスクリーンをドラッグで移動できるように<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int dragID = -1; //
ドラッグ移動する一番上のサブスクリーンのID<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dragingID == -1
&amp;&amp; isMouseOvered)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dragID = topMouseOverID;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dragingID != -1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dragID = dragingID;<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dragID != -1 &amp;&amp;
Input::Click[Mouse::DragL] &amp;&amp; Screen::IsInsideWindow())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto
dragScreen = layers[dragID];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dragingID = dragID;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(prevDragX != -1 &amp;&amp; prevDragY != -1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{&nbsp;&nbsp; // ★前の位置prevと現在の位置に移動があれば、その差ぶんだけ+=することでドラッグ移動を実現<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if
(prevDragX
!=
Input::Click[Mouse::DragLX])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dragScreen-&gt;x
+=
(float)(Input::Click[Mouse::DragLX]
-
prevDragX);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if
(prevDragY
!=
Input::Click[Mouse::DragLY])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dragScreen-&gt;y
+=
(float)(Input::Click[Mouse::DragLY]
-
prevDragY);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prevDragX = Input::Click[Mouse::DragLX];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prevDragY = Input::Click[Mouse::DragLY];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prevDragX = -1; prevDragY = -1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dragingID = -1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // サブスクリーンをバーの上てマウスホイールグリグリするとズームインズームアウトできるように<br>
&nbsp;&nbsp;&nbsp; static void ZoomScreens(bool isZoomByBar = true)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isMouseOvered) return;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto zoomScreen =
layers[topMouseOverID];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isZoomByBar &amp;&amp;
!zoomScreen-&gt;IsOnBar((float)Input::MouseX, (float)Input::MouseY))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return; // バーの上にカーソルがない<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
zoomScreen-&gt;SetZoomRate(zoomScreen-&gt;zoomRate + 0.1f *
(Input::MouseWheel));<br>
&nbsp;&nbsp;&nbsp; }<br>
};<br>
</em><br>
<br>
#endif<br>
</a></p>
<p><code><a id="mozTocId0004" class="mozTocH1">Screen.cppを新規作成</a></code><a
 id="mozTocId0004" class="mozTocH1">して
static変数を定義しましょう。</a></p>
<p class="source"><a id="mozTocId0004" class="mozTocH1">#include
"Screen.h"<br>
<br>
int SubScreen::serialDivID{ 0 }; // サブスクリーンを新たに生成するときの通し番号(シリアルID)<br>
bool SubScreen::isDepthLayerChanged{ false }; //
新しいレイヤが追加されり変更があった時だけ並べ替えるためのフラグ<br>
<br>
std::multiset&lt;SubScreen::depth_id_pair&gt;
SubScreen::depth_id_ordered; //
std::multiset[キーの無い版のstd::map(マルチでキーかぶりOK版)]<br>
<br>
bool SubScreen::isMouseOvered{ false }; // マウスオーバーしてるレイヤがあるか<br>
int SubScreen::topMouseOverID{ -1 }; // 一番上のマウスオーバーしてるレイヤのID<br>
int SubScreen::topDepthID{ -1 }; // 一番上のレイヤのID<br>
int SubScreen::topDepth{ -1 }; // 一番上のレイヤのDepth<br>
<br>
<br>
SubScreen::Layers SubScreen::layers; //
生成したサブスクリーンの高速辞書配列&lt;id,サブスクリーンの共有ポインタ&gt;<br>
<br>
int SubScreen::clickDownID{ -1 }; //
クリックした瞬間のマウスが乗ってるサブウィンドウの番号(マウスを話した瞬間のIDと比べて同じならそのウィンドウにフォーカスする)<br>
<br>
int SubScreen::prevDragX{ -1 }; // 直前のドラッグ中のマウスの位置<br>
int SubScreen::prevDragY{ -1 }; // 直前のドラッグ中のマウスの位置<br>
int SubScreen::dragingID{ -1 }; // ドラッグ中のサブスクリーンのID<br>
</a></p>
<p><a id="mozTocId0004" class="mozTocH1">ウィンドウのドラッグってどうやってるのって、シンプルにいうなら<br>
<span style="font-weight: bold; text-decoration: underline;">前の瞬間(prev)と
現在の位置に移動があれば、その差ぶんだけ+=する</span>、というだけなのでベースとなっているアイデア自体は実はシンプルなものです<br>
(まあレイヤーの並べ替えとか一番上じゃないレイヤーをクリックしたときにフォーカスして一番上にするとか考え出すと結構たいへんですが)<br>
<br>
</a></p>
<p></p>
<p><code><a id="mozTocId0004" class="mozTocH1">main.cpp</a></code><a
 id="mozTocId0004" class="mozTocH1">のコードにSubScreenクラスを使ってドラッグできるウィンドウズみた
いなサブのスクリーンを表
示させてみましょう。</a></p>
<p class="source"><a id="mozTocId0004" class="mozTocH1">#include
"DxLib.h"<br>
#include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
<em>#include "Input.h"</em><br>
#include "Screen.h"<br>
#include "Ply.h"<br>
<br>
//
設定画面の【リンカー】&rarr;【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain
からプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR
lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
&nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); //
画面サイズWidth&times;Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);//
ウィンドウサイズWidth&times;Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;&nbsp;
SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間
違ってるかも<br>
<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
&nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
&nbsp;&nbsp;&nbsp; int texImage = -1;<br>
&nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
&nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
&nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
&nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth,
&amp;imgHeight); // テクスチャ画像のサイズを得る<br>
<br>
&nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
&nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply",
Data); // .plyデータをロード 軸を変えてdice1.plyや
dice2.plyなどいろいろ試してみよう<br>
<br>
&nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; //
3Dモデルのポリゴンのインデックス配列<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; //
3Dモデルのポリゴンの頂点配列<br>
<br>
&nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
&nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp;
"Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
&nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
<br>
&nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報]
https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
&nbsp;&nbsp;&nbsp; const float* p_x =
vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_y =
vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_z =
vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_nx =
(vertex-&gt;properties.has_key("nx")) ?
vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_ny =
(vertex-&gt;properties.has_key("ny")) ?
vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_nz =
(vertex-&gt;properties.has_key("nz")) ?
vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr
|| p_nz == nullptr);<br>
&nbsp;&nbsp;&nbsp; const float* p_s =
(vertex-&gt;properties.has_key("s")) ?
vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; //
Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
&nbsp;&nbsp;&nbsp; const float* p_t =
(vertex-&gt;properties.has_key("t")) ?
vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_R =
(vertex-&gt;properties.has_key("red")) ?
vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("r")) ?
vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_G =
(vertex-&gt;properties.has_key("green"))
? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("g")) ?
vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_B =
(vertex-&gt;properties.has_key("blue"))
? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("b")) ?
vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_A =
(vertex-&gt;properties.has_key("alpha"))
? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("a")) ?
vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr
|| p_B == nullptr || p_A == nullptr);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt;
iEnd; i += 1)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧
https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り)
https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], -p_y[i], p_z[i]); //
右手Y&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm =
(has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f,
0.0f);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
右手Z&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos =
VGet(-(p_y[i]),
p_z[i], p_x[i]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm)
? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f,
0.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color)
? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255,
255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s ==
nullptr) ? 0.0f : p_s[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t ==
nullptr) ? 0.0f : 1 - p_t[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; const auto&amp; face_index =
Data["face"]-&gt;properties["vertex_indices"];<br>
&nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(),
nFace = 0; i &lt; iEnd; i += 3)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt;
3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1
&gt; 0; --j) // 左手系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(j == 0 &amp;&amp; !has_norm &amp;&amp;
Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f
&amp;&amp; Vertex[index].norm.z == 0.0f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index0
=
Index[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index1
=
Index[i
+
1];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index2
=
Index[i
+
2];<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
外積 a&times;b cross_a_b を求める
https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
a
=
VSub(Vertex[index1].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
b
=
VSub(Vertex[index2].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
cross1_2
=
VCross(a,
b);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
右手系(表面は反時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
cross2_1
=
VCross(b,
a);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
単位ベクトル(ノルム)に直す [単位ベクトル]は&radic;(x*x + y*y + z*z) = 1となる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
norm1_2
=
VNorm(cross1_2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
norm2_1
=
VNorm(cross2_1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Vertex[index0].norm
=
norm1_2;
Vertex[index1].norm
=
norm1_2;
Vertex[index2].norm
=
norm1_2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Vertex[index0].norm
=
norm2_1;
Vertex[index1].norm
=
norm2_1;
Vertex[index2].norm
=
norm2_1;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
++numIndex;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
&nbsp;&nbsp;&nbsp; keyControlXYZ.x = 200.0f; keyControlXYZ.y = 200.0f;
keyControlXYZ.z = 0;<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
<br>
&nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 =
SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0,
"サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 =
SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1,
"サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 =
SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1,
"サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0,
255));<br>
&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 =
SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");</em><br>
<br>
&nbsp;&nbsp;&nbsp; <u>float subscreenX = 0, subscreenY = 0; //
別描画スクリーンを描く位置<br>
&nbsp;&nbsp;&nbsp; int subscreenWidth = 600, subscreenHeight = 100;<br>
&nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE); //
SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドル作成を TRUE:許可<br>
&nbsp;&nbsp;&nbsp; // [別の描画スクリーンを用意]
https://dxlib.xsrv.jp/function/dxfunc_graph1.html#R3N25<br>
&nbsp;&nbsp;&nbsp; int subscreen = DxLib::MakeScreen(subscreenWidth,
subscreenHeight, FALSE);<br>
&nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE); //
FLASE:通常のグラフィックハンドルを作成するモードに戻す</u><br>
<br>
&nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
&nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
<br>
&nbsp;&nbsp;&nbsp; ScreenFlip();<br>
<br>
&nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
&nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは&times;ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();//
一旦キャンバスをきれいにまっさらに<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Input::Update(); //
マウスのドラッグなどを更新<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens();
// スクリーンの位置やドラッグによる移動を更新する</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>int MouseX, MouseY;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マウスの位置を取得<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetMousePoint(&amp;MouseX,
&amp;MouseY);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreenX = MouseX;
subscreenY = MouseY; // マウスのポインタの位置を起点にサブのスクリーンを描く</u><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput =
GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -=
speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y
+= speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position =
VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth;
float height = imgHeight; // テクスチャ画僧のサイズ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(50.0f,
50.0f, 50.0f); // 拡大縮小スケール<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_A) keyControlAngle.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_B) keyControlAngle.y += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_C) keyControlAngle.z += speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad =
DX_PI_F / 180.0f; // 角度(単位:&deg;度)からラジアン(単位:rad)へ変換する係数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate =
keyControlAngle.x * Deg2Rad;&nbsp; const float
yRotate = keyControlAngle.y * Deg2Rad; const float zRotate =
keyControlAngle.z * Deg2Rad;<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp;
matWorldDefault; // デフォルトのワールド行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); //
デフォルトのワールド行列を記憶しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX mat; // モデルのスケール&times;回転&times;移動を行列計算で設定する<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[スケール]拡大縮小のスケール行列を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
[勉強]&darr;スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp;
mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y;
mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp;
mat.m[3][3] = 1.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[回転]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matRot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::CreateIdentityMatrix(&amp;matRot);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
★MMultは行列の乗算【乗算した順にz軸回転&rarr;x軸回転&rarr;y軸回転&rarr;平行移動】<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotZ(zRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotX(xRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotY(yRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matRot); //スケール &times; 回転<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[移動]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matTrans = MGetTranslate(VGet(position.x, position.y,
position.z)); // 位置positionをここで設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matTrans); //スケール&times;回転&times;移動<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定]
https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawPolygon32bitIndexed3D(Vertex.data(),
Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); //
三角形ポリゴンをたくさん描画<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0,
0, GetColor(255, 255, 0), "x:%f y:%f
Angle:%f %f %f", position.x, position.y, keyControlAngle.x,
keyControlAngle.y, keyControlAngle.z);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>int tmpResetSetting =
DxLib::GetUseSetDrawScreenSettingReset(); // 設定を一旦tmpに退避<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetUseSetDrawScreenSettingReset(FALSE); //
SetDrawScreen切り替え時に設定をリセットしない(FALSE)(これをやらないとカメラ視点などがリセットされるから)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tmpDrawScreen =
DxLib::GetDrawScreen(); // 一旦変更前のスクリーンのハンドルを退避<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetDrawScreen(subscreen);// ゲームを描く先を用意しておいたサブスクリーンに設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
(0,0)位置を起点に別
スクリーンへ文字列を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる",
GetColor(255, 255, 255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetDrawScreen((tmpDrawScreen == -1) ? DX_SCREEN_BACK :
tmpDrawScreen); // 描く先をもとのデフォルトのスクリーンに戻しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetUseSetDrawScreenSettingReset((tmpResetSetting == -1) ? TRUE :
tmpResetSetting); // 設定を元に戻す<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 画面に別スクリーンの内容を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawRectExtendGraph((int)subscreenX, (int)subscreenY,
(int)(subscreenX + subscreenWidth), (int)(subscreenY +
subscreenHeight), 0, 0, subscreenWidth, subscreenHeight, subscreen,
FALSE);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 別スクリーンの枠を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(
(int)((int)subscreenX - 1 + 0.5f),(int)((int)subscreenY - 1 + 0.5f),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(int)((int)(subscreenX
+
subscreenWidth
+
1)
+
0.5f),
(int)((int)(subscreenY
+ subscreenHeight + 1) + 0.5f),
GetColor(255,255,255), FALSE);</u><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>subscreen1-&gt;ClearDrawScreen();
//
描く前に一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart();
// このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる",
GetColor(255, 255, 255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart();
// このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
半透明のスクリーンも描ける<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height,
GetColor(0, 255, 0), TRUE);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255,
255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart();
// このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255,
255, 255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();</em><br>
<em><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); //
サブのスクリーンを全部描く</em><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip();
//隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
&nbsp;&nbsp;&nbsp; WaitKey();<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
&nbsp;&nbsp;&nbsp; DxLib_End();<br>
&nbsp;&nbsp;&nbsp; // ソフトの終了<br>
&nbsp;&nbsp;&nbsp; return 0;<br>
}</a></p>
<p><a id="mozTocId0004" class="mozTocH1">いかがですか?ウィンドウズっぽいものが自作できたでしょうか?<br>
ドラッグだけじゃなくバーの上でマウスのホイールをグリグリするとウィンドウがズームできる機能もおまけでついてます<br>
</a></p>
<a id="mozTocId0004" class="mozTocH1"><br>
<br>
<br>
</a>
<h2><a id="mozTocId0005" class="mozTocH1">エディタを自作して視点カメラを動かせるようにする</a></h2>
<a id="mozTocId0005" class="mozTocH1"><br>
</a>
<p><code><a id="mozTocId0005" class="mozTocH1">Singleton.hを新規作成</a></code><a
 id="mozTocId0005" class="mozTocH1">して Editorクラスが唯一のシングルトンを継承できるように準備する。</a></p>
<p class="source"><a id="mozTocId0005" class="mozTocH1">#ifndef
SINGLETON_H_<br>
#define SINGLETON_H_<br>
<br>
// テンプレートT型シングルトンSingleton&lt;～&gt; ～になんでも指定して唯一物にできる<br>
// ★Singleton&lt;T&gt;型は【必ず唯一で複製不可】(使い方:どこからでもアクセスし変数を共有するクラス向き)<br>
// ★ゲーム内の【どこからアクセスしても統一性が保たれる】(唯一だから)「クラス名と実体が一致」<br>
template&lt;class T&gt;<br>
class Singleton<br>
{<br>
public:<br>
&nbsp;&nbsp;&nbsp; // GetInstanceを通して【しか】T型クラスをつくれないうえに、<br>
&nbsp;&nbsp;&nbsp; // ★作ったものは【かならず唯一で複製不可】<br>
&nbsp;&nbsp;&nbsp; // それが【シングルトン型】！<br>
&nbsp;&nbsp;&nbsp; // ゲーム中で唯一で複製不可にしたい【ゲームを一律管理するクラス】などに最適！<br>
&nbsp;&nbsp;&nbsp; // https://teratail.com/questions/17416<br>
&nbsp;&nbsp;&nbsp; // http://rudora7.blog81.fc2.com/blog-entry-393.html<br>
&nbsp;&nbsp;&nbsp; //
②&darr;同じ関数の定義はプログラム全体で１つだけしか許されません。(static関数名は被らない)<br>
&nbsp;&nbsp;&nbsp; static inline T&amp; GetInstance()<br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;
//①&darr;関数の中で定義されたstatic変数は、関数の定義毎に１つ領域が確保されます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static T instance;
//メモリ上にstatic変数確保(静かに常に待機するinstance)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return instance;
//①=(常駐)②=(唯一) ①と②両方満たすinstanceは【メモリ上に唯一】<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
protected:<br>
&nbsp;&nbsp;&nbsp; Singleton() {} //
外部でのインスタンス作成は禁止(protected:内部公開、外部禁止)<br>
&nbsp;&nbsp;&nbsp; virtual ~Singleton() {} //
仮想デストラクタ(シングルトンを【継承するためには忘れちゃダメ】)<br>
<br>
private:<br>
&nbsp;&nbsp;&nbsp; void operator=(const Singleton&amp; obj) {} //
代入演算子禁止<br>
&nbsp;&nbsp;&nbsp; Singleton(const Singleton&amp; obj) {} //
コピーコンストラクタ禁止(コピーできない【唯一】)<br>
&nbsp;&nbsp;&nbsp; static T* instance; //
private:だから外部アクセスできない【GetInstance()経由しか無理】<br>
};<br>
<br>
// ふだんcppで書くstatic変数初期化も★【Tテンプレートクラスだからすべて.hヘッダにまとめて書いた】<br>
template&lt; class T &gt;<br>
T* Singleton&lt; T &gt;::instance = 0; //
static変数はclass内で初期化できないが、class外では = 0できる<br>
<br>
#endif<br>
</a></p>
<p><a id="mozTocId0005" class="mozTocH1"><br>
</a></p>
<p><code><a id="mozTocId0005" class="mozTocH1">Editor.hを新規作成</a></code><a
 id="mozTocId0005" class="mozTocH1">して マウスの右ドラッグでカメラを回転、左ドラッグでカメラの視点を移動、<br>
キーボードのT,Yキーでカメラz軸回転、キーボードのH,Jキーでカメラy軸回転、キーボードのV,Bキーでカメラx軸回転できるようにする。</a></p>
<p class="source"><a id="mozTocId0005" class="mozTocH1">#ifndef
EDITOR_H_<br>
#define EDITOR_H_<br>
<br>
#include "DxLib.h"<br>
#include "Input.h"<br>
#include "Screen.h"<br>
<br>
#include "Singleton.h"<br>
<br>
class Editor : public Singleton&lt;Editor&gt;<br>
{<br>
public:<br>
<br>
&nbsp;&nbsp;&nbsp; struct Camera<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x = 0.f, y = 0.0f, z =
-10.0f; // カメラはz軸マイナス位置からz軸プラス向きに原点を見る形で初期化される<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float VRotate = 0.0f, HRotate =
0.0f, TRotate = 0.0f; // X軸 V,Y軸 H,Z軸 T まわりのカメラのオイラー回転の角度<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float wheelSpeed = 1.0f; //
マウスのホイールと連動した際のカメラのスピード<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向の単位ベクトル(ノルム)を求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR
GetCameraWorldDirByScreenXY(float screenX = (float)Input::MouseX, float
screenY = (float)Input::MouseY)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //
スクリーン(X,Y)からマウスの指すワールド座標(X,Y,Z)を求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR
currentPos = DxLib::ConvScreenPosToWorldPos(VGet(screenX, screenY,
0.0f));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
カメラからマウスの指す位置への方向の単位ベクトル(ノルム)を求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return
DxLib::VNorm(DxLib::VGet(currentPos.x - x, currentPos.y - y,
currentPos.z - z));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; };<br>
&nbsp;&nbsp;&nbsp; Camera camera;<br>
<br>
&nbsp;&nbsp;&nbsp; int prevDragX = -1, prevDragY = -1; //
前フレームでのスクリーン上でのドラッグXY位置<br>
&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; bool isInitFinished = false; // 一回でもInitされたかのフラグ<br>
&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; void Init()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isInitFinished) return; //
最初の一回だけInit処理をするためのフラグ<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitFinished = true;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; void UpdateKeyInput()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_V))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate
-= 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_B))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate
+= 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_H))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate
-= 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_J))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate
+= 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_T))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate
-= 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_Y))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate
+= 1.0f;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; void UpdateMouseInput()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!SubScreen::isMouseOvered) //
マウスオーバーしているSubscreenがないとき<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::MouseWheel != 0.0f) // マウスのホイールをグリグリしたとき<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界の奥への方向の単位ベクトル(ノルム)を求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; VECTOR camNorm =
camera.GetCameraWorldDirByScreenXY((float)Input::MouseX,
(float)Input::MouseY);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; float camSpeed = camera.wheelSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.wheelSpeed *= (camera.wheelSpeed &lt; 100.0f)
? 1.5f : 1.0f; // カメラのズーム速度を加速する<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // 求めた単位ベクトル&times;カメラのスピードぶんカメラの位置を移動<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.x += camNorm.x * Input::MouseWheel * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.y += camNorm.y * Input::MouseWheel * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.z += camNorm.z * Input::MouseWheel * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if
(camera.wheelSpeed &gt; 0.1f) camera.wheelSpeed *= 0.9f; //
カメラのズーム速度を減衰する<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else
camera.wheelSpeed = 0.1f; // カメラのズーム速度を減衰して最小0.1にすることで繊細なズーム調整もできるようにする<br>
<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
((Input::Click[Mouse::DragL] || Input::Click[Mouse::DragR]) &amp;&amp;
Screen::IsInsideWindow())<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if (prevDragX != -1 &amp;&amp; prevDragY != -1)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
前の位置prevと現在の位置に移動があれば、その差ぶんだけ+=することでドラッグ移動を実現<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragL])
// マウス左クリック<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX
!= Input::Click[Mouse::DragLX] || prevDragY !=
Input::Click[Mouse::DragLY])<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
{&nbsp;&nbsp;&nbsp; // マウスポインタがある画面上の座標に該当する３Ｄ空間上の座標を取得
https://dxlib.xsrv.jp/function/dxfunc_3d_camera.html#R12N11<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; float positionRatio = 0.9f;// 奥行の位置 Near 面 0.0f ～
1.0f Far 面<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; VECTOR start =
DxLib::ConvScreenPosToWorldPos(VGet((float)prevDragX, (float)prevDragY,
positionRatio));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; VECTOR end =
DxLib::ConvScreenPosToWorldPos(VGet((float)Input::Click[Mouse::DragLX],
(float)Input::Click[Mouse::DragLY], positionRatio));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; float camSpeed = 400; // ドラッグに対するカメラの移動速度<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.x -= (end.x - start.x) * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.y -= (end.y - start.y) * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.z -= (end.z - start.z) * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragR])
// マウス右クリック<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // カメラの角度を変更<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX
!= Input::Click[Mouse::DragRX])<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.HRotate +=
(float)(Input::Click[Mouse::DragRX] - prevDragX);<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragY
!= Input::Click[Mouse::DragRY])<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.VRotate +=
(float)(Input::Click[Mouse::DragRY] - prevDragY);<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
&plusmn;360度を超えたら割り算の余りを設定して 例.365度 &rarr; 5度に戻してやる<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(camera.HRotate &gt; 360.0f || camera.HRotate &lt; -360.0f)
camera.HRotate = std::fmodf(camera.HRotate, 360.0f);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(camera.VRotate &gt; 360.0f || camera.VRotate &lt; -360.0f)
camera.VRotate = std::fmodf(camera.VRotate, 360.0f);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; prevDragX = (Input::Click[Mouse::DragL]) ?
Input::Click[Mouse::DragLX] : Input::Click[Mouse::DragRX];<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; prevDragY = (Input::Click[Mouse::DragL]) ?
Input::Click[Mouse::DragLY] : Input::Click[Mouse::DragRY];<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; return;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; prevDragX = -1; prevDragY = -1; // マウスのドラッグがないときはリセット<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; void UpdateCamera()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラの位置と回転値をセット、カメラの位置は原点<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">DxLib::SetCameraPositionAndAngle</span>(<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
DxLib::VGet(camera.x, camera.y, camera.z),<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate
* DX_PI_F / 180.0f, camera.HRotate * DX_PI_F / 180.0f, camera.TRotate *
DX_PI_F / 180.0f);<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //
まとめてUpdateしたいときはUpdateを使い、個別にUIやKeyやMouseを別々にタイミングを取りながらUpdateしたいときは
Updateは呼ばない<br>
&nbsp;&nbsp;&nbsp; void Update()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateKeyInput();<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateMouseInput();<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateCamera();<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; void Draw()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 原点からx軸(R:赤) y軸(G:緑)
z軸(B:青)をライン表示する<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0),
VGet(1.0f * 5.0f, 0.0f * 5.0f, 0.0f * 5.0f), GetColor(255, 0, 0));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0),
VGet(0.0f * 5.0f, 1.0f * 5.0f, 0.0f * 5.0f), GetColor(0, 255, 0));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0),
VGet(0.0f * 5.0f, 0.0f * 5.0f, 1.0f * 5.0f), GetColor(0, 0, 255));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 画面に回転量を描画<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0,
DxLib::GetColor(255, 255, 255), "Cam(x:%f y:%f z:%f)", camera.x,
camera.y, camera.z);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 20,
DxLib::GetColor(255, 255, 255), "Rot(V:%f H:%f T:%f)", camera.VRotate,
camera.HRotate, camera.TRotate);<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
};<br>
<br>
#endif<br>
</a></p>
<p><a id="mozTocId0005" class="mozTocH1"><br>
</a></p>
<p><code><a id="mozTocId0005" class="mozTocH1">main.cpp</a></code><a
 id="mozTocId0005" class="mozTocH1">のコードにEditorクラスを使ってカメラの視点を移動、回転させてみま
しょう。</a></p>
<p class="source"><a id="mozTocId0005" class="mozTocH1">#include
"DxLib.h"<br>
#include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
#include "Input.h"<br>
#include "Screen.h"<br>
#include "Ply.h"<br>
<br>
<em>#include "Editor.h"</em><br>
<br>
//
設定画面の【リンカー】&rarr;【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain
からプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR
lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
&nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); //
画面サイズWidth&times;Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);//
ウィンドウサイズWidth&times;Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;&nbsp;
SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間
違ってるかも<br>
<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
&nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
&nbsp;&nbsp;&nbsp; int texImage = -1;<br>
&nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
&nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
&nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
&nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth,
&amp;imgHeight); // テクスチャ画像のサイズを得る<br>
<br>
&nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
&nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply",
Data); // .plyデータをロード 軸を変えてdice1.plyや
dice2.plyなどいろいろ試してみよう<br>
<br>
&nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; //
3Dモデルのポリゴンのインデックス配列<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; //
3Dモデルのポリゴンの頂点配列<br>
<br>
&nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
&nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp;
"Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
&nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
<br>
&nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報]
https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
&nbsp;&nbsp;&nbsp; const float* p_x =
vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_y =
vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_z =
vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_nx =
(vertex-&gt;properties.has_key("nx")) ?
vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_ny =
(vertex-&gt;properties.has_key("ny")) ?
vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_nz =
(vertex-&gt;properties.has_key("nz")) ?
vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr
|| p_nz == nullptr);<br>
&nbsp;&nbsp;&nbsp; const float* p_s =
(vertex-&gt;properties.has_key("s")) ?
vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; //
Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
&nbsp;&nbsp;&nbsp; const float* p_t =
(vertex-&gt;properties.has_key("t")) ?
vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_R =
(vertex-&gt;properties.has_key("red")) ?
vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("r")) ?
vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_G =
(vertex-&gt;properties.has_key("green"))
? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("g")) ?
vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_B =
(vertex-&gt;properties.has_key("blue"))
? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("b")) ?
vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_A =
(vertex-&gt;properties.has_key("alpha"))
? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("a")) ?
vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr
|| p_B == nullptr || p_A == nullptr);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt;
iEnd; i += 1)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧
https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り)
https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], -p_y[i], p_z[i]); //
右手Y&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm =
(has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f,
0.0f);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
右手Z&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos =
VGet(-(p_y[i]),
p_z[i], p_x[i]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm)
? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f,
0.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color)
? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255,
255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s ==
nullptr) ? 0.0f : p_s[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t ==
nullptr) ? 0.0f : 1 - p_t[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; const auto&amp; face_index =
Data["face"]-&gt;properties["vertex_indices"];<br>
&nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(),
nFace = 0; i &lt; iEnd; i += 3)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt;
3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1
&gt; 0; --j) // 左手系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(j == 0 &amp;&amp; !has_norm &amp;&amp;
Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f
&amp;&amp; Vertex[index].norm.z == 0.0f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index0
=
Index[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index1
=
Index[i
+
1];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index2
=
Index[i
+
2];<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
外積 a&times;b cross_a_b を求める
https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
a
=
VSub(Vertex[index1].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
b
=
VSub(Vertex[index2].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
cross1_2
=
VCross(a,
b);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
右手系(表面は反時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
cross2_1
=
VCross(b,
a);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
単位ベクトル(ノルム)に直す [単位ベクトル]は&radic;(x*x + y*y + z*z) = 1となる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
norm1_2
=
VNorm(cross1_2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
norm2_1
=
VNorm(cross2_1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Vertex[index0].norm
=
norm1_2;
Vertex[index1].norm
=
norm1_2;
Vertex[index2].norm
=
norm1_2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Vertex[index0].norm
=
norm2_1;
Vertex[index1].norm
=
norm2_1;
Vertex[index2].norm
=
norm2_1;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
++numIndex;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
&nbsp;&nbsp;&nbsp; keyControlXYZ.x = <em>0.0f</em>; keyControlXYZ.y = <em>0.0f</em>;
keyControlXYZ.z
=
0;<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 =
SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0,
"サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 =
SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1,
"サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 =
SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1,
"サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0,
255));<br>
&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 =
SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
<br>
&nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
&nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
<br>
&nbsp;&nbsp;&nbsp; <em>Editor&amp; editor = Editor::GetInstance(); //
エディタのシングルトン参照を得る</em><br>
<br>
&nbsp;&nbsp;&nbsp; <em>//奥行0.1～5000までをカメラの描画範囲とする<br>
&nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);</em><br>
<br>
&nbsp;&nbsp;&nbsp; ScreenFlip();<br>
<br>
&nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
&nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは&times;ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();//
一旦キャンバスをきれいにまっさらに<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); //
マウスのドラッグなどを更新<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens();
// スクリーンの位置やドラッグによる移動を更新する<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>editor.UpdateKeyInput();
//
エディタのキーのインプットを更新<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput();
// エディタのマウスのインプットを更新<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); //
エディタのカメラを更新</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput =
GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -=
speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y
+= speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position =
VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth;
float height = imgHeight; // テクスチャ画像のサイズ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(<em>1.0f,
1.0f,
1.0f</em>); // 拡大縮小スケール<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_A) keyControlAngle.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_B) keyControlAngle.y += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_C) keyControlAngle.z += speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad =
DX_PI_F / 180.0f; // 角度(単位:&deg;度)からラジアン(単位:rad)へ変換する係数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate =
keyControlAngle.x * Deg2Rad;&nbsp; const float
yRotate = keyControlAngle.y * Deg2Rad; const float zRotate =
keyControlAngle.z * Deg2Rad;<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp;
matWorldDefault; // デフォルトのワールド行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); //
デフォルトのワールド行列を記憶しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX mat; // モデルのスケール&times;回転&times;移動を行列計算で設定する<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[スケール]拡大縮小のスケール行列を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
[勉強]&darr;スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp;
mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y;
mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp;
mat.m[3][3] = 1.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[回転]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matRot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::CreateIdentityMatrix(&amp;matRot);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
★MMultは行列の乗算【乗算した順にz軸回転&rarr;x軸回転&rarr;y軸回転&rarr;平行移動】<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotZ(zRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotX(xRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotY(yRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matRot); //スケール &times; 回転<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[移動]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matTrans = MGetTranslate(VGet(position.x, position.y,
position.z)); // 位置positionをここで設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matTrans); //スケール&times;回転&times;移動<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定]
https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawPolygon32bitIndexed3D(Vertex.data(),
Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); //
三角形ポリゴンをたくさん描画<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0<em></em><em></em>,
<em>100</em>, GetColor(255, 255, 0), "x:%f y:%f
Angle:%f %f %f", position.x, position.y, keyControlAngle.x,
keyControlAngle.y, keyControlAngle.z);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart();
// このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる",
GetColor(255, 255, 255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart();
// このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
半透明のスクリーンも描ける<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height,
GetColor(0, 255, 0), TRUE);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255,
255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart();
// このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255,
255, 255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); //
サブのスクリーンを全部描く<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>editor.Draw(); //
エディタのDraw処理</em><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip();
//隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
&nbsp;&nbsp;&nbsp; WaitKey();<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
&nbsp;&nbsp;&nbsp; DxLib_End();<br>
&nbsp;&nbsp;&nbsp; // ソフトの終了<br>
&nbsp;&nbsp;&nbsp; return 0;<br>
}</a></p>
<a id="mozTocId0005" class="mozTocH1"><br>
<br>
</a>
<p><a id="mozTocId0005" class="mozTocH1">いかがでしょうか？カメラの視点の位置をマウスの左ドラッグで移
動、右ドラッグで回転、<br>
キーボードのT,Yキーでカメラz軸回転、キーボードのH,Jキーでカメラy軸回転、キーボードのV,Bキーでカメラx軸回転できるようになりましたか？<br>
<br>
<br>
<br>
<br>
</a></p>
<h2><a id="mozTocId0006" class="mozTocH1">キーボードのWSキーでカメラ視点を手前や奥に移動できるように
する</a></h2>
<p><code><a id="mozTocId0006" class="mozTocH1">Editor.h</a></code><a
 id="mozTocId0006" class="mozTocH1">を変更してキーボードのWSキーでカメラ視点を手前や奥に移動できるようにし
ます。</a></p>
<p class="source"><a id="mozTocId0006" class="mozTocH1">#ifndef
EDITOR_H_<br>
#define EDITOR_H_<br>
<br>
#include "DxLib.h"<br>
#include "Input.h"<br>
#include "Screen.h"<br>
<br>
#include "Singleton.h"<br>
<br>
class Editor : public Singleton&lt;Editor&gt;<br>
{<br>
public:<br>
<br>
&nbsp;&nbsp;&nbsp; struct Camera<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x = 0.f, y = 0.0f, z =
-10.0f; // カメラはz軸マイナス位置からz軸プラス向きに原点を見る形で初期化される<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float VRotate = 0.0f, HRotate =
0.0f, TRotate = 0.0f; // X軸 V,Y軸 H,Z軸 T まわりのカメラのオイラー回転の角度<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float wheelSpeed = 1.0f; //
マウスのホイールと連動した際のカメラのスピード<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // <span
 style="font-weight: bold;">スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向の単位ベクトル(ノルム)
を求める</span><br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR <span
 style="font-weight: bold;">GetCameraWorldDirByScreenXY</span>(float
screenX = (float)Input::MouseX, float screenY = (float)Input::MouseY)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //
スクリーン(X,Y)からマウスの指すワールド座標(X,Y,Z)を求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR
currentPos = <span style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet(screenX,
screenY,
0.0f));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
カメラからマウスの指す位置への方向の単位ベクトル(ノルム)を求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return
DxLib::VNorm(DxLib::VGet(currentPos.x - x, currentPos.y - y,
currentPos.z - z));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; };<br>
&nbsp;&nbsp;&nbsp; Camera camera;<br>
<br>
&nbsp;&nbsp;&nbsp; int prevDragX = -1, prevDragY = -1; //
前フレームでのスクリーン上でのドラッグXY位置<br>
&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; bool isInitFinished = false; // 一回でもInitされたかのフラグ<br>
&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; void Init()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isInitFinished) return; //
最初の一回だけInit処理をするためのフラグ<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitFinished = true;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; void UpdateKeyInput()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>float camXYZSpeed = 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向のの単位ベクトル(ノルム)を求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR camNorm =
camera.GetCameraWorldDirByScreenXY((float)Input::MouseX,
(float)Input::MouseY);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
キーボードのWSキーでカメラ視点を手前や奥に移動できるようにする<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_W))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera +=
VGet(camNorm.x * camXYZSpeed, camNorm.y * camXYZSpeed, camNorm.z *
camXYZSpeed);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_S))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera +=
VGet(-camNorm.x * camXYZSpeed, -camNorm.y * camXYZSpeed, -camNorm.z *
camXYZSpeed);</em><br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_V))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate
-= 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_B))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate
+= 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_H))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate
-= 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_J))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate
+= 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_T))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate
-= 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_Y))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate
+= 1.0f;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; void UpdateMouseInput()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!SubScreen::isMouseOvered) //
マウスオーバーしているSubscreenがないとき<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::MouseWheel != 0.0f) // マウスのホイールをグリグリしたとき<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界の奥への方向の単位ベクトル(ノルム)を求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; VECTOR camNorm = camera.<span
 style="font-weight: bold;">GetCameraWorldDirByScreenXY</span>((float)Input::MouseX,
(float)Input::MouseY);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; float camSpeed = camera.wheelSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.wheelSpeed *= (camera.wheelSpeed &lt; 100.0f)
? 1.5f : 1.0f; // カメラのズーム速度を加速する<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // 求めた単位ベクトル&times;カメラのスピードぶんカメラの位置を移動<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.x += camNorm.x * Input::MouseWheel * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.y += camNorm.y * Input::MouseWheel * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.z += camNorm.z * Input::MouseWheel * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if
(camera.wheelSpeed &gt; 0.1f) camera.wheelSpeed *= 0.9f; //
カメラのズーム速度を減衰する<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else
camera.wheelSpeed = 0.1f; // カメラのズーム速度を減衰して最小0.1にすることで繊細なズーム調整もできるようにする<br>
<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
((Input::Click[Mouse::DragL] || Input::Click[Mouse::DragR]) &amp;&amp;
Screen::IsInsideWindow())<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if (prevDragX != -1 &amp;&amp; prevDragY != -1)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
前の位置prevと現在の位置に移動があれば、その差ぶんだけ+=することでドラッグ移動を実現<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragL])
// マウス左クリック<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX
!= Input::Click[Mouse::DragLX] || prevDragY !=
Input::Click[Mouse::DragLY])<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
{&nbsp;&nbsp;&nbsp; // マウスポインタがある画面上の座標に該当する３Ｄ空間上の座標を取得
https://dxlib.xsrv.jp/function/dxfunc_3d_camera.html#R12N11<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; float positionRatio = 0.9f;// 奥行の位置 Near 面 0.0f ～
1.0f Far 面<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; VECTOR start =
<span style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet((float)prevDragX,
(float)prevDragY,
positionRatio));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; VECTOR end =
<span style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet((float)Input::Click[Mouse::DragLX],
(float)Input::Click[Mouse::DragLY],
positionRatio));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; float camSpeed = 400; // ドラッグに対するカメラの移動速度<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.x -= (end.x - start.x) * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.y -= (end.y - start.y) * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.z -= (end.z - start.z) * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragR])
// マウス右クリック<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // カメラの角度を変更<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX
!= Input::Click[Mouse::DragRX])<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.HRotate +=
(float)(Input::Click[Mouse::DragRX] - prevDragX);<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragY
!= Input::Click[Mouse::DragRY])<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.VRotate +=
(float)(Input::Click[Mouse::DragRY] - prevDragY);<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
&plusmn;360度を超えたら割り算の余りを設定して 例.365度 &rarr; 5度に戻してやる<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(camera.HRotate &gt; 360.0f ||
camera.HRotate &lt; -360.0f) camera.HRotate =
std::fmodf(camera.HRotate, 360.0f);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(camera.VRotate &gt; 360.0f ||
camera.VRotate &lt; -360.0f) camera.VRotate =
std::fmodf(camera.VRotate, 360.0f);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; prevDragX = (Input::Click[Mouse::DragL]) ?
Input::Click[Mouse::DragLX] : Input::Click[Mouse::DragRX];<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; prevDragY = (Input::Click[Mouse::DragL]) ?
Input::Click[Mouse::DragLY] : Input::Click[Mouse::DragRY];<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; return;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; prevDragX = -1; prevDragY = -1; // マウスのドラッグがないときはリセット<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; void UpdateCamera()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラの位置と回転値をセット、カメラの位置は原点<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngle(<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
DxLib::VGet(camera.x, camera.y, camera.z),<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate
* DX_PI_F / 180.0f, camera.HRotate * DX_PI_F / 180.0f, camera.TRotate *
DX_PI_F / 180.0f);<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //
まとめてUpdateしたいときはUpdateを使い、個別にUIやKeyやMouseを別々にタイミングを取りながらUpdateしたいときは
Updateは呼ばない<br>
&nbsp;&nbsp;&nbsp; void Update()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateKeyInput();<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateMouseInput();<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateCamera();<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; void Draw()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 原点からx軸(R:赤) y軸(G:緑)
z軸(B:青)をライン表示する<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0),
VGet(1.0f * 5.0f, 0.0f * 5.0f, 0.0f * 5.0f), GetColor(255, 0, 0));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0),
VGet(0.0f * 5.0f, 1.0f * 5.0f, 0.0f * 5.0f), GetColor(0, 255, 0));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0),
VGet(0.0f * 5.0f, 0.0f * 5.0f, 1.0f * 5.0f), GetColor(0, 0, 255));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 画面に回転量を描画<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0,
DxLib::GetColor(255, 255, 255), "Cam(x:%f y:%f z:%f)", camera.x,
camera.y, camera.z);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 20,
DxLib::GetColor(255, 255, 255),
"Rot(V:%f H:%f T:%f)", camera.VRotate, camera.HRotate, camera.TRotate);<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
};<br>
<br>
#endif<br>
</a></p>
<p><a id="mozTocId0006" class="mozTocH1">いかがでしょうか？カメラの視点の位置をキーボードのWSキーでカ
メラ視点を手前や奥に移動できるようになりましたか？<br>
重要なのはGetCameraWorldDirByScreenXY関数でカメラ画面の視界(ワールド座標)の奥への方向のの単位ベクトル(ノルム)を求
めることです<br>
カメラの視点を移動するときはXYZ軸に対して+1するようなシンプルな計算ではうまくいきません<br>
<span style="text-decoration: underline;">あてになるのは「カメラから見た奥行方向」の大きさ1の単位ベク
トル</span>です。このベクトルを+1方向で奥、-1方向で手前にカメラを移動できます<br>
GetCameraWorldDirByScreenXY関数の中では DxLib::ConvScreenPosToWorldPos を使って <br>
スクリーンの2D(X,Y)からマウスの指すワールド座標3D(X,Y,Z)を求めています<br>
<span style="text-decoration: underline;">スクリーンの2D位置からワールドの3D位置を変換する処理が</span>重
要なキーとなっているのでこの関数の存在は知っておきましょう<br>
</a></p>
<a id="mozTocId0006" class="mozTocH1"><br>
<br>
<br>
</a>
<h2><a id="mozTocId0007" class="mozTocH1">キーボードのDAキーとEQキーでカメラ視点を左右や上下に移動
できるようにする</a></h2>
<p><code><a id="mozTocId0007" class="mozTocH1">Editor.h</a></code><a
 id="mozTocId0007" class="mozTocH1">を変更してキーボードのDAキーとEQキーでカメラ視点を左右や上下に移動で
きるようにします。</a></p>
<p class="source"><a id="mozTocId0007" class="mozTocH1">#ifndef
EDITOR_H_<br>
#define EDITOR_H_<br>
<br>
#include "DxLib.h"<br>
#include "Input.h"<br>
#include "Screen.h"<br>
<br>
#include "Singleton.h"<br>
<br>
class Editor : public Singleton&lt;Editor&gt;<br>
{<br>
public:<br>
<br>
&nbsp;&nbsp;&nbsp; struct Camera<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x = 0.f, y = 0.0f, z =
-10.0f; // カメラはz軸マイナス位置からz軸プラス向きに原点を見る形で初期化される<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float VRotate = 0.0f, HRotate =
0.0f, TRotate = 0.0f; // X軸 V,Y軸 H,Z軸 T まわりのカメラのオイラー回転の角度<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float wheelSpeed = 1.0f; //
マウスのホイールと連動した際のカメラのスピード<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向の単位ベクトル(ノルム)を求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR
GetCameraWorldDirByScreenXY(float screenX = (float)Input::MouseX, float
screenY = (float)Input::MouseY)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //
スクリーン(X,Y)からマウスの指すワールド座標(X,Y,Z)を求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR
currentPos = <span style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet(screenX,
screenY,
0.0f));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
カメラからマウスの指す位置への方向の単位ベクトル(ノルム)を求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return
DxLib::VNorm(DxLib::VGet(currentPos.x - x, currentPos.y - y,
currentPos.z - z));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// スクリーンの2Dの start位置XY から
end位置XY の方向 が ワールド座標3D においてどんなベクトルになるかを求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR
GetWorldDirByCameraScreenXYDir(float screenStartX =
(float)Input::MouseX, float screenStartY = (float)Input::MouseY,<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float
screenEndX = (float)(Input::MouseX + 1), float screenEndY =
(float)(Input::MouseY + 1))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //
スクリーン(X,Y)からマウスの指すワールド座標(X,Y,Z)を求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR
startPos = <span style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet(screenStartX,
screenStartY,
0.0f));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR endPos
= <span style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet(screenEndX,
screenEndY,
0.0f));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
ワールド座標におけるstartからendへ向かう方向のベクトルを求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return
DxLib::VGet(endPos.x - startPos.x, endPos.y - startPos.y, endPos.z -
startPos.z);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</em><br>
&nbsp;&nbsp;&nbsp; };<br>
&nbsp;&nbsp;&nbsp; Camera camera;<br>
<br>
&nbsp;&nbsp;&nbsp; int prevDragX = -1, prevDragY = -1; //
前フレームでのスクリーン上でのドラッグXY位置<br>
&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; bool isInitFinished = false; // 一回でもInitされたかのフラグ<br>
&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; void Init()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (isInitFinished) return; //
最初の一回だけInit処理をするためのフラグ<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitFinished = true;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; void UpdateKeyInput()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float camXYZSpeed = 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
スクリーンの位置からカメラ画面の視界(ワールド座標)の奥への方向のの単位ベクトル(ノルム)を求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR camNorm =
camera.GetCameraWorldDirByScreenXY((float)Input::MouseX,
(float)Input::MouseY);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
キーボードのWSキーでカメラ視点を手前や奥に移動できるようにする<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_W))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera +=
VGet(camNorm.x * camXYZSpeed, camNorm.y * camXYZSpeed, camNorm.z *
camXYZSpeed);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_S))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera +=
VGet(-camNorm.x * camXYZSpeed, -camNorm.y * camXYZSpeed, -camNorm.z *
camXYZSpeed);<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// スクリーンの 2D上のX方向 が ワールド座標
3D ではどんな方向ベクトルになるかを求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR xCamDir =
VNorm(camera.GetWorldDirByCameraScreenXYDir((float)Input::MouseX,
(float)Input::MouseY, (float)(Input::MouseX + 10),
(float)Input::MouseY));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_D))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera +=
VGet(xCamDir.x * camXYZSpeed, xCamDir.y * camXYZSpeed, xCamDir.z *
camXYZSpeed);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_A))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera +=
VGet(-xCamDir.x * camXYZSpeed, -xCamDir.y * camXYZSpeed, -xCamDir.z *
camXYZSpeed);</em><br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// スクリーンの 2D上のY方向 が ワールド座標
3D ではどんな方向ベクトルになるかを求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR yCamDir =
VNorm(camera.GetWorldDirByCameraScreenXYDir((float)Input::MouseX,
(float)Input::MouseY, (float)Input::MouseX, (float)(Input::MouseY +
10)));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_Q))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera +=
VGet(yCamDir.x * camXYZSpeed, yCamDir.y * camXYZSpeed, yCamDir.z *
camXYZSpeed);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_E))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera +=
VGet(-yCamDir.x * camXYZSpeed, -yCamDir.y * camXYZSpeed, -yCamDir.z *
camXYZSpeed);</em><br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_V))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate
-= 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_B))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate
+= 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_H))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate
-= 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_J))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.HRotate
+= 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_T))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate
-= 1.0f;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_Y))<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.TRotate
+= 1.0f;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; void UpdateMouseInput()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!SubScreen::isMouseOvered) //
マウスオーバーしているSubscreenがないとき<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(Input::MouseWheel != 0.0f) // マウスのホイールをグリグリしたとき<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // スクリーンの位置からカメラ画面の視界の奥への方向の単位ベクトル(ノルム)を求める<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; VECTOR camNorm = camera.<span
 style="font-weight: bold;">GetCameraWorldDirByScreenXY</span>((float)Input::MouseX,
(float)Input::MouseY);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; float camSpeed = camera.wheelSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.wheelSpeed *= (camera.wheelSpeed &lt; 100.0f)
? 1.5f : 1.0f; // カメラのズーム速度を加速する<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // 求めた単位ベクトル&times;カメラのスピードぶんカメラの位置を移動<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.x += camNorm.x * Input::MouseWheel * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.y += camNorm.y * Input::MouseWheel * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.z += camNorm.z * Input::MouseWheel * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if
(camera.wheelSpeed &gt; 0.1f) camera.wheelSpeed *= 0.9f; //
カメラのズーム速度を減衰する<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else
camera.wheelSpeed = 0.1f; // カメラのズーム速度を減衰して最小0.1にすることで繊細なズーム調整もできるようにする<br>
<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
((Input::Click[Mouse::DragL] || Input::Click[Mouse::DragR]) &amp;&amp;
Screen::IsInsideWindow())<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if (prevDragX != -1 &amp;&amp; prevDragY != -1)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
前の位置prevと現在の位置に移動があれば、その差ぶんだけ+=することでドラッグ移動を実現<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragL])
// マウス左クリック<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX
!= Input::Click[Mouse::DragLX] || prevDragY !=
Input::Click[Mouse::DragLY])<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
{&nbsp;&nbsp;&nbsp; // マウスポインタがある画面上の座標に該当する３Ｄ空間上の座標を取得
https://dxlib.xsrv.jp/function/dxfunc_3d_camera.html#R12N11<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; float positionRatio = 0.9f;// 奥行の位置 Near 面 0.0f ～
1.0f Far 面<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; VECTOR start =
<span style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet((float)prevDragX,
(float)prevDragY,
positionRatio));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; VECTOR end =
<span style="font-weight: bold;">DxLib::ConvScreenPosToWorldPos</span>(VGet((float)Input::Click[Mouse::DragLX],
(float)Input::Click[Mouse::DragLY],
positionRatio));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; float camSpeed = 400; // ドラッグに対するカメラの移動速度<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.x -= (end.x - start.x) * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.y -= (end.y - start.y) * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.z -= (end.z - start.z) * camSpeed;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Input::Click[Mouse::DragR])
// マウス右クリック<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // カメラの角度を変更<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragX
!= Input::Click[Mouse::DragRX])<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.HRotate +=
(float)(Input::Click[Mouse::DragRX] - prevDragX);<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (prevDragY
!= Input::Click[Mouse::DragRY])<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; camera.VRotate +=
(float)(Input::Click[Mouse::DragRY] - prevDragY);<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
&plusmn;360度を超えたら割り算の余りを設定して 例.365度 &rarr; 5度に戻してやる<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(camera.HRotate &gt; 360.0f ||
camera.HRotate &lt; -360.0f) camera.HRotate =
std::fmodf(camera.HRotate, 360.0f);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(camera.VRotate &gt; 360.0f ||
camera.VRotate &lt; -360.0f) camera.VRotate =
std::fmodf(camera.VRotate, 360.0f);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; prevDragX = (Input::Click[Mouse::DragL]) ?
Input::Click[Mouse::DragLX] : Input::Click[Mouse::DragRX];<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; prevDragY = (Input::Click[Mouse::DragL]) ?
Input::Click[Mouse::DragLY] : Input::Click[Mouse::DragRY];<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; return;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; prevDragX = -1; prevDragY = -1; // マウスのドラッグがないときはリセット<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; void UpdateCamera()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラの位置と回転値をセット、カメラの位置は原点<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngle(<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
DxLib::VGet(camera.x, camera.y, camera.z),<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; camera.VRotate
* DX_PI_F / 180.0f, camera.HRotate * DX_PI_F / 180.0f, camera.TRotate *
DX_PI_F / 180.0f);<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //
まとめてUpdateしたいときはUpdateを使い、個別にUIやKeyやMouseを別々にタイミングを取りながらUpdateしたいときは
Updateは呼ばない<br>
&nbsp;&nbsp;&nbsp; void Update()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init();<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateKeyInput();<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateMouseInput();<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UpdateCamera();<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; void Draw()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 原点からx軸(R:赤) y軸(G:緑)
z軸(B:青)をライン表示する<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0),
VGet(1.0f * 5.0f, 0.0f * 5.0f, 0.0f * 5.0f), GetColor(255, 0, 0));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0),
VGet(0.0f * 5.0f, 1.0f * 5.0f, 0.0f * 5.0f), GetColor(0, 255, 0));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(VGet(0, 0, 0),
VGet(0.0f * 5.0f, 0.0f * 5.0f, 1.0f * 5.0f), GetColor(0, 0, 255));<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 画面に回転量を描画<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 0,
DxLib::GetColor(255, 255, 255), "Cam(x:%f y:%f z:%f)", camera.x,
camera.y, camera.z);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0, 20,
DxLib::GetColor(255, 255, 255),
"Rot(V:%f H:%f T:%f)", camera.VRotate, camera.HRotate, camera.TRotate);<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
};<br>
<br>
#endif<br>
</a></p>
<p><a id="mozTocId0007" class="mozTocH1">いかがでしょう?キーボードのDAキーとEQキーでカメラ視点を左
右や上下に移動できるようになりましたか?<br>
カメラの上下左右方向でも重要なのは 2Dのスクリーン から 3Dのワールド座標 での方向のベクトルを求めることです<br>
GetWorldDirByCameraScreenXYDir関数の中でもDxLib::ConvScreenPosToWorldPos関数を使って
2D &rarr; 3D座標 への変換を行っています<br>
カメラの左右移動方向は<span style="text-decoration: underline;">「スクリーンの枠」の左右方向</span>、
カメラの上下移動方向は<span style="text-decoration: underline;">「スクリーンの枠」の上下方向</span>と
平行になるベクトルです<br>
</a></p>
<a id="mozTocId0007" class="mozTocH1"><br>
<br>
<br>
</a>
<h2><a id="mozTocId0008" class="mozTocH1">Unityのアセットストアからとってきたテクスチャ1枚のシン
プルな3DモデルをDXのモデルビューアで.mv1形式に変換して表示させてみる</a></h2>
<p><a id="mozTocId0008" class="mozTocH1">複雑な3Dモデルだとテクスチャリンクつけなおしやボーンが崩れた
りして大変なので下記リンクのシンプルな無料3DモデルをUnityにインポート
します<br>
</a><a
 href="https://assetstore.unity.com/packages/3d/characters/humanoids/fantasy/devil-animated-character-60777?locale=ja-JP&amp;srsltid=AfmBOor53ggeWTlrD6CMx0iQtZj3gZrHiPBdYgzpG2Ljhm4FIBT912Q3">https://assetstore.unity.com/packages/3d/characters/humanoids/fantasy/devil-animated-character-60777?locale=ja-JP&amp;srsltid=AfmBOor53ggeWTlrD6CMx0iQtZj3gZrHiPBdYgzpG2Ljhm4FIBT912Q3</a>
<br>
</p>
<p>Unityの[Window]&rarr;[Package Manager]を開いて、取得したデビルのキャラのアセットを[Download]<br>
</p>
<p> <img src="image/mv1_from_unity_asset1.png" alt=""><br>
</p>
<p><br>
Unityへ[Import]ボタンでインポートする<br>
</p>
<p> <img src="image/mv1_from_unity_asset2.png" alt=""><br>
</p>
<p><br>
Assetフォルダ&rarr;Devilフォルダ&rarr;Animationsフォルダの「devil@fly」を[右クリック]&rarr;
[Show in Explorer]で3DのモデルのあるフォルダをWindowsで開く<br>
</p>
<p> <img src="image/mv1_from_unity_asset3.png" alt=""><br>
</p>
<p><br>
Unityのアセットフォルダの3DモデルをコピーしてDXのプロジェクトのImgaeフォルダへコピペする<br>
</p>
<p> <img src="image/mv1_from_unity_asset4.png" alt=""><br>
</p>
<p><br>
DXライブラリをインストールしたフォルダの中のToolフォルダにDXモデルビューアがあるので起動する<br>
</p>
<p> <img src="image/mv1_from_unity_asset5.png" alt=""><br>
</p>
<p><br>
[マテリアル]&rarr;[lambert1(ランバート反射マテリアル)]&rarr;[拡散光(ディフーズ反射)]&rarr;[ディフーズマッ
プ]のテクスチャリンクの[参照]先にファイルがないので<br>
3Dモデルが灰色で表示されてしまう<br>
</p>
<p> <img src="image/mv1_from_unity_asset6.png" alt=""><br>
</p>
<p><br>
Unityの[Assetsフォルダ]&rarr;[Devilフォルダ]&rarr;[Textureフォルダ]のテクスチャを[右クリッ
ク]&rarr;[Show in Explorer]でWindowsのフォルダ上で画像ファイルを見つける<br>
</p>
<p> <img src="image/mv1_from_unity_asset7.png" alt=""><br>
</p>
<p><br>
DXのプロジェクトのImageフォルダへテクスチャ画像をコピペする<br>
</p>
<p> <img src="image/mv1_from_unity_asset8.png" alt=""><br>
</p>
<p><br>
DXのモデルビューアで3Dモデルを開きなおすか、<br>
[マテリアル]&rarr;[lambert1]&rarr;[拡散光]&rarr;[ディフーズマップ]のテクスチャリンクの[参照]を押してコピペし
た画像に参照を貼りなおすと<br>
3Dモデル表面にテクスチャ画像が反映される<br>
</p>
<p> <img src="image/mv1_from_unity_asset9.png" alt=""><br>
<br>
</p>
<p>[ファイル]&rarr;[名前を付けて保存]でDXのプロジェクトのImageフォルダに.mv1形式(DXで扱える3Dモデル形式)で保存する<br>
</p>
<p> <img src="image/mv1_from_unity_asset10.png" alt=""><br>
</p>
<p><br>
</p>
<p><code>main.cpp</code>のコードに.mv1形式の3Dモデルをロードして、描画表示させるプログラムを追加してみましょう。</p>
<p class="source">#include "DxLib.h"<br>
#include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
#include "Input.h"<br>
#include "Screen.h"<br>
#include "Ply.h"<br>
<br>
#include "Editor.h"<br>
<br>
//
設定画面の【リンカー】&rarr;【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain
からプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR
lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
&nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); //
画面サイズWidth&times;Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);//
ウィンドウサイズWidth&times;Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;&nbsp;
SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間
違ってるかも<br>
<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
&nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<br>
&nbsp;&nbsp;&nbsp; <em>int devil3DModel =
DxLib::MV1LoadModel("Image/devil@fly.mv1"); // 3Dモデルをmv1形式で読込み</em><br>
<br>
&nbsp;&nbsp;&nbsp; int texImage = -1;<br>
&nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
&nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
&nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
&nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth,
&amp;imgHeight); // テクスチャ画像のサイズを得る<br>
<br>
&nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
&nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply",
Data); // .plyデータをロード 軸を変えてdice1.plyや
dice2.plyなどいろいろ試してみよう<br>
<br>
&nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; //
3Dモデルのポリゴンのインデックス配列<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; //
3Dモデルのポリゴンの頂点配列<br>
<br>
&nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
&nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp;
"Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
&nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
<br>
&nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報]
https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
&nbsp;&nbsp;&nbsp; const float* p_x =
vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_y =
vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_z =
vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_nx =
(vertex-&gt;properties.has_key("nx")) ?
vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_ny =
(vertex-&gt;properties.has_key("ny")) ?
vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_nz =
(vertex-&gt;properties.has_key("nz")) ?
vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr
|| p_nz == nullptr);<br>
&nbsp;&nbsp;&nbsp; const float* p_s =
(vertex-&gt;properties.has_key("s")) ?
vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; //
Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
&nbsp;&nbsp;&nbsp; const float* p_t =
(vertex-&gt;properties.has_key("t")) ?
vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_R =
(vertex-&gt;properties.has_key("red")) ?
vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("r")) ?
vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_G =
(vertex-&gt;properties.has_key("green"))
? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("g")) ?
vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_B =
(vertex-&gt;properties.has_key("blue"))
? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("b")) ?
vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_A =
(vertex-&gt;properties.has_key("alpha"))
? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("a")) ?
vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr
|| p_B == nullptr || p_A == nullptr);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt;
iEnd; i += 1)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧
https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り)
https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], -p_y[i], p_z[i]); //
右手Y&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm =
(has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f,
0.0f);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
右手Z&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos =
VGet(-(p_y[i]),
p_z[i], p_x[i]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm)
? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f,
0.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color)
? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255,
255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s ==
nullptr) ? 0.0f : p_s[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t ==
nullptr) ? 0.0f : 1 - p_t[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; const auto&amp; face_index =
Data["face"]-&gt;properties["vertex_indices"];<br>
&nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(),
nFace = 0; i &lt; iEnd; i += 3)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt;
3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1
&gt; 0; --j) // 左手系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(j == 0 &amp;&amp; !has_norm &amp;&amp;
Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f
&amp;&amp; Vertex[index].norm.z == 0.0f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index0
=
Index[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index1
=
Index[i
+
1];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index2
=
Index[i
+
2];<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
外積 a&times;b cross_a_b を求める
https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
a
=
VSub(Vertex[index1].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
b
=
VSub(Vertex[index2].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
cross1_2
=
VCross(a,
b);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
右手系(表面は反時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
cross2_1
=
VCross(b,
a);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
単位ベクトル(ノルム)に直す [単位ベクトル]は&radic;(x*x + y*y + z*z) = 1となる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
norm1_2
=
VNorm(cross1_2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
norm2_1
=
VNorm(cross2_1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Vertex[index0].norm
=
norm1_2;
Vertex[index1].norm
=
norm1_2;
Vertex[index2].norm
=
norm1_2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Vertex[index0].norm
=
norm2_1;
Vertex[index1].norm
=
norm2_1;
Vertex[index2].norm
=
norm2_1;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
++numIndex;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
&nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f;
keyControlXYZ.z
= 0;<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 =
SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0,
"サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 =
SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1,
"サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 =
SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1,
"サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0,
255));<br>
&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 =
SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
<br>
&nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
&nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
<br>
&nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); //
エディタのシングルトン参照を得る<br>
<br>
&nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
&nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
<br>
&nbsp;&nbsp;&nbsp; ScreenFlip();<br>
<br>
&nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
&nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは&times;ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();//
一旦キャンバスをきれいにまっさらに<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); //
マウスのドラッグなどを更新<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens();
// スクリーンの位置やドラッグによる移動を更新する<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput();
// エディタのキーのインプットを更新<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput();
// エディタのマウスのインプットを更新<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); //
エディタのカメラを更新<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput =
GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -=
speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y
+= speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position =
VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth;
float height = imgHeight; // テクスチャ画僧のサイズ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f,
1.0f, 1.0f); // 拡大縮小スケール<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_A) keyControlAngle.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_B) keyControlAngle.y += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_C) keyControlAngle.z += speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad =
DX_PI_F / 180.0f; // 角度(単位:&deg;度)からラジアン(単位:rad)へ変換する係数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate =
keyControlAngle.x * Deg2Rad;&nbsp; const float
yRotate = keyControlAngle.y * Deg2Rad; const float zRotate =
keyControlAngle.z * Deg2Rad;<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp;
matWorldDefault; // デフォルトのワールド行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); //
デフォルトのワールド行列を記憶しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX mat; // モデルのスケール&times;回転&times;移動を行列計算で設定する<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[スケール]拡大縮小のスケール行列を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
[勉強]&darr;スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp;
mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y;
mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp;
mat.m[3][3] = 1.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[回転]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matRot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::CreateIdentityMatrix(&amp;matRot);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
★MMultは行列の乗算【乗算した順にz軸回転&rarr;x軸回転&rarr;y軸回転&rarr;平行移動】<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotZ(zRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotX(xRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotY(yRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matRot); //スケール &times; 回転<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[移動]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matTrans = MGetTranslate(VGet(position.x, position.y,
position.z)); // 位置positionをここで設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matTrans); //スケール&times;回転&times;移動<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定]
https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawPolygon32bitIndexed3D(Vertex.data(),
Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); //
三角形ポリゴンをたくさん描画<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>DxLib::MV1DrawModel(devil3DModel);
//
3Dモデル(.mv1形式)を描く</em><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0<em></em><em></em>,
100,
GetColor(255,
255,
0),
"x:%f
y:%f
Angle:%f
%f %f", position.x, position.y, keyControlAngle.x,
keyControlAngle.y, keyControlAngle.z);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart();
// このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる",
GetColor(255, 255, 255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart();
// このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
半透明のスクリーンも描ける<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height,
GetColor(0, 255, 0), TRUE);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255,
255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart();
// このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255,
255, 255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); //
サブのスクリーンを全部描く<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); //
エディタのDraw処理<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip();
//隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
&nbsp;&nbsp;&nbsp; WaitKey();<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
&nbsp;&nbsp;&nbsp; DxLib_End();<br>
&nbsp;&nbsp;&nbsp; // ソフトの終了<br>
&nbsp;&nbsp;&nbsp; return 0;<br>
}</p>
<br>
<br>
いかがでしょうか?MV1形式の3Dモデルがちゃんと表示されたでしょうか?<br>
Unityのアセットは基本100倍のスケールで制作されているのでマウスをぐりぐりさせてズームアウトさせないとデカすぎて見えないはずです。<br>
こういうトラブルを回避するために事前にエディタの直感的な操作を準備しておいたのです。<br>
<p> <img src="image/mv1_from_unity_asset11.png" alt=""><br>
<br>
</p>
<p><span style="font-weight: bold;">[練習問題]</span> .plyのときに
DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定] <br>
したのと同じように.mv1形式の3Dモデルにもスケールや回転や移動の行列を反映させてみよ<br>
</p>
<br>
<br>
<br>
<h2><a id="mozTocId0009" class="mozTocH1"></a>MV1形式の3Dモデルをアニメーション描画する</h2>
<br>
<p><code>main.cpp</code>のコードに.mv1形式の3Dモデルにデフォルトでアニメがついていたら、そ
のアニメをモデルにアタッチしてアニメーションさせるプログラムを追加してみましょう。</p>
<p class="source">#include
"DxLib.h"<br>
#include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
#include "Input.h"<br>
#include "Screen.h"<br>
#include "Ply.h"<br>
<br>
#include "Editor.h"<br>
<br>
//
設定画面の【リンカー】&rarr;【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain
からプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR
lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
&nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); //
画面サイズWidth&times;Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);//
ウィンドウサイズWidth&times;Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;&nbsp;
SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間
違ってるかも<br>
<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
&nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
<br>
&nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<a id="mozTocId0009"
 class="mozTocH1"><br>
&nbsp;&nbsp;&nbsp; int devil3DModel =
DxLib::MV1LoadModel("Image/devil@fly.mv1"); // 3Dモデルをmv1形式で読込み<br>
<br>
&nbsp;&nbsp;&nbsp; <em>float animTime = 0.0f; // アニメの現在時刻<br>
&nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
&nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
&nbsp;&nbsp;&nbsp; int DefalutAnimNum =
DxLib::<span style="font-weight: bold;">MV1GetAnimNum</span>(devil3DModel);
//
3Dモデル内のアニメの数<br>
&nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, int&gt;
animNameToIndex; // アニメ名からアニメのインデックス番号への辞書<br>
&nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, float&gt;
animNameToTotalTime; // アニメ名からアニメの総再生時間への辞書<br>
&nbsp;&nbsp;&nbsp; for (int index = 0; index &lt; DefalutAnimNum;
++index)<br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // アニメの数ぶん順番にアタッチを設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* animName =
DxLib::MV1GetAnimName(devil3DModel, index); // アニメーション名を取得<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
アニメ名からインデックス番号を得るために辞書に登録しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
 style="font-weight: bold;">animNameToIndex</span>[animName] =
DxLib::<span style="font-weight: bold;">MV1AttachAnim</span>(devil3DModel,
index);
//
アニメをアタッチして、その番号を辞書に登録<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<span style="font-weight: bold;">animNameToTotalTime</span>[animName] =
DxLib::<span style="font-weight: bold;">MV1GetAttachAnimTotalTime</span>(devil3DModel,
index);
//
アニメをループさせるためにアニメの総再生時間を辞書に記録しておく<br>
&nbsp;&nbsp;&nbsp; }</em><br>
&nbsp;&nbsp;&nbsp; </a><a id="mozTocId0009" class="mozTocH1"><br>
&nbsp;&nbsp;&nbsp; int texImage = -1;<br>
&nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
&nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
&nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
&nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth,
&amp;imgHeight); // テクスチャ画像のサイズを得る<br>
<br>
&nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
&nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply",
Data); // .plyデータをロード 軸を変えてdice1.plyや
dice2.plyなどいろいろ試してみよう<br>
<br>
&nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; //
3Dモデルのポリゴンのインデックス配列<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; //
3Dモデルのポリゴンの頂点配列<br>
<br>
&nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
&nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp;
"Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
&nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
<br>
&nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報]
https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
&nbsp;&nbsp;&nbsp; const float* p_x =
vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_y =
vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_z =
vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_nx =
(vertex-&gt;properties.has_key("nx")) ?
vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_ny =
(vertex-&gt;properties.has_key("ny")) ?
vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_nz =
(vertex-&gt;properties.has_key("nz")) ?
vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr
|| p_nz == nullptr);<br>
&nbsp;&nbsp;&nbsp; const float* p_s =
(vertex-&gt;properties.has_key("s")) ?
vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; //
Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
&nbsp;&nbsp;&nbsp; const float* p_t =
(vertex-&gt;properties.has_key("t")) ?
vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_R =
(vertex-&gt;properties.has_key("red")) ?
vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("r")) ?
vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_G =
(vertex-&gt;properties.has_key("green"))
? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("g")) ?
vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_B =
(vertex-&gt;properties.has_key("blue"))
? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("b")) ?
vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_A =
(vertex-&gt;properties.has_key("alpha"))
? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("a")) ?
vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr
|| p_B == nullptr || p_A == nullptr);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt;
iEnd; i += 1)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧
https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り)
https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], -p_y[i], p_z[i]); //
右手Y&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm =
(has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f,
0.0f);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
右手Z&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos =
VGet(-(p_y[i]),
p_z[i], p_x[i]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm)
? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f,
0.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color)
? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255,
255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s ==
nullptr) ? 0.0f : p_s[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t ==
nullptr) ? 0.0f : 1 - p_t[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; const auto&amp; face_index =
Data["face"]-&gt;properties["vertex_indices"];<br>
&nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(),
nFace = 0; i &lt; iEnd; i += 3)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt;
3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1
&gt; 0; --j) // 左手系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(j == 0 &amp;&amp; !has_norm &amp;&amp;
Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f
&amp;&amp; Vertex[index].norm.z == 0.0f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index0
=
Index[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index1
=
Index[i
+
1];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index2
=
Index[i
+
2];<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
外積 a&times;b cross_a_b を求める
https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
a
=
VSub(Vertex[index1].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
b
=
VSub(Vertex[index2].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
cross1_2
=
VCross(a,
b);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
右手系(表面は反時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
cross2_1
=
VCross(b,
a);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
単位ベクトル(ノルム)に直す [単位ベクトル]は&radic;(x*x + y*y + z*z) = 1となる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
norm1_2
=
VNorm(cross1_2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
norm2_1
=
VNorm(cross2_1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Vertex[index0].norm
=
norm1_2;
Vertex[index1].norm
=
norm1_2;
Vertex[index2].norm
=
norm1_2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Vertex[index0].norm
=
norm2_1;
Vertex[index1].norm
=
norm2_1;
Vertex[index2].norm
=
norm2_1;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
++numIndex;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
&nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f;
keyControlXYZ.z
= 0;<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 =
SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0,
"サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 =
SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1,
"サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 =
SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1,
"サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0,
255));<br>
&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 =
SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
<br>
&nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
&nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
<br>
&nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); //
エディタのシングルトン参照を得る<br>
<br>
&nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
&nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
<br>
&nbsp;&nbsp;&nbsp; ScreenFlip();<br>
<br>
&nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
&nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは&times;ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();//
一旦キャンバスをきれいにまっさらに<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); //
マウスのドラッグなどを更新<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens();
// スクリーンの位置やドラッグによる移動を更新する<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput();
// エディタのキーのインプットを更新<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput();
// エディタのマウスのインプットを更新<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); //
エディタのカメラを更新<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput =
GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -=
speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y
+= speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position =
VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width = imgWidth;
float height = imgHeight; // テクスチャ画僧のサイズ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f,
1.0f, 1.0f); // 拡大縮小スケール<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_A) keyControlAngle.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_B) keyControlAngle.y += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_C) keyControlAngle.z += speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad =
DX_PI_F / 180.0f; // 角度(単位:&deg;度)からラジアン(単位:rad)へ変換する係数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate =
keyControlAngle.x * Deg2Rad;&nbsp; const float
yRotate = keyControlAngle.y * Deg2Rad; const float zRotate =
keyControlAngle.z * Deg2Rad;<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp;
matWorldDefault; // デフォルトのワールド行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); //
デフォルトのワールド行列を記憶しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX mat; // モデルのスケール&times;回転&times;移動を行列計算で設定する<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[スケール]拡大縮小のスケール行列を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
[勉強]&darr;スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp;
mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y;
mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp;
mat.m[3][3] = 1.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[回転]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matRot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::CreateIdentityMatrix(&amp;matRot);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
★MMultは行列の乗算【乗算した順にz軸回転&rarr;x軸回転&rarr;y軸回転&rarr;平行移動】<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotZ(zRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotX(xRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotY(yRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matRot); //スケール &times; 回転<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[移動]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matTrans = MGetTranslate(VGet(position.x, position.y,
position.z)); // 位置positionをここで設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matTrans); //スケール&times;回転&times;移動<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定]
https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawPolygon32bitIndexed3D(Vertex.data(),
Vertex.size(), Index.data(), numIndex / 3, texImage, FALSE); //
三角形ポリゴンをたくさん描画<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0<em></em><em></em>,
100,
GetColor(255,
255,
0),
"x:%f
y:%f
Angle:%f
%f %f", position.x, position.y, keyControlAngle.x,
keyControlAngle.y, keyControlAngle.z);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>std::string <span
 style="font-weight: bold;">animName</span> =
"Take 001"; // アニメ名:DXモデルビューアでアニメ名をきちんと確認したほうがよい&darr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
assert(animNameToTotalTime.count(animName) &gt; 0 &amp;&amp;
"指定されたアニメ名のアニメはMV1に付属していませんでした");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime += animStepTime *
animSpeed; // 1.0&times;2倍 なら2倍速でアニメ時刻が進む<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animTime &gt;
<span style="font-weight: bold;">animNameToTotalTime</span>[<span
 style="font-weight: bold;">animName</span>])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
animTime = 0.0f; // 0秒目へとアニメをループさせる<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 再生時間をセットする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::<span style="font-weight: bold;">MV1SetAttachAnimTime</span>(devil3DModel,
<span style="font-weight: bold;">animNameToIndex</span>[<span
 style="font-weight: bold;">animName</span>],
animTime);</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart();
// このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる",
GetColor(255, 255, 255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart();
// このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
半透明のスクリーンも描ける<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height,
GetColor(0, 255, 0), TRUE);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255,
255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart();
// このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255,
255, 255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); //
サブのスクリーンを全部描く<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); //
エディタのDraw処理<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip();
//隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
&nbsp;&nbsp;&nbsp; WaitKey();<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
&nbsp;&nbsp;&nbsp; DxLib_End();<br>
&nbsp;&nbsp;&nbsp; // ソフトの終了<br>
&nbsp;&nbsp;&nbsp; return 0;<br>
}</a></p>
<a id="mozTocId0009" class="mozTocH1"><br>
アニメ名をDXモデルビューアーの[アニメ]から確認<br>
</a>
<p><a id="mozTocId0009" class="mozTocH1"> <img
 src="image/mv1_from_unity_asset12.png" alt=""><br>
</a></p>
<p><a id="mozTocId0009" class="mozTocH1"><br>
アニメの総再生時間とアニメのインデックス番号はここ<br>
</a></p>
<p><a id="mozTocId0009" class="mozTocH1"><img
 src="image/mv1_from_unity_asset13.png" alt=""><br>
</a></p>
<p><a id="mozTocId0009" class="mozTocH1">いかがですか?3Dキャラがアニメーションしたでしょうか?<br>
アニメーションの時刻を進めるプログラムを書くには<br>
アニメーション番号(No.)かアニメーション名(例.Take
001)を使う必要があるのでDXモデルビューアーで確認して間違わないようにしましょう<br>
</a></p>
<a id="mozTocId0009" class="mozTocH1"><br>
</a>
<h2><a id="mozTocId0010" class="mozTocH1"></a>複数の3DモデルやアニメをResourceクラスで2
重ロード
しないよう読み込んで複数アニメを切替えする</h2>
<p><code>Resource.hを新規作成</code>
してResourceクラスで画像やテクスチャや3Dモデルなどのリソースを
2重にロー
ドしないよう読み込んだときにstd::unordered_mapのfiles辞書に登録する機能を準備する。</p>
<p class="source">#ifndef
RESOURCE_H_<br>
#define RESOURCE_H_<br>
<br>
#include "DxLib.h"<br>
<br>
#include &lt;vector&gt;<br>
#include &lt;string&gt;<br>
#include &lt;memory&gt; // 共有ポインタstd::shared_ptrを使う<br>
#include &lt;unordered_map&gt; // 高速辞書&lt;ファイルパス,
共有リソース&gt;で一度読み込んだファイルはかぶらないように(2重ロード防止)する<br>
#include &lt;assert.h&gt;<br>
<br>
struct Resource : public std::enable_shared_from_this&lt;Resource&gt;<br>
{&nbsp;&nbsp;&nbsp; // [std::shared_ptrでthisポインタをつかうためには]&uarr;
https://www.kabuku.co.jp/developers/cpp_enable_shared_from_this<br>
&nbsp;&nbsp;&nbsp; enum class Type { None, MV1, Ply, Texture, Sound, SE
};<br>
&nbsp;&nbsp;&nbsp; Type m_type{ Type::None }; // データの種類<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; m_handles; // ロードしたリソースのハンドル番号<br>
&nbsp;&nbsp;&nbsp; inline operator int() { return (m_handles.size()
&gt; 0) ? m_handles[0] : -1; } // intでキャストした場合には先頭の0個目のハンドル番号を返す<br>
&nbsp;&nbsp;&nbsp; std::string m_FilePath{ "" }; // ロードしたリソースのファイルパス<br>
&nbsp;&nbsp;&nbsp; static std::unordered_map&lt;std::string,
std::shared_ptr&lt;Resource&gt;&gt; files; // ロード済みのリソースファイルを保管する辞書<br>
<br>
&nbsp;&nbsp;&nbsp; virtual ~Resource() {}<br>
<br>
protected: // コンストラクタ経由の生成経路を隠蔽してMakeShared関数経由でしか生成できないようにする<br>
&nbsp;&nbsp;&nbsp; Resource(const std::string&amp; filePath = "", Type
type = Type::None) : m_FilePath{ filePath }, m_type{ type } {}<br>
public:<br>
&nbsp;&nbsp;&nbsp; //[protectedなコンストラクタでもstd::make_sharedで呼ぶテク]
https://gintenlabo.hatenablog.com/entry/20131211/1386771626<br>
&nbsp;&nbsp;&nbsp; template&lt;typename ResourceT&gt;<br>
&nbsp;&nbsp;&nbsp; struct ProtectedCall : public ResourceT<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; template&lt;class... ArgsT&gt; //
std::make_sharedはprotectedな継承クラスは呼べないのでそれを回避するテクニック<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; explicit
ProtectedCall(ArgsT&amp;&amp;... args)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; :
ResourceT(std::forward&lt;ArgsT&gt;(args)...) { }
//std::forwardで複数引数を完全転送で引き渡し
https://proc-cpuinfo.fixstars.com/2016/03/c-html/<br>
&nbsp;&nbsp;&nbsp; };<br>
<br>
&nbsp;&nbsp;&nbsp; //
コンストラクタをprotected:にしてあるのでこのMakeShared関数経由でしかResourceの新規生成はできないように縛ってある<br>
&nbsp;&nbsp;&nbsp; template&lt;typename ResourceT, typename... ArgsT&gt;<br>
&nbsp;&nbsp;&nbsp; static std::shared_ptr&lt;ResourceT&gt;
MakeShared(const std::string&amp; filePath = "", ArgsT... args)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (files.find(filePath) ==
files.end()) // 辞書に未登録のファイルの場合は<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
files[filePath] =
std::make_shared&lt;ProtectedCall&lt;ResourceT&gt;&gt;(filePath,
std::forward&lt;ArgsT&gt;(args)...); // 辞書へ登録<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return
std::dynamic_pointer_cast&lt;ResourceT&gt;(files[filePath]);
//[共有ポインタの派生先へのダウンキャスト]
https://cdecrement.blog.fc2.com/blog-entry-15.html<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; template&lt;typename ResourceT&gt; //
指定されたfilepathのデータをResourceT型の共有ポインタとして返す<br>
&nbsp;&nbsp;&nbsp; static std::shared_ptr&lt;ResourceT&gt; at(const
std::string&amp; filepath)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(files.count(filepath) &gt;
0 &amp;&amp; "指定されたファイル名のファイルは未生成です。MakeShared関数で生成してからアクセスしてください");<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return
std::dynamic_pointer_cast&lt;ResourceT&gt;(files.at(filepath));
//[共有ポインタの派生先へのダウンキャスト]
https://komorinfo.com/blog/cast-of-smart-pointers/ <br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; static size_t count(const std::string&amp; filepath)
{ return files.count(filepath); }<br>
<br>
&nbsp;&nbsp;&nbsp; virtual int Load(const std::string&amp; filePath =
"") = 0; //[ = 0 純粋仮想関数] ロード関数をoverrideして色んな種類のファイルのロードを実装する<br>
};<br>
<br>
struct Texture : public Resource<br>
{<br>
protected: //
ファクトリーパターンでコンストラクタ経由の生成経路をprotected隠蔽(ResourceクラスのMakeShared関数経由でしか新規生成は
できない)<br>
&nbsp;&nbsp;&nbsp; Texture(const std::string&amp; filePath = "", int
m_XNum = 1, int m_YNum = 1, int m_XSize = 1, int m_YSize = 1)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : Resource(filePath,
Type::Texture), m_XNum{ m_XNum }, m_YNum{ m_YNum }, m_XSize{ m_XSize },
m_YSize{ m_YSize } {}<br>
public:<br>
&nbsp;&nbsp;&nbsp; int m_XNum = 1, m_YNum = 1, m_XSize = 1, m_YSize =
1; // XNum,YNumはx,y方向の分割画像の数 XSize,YSizeは画像の横&times;縦のサイズ(pixel数)<br>
<br>
&nbsp;&nbsp;&nbsp; inline int operator[](std::size_t index) const {
//constは変更できないから添え字[]の 読み取り専用処理<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return m_handles[index]; //
読み取り専用(returnの型が &amp;参照ついてないので書き換え不可能)<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // すでにロードしてあるハンドルをDeleteGraphで破棄する<br>
&nbsp;&nbsp;&nbsp; virtual ~Texture() { DeleteGraph(); }<br>
<br>
&nbsp;&nbsp;&nbsp; virtual int DeleteGraph() //
すでにロードしてあるハンドルをDxLib::DeleteGraphで破棄する<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int result = 0;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int handle : m_handles)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; result =
(result == -1) ? -1 : DxLib::DeleteGraph(handle); // 一つでもDeleteに失敗したら-1<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
std::vector&lt;int&gt;().swap(m_handles); // ハンドルの配列を完全に消去<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return result;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; virtual int Load(const std::string&amp; filePath =
"") override<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (filePath == "" &amp;&amp;
m_FilePath == "") return -1;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (files.count(filePath)
&gt; 0 &amp;&amp; m_handles.size() &gt; 0) return
files[filePath]-&gt;m_handles[0]; // すでに辞書にロード済みハンドルがあった<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (filePath != ""
&amp;&amp; m_FilePath == "") m_FilePath = filePath; // 読み出しファイルパスを記録<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (m_XNum &gt; 1 || m_YNum &gt;
1) return LoadDivGraph(m_FilePath, m_XNum, m_YNum, m_XSize, m_YSize);
// 分割画像としてロード<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int loadHandle =
DxLib::LoadGraph(m_FilePath.c_str()); // ファイルをロードする<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(loadHandle != -1); //
画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (loadHandle == -1) return -1;
// ロード失敗<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
m_handles.emplace_back(loadHandle); // ロード成功ならハンドル番号を記録<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
[std::shared_ptrへthis&darr;ポインタをつかうためには]
https://cpprefjp.github.io/reference/memory/enable_shared_from_this.html<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; files.emplace(m_FilePath,
shared_from_this()); // 辞書へ登録<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::GetGraphSize(loadHandle,
&amp;m_XSize, &amp;m_YSize); // 横XSize&times;縦YSizeを得る<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return loadHandle;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; virtual int LoadDivGraph(const std::string&amp;
filePath = "", int XNum = -1, int YNum = -1, int XSize = -1, int YSize
= -1)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (files.count(filePath) &gt; 0
&amp;&amp; m_handles.size() &gt; 0) return
files[filePath]-&gt;m_handles[0]; // すでに辞書にロード済みのファイルのとき<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (filePath == "") return -1;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (filePath == "" &amp;&amp;
m_FilePath == "") return -1;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (filePath != ""
&amp;&amp; m_FilePath == "") m_FilePath = filePath; // 読み出しファイルパスを記録<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (XNum &gt; 0) m_XNum = XNum;
// 数値を設定<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (YNum &gt; 0) m_YNum = YNum;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (XSize &gt; 0) m_XSize = XSize;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (YSize &gt; 0) m_YSize = YSize;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_handles.resize(m_XNum *
m_YNum); // XNum&times;YNum個ぶんの配列を事前確保しておく<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int result =
DxLib::LoadDivGraph(m_FilePath.c_str(), m_XNum * m_YNum, m_XNum,
m_YNum, m_XSize, m_YSize, m_handles.data());<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(result != -1); //
画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int handle : m_handles)
assert(handle != -1); // 画像読込失敗、たてやよこのサイズの指定がおかしいのかも<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
[std::shared_ptrへthis&darr;ポインタをつかうためには]
https://cpprefjp.github.io/reference/memory/enable_shared_from_this.html<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; files.emplace(m_FilePath,
shared_from_this()); // 辞書へ登録<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return m_handles[0]; //
とりあえずは先頭配列を返す<br>
&nbsp;&nbsp;&nbsp; }<br>
};<br>
<br>
#endif<br>
</p>
<a id="mozTocId0010" class="mozTocH1"><br>
</a>
<p><code><a id="mozTocId0010" class="mozTocH1"></a>DataMV1.hを新規作成</code>し
てResourceクラスを継承して3Dモデルのロードやアニメをアタッチ
して管理する
機能を追加する。</p>
<p class="source">#ifndef
DATAMV1_H_<br>
#define DATAMV1_H_<br>
<br>
#include "DxLib.h"<br>
<br>
#include "Resource.h"<br>
<br>
#include &lt;unordered_map&gt; // 高速辞書配列<br>
<br>
struct DataMV1 : public Resource<br>
{<br>
protected: //
ファクトリーパターンでコンストラクタ経由の生成経路をprotected隠蔽(ResourceクラスのMakeShared関数経由でしか新規生成は
できない)<br>
&nbsp;&nbsp;&nbsp; DataMV1(std::string filePath = "")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Resource(filePath,
Type::MV1) {}<br>
public:<br>
&nbsp;&nbsp;&nbsp; int m_DefalutAnimNum = -1; // 3Dモデル内のデフォルトのアニメの数<br>
&nbsp;&nbsp;&nbsp; int m_AttachAnimNum = 0; //
この3Dモデルにアタッチされたアニメの数(デフォルトのアニメに加えて追加アタッチされたアニメの数も含む)<br>
<br>
&nbsp;&nbsp;&nbsp; struct AnimInfo // アニメに関する情報<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int index = -1; //
アニメのインデックス番号<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float endTime = 0.0f; //
アニメの終了時刻(総再生時間):超えるとループかストップさせる<br>
&nbsp;&nbsp;&nbsp; };<br>
&nbsp;&nbsp;&nbsp; std::unordered_map&lt;std::string, AnimInfo&gt;
m_AnimInfo; // 「ファイルパス + ":" + アニメ名」 から アニメの情報への辞書<br>
<br>
&nbsp;&nbsp;&nbsp; // ["devil@fly.fbx:Take 00"]のように m_FilePath + ":" +
animName の形式にして<br>
&nbsp;&nbsp;&nbsp; //&nbsp; ファイル1とファイル2で両方"Take
00"というアニメ名を使っていたときに辞書がかぶっちゃうことを予防する必要がある<br>
&nbsp;&nbsp;&nbsp; AnimInfo&amp; operator [] (const std::string&amp;
animPathName)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
m_AnimInfo.at(animPathName);<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; size_t count(const std::string&amp; animPathName) {
return m_AnimInfo.count(animPathName); }<br>
<br>
&nbsp;&nbsp;&nbsp; bool isInitialized = false;
//[継承2重ロード対策]ロード済みになったらtrueに falseのときにLoadするとリロード<br>
<br>
&nbsp;&nbsp;&nbsp; virtual ~DataMV1()<br>
&nbsp;&nbsp;&nbsp; {// 仮想デストラクタ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear();// データのお掃除<br>
&nbsp;&nbsp;&nbsp; };<br>
<br>
&nbsp;&nbsp;&nbsp; virtual int DeleteModels() //
すでにロードしてあるハンドルをDxLib::MV1DeleteModelで破棄する<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int result = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int handle : m_handles)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
result = (result == -1) ? -1 : DxLib::MV1DeleteModel(handle); //
一つでもDeleteに失敗したら-1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
std::vector&lt;int&gt;().swap(m_handles); // ハンドルの配列を完全に消去<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
std::unordered_map&lt;std::string, AnimInfo&gt;().swap(m_AnimInfo); //
アニメの辞書をクリア<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // データをクリアしてメモリを節約する<br>
&nbsp;&nbsp;&nbsp; virtual void clear()<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteModels(); //
すでにロードしてあるハンドルをDxLib::MV1DeleteModelで破棄する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = false;
//ロード済みフラグをOFF<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // ３Ｄアニメのアタッチ、DXライブラリの機能をラッピング<br>
&nbsp;&nbsp;&nbsp; //
https://dxlib.xsrv.jp/function/dxfunc_3d_model_1.html#R4N1<br>
&nbsp;&nbsp;&nbsp; virtual void AttachAnim(DataMV1&amp; otherMV1Anim)<br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // モデルに含まれるアニメーションの数を取得する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int Num = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_handles[0] ==
otherMV1Anim.m_handles[0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Num
= m_AttachAnimNum = DxLib::MV1GetAnimNum(m_handles[0]); // 3Dモデル内のアニメ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //
追加の別mv1ファイルのアニメのアタッチのとき&darr;は Num = 追加側のアニメ数, m_AttachAnimNum = Num +
m_AttachAnimNumを格納<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m_AttachAnimNum += (Num =
DxLib::MV1GetAnimNum(otherMV1Anim.m_handles[0])); //
アニメの追加アタッチ数だけ総アニメ数を加算 <br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; Num;
i++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
アニメの数ぶん順番にアタッチを設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const char* animName = DxLib::MV1GetAnimName(otherMV1Anim.m_handles[0],
i); // アニメーション名を取得<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
animSrcHandle = (m_handles[0] == otherMV1Anim.m_handles[0]) ? -1 :
otherMV1Anim.m_handles[0]; // 3Dモデル内アニメ(-1) or 追加アタッチアニメ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
attachedIndex = m_AnimInfo[otherMV1Anim.m_FilePath + ":" +
animName].index = DxLib::MV1AttachAnim(m_handles[0], i, animSrcHandle,
FALSE); // アタッチとその番号を辞書に登録<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//アニメ総時間の取得と登録<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(attachedIndex != -1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m_AnimInfo[otherMV1Anim.m_FilePath
+
":"
+
animName].endTime =
DxLib::MV1GetAttachAnimTotalTime(m_handles[0], attachedIndex);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m_AnimInfo[otherMV1Anim.m_FilePath
+
":"
+
animName].endTime = 0.0f;
//アニメアタッチ失敗時はアニメ進行を0.0に<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // ファイルの読み込み<br>
&nbsp;&nbsp;&nbsp; virtual int Load(const std::string&amp; filePath =
"") override<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (filePath == ""
&amp;&amp; m_FilePath == "") return -1; //ファイル名がない<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
(files.count(filePath) &gt; 0 &amp;&amp; isInitialized) return 0; //
すでに辞書にロード済みファイルがあった<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (filePath != ""
&amp;&amp; m_FilePath == "") m_FilePath = filePath; // 読み出しファイルパスを記録<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear(); //データを一旦クリア<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int loadHandle =
DxLib::MV1LoadModel(m_FilePath.c_str()); // 3Dモデルモデル読込み<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (loadHandle == -1)
assert("3Dモデルファイル見つからず読込み失敗！" == "");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (loadHandle == -1) return
-1; // ロード失敗<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m_handles.emplace_back(loadHandle); // ロード成功ならハンドル番号を記録<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
[std::shared_ptrへthis&darr;ポインタをつかうためには]
https://cpprefjp.github.io/reference/memory/enable_shared_from_this.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; files.emplace(m_FilePath,
shared_from_this()); // 辞書へ登録<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_DefalutAnimNum =
DxLib::MV1GetAnimNum(m_handles[0]); // 3Dモデル内にデフォルトでついていたアニメの数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int index = 0; index
&lt; m_DefalutAnimNum; ++index)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
アニメの数ぶん順番にアタッチを設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const char* animName = DxLib::MV1GetAnimName(m_handles[0], index); //
アニメーション名を取得<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
アニメ名からアニメのインデックス番号を得るために辞書に登録しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
アニメのアタッチする前の大元のファイルパス + アニメ名"例.Take 00"など を組み合わせないと<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
ファイル1とファイル2で両方"Take 00"というアニメ名を使っていたときに辞書がかぶっちゃって唯一性が保てない<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m_AnimInfo[m_FilePath + ":" + animName].index =
DxLib::MV1AttachAnim(m_handles[0], index); // アニメをアタッチして、その番号を辞書に登録<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
アニメをループさせるためにアニメの総再生時間を辞書に記録しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m_AnimInfo[m_FilePath + ":" + animName].endTime =
DxLib::MV1GetAttachAnimTotalTime(m_handles[0], index);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
++m_AttachAnimNum; // アニメの数を +1 カウントする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = true;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>
&nbsp;&nbsp;&nbsp; }<br>
};<br>
<br>
#endif<br>
</p>
<br>
devilのデータをMV1形式に変換するにあたって、Blenderを通してリグ付けをしたいのだが、<br>
Blenderで読み込めないバージョンのFBXとして書き出されたFBXモデル(devil)を、一旦UnityのFBXエクスポータで保存しなおして<br>
FBXの保存バージョンを変えてしまうことでBlenderで読み込めるようにします。<br>
<p><img src="image/mv1_from_unity_fbx_exporter1.png" alt="" style=""><br>
</p>
<p><br>
UnityにFBXエクスポーターをインストールすると、<br>
変換したいモデルをアセットのフォルダから選択した状態で[GameObject]&rarr;[Export To
FBX]ができるようになっているので<br>
クリックして出てきたウィンドウの[Export]ボタンをクリックします<br>
</p>
<p><img src="image/mv1_from_unity_fbx_exporter2.png" alt="" style=""><br>
</p>
<p><br>
デフォルトの保存先はUnityのアセットフォルダと違って<br>
/ユーザー の /My projectフォルダ の中の /Assetsフォルダ の中<br>
になっていて混乱しやすいのでUnityウィンドウの左下に表示された Successfully exported: C:○○○ ～
を注意深く見て、<br>
エクスポータから出力されたファイルの保存先をたどって、出力されたFBXファイルをDXのImageフォルダにコピーしておきます<br>
</p>
<p><img src="image/mv1_from_unity_fbx_exporter3.png" alt="" style=""><br>
</p>
<p><br>
</p>
<p>mixamoのサイトにアクセスして、<br>
<a
 href="https://www.adobe.com/products/substance3d/plugins/mixamo-in-blender.html">https://www.adobe.com/products/substance3d/plugins/mixamo-in-blender.html</a>
<br>
Blender上でmixamoに対応したリグを3Dモデルに自動で入れてくれる「Mixamo Blender
add-on」をダウンロードしておいてから、<br>
Blenderを開いて、[編集]&rarr;[プリファレンス]から[アドオン]を開いて[インストール]ボタンを押して、mixamoのサイトからダ
ウンロードしたファイルを開きます。<br>
</p>
<p><img src="image/mv1_from_unity_fbx_exporter4.png" alt="" style=""><br>
</p>
<p><br>
[アドオンをインストール]すると[プリファレンス]から[アドオン]でMixamo Rigで検索すると<br>
(Blenderのバージョンが3.0台であれば)「アニメーション:Mixamo Rig」にチェックが入れられるようになっています。<br>
</p>
<p><img src="image/mv1_from_unity_fbx_exporter5.png" alt="" style=""><br>
</p>
<p><br>
[ファイル]から[インポート]で[FBX(.fbx)]からUnityのFBXエクスポータから書き出したdevilのFBXモデルを読み込んでから、<br>
画面の右上のXYZ軸の横にある「 &lt; 」をクリックするとMixamoのタブを出すことができます。<br>
</p>
<p><img src="image/mv1_from_unity_fbx_exporter6.png" alt="" style=""><br>
</p>
<p><br>
Mixamoのadd-onを使うと[Create Control
Rig]を押せば自動でMixamo向けに対応したアニメのモーション用のリグを3Dモデルに埋め込んでくれます。<br>
</p>
<p><img src="image/mv1_from_unity_fbx_exporter7.png" alt="" style=""><br>
</p>
<p><br>
Mixamo向けのリグを埋め込んでから[ファイル]&rarr;[エクスポート]&rarr;[FBX(.fbx)]から「Mixamo対応リグの入っ
たFBXモデル」を保存書き出しします。<br>
</p>
<p><img src="image/mv1_from_unity_fbx_exporter8.png" alt="" style=""><br>
</p>
<p><br>
保存するファイル名は他のファイルとごっちゃになって混乱しないように「devil@mixamo_addon.fbx」など区別しやすい名前を付けて保
存しておきます。<br>
</p>
<p><img src="image/mv1_from_unity_fbx_exporter9.png" alt="" style=""><br>
</p>
<p><br>
</p>
<p>mixamoのモーションをいれるサイトにアクセスして<br>
<a href="https://www.mixamo.com/#/?page=1&amp;type=Motion%2CMotionPack">https://www.mixamo.com/#/?page=1&amp;type=Motion%2CMotionPack</a>
<br>
右端の[UPLOAD
CHARACTER]ボタンを押して出てきたウィンドウに先ほど書き出した「devil@mixamo_addon.fbx」ファイルをドラッ
グ&amp;ドロップします。<br>
</p>
<p><img src="image/mv1_from_unity_fbx_exporter10.png" alt="" style=""><br>
</p>
<p><br>
Mixamo対応リグが入ったFBXモデルならばアップロードが成功してキャラクターが動いている画面が出てくるので[NEXT]を押します。<br>
</p>
<p><img src="image/mv1_from_unity_fbx_exporter11.png" alt="" style=""><br>
</p>
<p><br>
左側から好きなモーションを選択して、[DOWNLOAD]ボタンを押すと好きなモーションを付けたキャラをダウンロードできるようになります。<br>
</p>
<p><img src="image/mv1_from_unity_fbx_exporter12.png" alt="" style=""><br>
</p>
<p><br>
Format(ダウンロードするFBXのフォーマット)やSkin(3Dポリゴンの表面データも付属したデータか)などを設定して[DOWNLOAD]ボ
タンでダウンロードします。<br>
</p>
<p><img src="image/mv1_from_unity_fbx_exporter13.png" alt="" style=""><br>
</p>
<p><br>
どのモーションを付けたかわかりやすいようにdevil@kick.fbxなどのファイル名に変えてから、DXのImageフォルダへコピーします。<br>
</p>
<p><img src="image/mv1_from_unity_fbx_exporter14.png" alt="" style=""><br>
</p>
<p><br>
DXのモデルビューワーから[ファイル]&rarr;[開く]で「devil@kick.fbx」を読み込んで、<br>
[アニメーション]でmixamo.comのアニメがついていることを確認したら、<br>
[ファイル]&rarr;[名前を付けて保存]から「devil@kick.mv1」というファイル名でMV1形式の3Dモデルを変換書き出しします。<br>
</p>
<p><img src="image/mv1_from_unity_fbx_exporter15.png" alt="" style=""><br>
</p>
<p><br>
複数のモーションの切替を試すためにキックのモーションだけでなく、ジャンプなどのモーションも「devil@jump.mv1」としてDXのImage
フォルダに書き出しておきます。<br>
</p>
<p><img src="image/mv1_from_unity_fbx_exporter16.png" alt="" style=""><br>
</p>
書き出したMV1形式の3Dモデルをプログラム上で切り替えられるようにしてキーボードの「0」キーと「1」キーで切り替えられるようにしていきましょ
う。<br>
<br>
<p><code>main.cpp</code>のコードにMV1形式のファイルを複数ロードしてキーボードの 0 1
などの数字キーでアニメを切替えできる機能を追加する。</p>
<p class="source">#include "DxLib.h"<br>
#include &lt;assert.h&gt; // 画像読み込みの読込み失敗表示用<br>
#include "Input.h"<br>
#include "Screen.h"<br>
#include "Ply.h"<br>
<em>#include "DataMV1.h"</em><br>
<br>
#include "Editor.h"<br>
<br>
//
設定画面の【リンカー】&rarr;【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMain
からプログラムが開始する<br>
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR
lpCmdLine, int nCmdShow)<br>
{<br>
&nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
&nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); //
画面サイズWidth&times;Heightのカラービット数32ビットで起動<br>
&nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);//
ウィンドウサイズWidth&times;Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
&nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
&nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
&nbsp;&nbsp;&nbsp;
SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間
違ってるかも<br>
<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
&nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
&nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
&nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; // ゲームのwhileループを開始する前の初期化処理<u><br>
&nbsp;&nbsp;&nbsp; int devil3DModel
=
DxLib::MV1LoadModel("Image/devil@fly.mv1"); // 3Dモデルをmv1形式で読込み<br>
<br>
&nbsp;&nbsp;&nbsp; float animTime =
0.0f; // アニメの現在時刻
&nbsp;&nbsp;&nbsp; float animSpeed =
2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
&nbsp;&nbsp;&nbsp; float animStepTime
= 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
&nbsp;&nbsp;&nbsp; int DefalutAnimNum
=
DxLib::MV1GetAnimNum(devil3DModel); // 3Dモデル内のアニメの数<br>
&nbsp;&nbsp;&nbsp;
std::unordered_map&lt;std::string, int&gt;
animNameToIndex; // アニメ名からアニメのインデックス番号への辞書<br>
&nbsp;&nbsp;&nbsp;
std::unordered_map&lt;std::string, float&gt;
animNameToTotalTime; // アニメ名からアニメの総再生時間への辞書<br>
&nbsp;&nbsp;&nbsp; for (int index =
0; index &lt; DefalutAnimNum;
++index)<br>
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
アニメの数ぶん順番にアタッチを設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
char* animName =
DxLib::MV1GetAnimName(devil3DModel, index); // アニメーション名を取得<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
アニメ名からインデックス番号を得るために辞書に登録しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
animNameToIndex[animName] =
DxLib::MV1AttachAnim(devil3DModel, index); //
アニメをアタッチして、その番号を辞書に登録<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
animNameToTotalTime[animName] =
DxLib::MV1GetAttachAnimTotalTime(devil3DModel, index); //
アニメをループさせるためにアニメの総再生時間を辞書に記録しておく<br>
&nbsp;&nbsp;&nbsp; }</u><br>
&nbsp;&nbsp;&nbsp; <em>float animTime = 0.0f; // アニメの現在時刻<br>
&nbsp;&nbsp;&nbsp; float animSpeed = 2.0f; // MV1のアニメの再生速度設定 2.0fなら2倍速<br>
&nbsp;&nbsp;&nbsp; float animStepTime = 1.0f; // MV1のアニメの毎時間の進む時間の設定<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilData =
Resource::MakeShared&lt;DataMV1&gt;("Image/devil@kick.mv1");<br>
&nbsp;&nbsp;&nbsp; pDevilData-&gt;Load(); // 3Dモデルをmv1形式で読込み<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DataMV1&gt; pDevilAttackAnimData
= Resource::MakeShared&lt;DataMV1&gt;("Image/devil@jump.mv1");<br>
&nbsp;&nbsp;&nbsp; pDevilAttackAnimData-&gt;Load(); //
3Dの追加アニメデータをmv1形式で読込み<br>
&nbsp;&nbsp;&nbsp; pDevilData-&gt;AttachAnim(*pDevilAttackAnimData); //
アニメを追加でflyのほうをベースとしたモデルにアタッチ<br>
&nbsp;&nbsp;&nbsp; int <span style="font-weight: bold;">animeButton</span>
= 0; // ボタンでアニメを切り替えられるようにする</em><br>
<br>
<u>&nbsp;&nbsp;&nbsp; int texImage = -1;<br>
&nbsp;&nbsp;&nbsp; texImage = LoadGraph("Image/dice.png");<br>
&nbsp;&nbsp;&nbsp; assert(texImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
&nbsp;&nbsp;&nbsp; float imgWidth, imgHeight;<br>
&nbsp;&nbsp;&nbsp; GetGraphSizeF(texImage, &amp;imgWidth,
&amp;imgHeight); // テクスチャ画像のサイズを得る&nbsp;</u>
<br>
&nbsp;&nbsp;&nbsp; <em>std::shared_ptr&lt;Texture&gt; pTexImage =
Resource::MakeShared&lt;Texture&gt;("Image/dice.png");<br>
&nbsp;&nbsp;&nbsp; pTexImage-&gt;Load(); //
MakeSharedとLoadを分けた(フォルダだけ設定しておいて、あとからロードもできるように)<br>
&nbsp;&nbsp;&nbsp; assert((int)*pTexImage != -1); //
画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
<br>
<br>
&nbsp;&nbsp;&nbsp; Ply::Data Data; // .plyのデータのクラス<br>
&nbsp;&nbsp;&nbsp; Ply::load("Image/dice.ply",
Data); // .plyデータをロード 軸を変えてdice1.plyや
dice2.plyなどいろいろ試してみよう<br>
<br>
&nbsp;&nbsp;&nbsp; size_t numIndex = 0; // インデックスの数<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;uint32_t&gt; Index; //
3Dモデルのポリゴンのインデックス配列<br>
&nbsp;&nbsp;&nbsp; std::vector&lt;VERTEX3D&gt; Vertex; //
3Dモデルのポリゴンの頂点配列<br>
<br>
&nbsp;&nbsp;&nbsp; auto vertex = Data["vertex"]; // 頂点へのアクセス<br>
&nbsp;&nbsp;&nbsp; assert(vertex-&gt;size() != 0 &amp;&amp;
"Plyデータの頂点サイズが0です。ファイルのパスは大丈夫ですか?");<br>
&nbsp;&nbsp;&nbsp; Vertex.resize(vertex-&gt;size()); // 配列の数の事前確保<br>
<br>
&nbsp;&nbsp;&nbsp; // [.plyの頂点のプロパティ情報]
https://jp.mathworks.com/help/vision/ug/the-ply-format.html<br>
&nbsp;&nbsp;&nbsp; const float* p_x =
vertex-&gt;properties["x"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_y =
vertex-&gt;properties["y"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_z =
vertex-&gt;properties["z"]-&gt;ptr&lt;float&gt;();<br>
&nbsp;&nbsp;&nbsp; const float* p_nx =
(vertex-&gt;properties.has_key("nx")) ?
vertex-&gt;properties["nx"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_ny =
(vertex-&gt;properties.has_key("ny")) ?
vertex-&gt;properties["ny"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const float* p_nz =
(vertex-&gt;properties.has_key("nz")) ?
vertex-&gt;properties["nz"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_norm = !(p_nx == nullptr || p_ny == nullptr
|| p_nz == nullptr);<br>
&nbsp;&nbsp;&nbsp; const float* p_s =
(vertex-&gt;properties.has_key("s")) ?
vertex-&gt;properties["s"]-&gt;ptr&lt;float&gt;() : nullptr; //
Blender書き出しでは(u,v)ではなく(s,t)として書き出されている<br>
&nbsp;&nbsp;&nbsp; const float* p_t =
(vertex-&gt;properties.has_key("t")) ?
vertex-&gt;properties["t"]-&gt;ptr&lt;float&gt;() : nullptr;<br>
<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_R =
(vertex-&gt;properties.has_key("red")) ?
vertex-&gt;properties["red"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("r")) ?
vertex-&gt;properties["r"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_G =
(vertex-&gt;properties.has_key("green"))
? vertex-&gt;properties["green"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("g")) ?
vertex-&gt;properties["g"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_B =
(vertex-&gt;properties.has_key("blue"))
? vertex-&gt;properties["blue"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("b")) ?
vertex-&gt;properties["b"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; const unsigned char* p_A =
(vertex-&gt;properties.has_key("alpha"))
? vertex-&gt;properties["alpha"]-&gt;ptr&lt;unsigned char&gt;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
(vertex-&gt;properties.has_key("a")) ?
vertex-&gt;properties["a"]-&gt;ptr&lt;unsigned char&gt;() : nullptr;<br>
&nbsp;&nbsp;&nbsp; bool has_color = !(p_R == nullptr || p_G == nullptr
|| p_B == nullptr || p_A == nullptr);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = Vertex.size(); i &lt;
iEnd; i += 1)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頂点のデータをセット 各ツールの系一覧
https://zenn.dev/it_ks/articles/cbe27860548ea1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], p_y[i], p_z[i]); // 右手系(裏面は時計回り)
https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].pos =
VGet(p_x[i], -p_y[i], p_z[i]); //
右手Y&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Vertex[i].norm =
(has_norm) ? VNorm(VGet(p_nx[i], -p_ny[i], p_nz[i])) : VGet(0.0f, 0.0f,
0.0f);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
右手Z&uarr;&rarr;左手Y&uarr;系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].pos =
VGet(-(p_y[i]),
p_z[i], p_x[i]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].norm = (has_norm)
? VNorm(VGet(-p_ny[i], p_nz[i], p_nx[i])) : VGet(0.0f, 0.0f,
0.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].dif = (has_color)
? GetColorU8(p_R[i], p_G[i], p_B[i], p_A[i]) : GetColorU8(255, 255,
255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].spc =
GetColorU8(255, 255, 255, 255);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].u = (p_s ==
nullptr) ? 0.0f : p_s[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].v = (p_t ==
nullptr) ? 0.0f : 1 - p_t[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].su = -1.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[i].sv = 0.0f;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; const auto&amp; face_index =
Data["face"]-&gt;properties["vertex_indices"];<br>
&nbsp;&nbsp;&nbsp; Index.resize(face_index-&gt;size() * 3);<br>
<br>
&nbsp;&nbsp;&nbsp; for (size_t i = 0, iEnd = face_index-&gt;size(),
nFace = 0; i &lt; iEnd; i += 3)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for (size_t j = 0; j &lt;
3; ++j) // 右手系(裏面は時計回り) https://yttm-work.jp/gmpg/gmpg_0014.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 2; j + 1
&gt; 0; --j) // 左手系(裏面は反時計回り)
http://www.ohshiro.tuis.ac.jp/~ohshiro/gamesoft/coordinate/index.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned int index = face_index-&gt;at&lt;unsigned int&gt;(i + j);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const size_t uvIndex = 2 * (i + j); // uとv 2つ * ( i + j )<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Index[i + j] = index;&nbsp;&nbsp; // 右手系(裏面は時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Index[i + 2 - j] = index; // 左手系(裏面は反時計回り)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
三角形の2辺のベクトルの外積から法線を計算(法線がないとライトの光の反射方向をシェーディングできないから)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(j == 0 &amp;&amp; !has_norm &amp;&amp;
Vertex[index].norm.x == 0.0f &amp;&amp; Vertex[index].norm.y == 0.0f
&amp;&amp; Vertex[index].norm.z == 0.0f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index0
=
Index[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index1
=
Index[i
+
1];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
unsigned
int
index2
=
Index[i
+
2];<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
外積 a&times;b cross_a_b を求める
https://examist.jp/mathematics/space-vector/vector-gaiseki/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
a
=
VSub(Vertex[index1].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
b
=
VSub(Vertex[index2].pos,
Vertex[index0].pos);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
左手系(表面は時計回り) 右手系と左手系では裏面の時計回りと反時計回りが変わる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
cross1_2
=
VCross(a,
b);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
右手系(表面は反時計回り)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
cross2_1
=
VCross(b,
a);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
単位ベクトル(ノルム)に直す [単位ベクトル]は&radic;(x*x + y*y + z*z) = 1となる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
VECTOR
norm1_2
=
VNorm(cross1_2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//const
VECTOR
norm2_1
=
VNorm(cross2_1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Vertex[index0].norm
=
norm1_2;
Vertex[index1].norm
=
norm1_2;
Vertex[index2].norm
=
norm1_2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//Vertex[index0].norm
=
norm2_1;
Vertex[index1].norm
=
norm2_1;
Vertex[index2].norm
=
norm2_1;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
++numIndex;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlXYZ; // 上下左右キーでxy位置を動かせるように<br>
&nbsp;&nbsp;&nbsp; keyControlXYZ.x = 0.0f; keyControlXYZ.y = 0.0f;
keyControlXYZ.z
= 0;<br>
&nbsp;&nbsp;&nbsp; VECTOR keyControlAngle = VGet(0.0f,0.0f,0.0f); // 回転<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen1 =
SubScreen::Create()-&gt;Set(600, 450, 600, 100, 255, 0,
"サブスクリーン1")-&gt;SetIsBarFrameShow(true,true);<br>
&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen2 =
SubScreen::Create()-&gt;Set(200, 100, 150, 100, 255, 1,
"サブスクリーン2\nバーを30で太めに")-&gt;SetFrame(1,GetColor(255,255,255),true,30);<br>
&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する 透明度を128にして半透明にしてみる<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen3 =
SubScreen::Create()-&gt;Set(150, 450, 300, 100, 128, 1,
"サブスクリーン3")-&gt;SetIsBarFrameShow(true)-&gt;SetBarColor(GetColor(0, 0,
255));<br>
&nbsp;&nbsp;&nbsp; // サブのスクリーンを生成する<br>
&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SubScreen&gt; subscreen4 =
SubScreen::Create()-&gt;Set(300, 100, 600, 100, 255, 1, "サブスクリーン4");<br>
<br>
&nbsp;&nbsp;&nbsp; // バックカリングするか?(裏面になっているポリゴンを書かない処理)<br>
&nbsp;&nbsp;&nbsp; DxLib::SetUseBackCulling(TRUE);<br>
<br>
&nbsp;&nbsp;&nbsp; Editor&amp; editor = Editor::GetInstance(); //
エディタのシングルトン参照を得る<br>
<br>
&nbsp;&nbsp;&nbsp; //奥行0.1～5000までをカメラの描画範囲とする<br>
&nbsp;&nbsp;&nbsp; DxLib::SetCameraNearFar(0.1f, 5000.0f);<br>
<br>
&nbsp;&nbsp;&nbsp; ScreenFlip();<br>
<br>
&nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
&nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
&nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは&times;ボタン押したときなど<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen();//
一旦キャンバスをきれいにまっさらに<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); //
マウスのドラッグなどを更新<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::UpdateScreens();
// スクリーンの位置やドラッグによる移動を更新する<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateKeyInput();
// エディタのキーのインプットを更新<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateMouseInput();
// エディタのマウスのインプットを更新<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.UpdateCamera(); //
エディタのカメラを更新<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// キーボードの 0 1
キーで3Dアニメを切り替えられるようにする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_0))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
animeButton = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(Input::GetButton(Pad::Keyboard, KEY_INPUT_1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
animeButton = 1;</em><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int PadInput =
GetJoypadInputState(DX_INPUT_KEY_PAD1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int speed = 5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上下左右キーでポリゴンを描く起点(x,y)を移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_LEFT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.x -=
speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_RIGHT) keyControlXYZ.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_UP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyControlXYZ.y
+= speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (PadInput &amp;
PAD_INPUT_DOWN) keyControlXYZ.y -= speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR position =
VGet(keyControlXYZ.x, keyControlXYZ.y, keyControlXYZ.z); // 3Dモデルの位置<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float width =&nbsp; <em>pTexImage-&gt;m_XSize</em>;
float
height
=&nbsp; <em>pTexImage-&gt;m_YSize</em>; // テクスチャ画像のサイズ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR scale = VGet(1.0f,
1.0f, 1.0f); // 拡大縮小スケール<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
キーボードのzキー(A)とxキー(B)とcキー(C)でx,y,z軸まわりに画像を回転<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_A) keyControlAngle.x += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_B) keyControlAngle.y += speed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PadInput &amp;
PAD_INPUT_C) keyControlAngle.z += speed;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float Deg2Rad =
DX_PI_F / 180.0f; // 角度(単位:&deg;度)からラジアン(単位:rad)へ変換する係数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const float xRotate =
keyControlAngle.x * Deg2Rad;&nbsp; const float
yRotate = keyControlAngle.y * Deg2Rad; const float zRotate =
keyControlAngle.z * Deg2Rad;<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX&nbsp;
matWorldDefault; // デフォルトのワールド行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::GetTransformToWorldMatrix(&amp;matWorldDefault); //
デフォルトのワールド行列を記憶しておく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[ワールド行列] https://ny-program.hatenablog.com/entry/2019/09/15/114245<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX mat; // モデルのスケール&times;回転&times;移動を行列計算で設定する<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[スケール]拡大縮小のスケール行列を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MGetScale(scale); // まずは拡大縮小のスケール行列からはじめる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
[勉強]&darr;スケール行列は 斜めに x , y , zのスケールの倍率がならんでいる行列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[0][0] = scale.x;&nbsp; mat.m[0][1] = 0.0f;&nbsp;&nbsp;&nbsp;
mat.m[0][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[0][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[1][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][1] = scale.y;
mat.m[1][2] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[1][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[2][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[2][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[2][2] = scale.z;&nbsp; mat.m[2][3] = 0.0f;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//mat.m[3][0] = 0.0f;&nbsp;&nbsp;&nbsp;&nbsp; mat.m[3][1] =
0.0f;&nbsp;&nbsp;&nbsp; mat.m[3][2] = 0.0f;&nbsp;&nbsp; &nbsp;
mat.m[3][3] = 1.0f;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[回転]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matRot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::CreateIdentityMatrix(&amp;matRot);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
★MMultは行列の乗算【乗算した順にz軸回転&rarr;x軸回転&rarr;y軸回転&rarr;平行移動】<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotZ(zRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotX(xRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
matRot = MMult(matRot, MGetRotY(yRotate));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matRot); //スケール &times; 回転<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//[移動]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATRIX matTrans = MGetTranslate(VGet(position.x, position.y,
position.z)); // 位置positionをここで設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat
= MMult(mat, matTrans); //スケール&times;回転&times;移動<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;mat); // [ワールド行列を指定]
https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4341<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawPolygon32bitIndexed3D(Vertex.data(),
Vertex.size(), Index.data(), numIndex / 3, <em>(int)*pTexImage</em>,
FALSE); //
三角形ポリゴンをたくさん描画<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::SetTransformToWorld(&amp;matWorldDefault); // デフォルトのワールド行列に戻しておく<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::MV1DrawModel(devil3DModel); // 3Dモデル(.mv1形式)を描く<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawFormatString(0<em></em><em></em>,
100,
GetColor(255,
255,
0),
"x:%f
y:%f
Angle:%f
%f %f", position.x, position.y, keyControlAngle.x,
keyControlAngle.y, keyControlAngle.z);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// ファイルのパス + ":" +
アニメ名でアクセス</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string <em><span
 style="font-weight: bold;">animPathName</span></em> = <em>(<span
 style="font-weight: bold;">animeButton </span>== 0) ?
"Image/devil@kick.mv1:mixamo.com" : "Image/devil@jump.mv1:mixamo.com";<br>
</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
assert(<em>pDevilData-&gt;count(<span style="font-weight: bold;">animPathName</span>)</em>
&gt; 0 &amp;&amp;
"指定されたアニメ名のアニメはMV1に付属していませんでした");<em><br>
</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animTime +=
animStepTime *
animSpeed; // 1.0&times;2倍 なら2倍速でアニメ時刻が進む<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animTime &gt;
(*pDevilData)[<em><span style="font-weight: bold;">animPathName</span></em>].endTime)<em><br>
</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
animTime = 0.0f; // 0秒目へとアニメをループさせる<em><br>
<br>
</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 再生時間をセットする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::MV1SetAttachAnimTime(<em>(int)*pDevilData, (*pDevilData)[<span
 style="font-weight: bold;">animPathName</span>].index</em>,
animTime);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
subscreen1-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawStart();
// このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "サブのスクリーンを使ってWindowsみたいな自作ウインドウを描画してみる",
GetColor(255, 255, 255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen1-&gt;DrawEnd();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
subscreen3-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawStart();
// このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
半透明のスクリーンも描ける<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawBox(0, 0, subscreen3-&gt;Width, subscreen3-&gt;Height,
GetColor(0, 255, 0), TRUE);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "アルファを設定すれば\n半透明スクリーンも可能", GetColor(255, 255,
255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen3-&gt;DrawEnd();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
subscreen4-&gt;ClearDrawScreen(); // 描く前に一旦キャンバスをきれいにまっさらに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawStart();
// このDrawStartとDrawEndのあいだにDraw～されたらサブのスクリーンに描かれるようになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //
サブの別のスクリーンの(0,0)位置を起点に文字列を描く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DxLib::DrawString(0, 0, "枠の無いスクリーンを使えば2Pの分割画面などにも応用できる", GetColor(255,
255, 255));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subscreen4-&gt;DrawEnd();<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubScreen::DrawScreens(); //
サブのスクリーンを全部描く<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editor.Draw(); //
エディタのDraw処理<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip();
//隠れて裏側で描いておいた画像を表面に入れ替え<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
&nbsp;&nbsp;&nbsp; WaitKey();<br>
&nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
&nbsp;&nbsp;&nbsp; DxLib_End();<br>
&nbsp;&nbsp;&nbsp; // ソフトの終了<br>
&nbsp;&nbsp;&nbsp; return 0;<br>
}</p>
<br>
いかがでしょう?キーボードのDAキーとEQキーでカメラ視点を左右や上下に移動できるようになりましたか?
<br>
<br>
<br>
<br>
<br>
</body>
</html>
