<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>[C++]ベクトルの練習</title>
    <link rel="stylesheet" href="style.css">
    <style>
      
    </style>
  </head>
  <body>
    <p class="title">[C++]ベクトルの練習</p>
    <br>
    <p>先にシューティングのページを参考にプロジェクトの初期設定↓とScreen.hの導入まではやっておいた前提で進めます <br>
      <a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/">https://yonezawashin.github.io/yonezawashin.github.io-2020c/</a><br>
    </p>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId0001">Vector2を使って簡単な直線を描いてみる</a></li>
      <li><a href="#mozTocId0002">operator +などを定義して、Vector2どうしの足し算などができるようにする</a></li>
      <li><a href="#mozTocId0003">Unityの定義に習って、zeroベクトルupベクトルなどの定義を追加</a></li>
      <li><a href="#mozTocId0004">数学グラフクラスを作成して数学っぽいマス目を引いたり画面上y方向プラス、画面中心(0,0)、 (x,y)が(3,9)のとき(30,90)など拡大した位置に描く</a></li>
      <li><a href="#mozTocId0005">数学クラスMyMathを作成して円と円の当たり判定をしてみる</a></li>
      <li><a href="#mozTocId0006">Vector2にベクトルの大きさを三平方の定理で計算するmagnitude関数を追加する</a></li>
      <li><a href="#mozTocId0007">Vector2に内積dotと外積cross関数を追加してMyMathクラスで円と線の当たり判 定をできるようにする</a></li>
      <li><a href="#mozTocId0008">MyMathクラスで円と線が当たったら線に沿って押し戻す処理ができるようにする</a></li>
      <li><a href="#mozTocId0009">MyMathクラスで線に垂直に下した点の影(射影)位置と線と点の最短距離を求める</a></li>
      <li><a href="#mozTocId0010">MyMathクラスで線と線が交差するか判定する</a></li>
      <li><a href="#mozTocId0011">MyMathクラスでレイ(光線)と線分(壁や床など)が交差するか判定する</a></li>
      <li><a href="#mozTocId0012">MyMathクラスでレイ(光線)と線分(壁や床など)の交点を求める</a></li>
      <li><a href="#mozTocId0013">MyMathクラスで線と線の交点を求める</a></li>
      <li><a href="#mozTocId0014">MyMathクラスで壁(線)に対する点の反射(線の終点の反射位置と交点)を求める</a></li>
      <li><a href="#mozTocId0015">MyMathクラスで壁(線)に対する円(半径r)の反射(円の中心点の反射位置と円の反射する瞬間の中心点)を求める</a></li>
      <li><a href="#mozTocId0016">MyMathクラスでレイ光線と円(半径r)の当たり判定と交点を求める</a></li>
      <li><a href="#mozTocId0017">Matrix3x3で点を行列で平行移動(translate)させる</a></li>
      <li><a href="#mozTocId0018">Matrix3x3で点を行列でスケール(拡大縮小)させる</a></li>
      <li><a href="#mozTocId0019">Matrix3x3で点を行列で回転(rotate:ローテーション)させる</a></li>
      <li><a href="#mozTocId0020">Matrix3x3で点を組み合わせ行列(transform行列)で回転、スケール、平行移動させる</a></li>
    </ol>
    <a id="mozTocId0001" class="mozTocH1">
      <h1>Vector2を使って簡単な直線などを描いてみる</h1>
      まずは2Dで(x,y)座標の2つのfloat型を保持する構造体Vector2を作成しましょう。<br>
      <p><code>Vector2.hの簡易版を新規作成</code>して以下のコードを実装します。</p>
      <p class="source">#ifndef VECTOR2_H_<br>
        #define VECTOR2_H_<br>
        <br>
        #include &lt;array&gt; //基本配列と同じ(有限個数)。生配列より便利な機能がある.size()関数とかstd::vector系関数が使える<br>
        #include &lt;limits&gt; // std::numeric_limitsで無限大などを使う https://cpprefjp.github.io/reference/limits/numeric_limits.html<br>
        #include &lt;cmath&gt; // std::の数学系関数に必要<br>
        <br>
        //【注意】std::vectorとは全く違う。数学で習う【ベクトル】です。ごっちゃにしないで。<br>
        <br>
        //★【UnityのVector演算コード】https://github.com/Unity-Technologies /UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector2.cs<br>
        //★【UnityのMath演算コード】https://github.com/Unity-Technologies /UnityCsReference/blob/master/Runtime/Export/Math/Mathf.cs<br>
        <br>
        <br>
        // 2変数x,yを持つ構造体。2つの数字をまとめて扱うならXY座標以外にも使えるよ。x,y別々に足したり引いたり面倒でしょう。 <br>
        struct Vector2<br>
        {<br>
        &nbsp;&nbsp; &nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float y;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }; //[匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 2&gt; xy; // float xy[2];と同じ意味 float 2個ぶんのデータサイズでx,y 2個ぶんと一致するので★unionで共用<br>
        &nbsp;&nbsp; &nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y分けて記述するの面倒なとき配列xy[2]をfor文i=0～2で回せる<br>
        <br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator float* () const { return (float*)this; }<br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(const float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator const float* () const { return (const float*)this; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;// 初期化コンストラクタ<br>
        &nbsp;&nbsp; &nbsp;Vector2(float x = 0.0f, float y = 0.0f) //初期化<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; this-&gt;xy = { x,y }; // たった1行で書ける<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;x = x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;y = y; 2行が上のxyzの様にたった1行で書けるようになる<br>
        &nbsp;&nbsp; &nbsp;}<br>
        };<br>
        <br>
        <br>
        #endif</p>
      <br>
      <br>
      <p><code>main.cppを作成</code>して以下のコードでVector2を使って直線や円を描いてみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 100,100 }; // (x,y) = (100,100)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 200,200 }; // (x,y) = (200,200)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 300,300 }; // (x,y) = (300,300)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 30; // 円の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255)); // 線分p1p2を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      どうでしょうか？線と円が表示されましたか？ <br>
      <br>
    </a><a id="mozTocId0002" class="mozTocH1">
      <h1>operator +などを定義して、Vector2どうしの足し算などができるようにする</h1>
      こんどはVector2どうしの足し算などができるように足し算オペレーターoperator +などを定義してみましょう。<br>
      <p><code>Vector2.h</code>に以下のoperator関連のコードを追加します。</p>
      <p class="source">#ifndef VECTOR2_H_<br>
        #define VECTOR2_H_<br>
        <br>
        #include &lt;array&gt; //基本配列と同じ(有限個数)。生配列より便利な機能がある.size()関数とかstd::vector系関数が使える<br>
        #include &lt;limits&gt; // std::numeric_limitsで無限大などを使う https://cpprefjp.github.io/reference/limits/numeric_limits.html<br>
        #include &lt;cmath&gt; // std::の数学系関数に必要<br>
        <br>
        <br>
        //【注意】std::vectorとは全く違う。数学で習う【ベクトル】です。ごっちゃにしないで。<br>
        <br>
        //★【UnityのVector演算コード】https://github.com/Unity-Technologies /UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector2.cs<br>
        //★【UnityのMath演算コード】https://github.com/Unity-Technologies /UnityCsReference/blob/master/Runtime/Export/Math/Mathf.cs<br>
        <br>
        <br>
        // 2変数x,yを持つ構造体。2つの数字をまとめて扱うならXY座標以外にも使えるよ。x,y別々に足したり引いたり面倒でしょう。 <br>
        struct Vector2<br>
        {<br>
        &nbsp;&nbsp; &nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float y;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }; //[匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 2&gt; xy; // float xy[2];と同じ意味 float 2個ぶんのデータサイズでx,y 2個ぶんと一致するので★unionで共用<br>
        &nbsp;&nbsp; &nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y分けて記述するの面倒なとき配列xy[2]をfor文i=0～2で回せる<br>
        <br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator float* () const { return (float*)this; }<br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(const float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator const float* () const { return (const float*)this; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;// 初期化コンストラクタ<br>
        &nbsp;&nbsp; &nbsp;Vector2(float x = 0.0f, float y = 0.0f) //初期化<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; this-&gt;xy = { x,y }; // たった1行で書ける<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;x = x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;y = y; 2行が上のxyzの様にたった1行で書けるようになる<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>/*-----　演算子オーバーロード　-----*/<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 逆ベクトル<br>
          &nbsp;&nbsp;&nbsp; inline Vector2 operator -() const<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ -this-&gt;x, -this-&gt;y };<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // Vectorをそのまま足し合わせる<br>
          &nbsp;&nbsp;&nbsp; inline Vector2 operator + () const<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; Vector2&amp; operator += (const Vector2 add_v2)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x += add_v2.x;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y += add_v2.y;<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this; //*thisを返すことで v1 + v2 + v3見たく数珠繋ぎできる<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; Vector2&amp; operator -= (const Vector2 minus_v2)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x -= minus_v2.x;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y -= minus_v2.y;<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; Vector2&amp; operator *= (float multiply_num)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x *= multiply_num;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y *= multiply_num;<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 0.fで割ったときは±無限大を返す<br>
          &nbsp;&nbsp;&nbsp; inline Vector2&amp; operator /= (float divide_num)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (divide_num == 0.0f) // 0で割ったら±無限大を返す<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *this = Vector2{ ((this-&gt;x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;((this-&gt;y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x /= divide_num;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y /= divide_num;<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 代入演算子 x,y,zを全部 change_numに変える<br>
          &nbsp;&nbsp;&nbsp; Vector2&amp; operator = (float change_num)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x = change_num;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y = change_num;<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 一致演算子 x,y,zを全部一致するか 一つでも違えばfalse<br>
          &nbsp;&nbsp;&nbsp; bool operator == (const Vector2&amp; v2_other)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;x != v2_other.x) return false;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;y != v2_other.y) return false;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 不一致演算子 一致演算子の逆<br>
          &nbsp;&nbsp;&nbsp; bool operator != (const Vector2&amp; v2_other)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return !(*this == v2_other);<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        };<br>
        <br>
        <br>
        <em>// Vector2どうしの足し算 割り算 掛け算 割り算などの 基本演算の グローバル定義<br>
          <br>
          // Vector同士の足し算 x,y個別に足し合わせる<br>
          inline Vector2 operator + (const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 + vec2のとき vec1の数値が書き変わったら嫌だからv3を新たに用意<br>
          &nbsp;&nbsp;&nbsp; v2.x = left.x + right.x; //[コレはダメ] left.x = left.x + right.x;<br>
          &nbsp;&nbsp;&nbsp; v2.y = left.y + right.y;<br>
          <br>
          &nbsp;&nbsp;&nbsp; return v2;<br>
          }<br>
          <br>
          // Vector同士の引き算 x,y個別に足し合わせる<br>
          inline Vector2 operator - (const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 - vec2のとき vec1の数値が書き変わったら嫌だからv2を新たに用意<br>
          &nbsp;&nbsp;&nbsp; v2.x = left.x - right.x; //[コレはダメ] left.x = left.x - right.x;<br>
          &nbsp;&nbsp;&nbsp; v2.y = left.y - right.y;<br>
          <br>
          &nbsp;&nbsp;&nbsp; return v2;<br>
          }<br>
          <br>
          // Vectorと数値の掛け算 x,y個別に掛け合わせる<br>
          inline Vector2 operator * (const Vector2&amp; left, float right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
          &nbsp;&nbsp;&nbsp; v2.x = left.x * right;<br>
          &nbsp;&nbsp;&nbsp; v2.y = left.y * right;<br>
          <br>
          &nbsp;&nbsp;&nbsp; return v2;<br>
          }<br>
          <br>
          <br>
          // 数値とVectorの掛け算 x,y個別に掛け合わせる<br>
          inline Vector2 operator * (float left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
          &nbsp;&nbsp;&nbsp; v2.x = left * right.x;<br>
          &nbsp;&nbsp;&nbsp; v2.y = left * right.y;<br>
          <br>
          &nbsp;&nbsp;&nbsp; return v2;<br>
          }<br>
          <br>
          // Vectorと数値の割り算 x,y,z個別に割り合わせる<br>
          // 0.fで割ると±無限大を返す<br>
          inline Vector2 operator / (const Vector2&amp; left, float right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; if (right == 0.0f) // 0で割ったら±無限大を返す<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ ((left.x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ((left.y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
          <br>
          &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
          &nbsp;&nbsp;&nbsp; v2.x = left.x / right;<br>
          &nbsp;&nbsp;&nbsp; v2.y = left.y / right;<br>
          <br>
          &nbsp;&nbsp;&nbsp; return v2;<br>
          }<br>
          <br>
          // 比較不等号 &lt; 演算子<br>
          inline bool operator &lt; (const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &lt; right.x;<br>
          &nbsp;&nbsp;&nbsp; return left.y &lt; right.y;<br>
          }<br>
          <br>
          // 比較不等号 &gt; 演算子<br>
          inline bool operator &gt; (const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &gt; right.x;<br>
          &nbsp;&nbsp;&nbsp; return left.y &gt; right.y;<br>
          }<br>
          <br>
          // 比較不等号 &lt;= 演算子<br>
          inline bool operator &lt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &gt; right);<br>
          }<br>
          <br>
          // 比較不等号 &gt;= 演算子<br>
          inline bool operator &gt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &lt; right);<br>
          }</em><br>
        <br>
        <br>
        #endif</p>
      <br>
      <br>
      <p><code>main.cpp</code>を変更してVector2どうしの足し算や引き算を使って線を描いてみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 100,100 }; // (x,y) = (100,100)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 200,200 }; // (x,y) = (200,200)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 300,300 }; // (x,y) = (300,300)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 30; // 円の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>DxLib::DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の<b>2倍</b>した線を描く</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine(p1.x, p1.y, <em>p1.x + v13.x, p1.y + v13.y</em>, GetColor(255, 255, 255)); // 線分p1<em>p3</em>を 描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょうか？ベクトルを足したり、引いたり、掛け算したりするとどうなるか理解できましたか？<br>
      ベクトルの 終点 - 始点 の計算をすると 始点→終点に向かう方向ベクトルとなり、<br>
      ベクトルの始点 + 方向ベクトル すると 終点に到着することが理解できたらOKです。<br>
      また、方向ベクトル×2 すると線の長さが2倍になっていることも直感的に理解できるとよいです。<br>
      <br>
      <br>
    </a><a id="mozTocId0003" class="mozTocH1">
      <h1>Unityの定義に習って、zeroベクトルupベクトルなどの定義を追加する</h1>
      UnityのVector2の定義は以下のサイトでコードが見れたりしますので参考にしてzeroやupなどをC#ではなくC++として定義してましょう。<br>
    </a><a href="https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector2.cs">https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector2.cs</a> <br>
    <p><code>Vector2.h</code>に以下のzeroベクトルupベクトルなどの定義のコードを追加します。</p>
    <p class="source">#ifndef VECTOR2_H_<br>
      #define VECTOR2_H_<br>
      <br>
      #include &lt;array&gt; //基本配列と同じ(有限個数)。生配列より便利な機能がある.size()関数とかstd::vector系関数が使える<br>
      #include &lt;limits&gt; // std::numeric_limitsで無限大などを使う https://cpprefjp.github.io/reference/limits/numeric_limits.html<br>
      #include &lt;cmath&gt; // std::の数学系関数に必要<br>
      <br>
      <br>
      //【注意】std::vectorとは全く違う。数学で習う【ベクトル】です。ごっちゃにしないで。<br>
      <br>
      //★【UnityのVector演算コード】https://github.com/Unity-Technologies /UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
      //★【UnityのMath演算コード】https://github.com/Unity-Technologies/UnityCsReference /blob/master/Runtime/Export/Math/Mathf.cs<br>
      <br>
      <br>
      // 2変数x,yを持つ構造体。2つの数字をまとめて扱うならXY座標以外にも使えるよ。x,y別々に足したり引いたり面倒でしょう。 <br>
      struct Vector2<br>
      {<br>
      &nbsp;&nbsp; &nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float y;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }; //[匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 2&gt; xy; // float xy[2];と同じ意味 float 2個ぶんのデータサイズでx,y 2個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp; &nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y分けて記述するの面倒なとき配列xy[2]をfor文i=0～2で回せる<br>
      <br>
      &nbsp;&nbsp; &nbsp;// float型のポインタへ(float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
      &nbsp;&nbsp; &nbsp;inline operator float* () const { return (float*)this; }<br>
      &nbsp;&nbsp; &nbsp;// float型のポインタへ(const float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
      &nbsp;&nbsp; &nbsp;inline operator const float* () const { return (const float*)this; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;Vector2(float x = 0.0f, float y = 0.0f) //初期化<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; this-&gt;xy = { x,y }; // たった1行で書ける<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;x = x;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;y = y; 2行が上のxyzの様にたった1行で書けるようになる<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 zero;// = { 0.f,&nbsp; 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 one; // = { 1.f,&nbsp; 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 up;&nbsp; // = { 0.f,&nbsp; 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 down;// = { 0.f, -1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 left; // = { -1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 right;// = { 1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; //[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 negativeInfinity;// = { -std::numeric_limits&lt;float&gt;::infinity(), .. };<br>
        &nbsp;&nbsp;&nbsp; //[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 positiveInfinity;// = { std::numeric_limits&lt;float&gt;::infinity(), .. };</em><br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; /*-----　演算子オーバーロード　-----*/<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 逆ベクトル<br>
      &nbsp;&nbsp;&nbsp; inline Vector2 operator -() const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ -this-&gt;x, -this-&gt;y };<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Vectorをそのまま足し合わせる<br>
      &nbsp;&nbsp;&nbsp; inline Vector2 operator + () const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; Vector2&amp; operator += (const Vector2 add_v2)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x += add_v2.x;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y += add_v2.y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this; //*thisを返すことで v1 + v2 + v3見たく数珠繋ぎできる<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; Vector2&amp; operator -= (const Vector2 minus_v2)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x -= minus_v2.x;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y -= minus_v2.y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; Vector2&amp; operator *= (float multiply_num)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x *= multiply_num;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y *= multiply_num;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 0.fで割ったときは±無限大を返す<br>
      &nbsp;&nbsp;&nbsp; inline Vector2&amp; operator /= (float divide_num)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (divide_num == 0.0f) // 0で割ったら±無限大を返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *this = Vector2{ ((this-&gt;x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;((this-&gt;y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x /= divide_num;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y /= divide_num;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 代入演算子 x,y,zを全部 change_numに変える<br>
      &nbsp;&nbsp;&nbsp; Vector2&amp; operator = (float change_num)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x = change_num;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y = change_num;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 一致演算子 x,y,zを全部一致するか 一つでも違えばfalse<br>
      &nbsp;&nbsp;&nbsp; bool operator == (const Vector2&amp; v2_other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;x != v2_other.x) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;y != v2_other.y) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 不一致演算子 一致演算子の逆<br>
      &nbsp;&nbsp;&nbsp; bool operator != (const Vector2&amp; v2_other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return !(*this == v2_other);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      <br>
      // Vector2どうしの足し算 割り算 掛け算 割り算などの 基本演算の グローバル定義<br>
      <br>
      // Vector同士の足し算 x,y個別に足し合わせる<br>
      inline Vector2 operator + (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 + vec2のとき vec1の数値が書き変わったら嫌だからv3を新たに用意<br>
      &nbsp;&nbsp;&nbsp; v2.x = left.x + right.x; //[コレはダメ] left.x = left.x + right.x;<br>
      &nbsp;&nbsp;&nbsp; v2.y = left.y + right.y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return v2;<br>
      }<br>
      <br>
      // Vector同士の引き算 x,y個別に足し合わせる<br>
      inline Vector2 operator - (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 - vec2のとき vec1の数値が書き変わったら嫌だからv2を新たに用意<br>
      &nbsp;&nbsp;&nbsp; v2.x = left.x - right.x; //[コレはダメ] left.x = left.x - right.x;<br>
      &nbsp;&nbsp;&nbsp; v2.y = left.y - right.y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return v2;<br>
      }<br>
      <br>
      // Vectorと数値の掛け算 x,y個別に掛け合わせる<br>
      inline Vector2 operator * (const Vector2&amp; left, float right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
      &nbsp;&nbsp;&nbsp; v2.x = left.x * right;<br>
      &nbsp;&nbsp;&nbsp; v2.y = left.y * right;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return v2;<br>
      }<br>
      <br>
      <br>
      // 数値とVectorの掛け算 x,y個別に掛け合わせる<br>
      inline Vector2 operator * (float left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
      &nbsp;&nbsp;&nbsp; v2.x = left * right.x;<br>
      &nbsp;&nbsp;&nbsp; v2.y = left * right.y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return v2;<br>
      }<br>
      <br>
      // Vectorと数値の割り算 x,y,z個別に割り合わせる<br>
      // 0.fで割ると±無限大を返す<br>
      inline Vector2 operator / (const Vector2&amp; left, float right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (right == 0.0f) // 0で割ったら±無限大を返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ ((left.x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ((left.y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
      <br>
      &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
      &nbsp;&nbsp;&nbsp; v2.x = left.x / right;<br>
      &nbsp;&nbsp;&nbsp; v2.y = left.y / right;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return v2;<br>
      }<br>
      <br>
      // 比較不等号 &lt; 演算子<br>
      inline bool operator &lt; (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &lt; right.x;<br>
      &nbsp;&nbsp;&nbsp; return left.y &lt; right.y;<br>
      }<br>
      <br>
      // 比較不等号 &gt; 演算子<br>
      inline bool operator &gt; (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &gt; right.x;<br>
      &nbsp;&nbsp;&nbsp; return left.y &gt; right.y;<br>
      }<br>
      <br>
      // 比較不等号 &lt;= 演算子<br>
      inline bool operator &lt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &gt; right);<br>
      }<br>
      <br>
      // 比較不等号 &gt;= 演算子<br>
      inline bool operator &gt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &lt; right);<br>
      }<br>
      <br>
      <br>
      #endif</p>
    <br>
    <p><code>Vector2.cppを新規作成して</code>以下のzeroベクトルやupベクトルなどの数値の初期化のコードを追加します (static定義した変数はcppでしか初期化できないので)。</p>
    <p class="source">#include "Vector2.h"<br>
      <br>
      // Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
      Vector2 const Vector2::zero = Vector2(0.f, 0.f);<br>
      Vector2 const Vector2::one = Vector2(1.f, 1.f);<br>
      Vector2 const Vector2::up = Vector2(0.f, 1.f);<br>
      Vector2 const Vector2::down = Vector2(0.f, -1.f);<br>
      Vector2 const Vector2::left = Vector2(-1.f, 0.f);<br>
      Vector2 const Vector2::right = Vector2(1.f, 0.f);<br>
      //[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
      Vector2 const Vector2::negativeInfinity = Vector2(-std::numeric_limits&lt;float&gt;::infinity(), -std::numeric_limits&lt;float&gt;::infinity());<br>
      //[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits /lowest.html<br>
      Vector2 const Vector2::positiveInfinity = Vector2(std::numeric_limits&lt;float&gt;::infinity(), std::numeric_limits&lt;float&gt;::infinity());<br>
      <br>
    </p>
    <br>
    <br>
    <p><code>main.cpp</code>を変更して上方向upベクトルを水色の線で描いてみます。 </p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Screen.h"<br>
      #include "Vector2.h"<br>
      <br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 100,100 }; // (x,y) = (100,100)の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 200,200 }; // (x,y) = (200,200)の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 300,300 }; // (x,y) = (300,300)の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 30; // 円の半径<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>DxLib::DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * 30, p1.y + Vector2::up.y * 30, GetColor(0, 255, 255)); // upベクトルを30倍した線を描く</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    いかがでしょうか？あれっ？上方向のupベクトルの描画したつもりが水色の線が下方向に出てしましました。<br>
    実は2Dのスクリーンに図形を描画する関数は左上が(x,y)=(0,0)でyの下方向がプラス方向となっていますが、3D空間はy上方向がプラスで逆になってい ます。<br>
    数学の教科書とかも基本的にはyが上方向がプラスなので非常にわかりにくくなっていますよね。<br>
    都度、yを描くときに - マイナスをつけてやればよいですが、今は数学のベクトルを勉強しているのでもうちょっと直感的に描画したいですよね。<br>
    次の項では数学っぽく画面の中心が原点(0,0)で、y上方向がプラスになるように描くクラスを実装して見やすくしてベクトルを数学的に考えやすく描画できるよう にしてみましょう。<br>
    <br>
    <br>
    <a id="mozTocId0004" class="mozTocH1">
      <h1>数学グラフクラスを作成して数学っぽいマス目を引いたり、画面上y方向プラス、画面中心(0,0)、(x,y)が(3,9)のとき(30,90)など 拡大した位置に描く</h1>
      <code>MathGraph2D.hを新規作成して</code>数学っぽいマス目グリッドを描いたり、画面上方向がy方向プラスにしたり、<br>
      (x,y)が(3,9)のときに(30,90)など拡大した位置に描いて見やすくできるようにグラフのスケールを設定できるようにするクラスのコードを追加し ます。
      <p class="source">#ifndef MATHGRAPH_H_<br>
        #define MATHGRAPH_H_<br>
        <br>
        #include "DxLib.h"<br>
        #include "Vector2.h"<br>
        #include "Screen.h"<br>
        #include &lt;cmath&gt;<br>
        #include &lt;string&gt;<br>
        <br>
        // 数学のグラフを描く(DXで普通に描くと左上 0,0 で↓方向が+なので数学らしくないので)<br>
        class MathGraph2D<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;Vector2 pos; // グラフを描く起点(100,100なら左上から→に100,↓に100の位置がグラフの原点)<br>
        &nbsp;&nbsp; &nbsp;//Vector2 origin; // グラフ原点<br>
        &nbsp;&nbsp; &nbsp;float scale; // グラフのスケール(1/10 なら10ドットで1目盛りぶん)<br>
        &nbsp;&nbsp; &nbsp;Vector2 grid; // (10,10)なら10おきにグリッドを描く<br>
        &nbsp;&nbsp; &nbsp;MathGraph2D(Vector2 position, float scale = 5.0f, Vector2 grid = { 5.0f,5.0f })<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; : pos{ Vector2((int)position.x,(int)position.y)}, scale{scale}, grid{ Vector2((int)grid.x,(int)grid.y) }<br>
        &nbsp;&nbsp; &nbsp;{}<br>
        <br>
        &nbsp;&nbsp; &nbsp;virtual ~MathGraph2D(){};<br>
        <br>
        &nbsp;&nbsp; &nbsp;inline Vector2 graphPos(Vector2 mousePos) { return Vector2{ (mousePos.x - pos.x) / scale, (-mousePos.y + pos.y) / scale }; }<br>
        &nbsp;&nbsp; &nbsp;inline Vector2 graphPosInt(Vector2 mousePos) { return Vector2{ (float)((int)((mousePos.x - pos.x) / scale)), (float)((int)((-mousePos.y + pos.y) / scale)) }; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;int DrawString(float x, float y, const TCHAR* String, unsigned int Color, unsigned int EdgeColor DEFAULTPARAM(= 0))<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawString(pos.x + x * scale, pos.y - y * scale, String, Color, EdgeColor);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;int DrawLine(float x1, float y1, float x2, float y2, unsigned int Color, int Thickness DEFAULTPARAM(= 1))<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawLine(pos.x + x1 * scale, pos.y - y1 * scale, pos.x + x2 * scale, pos.y - y2 * scale, Color, Thickness);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp;&nbsp; int DrawTriangle(float x1, float y1, float x2, float y2, float x3, float y3, unsigned int Color, int FillFlag DEFAULTPARAM(= TRUE))<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return DxLib::DrawTriangle(pos.x + x1 * scale, pos.y - y1 * scale, <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos.x + x2 * scale, pos.y - y2 * scale, <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos.x + x3 * scale, pos.y - y3 * scale, Color, FillFlag);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;// 矢印→を線のかわりに描く<br>
        &nbsp;&nbsp; &nbsp;int DrawArrow(float x1, float y1, float w1, float h1, float x2, float y2, float w2, float h2, unsigned int Color, int Thickness DEFAULTPARAM(= 1))<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //[矢印の描きかた] https://ameblo.jp/tomi-omiya/entry-12641374677.html<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (w1 != 0.0f &amp;&amp; h1 != 0.0f)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float theta1 = -std::atan2(y1 - y2, x1 - x2), cos1 = std::cosf(theta1), sin1 = std::sinf(theta1);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float angle = theta1 / DX_PI * 180;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawTriangle(x1, y1, x1 - h1 * cos1 - w1 / 2 * sin1, y1 + h1 * sin1 - w1 / 2 * cos1,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; x1 - h1 * cos1 + w1 / 2 * sin1, y1 + h1 * sin1 + w1 / 2 * cos1, Color, TRUE);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (w2 != 0.0f &amp;&amp; h2 != 0.0f)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float theta2 = -std::atan2(y2 - y1, x2 - x1), cos2 = std::cosf(theta2), sin2 = std::sinf(theta2);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawTriangle(x2, y2, x2 - h2 * cos2 - w2 / 2 * sin2, y2 + h2 * sin2 - w2 / 2 * cos2,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x2 - h2 * cos2 + w2 / 2 * sin2, y2 + h2 * sin2 + w2 / 2 * cos2, Color, TRUE);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawLine(pos.x + x1 * scale, pos.y - y1 * scale, pos.x + x2 * scale, pos.y - y2 * scale, Color, Thickness);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;int DrawLineBox(float x1, float y1, float x2, float y2, unsigned int Color)<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawLineBox(pos.x + x1 * scale, pos.y - y1 * scale, pos.x + x2 * scale, pos.y - y2 * scale, Color);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;int DrawFillBox(float x1, float y1, float x2, float y2, unsigned int Color)<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawFillBox(pos.x + x1 * scale, pos.y - y1 * scale, pos.x + x2 * scale, pos.y - y2 * scale, Color);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;int&nbsp;&nbsp; &nbsp;DrawCircle(float x, float y, int r, unsigned int Color, int FillFlag DEFAULTPARAM(= TRUE), int LineThickness DEFAULTPARAM(= 1))<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawCircle(pos.x + x * scale, pos.y - y * scale, r * scale, Color, FillFlag, LineThickness);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;int&nbsp;&nbsp; &nbsp;DrawPoint(float x, float y, int r, unsigned int Color, int FillFlag DEFAULTPARAM(= TRUE), int LineThickness DEFAULTPARAM(= 1))<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawCircle(pos.x + x * scale, pos.y - y * scale, r, Color, FillFlag, LineThickness);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;// グラフの目盛りの縦横グリッドを描く<br>
        &nbsp;&nbsp; &nbsp;void DrawGrid(unsigned int Color, int Thickness DEFAULTPARAM(= 1))<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; float test = std::fmodf(pos.x, grid.x * scale);<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; for (int x = std::fmodf(pos.x, grid.x * scale); x &lt; Screen::Width; x += grid.x * scale)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine(x, 0, x, Screen::Height,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (x == (int)pos.x) ? GetColor(255,0,0) : // グラフの原点を通る線は色を変える<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((x-(int)pos.x) % (int)(grid.x * scale * 10) == 0) ? GetColor(255, 255, 255) : Color, // 10マスおきに色を変える<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Thickness);<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; for (int y = std::fmodf(pos.y, grid.y * scale); y &lt;= Screen::Height; y += grid.y * scale)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine(0, y, Screen::Width, y,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (y == (int)pos.y) ? GetColor(0, 0, 255) : // グラフの原点を通る線は色を変える<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ((y - (int)pos.y) % (int)(grid.y * scale * 10) == 0) ? GetColor(255, 255, 255) : Color, // 10マスおきに色を変える<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Thickness);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        };<br>
        <br>
        #endif</p>
      <br>
      <br>
      <br>
      <p><code>main.cpp</code>を変更して数学グラフクラスMathGraph2Dを通して円や線を描いてみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        <em>#include "MathGraph2D.h"</em><br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>// 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
          &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        </em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ <em>1,1</em> }; // (x,y) = <em>(1,1)</em>の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ <em>2,2</em> }; // (x,y) = <em>(2,2)</em>の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ <em>3,3</em> }; // (x,y) = <em>(3,3)</em>の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = <em>1</em>; // 円の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.</em>DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * <em>3</em>, p1.y + Vector2::up.y * <em>3</em>, GetColor(0, 255, 255)); // upベクトルを<em>3倍</em>した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.</em>DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.</em>DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.</em>DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょうか？これで水色のup上方向ベクトルも上向きになり、ベクトルの数字も(1,1)など手で計算しやすいスケール感に収めることができ、算数しや すくなったと思います。<br>
      <br>
      <br>
    </a><a id="mozTocId0005" class="mozTocH1">
      <h1>数学クラスMyMathを作成して円と円の当たり判定をしてみる</h1>
      <code>MyMath.hを新規作成して</code>πなどの定義や円と円の当たり判定の関数を定義します。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と円が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc1"&gt;円1の中心pc1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc2"&gt;円2の中心pc2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1, float radius1,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2, float radius2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((pc1.x - pc2.x) * (pc1.x - pc2.x) + (pc1.y - pc2.y) * (pc1.y - pc2.y))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt; ((radius1 + radius2) * (radius1 + radius2));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        #endif</p>
      <br>
      <code>MyMath.cppを新規作成して</code>πなどのstatic定義の初期値を設定します。<br>
      <p class="source">#include "MyMath.h"<br>
        <br>
        const float MyMath::Sqrt2 = 1.41421356237f;//(floatは有効桁は実質7桁まで正確だがそれ以降は環境によって誤差出るよ)<br>
        <br>
        const float MyMath::PI = 3.14159265359f; // 円周率<br>
        const float MyMath::Deg2Rad = PI / 180; // 度からラジアンに変換する定数<br>
        <br>
      </p>
      <br>
      <br>
      <br>
      <p><code>main.cpp</code>を変更して円と円の当たり判定を試してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        <em>#include "MyMath.h"</em><br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 1,1 }; // (x,y) = (1,1)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 2,2 }; // (x,y) = (2,2)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 3,3 }; // (x,y) = (3,3)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 1; // 円の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Vector2 pc1{ 6,5 }; // 円1の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r1 = 2; // 円1の半径<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2{ 10,9 }; // 円2の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r2 = 3; // 円1の半径</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 円1と円2が当たっているかの判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision12 = MyMath::CircleCircleIntersection(pc1, r1, pc2, r2);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc1.x, pc1.y, r1, (isCollision12) ? GetColor(255, 0, 0): GetColor(255, 255, 255), FALSE); // 円1を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc2.x, pc2.y, r2, (isCollision12) ? GetColor(255, 0, 0) : GetColor(255, 255, 255), FALSE); // 円2を描く</em><br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * 3, p1.y + Vector2::up.y * 3, GetColor(0, 255, 255)); // upベクトルを3倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      さて、円1と円2は触れていないので白色GetColor(255,255,255)で描かれているはずです。<br>
      こんどは円2の中心を{10,9}ではなく{8,9}に変えてみましょう。<br>
      <p><code>main.cpp</code>を変更して円2の中心を{10,9}ではなく{8,9}に変えます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 1,1 }; // (x,y) = (1,1)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 2,2 }; // (x,y) = (2,2)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 3,3 }; // (x,y) = (3,3)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 1; // 円の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1{ 6,5 }; // 円1の中心<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r1 = 2; // 円1の半径<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2{ <em>8</em>,9 }; // 円2の中心<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r2 = 3; // 円1の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円1と円2が当たっているかの判定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision12 = MyMath::CircleCircleIntersection(pc1, r1, pc2, r2);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc1.x, pc1.y, r1, (isCollision12) ? GetColor(255, 0, 0): GetColor(255, 255, 255), FALSE); // 円1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc2.x, pc2.y, r2, (isCollision12) ? GetColor(255, 0, 0) : GetColor(255, 255, 255), FALSE); // 円2を描く<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * 3, p1.y + Vector2::up.y * 3, GetColor(0, 255, 255)); // upベクトルを3倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      さて、こんどは円1と円2は触れいるので赤色GetColor(255,0,0)で描かれているはずです。<br>
      円と円の当たり判定をMyMathクラスで正しくできたことが確認できました。<br>
      <br>
      <br>
    </a><a id="mozTocId0006" class="mozTocH1">
      <h1>Vector2にベクトルの大きさを三平方の定理で計算するmagnitude関数を追加する</h1>
      <code>Vector2.h</code>に関数を追加で定義します。<br>
      <p class="source">#ifndef VECTOR2_H_<br>
        #define VECTOR2_H_<br>
        <br>
        #include &lt;array&gt; //基本配列と同じ(有限個数)。生配列より便利な機能がある.size()関数とかstd::vector系関数が使える<br>
        #include &lt;limits&gt; // std::numeric_limitsで無限大などを使う https://cpprefjp.github.io/reference/limits/numeric_limits.html<br>
        #include &lt;cmath&gt; // std::の数学系関数に必要<br>
        <br>
        <br>
        //【注意】std::vectorとは全く違う。数学で習う【ベクトル】です。ごっちゃにしないで。<br>
        <br>
        //★【UnityのVector演算コード】https://github.com/Unity-Technologies /UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
        //★【UnityのMath演算コード】https://github.com/Unity-Technologies /UnityCsReference /blob/master/Runtime/Export/Math/Mathf.cs<br>
        <br>
        <br>
        // 2変数x,yを持つ構造体。2つの数字をまとめて扱うならXY座標以外にも使えるよ。x,y別々に足したり引いたり面倒でしょう。 <br>
        struct Vector2<br>
        {<br>
        &nbsp;&nbsp; &nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float y;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }; //[匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 2&gt; xy; // float xy[2];と同じ意味 float 2個ぶんのデータサイズでx,y 2個ぶんと一致するので★unionで共用<br>
        &nbsp;&nbsp; &nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y分けて記述するの面倒なとき配列xy[2]をfor文i=0～2で回せる<br>
        <br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator float* () const { return (float*)this; }<br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(const float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator const float* () const { return (const float*)this; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;// 初期化コンストラクタ<br>
        &nbsp;&nbsp; &nbsp;Vector2(float x = 0.0f, float y = 0.0f) //初期化<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; this-&gt;xy = { x,y }; // たった1行で書ける<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;x = x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;y = y; 2行が上のxyzの様にたった1行で書けるようになる<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp;&nbsp; // Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 zero;// = { 0.f,&nbsp; 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 one; // = { 1.f,&nbsp; 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 up;&nbsp; // = { 0.f,&nbsp; 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 down;// = { 0.f, -1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 left; // = { -1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 right;// = { 1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; //[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 negativeInfinity;// = { -std::numeric_limits&lt;float&gt;::infinity(), .. };<br>
        &nbsp;&nbsp;&nbsp; //[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 positiveInfinity;// = { std::numeric_limits&lt;float&gt;::infinity(), .. };<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>// ベクトルの長さ(0から点(x,y,z)までの距離)<br>
          &nbsp;&nbsp;&nbsp; inline float magnitude() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return std::sqrt(x * x + y * y); // √(x*x + y*y)<br>
          &nbsp;&nbsp;&nbsp; };<br>
          <br>
          &nbsp;&nbsp;&nbsp; // ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)<br>
          &nbsp;&nbsp;&nbsp; inline float sqrMagnitude() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return x * x + y * y; // x*x + y*y <br>
          &nbsp;&nbsp;&nbsp; };</em><br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; /*-----　演算子オーバーロード　-----*/<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 逆ベクトル<br>
        &nbsp;&nbsp;&nbsp; inline Vector2 operator -() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ -this-&gt;x, -this-&gt;y };<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // Vectorをそのまま足し合わせる<br>
        &nbsp;&nbsp;&nbsp; inline Vector2 operator + () const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator += (const Vector2 add_v2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x += add_v2.x;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y += add_v2.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this; //*thisを返すことで v1 + v2 + v3見たく数珠繋ぎできる<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator -= (const Vector2 minus_v2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x -= minus_v2.x;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y -= minus_v2.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator *= (float multiply_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x *= multiply_num;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y *= multiply_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 0.fで割ったときは±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; inline Vector2&amp; operator /= (float divide_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (divide_num == 0.0f) // 0で割ったら±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *this = Vector2{ ((this-&gt;x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;((this-&gt;y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x /= divide_num;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y /= divide_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 代入演算子 x,y,zを全部 change_numに変える<br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator = (float change_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x = change_num;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y = change_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 一致演算子 x,y,zを全部一致するか 一つでも違えばfalse<br>
        &nbsp;&nbsp;&nbsp; bool operator == (const Vector2&amp; v2_other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;x != v2_other.x) return false;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;y != v2_other.y) return false;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 不一致演算子 一致演算子の逆<br>
        &nbsp;&nbsp;&nbsp; bool operator != (const Vector2&amp; v2_other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return !(*this == v2_other);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        <br>
        // Vector2どうしの足し算 割り算 掛け算 割り算などの 基本演算の グローバル定義<br>
        <br>
        // Vector同士の足し算 x,y個別に足し合わせる<br>
        inline Vector2 operator + (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 + vec2のとき vec1の数値が書き変わったら嫌だからv3を新たに用意<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x + right.x; //[コレはダメ] left.x = left.x + right.x;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y + right.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // Vector同士の引き算 x,y個別に足し合わせる<br>
        inline Vector2 operator - (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 - vec2のとき vec1の数値が書き変わったら嫌だからv2を新たに用意<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x - right.x; //[コレはダメ] left.x = left.x - right.x;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y - right.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // Vectorと数値の掛け算 x,y個別に掛け合わせる<br>
        inline Vector2 operator * (const Vector2&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x * right;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y * right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        <br>
        // 数値とVectorの掛け算 x,y個別に掛け合わせる<br>
        inline Vector2 operator * (float left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
        &nbsp;&nbsp;&nbsp; v2.x = left * right.x;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left * right.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // Vectorと数値の割り算 x,y,z個別に割り合わせる<br>
        // 0.fで割ると±無限大を返す<br>
        inline Vector2 operator / (const Vector2&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (right == 0.0f) // 0で割ったら±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ ((left.x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ((left.y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x / right;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y / right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // 比較不等号 &lt; 演算子<br>
        inline bool operator &lt; (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &lt; right.x;<br>
        &nbsp;&nbsp;&nbsp; return left.y &lt; right.y;<br>
        }<br>
        <br>
        // 比較不等号 &gt; 演算子<br>
        inline bool operator &gt; (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &gt; right.x;<br>
        &nbsp;&nbsp;&nbsp; return left.y &gt; right.y;<br>
        }<br>
        <br>
        // 比較不等号 &lt;= 演算子<br>
        inline bool operator &lt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &gt; right);<br>
        }<br>
        <br>
        // 比較不等号 &gt;= 演算子<br>
        inline bool operator &gt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &lt; right);<br>
        }<br>
        <br>
        <em>// ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)<br>
          inline float sqrMagnitude(const Vector2&amp; vec)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; return vec.x * vec.x + vec.y * vec.y; // x*x + y*y<br>
          }<br>
          <br>
          // ベクトルの長さ(原点0から点(x,y)までの距離)<br>
          inline float magnitude(const Vector2&amp; vec)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; return std::sqrt(sqrMagnitude(vec)); // √x*x + y*y<br>
          }</em><br>
        <br>
        #endif</p>
      <br>
      <code>MyMath.h</code>を変更して円と円の距離をsqrMagnitude関数(円どうしの距離の2乗)を使った形に置き換えてみましょ う。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と円が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc1"&gt;円1の中心pc1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc2"&gt;円2の中心pc2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1, float radius1,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2, float radius2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <em>(pc1 - pc2).sqrMagnitude()</em> &lt; ((radius1 + radius2) * (radius1 + radius2));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        #endif </p>
      さて、だいぶ式がすっきりしましたが、これでもちゃんと円どうしの当たり判定を計算できます。<br>
      magnitude系関数はつまり「三平方の定理」の距離を求める処理を関数という機能に置き換えた便利ツールと考えるとイメージしやすいかもしれません。<br>
      <br>
    </a> <a id="mozTocId0007" class="mozTocH1">
      <h1>Vector2に内積dotと外積cross関数を追加してMyMathクラスで円と線の当たり判定をできるようにする</h1>
      <code>Vector2.h</code>に関数を追加で定義します。<br>
      <p class="source">#ifndef VECTOR2_H_<br>
        #define VECTOR2_H_<br>
        <br>
        #include &lt;array&gt; //基本配列と同じ(有限個数)。生配列より便利な機能がある.size()関数とかstd::vector系関数が使える<br>
        #include &lt;limits&gt; // std::numeric_limitsで無限大などを使う https://cpprefjp.github.io/reference/limits/numeric_limits.html<br>
        #include &lt;cmath&gt; // std::の数学系関数に必要<br>
        <br>
        <br>
        //【注意】std::vectorとは全く違う。数学で習う【ベクトル】です。ごっちゃにしないで。<br>
        <br>
        //★【UnityのVector演算コード】https://github.com/Unity-Technologies /UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
        //★【UnityのMath演算コード】https://github.com/Unity-Technologies /UnityCsReference /blob/master/Runtime/Export/Math/Mathf.cs<br>
        <br>
        <br>
        // 2変数x,yを持つ構造体。2つの数字をまとめて扱うならXY座標以外にも使えるよ。x,y別々に足したり引いたり面倒でしょう。 <br>
        struct Vector2<br>
        {<br>
        &nbsp;&nbsp; &nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float y;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }; //[匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 2&gt; xy; // float xy[2];と同じ意味 float 2個ぶんのデータサイズでx,y 2個ぶんと一致するので★unionで共用<br>
        &nbsp;&nbsp; &nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y分けて記述するの面倒なとき配列xy[2]をfor文i=0～2で回せる<br>
        <br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator float* () const { return (float*)this; }<br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(const float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator const float* () const { return (const float*)this; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;// 初期化コンストラクタ<br>
        &nbsp;&nbsp; &nbsp;Vector2(float x = 0.0f, float y = 0.0f) //初期化<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; this-&gt;xy = { x,y }; // たった1行で書ける<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;x = x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;y = y; 2行が上のxyzの様にたった1行で書けるようになる<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp;&nbsp; // Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 zero;// = { 0.f,&nbsp; 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 one; // = { 1.f,&nbsp; 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 up;&nbsp; // = { 0.f,&nbsp; 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 down;// = { 0.f, -1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 left; // = { -1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 right;// = { 1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; //[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 negativeInfinity;// = { -std::numeric_limits&lt;float&gt;::infinity(), .. };<br>
        &nbsp;&nbsp;&nbsp; //[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 positiveInfinity;// = { std::numeric_limits&lt;float&gt;::infinity(), .. };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ベクトルの長さ(0から点(x,y,z)までの距離)<br>
        &nbsp;&nbsp;&nbsp; inline float magnitude() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return std::sqrt(x * x + y * y); // √(x*x + y*y)<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)<br>
        &nbsp;&nbsp;&nbsp; inline float sqrMagnitude() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return x * x + y * y; // x*x + y*y <br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>// 正規化したベクトルを返す<br>
          &nbsp;&nbsp;&nbsp; Vector2 normalized() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float mag = magnitude();<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (mag &lt; 0.00001f) // ほぼ0ベクトルか？<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ x / mag, y / mag }; // x / |x|, y / |y|<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; /*-----　演算子オーバーロード　-----*/<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 逆ベクトル<br>
        &nbsp;&nbsp;&nbsp; inline Vector2 operator -() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ -this-&gt;x, -this-&gt;y };<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // Vectorをそのまま足し合わせる<br>
        &nbsp;&nbsp;&nbsp; inline Vector2 operator + () const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator += (const Vector2 add_v2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x += add_v2.x;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y += add_v2.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this; //*thisを返すことで v1 + v2 + v3見たく数珠繋ぎできる<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator -= (const Vector2 minus_v2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x -= minus_v2.x;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y -= minus_v2.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator *= (float multiply_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x *= multiply_num;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y *= multiply_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 0.fで割ったときは±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; inline Vector2&amp; operator /= (float divide_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (divide_num == 0.0f) // 0で割ったら±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *this = Vector2{ ((this-&gt;x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;((this-&gt;y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x /= divide_num;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y /= divide_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 代入演算子 x,y,zを全部 change_numに変える<br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator = (float change_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x = change_num;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y = change_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 一致演算子 x,y,zを全部一致するか 一つでも違えばfalse<br>
        &nbsp;&nbsp;&nbsp; bool operator == (const Vector2&amp; v2_other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;x != v2_other.x) return false;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;y != v2_other.y) return false;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 不一致演算子 一致演算子の逆<br>
        &nbsp;&nbsp;&nbsp; bool operator != (const Vector2&amp; v2_other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return !(*this == v2_other);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        <br>
        // Vector2どうしの足し算 割り算 掛け算 割り算などの 基本演算の グローバル定義<br>
        <br>
        // Vector同士の足し算 x,y個別に足し合わせる<br>
        inline Vector2 operator + (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 + vec2のとき vec1の数値が書き変わったら嫌だからv3を新たに用意<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x + right.x; //[コレはダメ] left.x = left.x + right.x;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y + right.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // Vector同士の引き算 x,y個別に足し合わせる<br>
        inline Vector2 operator - (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 - vec2のとき vec1の数値が書き変わったら嫌だからv2を新たに用意<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x - right.x; //[コレはダメ] left.x = left.x - right.x;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y - right.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // Vectorと数値の掛け算 x,y個別に掛け合わせる<br>
        inline Vector2 operator * (const Vector2&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x * right;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y * right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        <br>
        // 数値とVectorの掛け算 x,y個別に掛け合わせる<br>
        inline Vector2 operator * (float left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
        &nbsp;&nbsp;&nbsp; v2.x = left * right.x;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left * right.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // Vectorと数値の割り算 x,y,z個別に割り合わせる<br>
        // 0.fで割ると±無限大を返す<br>
        inline Vector2 operator / (const Vector2&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (right == 0.0f) // 0で割ったら±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ ((left.x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ((left.y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x / right;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y / right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // 比較不等号 &lt; 演算子<br>
        inline bool operator &lt; (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &lt; right.x;<br>
        &nbsp;&nbsp;&nbsp; return left.y &lt; right.y;<br>
        }<br>
        <br>
        // 比較不等号 &gt; 演算子<br>
        inline bool operator &gt; (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &gt; right.x;<br>
        &nbsp;&nbsp;&nbsp; return left.y &gt; right.y;<br>
        }<br>
        <br>
        // 比較不等号 &lt;= 演算子<br>
        inline bool operator &lt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &gt; right);<br>
        }<br>
        <br>
        // 比較不等号 &gt;= 演算子<br>
        inline bool operator &gt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &lt; right);<br>
        }<br>
        <br>
        // ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)<br>
        inline float sqrMagnitude(const Vector2&amp; vec)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return vec.x * vec.x + vec.y * vec.y; // x*x + y*y<br>
        }<br>
        <br>
        // ベクトルの長さ(原点0から点(x,y)までの距離)<br>
        inline float magnitude(const Vector2&amp; vec)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return std::sqrt(sqrMagnitude(vec)); // √x*x + y*y<br>
        }<br>
        <br>
        <em>// 2つのベクトルの内積<br>
          inline float dot(const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; return left.x * right.x + left.y * right.y; //普通にx同士,y同士掛けるだけ<br>
          }<br>
          <br>
          // 2つのベクトルの外積<br>
          inline float cross(const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; return left.x * right.y - left.y * right.x;// 外積のたすき掛け<br>
          }</em><br>
        <br>
        #endif</p>
      <br>
      <code>MyMath.h</code>を変更して円と線が接触しているか判定する関数CircleSegment関数を追加してみましょ う。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と円が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc1"&gt;円1の中心pc1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc2"&gt;円2の中心pc2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1, float radius1,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2, float radius2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (pc1 - pc2).sqrMagnitude() &lt; ((radius1 + radius2) * (radius1 + radius2));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>/// &lt;summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// 円と線が重なっているかを調べる<br>
          &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="pc"&gt;円の中心&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="r"&gt;円の半径&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;線の端p1&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;線の端p2&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
          &nbsp;&nbsp;&nbsp; static bool CircleSegment(Vector2 pc, float r, Vector2 p1, Vector2 p2)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v12 = p2 - p1; // 線p1p2の始点p1から終点p2へ向かうベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = pc - p1; // 点p1から円の中心pcへ向かうベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v2 = pc - p2; // 点p2から円の中心pcへ向かうベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ev12 = v12.normalized(); // 単位ベクトル 線p1p2のp1からp2へ向かう単位ベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L; // 円と線の距離<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //円の中心pcが線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(v12, v1) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v1.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-v1, v2) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v2.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //外積を求めれば点pcと直線p1_p2の距離Lが求まる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = std::abs(cross(ev12, v1)); // |外積| (外積の絶対値をabsで求める)<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (L &lt; r) //衝突条件　L &lt; r(L &lt;= rにするかは地面から丁度半径r離れた位置で触れていると判定したいか次第)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        };<br>
        <br>
        #endif </p>
      下図で上記コードのv12をvに、ev12をevに置き換えて式との対応関係を確認してみてください。<br>
      <p> <img src="image/circle_line_collision1.png" alt=""></p>
      <br>
      <br>
      <p><code>main.cpp</code>を変更して円と線の当たり判定をしてみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 1,1 }; // (x,y) = (1,1)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ <em>7,13</em> }; // (x,y) = (<em>7,13</em>)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 3,3 }; // (x,y) = (3,3)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 1; // 円の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1{ 6,5 }; // 円1の中心<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r1 = 2; // 円1の半径<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2{ 8,9 }; // 円2の中心<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r2 = 3; // 円1の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円1と円2が当たっているかの判定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision12 = MyMath::CircleCircleIntersection(pc1, r1, pc2, r2);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 円1と線p1p2が当たっているかの判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision1_12 = MyMath::CircleSegment(pc1, r1, p1, p2);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円2と線p1p2が当たっているかの判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision2_12 = MyMath::CircleSegment(pc2, r2, p1, p2);</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc1.x, pc1.y, r1, (<em>isCollision1_12</em>) ? GetColor(255, 0, 0): GetColor(255, 255, 255), FALSE); // 円1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc2.x, pc2.y, r2, (<em>isCollision2_12</em>) ? GetColor(255, 0, 0) : GetColor(255, 255, 255), FALSE); // 円2を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, (isCollision1_12 || isCollision2_12) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分p1p2<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(255, 0, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(255, 0, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p0_String.c_str(), GetColor(0, 0, 255));</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * 3, p1.y + Vector2::up.y * 3, GetColor(0, 255, 255)); // upベクトルを3倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかかでしょう? こんどは 円1 と 円2 と 線分p1p2 の当たり判定をして、円2と線が接触して赤色になっていますか。<br>
      内積dotで (点p1→p2)・(点p1→円中心) &lt; 0 以下なら 内積のcosθが±90度を超えるので円の中心は線の外側p1サイドの外側になり、距離Lはmagnitudeで求まる<br>
      内積dotで (点p1←円中心)・(点p2→円中心) &lt; 0 以下なら 内積のcosθが±90度を超えるので円の中心は線の外側p2サイドの外側で、 距離Lはmagnitudeで求まる<br>
      円の中心が線p1とp2の間の空中にあるのなら円と線の距離Lは外積=円の中心から線p1p2へ垂直に下した線の長さで求まる<br>
      というふうに内積dotで角度を判別して、大きさmagunitudeや外積crossと正規化normalizedの組み合わせで円と線の距離が求まってい ます。<br>
      ゲームの当たり判定に、内積dot、外積cross、大きさmagnitude、単位ベクトルnormalizedが活躍していることが実感できたでしょう か?<br>
      <br>
    </a> <a id="mozTocId0008" class="mozTocH1">
      <h1>MyMathクラスで円と線が当たったら線に沿って押し戻す処理ができるようにする</h1>
      <code>MyMath.h</code>を変更して円と線が接触したら押し戻した位置をreturnする関数CircleBoundを追加してみましょ う。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と円が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc1"&gt;円1の中心pc1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc2"&gt;円2の中心pc2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1, float radius1,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2, float radius2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (pc1 - pc2).sqrMagnitude() &lt; ((radius1 + radius2) * (radius1 + radius2));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と線が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc"&gt;円の中心&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="r"&gt;円の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;線の端p1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;線の端p2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleSegment(Vector2 pc, float r, Vector2 p1, Vector2 p2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v12 = p2 - p1; // 線p1p2の始点p1から終点p2へ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = pc - p1; // 点p1から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v2 = pc - p2; // 点p2から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ev12 = v12.normalized(); // 単位ベクトル 線p1p2のp1からp2へ向かう単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L; // 円と線の距離<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //円の中心pcが線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(v12, v1) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v1.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-v1, v2) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v2.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //外積を求めれば点pcと直線p1_p2の距離Lが求まる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = std::abs(cross(ev12, v1)); // |外積| (外積の絶対値をabsで求める)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (L &lt; r) //衝突条件　L &lt; r(L &lt;= rにするかは地面から丁度半径r離れた位置で触れていると判定したいか次第)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>/// &lt;summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// 円と線が重なっているかを調べる<br>
          &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="pc"&gt;円の中心&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="r"&gt;円の半径&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;線の端p1&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;線の端p2&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;押し戻しした円の中心の点&lt;/returns&gt;<br>
          &nbsp;&nbsp;&nbsp; static Vector2 CircleBound(Vector2 pc, float r, Vector2 p1, Vector2 p2)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v12 = p2 - p1; // 線p1p2の始点p1から終点p2へ向かうベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = pc - p1; // 点p1から円の中心pcへ向かうベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v2 = pc - p2; // 点p2から円の中心pcへ向かうベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ev12 = v12.normalized(); // 単位ベクトル 線p1p2のp1からp2へ向かう単位ベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //円の中心pcが線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(v12, v1) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p1 + v1.normalized() * (r + 0.001f); // 半径よりちょっとだけ0.001f離れた位置まで押し戻す<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-v1, v2) &lt; 0) //点p0が線p1p2の外側にあるときは 内積 &lt; 0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p2 + v2.normalized() * (r + 0.001f); // 半径よりちょっとだけ0.001f離れた位置まで押し戻す<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //外積を求めれば点pcと直線p1_p2の距離Lが求まる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = dot(ev12, v1); // 内積で点p1から交点Qまでの距離を求める<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q = p1 + L * ev12; // 円と線の衝突点Q<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 e = (pc - Q).normalized(); // 跳ね返り方向のの半径1の単位ベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Q + e * (r + 0.001f); // 押し戻し処理<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        };<br>
        <br>
        #endif </p>
      下図で上記コードのv12をvに、ev12をevに置き換えて式との対応関係を確認してみてください。<br>
      <p> <img src="image/circle_line_collision2.png" alt=""></p>
      <br>
      <br>
      <p><code>main.cpp</code>を変更して円と線の当たり判定をして接触している際はMyMath::CircleBoundで円を押し戻 した位置を描く処理を追加してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 1,1 }; // (x,y) = (1,1)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ <em>8,8</em> }; // (x,y) = (<em>8,8</em>)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 3,3 }; // (x,y) = (3,3)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 1; // 円の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1{ 6,5 }; // 円1の中心<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r1 = 2; // 円1の半径<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2{ 8,9 }; // 円2の中心<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r2 = 3; // 円1の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円1と円2が当たっているかの判定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision12 = MyMath::CircleCircleIntersection(pc1, r1, pc2, r2);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円1と線p1p2が当たっているかの判定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision1_12 = MyMath::CircleSegment(pc1, r1, p1, p2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円2と線p1p2が当たっているかの判定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision2_12 = MyMath::CircleSegment(pc2, r2, p1, p2);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Vector2 pb1 = pc1; // 線に押し戻された円1の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision1_12) <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb1 = MyMath::CircleBound(pc1, r1, p1, p2);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pb2 = pc2; // 線に押し戻された円2の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision2_12)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb2 = MyMath::CircleBound(pc2, r2, p1, p2);</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc1.x, pc1.y, r1, (isCollision1_12) ? GetColor(255, 0, 0): GetColor(255, 255, 255), FALSE); // 円1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc2.x, pc2.y, r2, (isCollision2_12) ? GetColor(255, 0, 0) : GetColor(255, 255, 255), FALSE); // 円2を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if (pb1 != pc1) // 線に当たって押し戻された円1を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pb1.x, pb1.y, r1, GetColor(255, 0, 255), FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pb2 != pc2) // 線に当たって押し戻された円2を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pb2.x, pb2.y, r2, GetColor(255, 0, 255), FALSE);</em><br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, (isCollision1_12 || isCollision2_12) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分p1p2<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p0_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * 3, p1.y + Vector2::up.y * 3, GetColor(0, 255, 255)); // upベクトルを3倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかかでしょう? 線と 円1 と 円2 の両方が接触して 押し戻されて線にぴったり沿う位置に円が描かれていますか。<br>
      <br>
      <br>
    </a> <a id="mozTocId0009" class="mozTocH1">
      <h1>MyMathクラスで線に垂直に下した点の影(射影)位置と線と点の最短距離を求める</h1>
      <code>MyMath.h</code>を変更して線p1p2に対して点p0から垂直に下した交点Qとp0からQへの距離Lと点p0から線p1p2への最 短距離Hを求める関数LineProjectionを追加してみましょ う。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と円が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc1"&gt;円1の中心pc1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc2"&gt;円2の中心pc2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1, float radius1,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2, float radius2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (pc1 - pc2).sqrMagnitude() &lt; ((radius1 + radius2) * (radius1 + radius2));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と線が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc"&gt;円の中心&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="r"&gt;円の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;線の端p1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;線の端p2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleSegment(Vector2 pc, float r, Vector2 p1, Vector2 p2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v12 = p2 - p1; // 線p1p2の始点p1から終点p2へ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = pc - p1; // 点p1から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v2 = pc - p2; // 点p2から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ev12 = v12.normalized(); // 単位ベクトル 線p1p2のp1からp2へ向かう単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L; // 円と線の距離<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //円の中心pcが線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(v12, v1) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v1.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-v1, v2) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v2.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //外積を求めれば点pcと直線p1_p2の距離Lが求まる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = std::abs(cross(ev12, v1)); // |外積| (外積の絶対値をabsで求める)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (L &lt; r) //衝突条件　L &lt; r(L &lt;= rにするかは地面から丁度半径r離れた位置で触れていると判定したいか次第)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と線が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc"&gt;円の中心&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="r"&gt;円の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;線の端p1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;線の端p2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;押し戻しした円の中心の点&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static Vector2 CircleBound(Vector2 pc, float r, Vector2 p1, Vector2 p2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v12 = p2 - p1; // 線p1p2の始点p1から終点p2へ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = pc - p1; // 点p1から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v2 = pc - p2; // 点p2から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ev12 = v12.normalized(); // 単位ベクトル 線p1p2のp1からp2へ向かう単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //円の中心pcが線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(v12, v1) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p1 + v1.normalized() * (r + 0.001f); // 半径よりちょっとだけ0.001f離れた位置まで押し戻す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-v1, v2) &lt; 0) //点p0が線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p2 + v2.normalized() * (r + 0.001f); // 半径よりちょっとだけ0.001f離れた位置まで押し戻す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //外積を求めれば点pcと直線p1_p2の距離Lが求まる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = dot(ev12, v1); // 内積で点p1から交点Qまでの距離を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q = p1 + L * ev12; // 円と線の衝突点Q<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 e = (pc - Q).normalized(); // 跳ね返り方向のの半径1の単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Q + e * (r + 0.001f); // 押し戻し処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em><br>
          &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// 斜面a(線p1→p2),線b(p1→p0)のとき斜面a上に点p0から垂直に下した射影点(点Q)の位置とp0からQへの長さLとp0と線aとの距離Hを求める<br>
          &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="p0"&gt;線bの先っぽp0&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;aとbの起点p1&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;斜面aの端p2&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="L"&gt;p1からQまでの距離&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="H"&gt;p0と直線p1p2の距離(= 高さ[線の内側]か端っこの点からの半径[線の外側])&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;線aに線bから下した交点Q&lt;/returns&gt;<br>
          &nbsp;&nbsp;&nbsp; static Vector2 LineProjection(Vector2 p0, Vector2 p1, Vector2 p2, float&amp; L, float&amp; H, Vector2&amp; nearest)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ベクトルaとベクトルbを求める。ただマイナスするだけ。<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 a = p2 - p1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 b = p0 - p1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 c = p0 - p2; // p2→p0のベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 正規化ベクトルを求める<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ea = a.normalized(); // a / |a|<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isOutside = false; // p0が線の外側か?<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //点p0が線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(a, b) &lt; 0) // 点p0が線p1p2の外側にあるときは 内積 &lt; 0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; H = b.magnitude(); // 点p0と直線p1p2の距離は単なるベクトルbの直線距離でいい<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearest = p1; // 一番近い点はp1<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isOutside = true; // p1側の外側<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-a, c) &lt; 0) // 点p0が線p1p2の外側にあるときは 内積 &lt; 0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; H = c.magnitude(); // 点p0と直線p1p2の距離は単なるベクトルcの直線距離でいい<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearest = p2; // 一番近い点はp2<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isOutside = true; // p2側の外側<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 外積を求めれば点p0と直線p1_p2の距離Lが求まる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ea_cross_b = cross(ea, b);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; H = ea_cross_b.magnitude();<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = dot(ea, b); // 長さLは内積で求まる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 resultQ = p1 + L * ea;<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isOutside)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearest = resultQ; // 一番近い点はQ<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return resultQ;<br>
          &nbsp;&nbsp;&nbsp; }<br>
        </em><br>
        <br>
        };<br>
        <br>
        #endif </p>
      下図で上記コードの式との対応関係を確認してみてください。<br>
      <p> <img src="image/circle_line_collision3.png" alt=""></p>
      <br>
      <br>
      <p><code>main.cpp</code>がちらかってきたので一旦、今まで書いてきたVector関連のコードを消してから今回のコードを入れま しょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        <u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 1,1 }; // (x,y) = (1,1)の位置の点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 8,8 }; // (x,y) = (8,8)の位置の点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 3,3 }; // (x,y) = (3,3)の位置の点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 1; // 円の半径<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1{ 6,5 }; // 円1の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r1 = 2; // 円1の半径<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2{ 8,9 }; // 円2の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r2 = 3; // 円1の半径<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円1と円2が当たっているかの判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision12 = MyMath::CircleCircleIntersection(pc1, r1, pc2, r2);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円1と線p1p2が当たっているかの判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision1_12 = MyMath::CircleSegment(pc1, r1, p1, p2);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円2と線p1p2が当たっているかの判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision2_12 = MyMath::CircleSegment(pc2, r2, p1, p2);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pb1 = pc1; // 線に押し戻された円1の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision1_12) <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb1 = MyMath::CircleBound(pc1, r1, p1, p2);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pb2 = pc2; // 線に押し戻された円2の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision2_12)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb2 = MyMath::CircleBound(pc2, r2, p1, p2);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc1.x, pc1.y, r1, (isCollision1_12) ? GetColor(255, 0, 0): GetColor(255, 255, 255), FALSE); // 円1を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc2.x, pc2.y, r2, (isCollision2_12) ? GetColor(255, 0, 0) : GetColor(255, 255, 255), FALSE); // 円2を描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pb1 != pc1) // 線に当たって押し戻された円1を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pb1.x, pb1.y, r1, GetColor(255, 0, 255), FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pb2 != pc2) // 線に当たって押し戻された円2を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pb2.x, pb2.y, r2, GetColor(255, 0, 255), FALSE);<br>
          <br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, (isCollision1_12 || isCollision2_12) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分p1p2<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(255, 0, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(255, 0, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p0_String.c_str(), GetColor(0, 0, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * 3, p1.y + Vector2::up.y * 3, GetColor(0, 255, 255)); // upベクトルを3倍した線を描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      <p><code>main.cpp</code>を変更してMyMath::LineProjectionで線に点から垂直に下した位置と最短距離の表示処 理を追加してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Vector2 p0{ 5,8 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 2,2 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 10,3 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = 0; // 点p1から交点Qへの距離<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float H = 0; // 線分p1p2と点p0の最短距離H<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 nearest; // 点p0から一番近い直線p1p2上の点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q = MyMath::LineProjection(p0,p1,p2,L,H, nearest); // 点p0から線分p1p2に垂直に下した交点Q<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255)); // 線分p1p2<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p0.x, p0.y, GetColor(150, 150, 150)); // 線分p1p0<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, nearest.x, nearest.y, GetColor(255, 255, 0)); // p0からの最短距離を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, Q.x, Q.y, GetColor(0, 255, 255)); // p0からQへの距離Lを描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y-5, Q_String.c_str(), GetColor(255, 0, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string H_String = "最短距離H=" + std::to_string(H);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(nearest.x, nearest.y - 10, H_String.c_str(), GetColor(255, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string L_String = "L=" + std::to_string(L);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 3, L_String.c_str(), GetColor(0, 255, 255));</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      いかがですか？最短距離が表示されましたか?<br>
      念のため、p1側の外側の場合の最短距離も試しておきましょう。<br>
      <br>
      <p><code>main.cpp</code>の数値を変更してp1側の外側の場合の最短距離も試しておきましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ <em>-3</em>,8 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 2,2 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 10,3 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = 0; // 点p1から交点Qへの距離<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float H = 0; // 線分p1p2と点p0の最短距離H<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 nearest; // 点p0から一番近い直線p1p2上の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q = MyMath::LineProjection(p0,p1,p2,L,H, nearest); // 点p0から線分p1p2に垂直に下した交点Q<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255)); // 線分p1p2<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p0.x, p0.y, GetColor(150, 150, 150)); // 線分p1p0<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, nearest.x, nearest.y, GetColor(255, 255, 0)); // p0からの最短距離を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, Q.x, Q.y, GetColor(0, 255, 255)); // p0からQへの距離Lを描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y-5, Q_String.c_str(), GetColor(255, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string H_String = "最短距離H=" + std::to_string(H);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(nearest.x, nearest.y - 10, H_String.c_str(), GetColor(255, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string L_String = "L=" + std::to_string(L);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 3, L_String.c_str(), GetColor(0, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      いかがですか？p1側の外側の場合の最短距離が表示されましたか?<br>
      念のため、p2側の外側の場合の最短距離も試しておきましょう。<br>
      <br>
      <p><code>main.cpp</code>の数値を変更してp2側の外側の場合の最短距離も試しておきましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ <em>15</em>,8 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 2,2 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 10,3 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = 0; // 点p1から交点Qへの距離<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float H = 0; // 線分p1p2と点p0の最短距離H<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 nearest; // 点p0から一番近い直線p1p2上の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q = MyMath::LineProjection(p0,p1,p2,L,H, nearest); // 点p0から線分p1p2に垂直に下した交点Q<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255)); // 線分p1p2<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p0.x, p0.y, GetColor(150, 150, 150)); // 線分p1p0<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, nearest.x, nearest.y, GetColor(255, 255, 0)); // p0からの最短距離を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, Q.x, Q.y, GetColor(0, 255, 255)); // p0からQへの距離Lを描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y-5, Q_String.c_str(), GetColor(255, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string H_String = "最短距離H=" + std::to_string(H);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(nearest.x, nearest.y - 10, H_String.c_str(), GetColor(255, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string L_String = "L=" + std::to_string(L);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 3, L_String.c_str(), GetColor(0, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょうか？この最短距離の処理は2Dのカプセルコライダーの点との当たり判定の場合分けの条件と同じです。<br>
      カプセルコライダーは複雑そうに思えて、実はシンプルな内積や外積の場合分けの計算で高速に計算できるのです。<br>
      計算時間が早く、当たり判定の伸縮性がありゲームの当たり判定はカプセルコライダーを多用して制作されているのです。<br>
      <br>
      <br>
    </a> <a id="mozTocId0010" class="mozTocH1">
      <h1>MyMathクラスで線と線が交差するか判定する</h1>
      <code>MyMath.h</code>を変更して線分line0と線分line1が交差するかを求める関数LineIntersection(判定のみ ver.)を追加してみましょう。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と円が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc1"&gt;円1の中心pc1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc2"&gt;円2の中心pc2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1, float radius1,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2, float radius2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (pc1 - pc2).sqrMagnitude() &lt; ((radius1 + radius2) * (radius1 + radius2));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と線が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc"&gt;円の中心&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="r"&gt;円の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;線の端p1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;線の端p2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleSegment(Vector2 pc, float r, Vector2 p1, Vector2 p2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v12 = p2 - p1; // 線p1p2の始点p1から終点p2へ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = pc - p1; // 点p1から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v2 = pc - p2; // 点p2から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ev12 = v12.normalized(); // 単位ベクトル 線p1p2のp1からp2へ向かう単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L; // 円と線の距離<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //円の中心pcが線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(v12, v1) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v1.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-v1, v2) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v2.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //外積を求めれば点pcと直線p1_p2の距離Lが求まる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = std::abs(cross(ev12, v1)); // |外積| (外積の絶対値をabsで求める)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (L &lt; r) //衝突条件　L &lt; r(L &lt;= rにするかは地面から丁度半径r離れた位置で触れていると判定したいか次第)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と線が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc"&gt;円の中心&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="r"&gt;円の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;線の端p1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;線の端p2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;押し戻しした円の中心の点&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static Vector2 CircleBound(Vector2 pc, float r, Vector2 p1, Vector2 p2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v12 = p2 - p1; // 線p1p2の始点p1から終点p2へ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = pc - p1; // 点p1から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v2 = pc - p2; // 点p2から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ev12 = v12.normalized(); // 単位ベクトル 線p1p2のp1からp2へ向かう単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //円の中心pcが線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(v12, v1) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p1 + v1.normalized() * (r + 0.001f); // 半径よりちょっとだけ0.001f離れた位置まで押し戻す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-v1, v2) &lt; 0) //点p0が線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p2 + v2.normalized() * (r + 0.001f); // 半径よりちょっとだけ0.001f離れた位置まで押し戻す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //外積を求めれば点pcと直線p1_p2の距離Lが求まる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = dot(ev12, v1); // 内積で点p1から交点Qまでの距離を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q = p1 + L * ev12; // 円と線の衝突点Q<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 e = (pc - Q).normalized(); // 跳ね返り方向のの半径1の単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Q + e * (r + 0.001f); // 押し戻し処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em><br>
        </em>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 斜面a(線p1→p2),線b(p1→p0)のとき斜面a上に点p0から垂直に下した射影点(点Q)の位置とp0からQへの長さLとp0と線aとの距離Hを求める<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p0"&gt;線bの先っぽp0&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;aとbの起点p1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;斜面aの端p2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="L"&gt;p1からQまでの距離&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="H"&gt;p0と直線p1p2の距離(= 高さ[線の内側]か端っこの点からの半径[線の外側])&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;線aに線bから下した交点Q&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static Vector2 LineProjection(Vector2 p0, Vector2 p1, Vector2 p2, float&amp; L, float&amp; H, Vector2&amp; nearest)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ベクトルaとベクトルbを求める。ただマイナスするだけ。<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 a = p2 - p1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 b = p0 - p1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 c = p0 - p2; // p2→p0のベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 正規化ベクトルを求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ea = a.normalized(); // a / |a|<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isOutside = false; // p0が線の外側か?<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //点p0が線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(a, b) &lt; 0) // 点p0が線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; H = b.magnitude(); // 点p0と直線p1p2の距離は単なるベクトルbの直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearest = p1; // 一番近い点はp1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isOutside = true; // p1側の外側<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-a, c) &lt; 0) // 点p0が線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; H = c.magnitude(); // 点p0と直線p1p2の距離は単なるベクトルcの直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearest = p2; // 一番近い点はp2<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isOutside = true; // p2側の外側<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 外積を求めれば点p0と直線p1_p2の距離Lが求まる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ea_cross_b = cross(ea, b);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; H = ea_cross_b.magnitude();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = dot(ea, b); // 長さLは内積で求まる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 resultQ = p1 + L * ea;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isOutside)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearest = resultQ; // 一番近い点はQ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return resultQ;<br>
        &nbsp;&nbsp;&nbsp; }<em><br>
        </em><br>
        <em>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// 線line0と線line1が重なっているかを調べる<br>
          &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="line0start"&gt;線line0の始点&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="line0end"&gt;線line0の終点&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="line1start"&gt;線line1の始点&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="line1end"&gt;線line1の終点&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;線line0と線line1が交差しているならtrue,してないならfalse&lt;/returns&gt;<br>
          &nbsp;&nbsp;&nbsp; static bool LineIntersection(Vector2 line0start, Vector2 line0end, Vector2 line1start, Vector2 line1end)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v0 = line0end - line0start; // line0の始点startから終点endへのベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = line1end - line1start; // line1の始点startから終点endへのベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v01 = line1start - line0start; // line0の始点からline1の始点へのベクトル 0start→1start<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t1 = cross(v01, v0) / cross(v0, v1);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t0 = cross(v01, v1) / cross(v0, v1);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line0と線分line1が【交差しているか判定】<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0 &lt; t1 &amp;&amp; t1 &lt; 1 &amp;&amp; 0 &lt; t0 &amp;&amp; t0 &lt; 1) return true; //【交差している】<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 線分line0と線分line1は【交差していない】<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        };<br>
        <br>
        #endif </p>
      下図で上記コードの式との対応関係を確認してみてください。(ベクトルaをv0に ベクトルbをv1に ベクトルcをv01に 置き換えてみよう[ピンクの部分])<br>
      <p> <img src="image/circle_line_collision4.png" alt=""></p>
      <br>
      <br>
      <p><code>main.cpp</code>がちらかってきたので一旦、今まで書いてきたVector関連のコードを消してから今回のコードを入れま しょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        <u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 15,8 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 2,2 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 10,3 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = 0; // 点p1から交点Qへの距離<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float H = 0; // 線分p1p2と点p0の最短距離H<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 nearest; // 点p0から一番近い直線p1p2上の点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q = MyMath::LineProjection(p0,p1,p2,L,H, nearest); // 点p0から線分p1p2に垂直に下した交点Q<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255)); // 線分p1p2<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p0.x, p0.y, GetColor(150, 150, 150)); // 線分p1p0<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, nearest.x, nearest.y, GetColor(255, 255, 0)); // p0からの最短距離を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, Q.x, Q.y, GetColor(0, 255, 255)); // p0からQへの距離Lを描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y-5, Q_String.c_str(), GetColor(255, 0, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string H_String = "最短距離H=" + std::to_string(H);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(nearest.x, nearest.y - 10, H_String.c_str(), GetColor(255, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string L_String = "L=" + std::to_string(L);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 3, L_String.c_str(), GetColor(0, 255, 255));</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      <p><code>main.cpp</code>を変更してMyMath::LineIntersectionで線分line0と線分line1が交差する かの判定を追加してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 線分line0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 5,5 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,11 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,6 };<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineIntersection(p0, p1, p2, p3);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      いかがですか？線line0と線line1が交差しているので線が赤色で表示されましたか?<br>
      念のため、交差しない場合も試しておきましょう。<br>
      <br>
      <br>
      <p><code>main.cpp</code>の点p1の位置を変更して線分line0と線分line1が交差しない場合(t0 &lt; 0)の判定を試してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ <em>11,9</em> };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,11 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineIntersection(p0, p1, p2, p3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      いかがですか？線line0と線line1が交差していていない(t0 &lt; 0)ので線が白色で表示されましたか?<br>
      念のため、別の交差しない場合(1 &lt; t0のとき)も試しておきましょう。<br>
      <br>
      <br>
      <p><code>main.cpp</code>の点p1の位置を変更して線分line0と線分line1が交差しない場合(1 &lt; t0)の判定を試してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ <em>5,5</em> };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ <em>9,7</em> };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineIntersection(p0, p1, p2, p3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがですか？線line0と線line1が交差していていない(1 &lt; t0)ので線が白色で表示されましたか?<br>
      念のため、別の交差しない場合(t1 &lt; 0のとき)も試しておきましょう。<br>
      <br>
      <br>
      <p><code>main.cpp</code>の点p1の位置を変更して線分line0と線分line1が交差しない場合(t1 &lt; 0)の判定を試してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 5,5 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ <em>15,11</em> };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ <em>12,8</em> };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineIntersection(p0, p1, p2, p3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがですか？線line0と線line1が交差していていない(t1 &lt; 0)ので線が白色で表示されましたか?<br>
      念のため、別の交差しない場合(1 &lt; t1のとき)も試しておきましょう。<br>
      <br>
      <br>
      <p><code>main.cpp</code>の点p1の位置を変更して線分line0と線分line1が交差しない場合(1 &lt; t1)の判定を試してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 5,5 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,11 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ <em>5,10</em> };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ <em>9,9</em> };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineIntersection(p0, p1, p2, p3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがですか？線line0と線line1が交差していていない(1 &lt; t1)ので線が白色で表示されましたか?<br>
      これで、t1 &lt; 0、1 &lt; t1、t0 &lt; 0、1 &lt; t0 の4種類の交差しないパターンを試すことができました。<br>
      線と線の交差判定は、2Dゲームのレイ(光線)と壁や地面の直線との交差判定に使えますね。<br>
      ただし、その場合はレイ(光線)は有限の直線ではなくて片方に無限の直線なので、点p0をレイ(光線)の始点とするなら、<br>
      上記の<b>「t0 &lt; 1 の判定をあえてせずに」</b>t0 が 1以上でもレイ(光線)があたっている、と判定する必要があります。<br>
      ではMyMathのLineIntersection関数を「t0 &lt; 1 の判定をあえてしないように」改造してレイ(光線)の当たり判定を実現してみましょう。<br>
      <br>
    </a> <a id="mozTocId0011" class="mozTocH1">
      <h1>MyMathクラスでレイ(光線)と線分(壁や床など)が交差するか判定する</h1>
      <code>MyMath.h</code>を変更して光線ray0と線分line1が交差するかを求める関数RayLineCollision(判定のみ ver.)を追加してみましょう。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp; &nbsp;(中略).....<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>/// &lt;summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// 光線ray0と線line1が重なっているかを調べる<br>
          &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="ray0start"&gt;光線ray0の始点&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="ray0dir"&gt;光線ray0の方向ベクトル&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="line1start"&gt;線line1の始点&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="line1end"&gt;線line1の終点&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;光線ray0と線line1が交差しているならtrue,してないならfalse&lt;/returns&gt;<br>
          &nbsp;&nbsp;&nbsp; static bool RayLineCollision(Vector2 ray0start, Vector2 ray0dir, Vector2 line1start, Vector2 line1end)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v0 = ray0dir; // 光線ray0のベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = line1end - line1start; // line1の始点startから終点endへのベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v01 = line1start - ray0start; // line0の始点からline1の始点へのベクトル 0start→1start<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t1 = cross(v01, v0) / cross(v0, v1);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t0 = cross(v01, v1) / cross(v0, v1);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光線ray0と線分line1が【交差しているか判定】<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0 &lt; t1 &amp;&amp; t1 &lt; 1 &amp;&amp; 0 &lt; t0) return true; //【交差している】<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 光線ray0と線分line1は【交差していない】<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        };<br>
        <br>
        #endif </p>
      <br>
      下図で上記コードの式との対応関係を確認してみてください。(v0をray0startに v1の代わりにray0dirに置き換えてみよう[オレンジの部分])<br>
      <p> <img src="image/circle_line_collision4.png" alt=""></p>
      <br>
      <br>
      <p><code>main.cpp</code>の点p0をray0posに、点p1の代わりにレイ光線の方向ray0dirに変更して、線分line1と交差するかの判定を試してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <em>ray0光線レイ</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 <em>ray0pos</em>{ 5,5 }; <em>// レイ光線の始点</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 <em>ray0dir</em>{ <em>1,1</em> }; <em>// レイ光線の方向</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ <em>15,6</em> };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::<em>RayLineCollision</em>(<em>ray0pos, ray0dir</em>, p2, p3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(<em>ray0pos</em>.x, <em>ray0pos</em>.y, 0, 0, <em>ray0pos.x + ray0dir.x</em>, <em>ray0pos.y + ray0dir.y</em>, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // <em>光線ray0</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(<em>ray0pos</em>.x, <em>ray0pos</em>.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "<em>ray0</em>=(" + std::to_string((int)<em>ray0pos</em>.x) + "," + std::to_string((int)<em>ray0pos</em>.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(<em>ray0pos</em>.x, <em>ray0pos</em>.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？レイの方向に有限の線分(壁や床)があるときに、線が赤色で表示されたでしょうか？<br>
      念のため、こんどはレイの方向を変えて、(-1,1) x方向に-1、y方向に+1の方向、<br>
      つまり、90°+45°=135°の方向のレイに変えた場合に光線と線分(壁や床)との当たり判定もためしてみましょう。<br>
      <p><code>main.cpp</code>のレイ光線の方向ray0dirを(-1,1)=135°の方向に変更して、線分line1と交差するかの 判定を試してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ray0光線レイ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0pos{ 5,5 }; // レイ光線の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0dir{ <em>-1</em>,1 }; // レイ光線の方向<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::RayLineCollision(ray0pos, ray0dir, p2, p3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(ray0pos.x, ray0pos.y, 0, 0, ray0pos.x + ray0dir.x, ray0pos.y + ray0dir.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 光線ray0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(ray0pos.x, ray0pos.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "ray0=(" + std::to_string((int)ray0pos.x) + "," + std::to_string((int)ray0pos.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(ray0pos.x, ray0pos.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？こんどはレイ光線の方向に線分(壁や床)がないので線が白色で表示されましたでしょうか？<br>
      <br>
      このように、数学の式の理解をすると、数式を少しだけ変えて(1 &lt; t0)&nbsp; t0 の1以上の判定 をしないだけで、<br>
      ゲームに実際に使えるようなレイの判定をできることが実感できたでしょうか?<br>
      <br>
      Unityに最初から用意されている機能に頼ってしまうと、このようなゲームを支える数学の基礎を学ぶ機会のないまま、就職活動をすることになってしまいま す。<br>
      すると、「Unityだけ」でゲームを作っている人は「ベクトルとか当たり判定の基礎の知識が薄い」のではないかとベテランのプログラマからは見られているわ けです。<br>
      2010年代以降の「Unity以降」世代と2010年以前の「自力勉強世代」との間の「ゲーム数学の勉強する機会格差」が生じてしまっています。<br>
      結果として、「自作ゲームは作れる」のに「ゲームプログラマ」としては就職に苦労する「世代ギャップ」が生じています。<br>
      「Unity」などのゲームエンジンの便利さにより、ゲームプログラマの「基礎的な数学力」の足腰とモチベーションをぐらつかせているという意味で、<br>
      Unityの教育の手軽さに対する「反作用」がでてきているともいえます。<br>
      (最近だと、デザイナー系や美大の学科なんかも自力でUnity勉強して、かっこいいゲーム作ってきちゃうので、差別化が大変なのです)<br>
      デザイナー系や美大の学科が、絶対に勉強してこない(勉強したくない)ような分野の代表が「ベクトルや当たり判定」なのです。<br>
      <br>
      <br>
    </a> <a id="mozTocId0012" class="mozTocH1">
      <h1>MyMathクラスでレイ(光線)と線分(壁や床など)の交点を求める</h1>
      <code>MyMath.h</code>を変更して光線ray0と線分line1の交点を求める関数RayLineCollision(交点も求める ver.)を変更してみましょう。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp; &nbsp;(中略).....<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 光線ray0と線line1が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; <em>/// &lt;param name="result"光線ray0と線line1の交点を求めてresultで返す&lt;/param&gt;</em><br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="ray0start"&gt;光線ray0の始点&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="ray0dir"&gt;光線ray0の方向ベクトル&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="line1start"&gt;線line1の始点&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="line1end"&gt;線line1の終点&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;光線ray0と線line1が交差しているならtrue,してないならfalse&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool RayLineCollision(<em>Vector2&amp; result, </em>Vector2 ray0start, Vector2 ray0dir, Vector2 line1start, Vector2 line1end)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v0 = ray0dir; // 光線ray0のベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = line1end - line1start; // line1の始点startから終点endへのベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v01 = line1start - ray0start; // line0の始点からline1の始点へのベクトル 0start→1start<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t1 = cross(v01, v0) / cross(v0, v1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t0 = cross(v01, v1) / cross(v0, v1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>result = ray0start + v0 * t0; //交点resultを求めて【&amp;result参照で返却】</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光線ray0と線分line1が【交差しているか判定】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0 &lt; t1 &amp;&amp; t1 &lt; 1 &amp;&amp; 0 &lt; t0) return true; //【交差している】<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 光線ray0と線分line1は【交差していない】<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        #endif </p>
      <br>
      下図で上記コードの式との対応関係を確認してみてください。<br>
      <p> <img src="image/circle_line_collision4.png" alt=""></p>
      <br>
      <p><code>main.cpp</code>に交点Qを追加して関数の引数に渡して、線分line1と光線ray0の交点を求めて表示してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ray0光線レイ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0pos{ 5,5 }; // レイ光線の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0dir{ -1,1 }; // レイ光線の方向<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Vector2 Q; // 光線ray0とline1の交点</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::RayLineCollision(<em>Q, </em>ray0pos, ray0dir, p2, p3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(ray0pos.x, ray0pos.y, 0, 0, ray0pos.x + ray0dir.x, ray0pos.y + ray0dir.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 光線ray0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(ray0pos.x, ray0pos.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "ray0=(" + std::to_string((int)ray0pos.x) + "," + std::to_string((int)ray0pos.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(ray0pos.x, ray0pos.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 165, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 10, Q_String.c_str(), GetColor(255, 165, 0));</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？なるほど、レイ光線の方向に線分(壁や床)がないときは、線分line1の延長線上に交点Qが求まるのですね。<br>
      では、光線の方向が壁と逆方向(-1,-1)の場合はどうなるか実験してみましょう。 <br>
      <br>
      <p><code>main.cpp</code>の交点Qが光線ray0と逆方向(-1,-1)の場合の交点を表示してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ray0光線レイ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0pos{ 5,5 }; // レイ光線の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0dir{ -1,<em>-1</em> }; // レイ光線の方向<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q; // 光線ray0とline1の交点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::RayLineCollision(Q, ray0pos, ray0dir, p2, p3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(ray0pos.x, ray0pos.y, 0, 0, ray0pos.x + ray0dir.x, ray0pos.y + ray0dir.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 光線ray0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(ray0pos.x, ray0pos.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "ray0=(" + std::to_string((int)ray0pos.x) + "," + std::to_string((int)ray0pos.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(ray0pos.x, ray0pos.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 165, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 10, Q_String.c_str(), GetColor(255, 165, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？なるほど、逆方向の場合はレイ光線の後ろ側に交点が数学的に求まって、表示されるのですね。<br>
      では、今度こそレイ光線が壁(線分)にヒットするときの実験をしてみましょう。<br>
      <br>
      <p><code>main.cpp</code>を変更して、光線ray0の方向が(1,1)で壁(線)とぶつかる場合にその交点Qを表示してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ray0光線レイ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0pos{ 5,5 }; // レイ光線の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0dir{ <em>1,1</em> }; // レイ光線の方向<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q; // 光線ray0とline1の交点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::RayLineCollision(Q, ray0pos, ray0dir, p2, p3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(ray0pos.x, ray0pos.y, 0, 0, ray0pos.x + ray0dir.x, ray0pos.y + ray0dir.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 光線ray0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(ray0pos.x, ray0pos.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "ray0=(" + std::to_string((int)ray0pos.x) + "," + std::to_string((int)ray0pos.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(ray0pos.x, ray0pos.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 165, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 10, Q_String.c_str(), GetColor(255, 165, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？つまり、この設計した関数を使う場合は、isCollision01でMyMath::RayLineCollisionの結果をbool型で受けて、<br>
      レイ光線がぶつかったかどうかと、セットで交点Qを使う必要があるのですね。<br>
      逆に言えば、isCollision01を無視すれば、壁や床が無限の長さのときの交点を求めるのにも、この関数は応用できるということですね。<br>
      <br>
    </a> <a id="mozTocId0013" class="mozTocH1">
      <h1>MyMathクラスで線と線の交点を求める</h1>
      <code>MyMath.h</code>を変更して線分line0と線分line1の交点を関数LineIntersection(交点も求める ver.)で求められるようにしてみましょう。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp; &nbsp;(中略).....<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 線line0と線line1が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; <em>/// &lt;param name="result"&gt;線line0と線line1の交点を求めてresultで返す&lt;/param&gt;</em><br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="line0start"&gt;線line0の始点&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="line0end"&gt;線line0の終点&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="line1start"&gt;線line1の始点&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="line1end"&gt;線line1の終点&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;線line0と線line1が交差しているならtrue,してないならfalse&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool LineIntersection(<em>Vector2&amp; result, </em>Vector2 line0start, Vector2 line0end, Vector2 line1start, Vector2 line1end)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v0 = line0end - line0start; // line0の始点startから終点endへのベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = line1end - line1start; // line1の始点startから終点endへのベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v01 = line1start - line0start; // line0の始点からline1の始点へのベクトル 0start→1start<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t1 = cross(v01, v0) / cross(v0, v1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t0 = cross(v01, v1) / cross(v0, v1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>result = line0start + v0 * t0; //交点resultを求めて【&amp;result参照で返却】</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line0と線分line1が【交差しているか判定】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0 &lt; t1 &amp;&amp; t1 &lt; 1 &amp;&amp; 0 &lt; t0 &amp;&amp; t0 &lt; 1) return true; //【交差している】<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 線分line0と線分line1は【交差していない】<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        #endif </p>
      <br>
      下図で上記コードの式との対応関係を確認してみてください。<br>
      <p> <img src="image/circle_line_collision4.png" alt=""></p>
      <br>
      <p><code>main.cpp</code>を変更して、線分line0と線分line1の交点を求めて表示してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 <em>p0</em>{ 5,5 }; // <em>line0の始点</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 <em>p1</em>{ <em>15,11</em> }; // <em>line0の終点</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q; // <em>line0</em>とline1の交点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::<em>LineIntersection</em>(Q, <em>p0</em>, <em>p1</em>, p2, p3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(<em>p0</em>.x, <em>p0</em>.y, 0, 0, <em>p1.x</em>, <em>p1.y</em>, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // <em>線分line0</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(<em>p0</em>.x, <em>p0</em>.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "<em>p</em>0=(" + std::to_string((int)<em>p0</em>.x) + "," + std::to_string((int)<em>p0</em>.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(<em>p0</em>.x, <em>p0</em>.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <em><br>
        </em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 165, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 10, Q_String.c_str(), GetColor(255, 165, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？線分line0と線分line1の交点Qが表示されましたか?<br>
      レイキャストと線分どうしの交差判定は基礎となっている数式は共通だという実感が湧いたでしょうか。<br>
      つまり、2Dのレイキャストは裏側で外積crossを使って、高速に計算されているのです。 <br>
      <br>
    </a> <a id="mozTocId0014" class="mozTocH1">
      <h1>MyMathクラスで壁(線)に対する点の反射(線の終点の反射位置と交点)を求める</h1>
      <code>MyMath.h</code>を変更して線(壁)wall0と線分line1の交点とline1の反射点を関数LineReflectionで求められるようにしてみましょう。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp; &nbsp;(中略).....<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>/// &lt;summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// 壁wall0(start→end)に対する線line1(start→end)の反射位置を求める<br>
          &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="reflectPoint"&gt;壁から反射したポイント点がreturnされる&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="collisionPoint"&gt;壁に衝突したポイント点がreturnされる&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="wall0start"&gt;壁の起点wall0start&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="wall0end"&gt;壁の終点wall0end&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="line1start"&gt;線bの起点line1start&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="line1end"&gt;線bの終点line1end&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;線line0(start→end)が壁wall0に接触するか?&lt;/returns&gt;<br>
          &nbsp;&nbsp;&nbsp; static bool LineReflection(Vector2&amp; reflectPoint, Vector2&amp; collisionPoint,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 wall0start, Vector2 wall0end, Vector2 line1start, Vector2 line1end)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 wall0 = wall0end - wall0start;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 line1 = line1end - line1start;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 e0 = wall0.normalized(); // 壁(wall0start→wall0end)の単位ベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v01 = line1end - wall0start;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float cross_e0_v01 = cross(e0, v01);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = std::abs(cross_e0_v01); // |外積| (外積の絶対値をabsで求める)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 n; // 壁の法線ベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(cross_e0_v01 &lt; 0) // 外積がプラスかマイナスかで壁のサイドが変わるので法線ベクトルnの方向切替<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = Vector2(-wall0.y, wall0.x).normalized(); // 法線ベクトル (-y,x)の単位ベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = Vector2(wall0.y, -wall0.x).normalized(); // 法線ベクトル (y,-x)の単位ベクトル<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 壁wall0と線分line1が交差しているか調べ、その交点をcollisionPointに得る<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision = LineIntersection(collisionPoint, wall0start, wall0end, line1start, line1end);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reflectPoint = line1end + 2 * L * n; // 壁wall0(start→end)に対する線line1(start→end)の終点line1endの反射点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return isCollision; // 壁wall0と線分line1が交差するかをreturnする<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        };<br>
        <br>
        #endif </p>
      壁wall0と線line1が交差しているか？とその交点を求める処理は、先に作ってあった線と線の交差LineIntersectionを再利用しています。<br>
      なので、反射のキーとなる式は <b>「 反射点 = line1の終点 + 2 × L × 法線n 」</b>ですね。この式は3Dの反射でも使われている式です。<br>
      下図で上記コードの式との対応関係を確認してみてください。<br>
      <p> <img src="image/circle_line_collision5.png" alt=""></p>
      <br>
      <p><code>main.cpp</code>を変更して、壁(線)line0 に対する 線分line1の交点Q と line1の終点p3の反射点R を求めて表示してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 5,5 }; // line0の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,11 }; // line0の終点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q; // line0とline1の交点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Vector2 R; // line0を壁wall0とした場合のline1の終点p3の壁line0に対する反射点Rと交点Qを求める</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::<em>LineReflection(R, Q, p0, p1, p2, p3);</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 反射ベクトル(交点Q→反射点R)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision01)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(Q.x, Q.y, 0, 0, R.x, R.y, 0.8f, 1.0f, GetColor(255, 255, 0));</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <em><br>
        </em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<em><br>
        </em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 165, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 10, Q_String.c_str(), GetColor(255, 165, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.DrawPoint(R.x, R.y, 3, GetColor(255, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string R_String = "R=(" + std::to_string(R.x) + "," + std::to_string(R.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(R.x, R.y - 10, R_String.c_str(), GetColor(255, 255, 0));</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？壁(線)line0(wall0) に対する 線分line1の終点p3 の 反射点R と 交点Q が表示されましたか?<br>
      交点Qは先に作っておいた線と線の交点を求める関数LineIntersectionが再利用されています。<br>
      念のため、壁と線が交差しないときはどうなるかも実験しておきましょう。 <br>
      <br>
      <p><code>main.cpp</code>を変更して、壁(線)line0 と 線分line1が交差しない場合(t0 &lt; 0)を実験で表示してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ <em>11,9</em> }; // line0の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,11 }; // line0の終点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q; // line0とline1の交点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 R; // line0を壁wall0とした場合のline1の終点p3の壁line0に対する反射点Rと交点Qを求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineReflection(R, Q, p0, p1, p2, p3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 反射ベクトル(交点Q→反射点R)を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision01)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(Q.x, Q.y, 0, 0, R.x, R.y, 0.8f, 1.0f, GetColor(255, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 165, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 10, Q_String.c_str(), GetColor(255, 165, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(R.x, R.y, 3, GetColor(255, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string R_String = "R=(" + std::to_string(R.x) + "," + std::to_string(R.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(R.x, R.y - 10, R_String.c_str(), GetColor(255, 255, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？あーなるほど、壁(線)line0(wall0)が途切れている場合でも、「その延長線上に交点Qは求まり」 反射点R は「その交点Qに対する反射」として計算はされるんですね。<br>
      ということは、壁の長さがwall0startと逆方向に無限な場合は、(t0 &lt; 0)のときの当たり判定を許して、反射点を調べれば求められそうですね。<br>
      では、こんどは(1 &lt; t0)の場合も実験してみましょう。<br>
      <br>
      <p><code>main.cpp</code>を変更して、壁(線)line0 と 線分line1が交差しない場合(1 &lt; t0)を実験で表示してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ <em>5,5</em> }; // line0の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ <em>9,7</em> }; // line0の終点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q; // line0とline1の交点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 R; // line0を壁wall0とした場合のline1の終点p3の壁line0に対する反射点Rと交点Qを求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineReflection(R, Q, p0, p1, p2, p3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 反射ベクトル(交点Q→反射点R)を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision01)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(Q.x, Q.y, 0, 0, R.x, R.y, 0.8f, 1.0f, GetColor(255, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 165, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 10, Q_String.c_str(), GetColor(255, 165, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(R.x, R.y, 3, GetColor(255, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string R_String = "R=(" + std::to_string(R.x) + "," + std::to_string(R.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(R.x, R.y - 10, R_String.c_str(), GetColor(255, 255, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？はい、なるほど予感通り、壁(線)line0(wall0)が「終点end側(点p1)で」途切れている場合でも「その延長線上に交点Qは求まり」 反射点R は「その交点Qに対する反射」として計算されました。<br>
      ということは、壁の長さがwall0endから先の方向に無限な場合は、(1 &lt; t0)のときの当たり判定を許して、反射点を調べれば求められそうですね。<br>
      では、こんどは(t1 &lt; 0)の場合も実験してみましょう。<br>
      <br>
      <p><code>main.cpp</code>を変更して、壁(線)line0 と 線分line1が交差しない場合(t1 &lt; 0)を実験で表示してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 5,5 }; // line0の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ <em>15,11</em> }; // line0の終点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ <em>12,8</em> };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q; // line0とline1の交点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 R; // line0を壁wall0とした場合のline1の終点p3の壁line0に対する反射点Rと交点Qを求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineReflection(R, Q, p0, p1, p2, p3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 反射ベクトル(交点Q→反射点R)を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision01)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(Q.x, Q.y, 0, 0, R.x, R.y, 0.8f, 1.0f, GetColor(255, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 165, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 10, Q_String.c_str(), GetColor(255, 165, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(R.x, R.y, 3, GetColor(255, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string R_String = "R=(" + std::to_string(R.x) + "," + std::to_string(R.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(R.x, R.y - 10, R_String.c_str(), GetColor(255, 255, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？うーん、こんどはline1の飛んでいく方向が壁と逆の場合でも「飛んでいく方向と逆方向に交点Qは求まり」 反射点R は「壁を鏡にした飛んでいく位置」として計算されました。<br>
      うーむ鏡の国のボール(青)の飛んでいくベクトルが、(t1 &lt; 0)のときの当たり判定を許して、反射点を調べれば求められるようなイメージでしょうか。<br>
      では、こんどは(1 &lt; t1)の場合も実験してみましょう。<br>
      <br>
      <p><code>main.cpp</code>を変更して、壁(線)line0 と 線分line1が交差しない場合(1 &lt; t1)を実験で表示してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 5,5 }; // line0の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,11 }; // line0の終点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ <em>5,10</em> };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ <em>9,9</em> };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q; // line0とline1の交点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 R; // line0を壁wall0とした場合のline1の終点p3の壁line0に対する反射点Rと交点Qを求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineReflection(R, Q, p0, p1, p2, p3);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 反射ベクトル(交点Q→反射点R)を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision01)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(Q.x, Q.y, 0, 0, R.x, R.y, 0.8f, 1.0f, GetColor(255, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 165, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 10, Q_String.c_str(), GetColor(255, 165, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(R.x, R.y, 3, GetColor(255, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string R_String = "R=(" + std::to_string(R.x) + "," + std::to_string(R.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(R.x, R.y - 10, R_String.c_str(), GetColor(255, 255, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？うーん、なるほど、line1の「始点p2の青のボールが壁に当たらない場合も交点Qは求まり」 反射点R は「壁を鏡にした移動後のボール(緑)の鏡に映った位置(黄)」でしょうか。<br>
      うーむ鏡に映った線分line0の鏡像が、(1 &lt; t1)のときの当たり判定を許して、反射点を調べれば求められるようなイメージでしょうか(うーん使いどころがあるかは謎)。<br>
      t0、t1について実験をすると、反射点はなかなか奥が深いですね。<br>
      実際に反射を求めるときには、衝突するかのisCollision01とセットで使うのが必須ですね。そうしないと反射していないときに壁の向こう側にボールがめり込んじゃいますからね。<br>
      <br>
    </a> <a id="mozTocId0015" class="mozTocH1">
      <h1>MyMathクラスで壁(線)に対する円(半径r)の反射(円の中心点の反射位置と円の反射する瞬間の中心点)を求める</h1>
      <code>MyMath.h</code>を変更して線(壁)wall0と線分line1の交点とline1endを中心とする半径rの円の反射点を関数LineReflectionで求められるようにしてみましょう。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp; &nbsp;(中略).....<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 壁wall0(start→end)に対する線line1(start→end)の反射位置を求める<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="reflectPoint"&gt;壁から反射したポイント点がreturnされる&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="collisionPoint"&gt;壁に衝突したポイント点がreturnされる&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="wall0start"&gt;壁の起点wall0start&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="wall0end"&gt;壁の終点wall0end&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="line1start"&gt;線bの起点line1start&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="line1end"&gt;線bの終点line1end&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; <em>/// &lt;param name="r"&gt;点line1startが点じゃなく円の場合はr=円の半径とするr=0なら点扱い&lt;/param&gt;</em><br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;線line0(start→end)が壁wall0に接触するか?&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool LineReflection(Vector2&amp; reflectPoint, Vector2&amp; collisionPoint,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 wall0start, Vector2 wall0end, Vector2 line1start, Vector2 line1end<em>, float r = 0</em>)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 wall0 = wall0end - wall0start;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 line1 = line1end - line1start;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 e0 = wall0.normalized(); // 壁(wall0start→wall0end)の単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v01 = line1end - wall0start;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float cross_e0_v01 = cross(e0, v01);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = <em>r + </em>std::abs(cross_e0_v01); // |外積| (外積の絶対値をabsで求める)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 n; // 壁の法線ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(cross_e0_v01 &lt; 0) // 外積がプラスかマイナスかで壁のサイドが変わるので法線ベクトルnの方向切替<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = Vector2(-wall0.y, wall0.x).normalized(); // 法線ベクトル (-y,x)の単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = Vector2(wall0.y, -wall0.x).normalized(); // 法線ベクトル (y,-x)の単位ベクトル<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 壁wall0と線分line1が交差しているか調べ、その交点をcollisionPointに得る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision = LineIntersection(collisionPoint, wall0start, wall0end, line1start, line1end);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if(r &gt; 0) // 半径が0以上のときは球の場合として衝突点を求めなおす<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 点(r==0)じゃなくて半径rが0じゃない円の反射計算のときだけ円の衝突点を計算<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dot_line1_n = dot(line1, n); // 内積 line1・n<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t = L / dot_line1_n;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collisionPoint = line1end + line1 * t; // 円の場合の衝突点を求める<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reflectPoint = line1end + 2 * L * n; // 壁wall0(start→end)に対する線line1(start→end)の終点line1endの反射点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return isCollision; // 壁wall0と線分line1が交差するかをreturnする<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        #endif </p>
      下図で上記コードの式との対応関係を確認してみてください。半径rが0じゃないときに衝突点Pt(collisionPoint)をline1と法線nの内積を使って求めなおしています。<br>
      注意点として、isCollisionは線と線の交差するかの判定を使っているので、厳密にはline0の始点P0と終点P1付近で線としては交差してないけど円と点が触れているときの判定はバグっちゃいそうですね。<br>
      <p> <img src="image/circle_line_collision6.png" alt=""></p>
      <br>
      <p><code>main.cpp</code>を変更して、壁(線)line0 に対する 線分line1方向に進む円(半径r)の衝突した瞬間の円の中心Q と 反射した円の中心点R を求めて表示してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 5,5 }; // line0の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,11 }; // line0の終点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ <em>15,6</em> };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>float r = 1.0f; // 円の半径r 始点p2が円(青ボール)の場合を想定</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q; // line0とline1の交点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 R; // line0を壁wall0とした場合のline1の終点p3の壁line0に対する反射点Rと交点Qを求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineReflection(R, Q, p0, p1, p2, p3<em>, r</em>);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.DrawCircle(p2.x, p2.y, r, GetColor(0, 0, 255), FALSE); // 円p2(始点)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(Q.x, Q.y, r, GetColor(255, 165, 0), FALSE); // 円Q(衝突位置)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(R.x, R.y, r, GetColor(255, 255, 0), FALSE); // 円R(反射位置)を描く</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 反射ベクトル(交点Q→反射点R)を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision01)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(Q.x, Q.y, 0, 0, R.x, R.y, 0.8f, 1.0f, GetColor(255, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 165, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 10, Q_String.c_str(), GetColor(255, 165, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(R.x, R.y, 3, GetColor(255, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string R_String = "R=(" + std::to_string(R.x) + "," + std::to_string(R.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(R.x, R.y - 10, R_String.c_str(), GetColor(255, 255, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？青ボール(始点p2)が壁(線)line0(wall0) に反射(衝突点Q:だいだい色ボール)して 反射点R(黄色ボール)に飛んでいく様子 が表示されましたか?<br>
      厳密には、isCollision01は線と線の交点を求める関数LineIntersectionが再利用されているため、壁始点p0 と 壁終点p1 付近で判定がバグります。<br>
      壁始点p0と壁終点p1の判定は別途考える必要があります。 <br>
      <br>
      <br>
    </a> <a id="mozTocId0016" class="mozTocH1">
      <h1>MyMathクラスでレイ光線と円(半径r)の当たり判定と交点を求める</h1>
      <code>MyMath.h</code>を変更してレイ光線ray0と円(中心点:pc 半径:r)の当たり判定と交点を関数RayCircleCollisionで求められるようにしてみましょう。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp; &nbsp;(中略).....<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>/// &lt;summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// 光線ray0と円(中心:pc 半径:r)が重なっているかを調べる<br>
          &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="result1"&gt;光線ray0と円の交点1(最初に交わる点)&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="result2"&gt;光線ray0と円の交点2(後ろ側で交わる点)&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="result_isInsideCircle"&gt;レイの始点が円の内側にあるかの結果がtrueかfalseで求まる&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="ray0start"&gt;光線ray0の始点&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="ray0dir"&gt;光線ray0の方向ベクトル&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="pc"&gt;円の中心点の位置ベクトル&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="r"&gt;円の半径&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;光線ray0と円が交差しているならtrue,してないならfalse&lt;/returns&gt;<br>
          &nbsp;&nbsp;&nbsp; static bool RayCircleCollision(Vector2&amp; result1, Vector2&amp; result2, bool&amp; result_isInsideCircle,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0start, Vector2 ray0dir, Vector2 pc, float r)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 vc0 = ray0start - pc; // 円の中心pc→レイの始点ray0startへ向かうベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 e0 = ray0dir.normalized(); // 光線ray0方向dirの単位ベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float vc0_dot_e0 = dot(vc0, e0);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float vc0_sqrMag = vc0.sqrMagnitude(); //|vc0|の2乗<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dif_vc0_vc0_r_r = vc0_sqrMag - r * r; //↓|vc0|の2乗 - rの2乗<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float D = vc0_dot_e0 * vc0_dot_e0 - dif_vc0_vc0_r_r;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dif_vc0_vc0_r_r &lt; 0) // |vc0|の2乗 - rの2乗 &lt; 0のときは円の内側に交点ray0の始点がある<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result_isInsideCircle = true; // レイの始点が円の内側なのでtrue判定を返す<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result_isInsideCircle = false; // レイの始点が円の外側なのでfalse判定を返す<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (D &lt; 0) return false; // D &lt; 0なら光線ray0は円とぶつからない<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float sqrD = std::sqrtf(D); // √D<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t1 = -vc0_dot_e0 - sqrD;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t2 = -vc0_dot_e0 + sqrD;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dif_vc0_vc0_r_r &lt; 0) // |vc0|の2乗 - rの2乗 &lt; 0のときは円の内側に交点ray0の始点があるので<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 円の内側のときは t1 と t2 の±をひっくり返す<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = -vc0_dot_e0 + sqrD; // t1とt2の＋と－をひっくり返す(とresult1が最初に交わる点扱いになる)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t2 = -vc0_dot_e0 - sqrD;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result1 = ray0start + t1 * e0; // D == 0 のときは1,2両方同じになり交点は一つ<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result2 = ray0start + t2 * e0;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // 光線ray0は円と交わる(D &gt; 0なら2点交わり、D == 0なら1点交わる)<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        };<br>
        <br>
        #endif </p>
      下図で上記コードの式との対応関係を確認してみてください。<b>dif_vc0_vc0_r_r &lt; 0</b> つまり<b>|vc0|の2乗が半径rの2乗より小さい(円の内側)</b>ときは <b>t1 と t2 の√の±をひっくり返しています</b>。<br>
      <b>t1 の－√D と +√D の－のほうが最初に円と交わる点</b>なのですが、<b>円の内側の場合</b>は<b>+√Dのほうが最初に交わる点</b>に変わっちゃうので、そのために±をひっくり返しています。<br>
      <p> <img src="image/circle_line_collision7.png" alt=""></p>
      <br>
      <p><code>main.cpp</code>を一旦、まっさらにリセットしましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>// line0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 5,5 }; // line0の始点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,11 }; // line0の終点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,6 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 1.0f; // 円の半径r 始点p2が円(青ボール)の場合を想定<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q; // line0とline1の交点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 R; // line0を壁wall0とした場合のline1の終点p3の壁line0に対する反射点Rと交点Qを求める<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineReflection(R, Q, p0, p1, p2, p3, r);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(p2.x, p2.y, r, GetColor(0, 0, 255), FALSE); // 円p2(始点)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(Q.x, Q.y, r, GetColor(255, 165, 0), FALSE); // 円Q(衝突位置)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(R.x, R.y, r, GetColor(255, 255, 0), FALSE); // 円R(反射位置)を描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 反射ベクトル(交点Q→反射点R)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision01)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(Q.x, Q.y, 0, 0, R.x, R.y, 0.8f, 1.0f, GetColor(255, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 165, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 10, Q_String.c_str(), GetColor(255, 165, 0));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(R.x, R.y, 3, GetColor(255, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string R_String = "R=(" + std::to_string(R.x) + "," + std::to_string(R.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(R.x, R.y - 10, R_String.c_str(), GetColor(255, 255, 0));</u><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      <br>
      <p><code>main.cpp</code>を変更して、光線ray0 と 円(中心点:pc 半径:r)の当たり判定 と衝突した 交点Q1,Q2 を求めて表示してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// ray0光線レイ<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0pos{ 1,2 }; // レイ光線の始点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0dir{ 2,1 }; // レイ光線の方向<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc{ 5,5 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 2.0f; // 円の半径r<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isInsideCircle = false; // レイの始点が円の内側のときはtrueになる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q1, Q2; // 光線ray0と円の交点(Q1が最初に円とぶつかる点、Q2が後ろ側でぶつかる点)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::RayCircleCollision(Q1, Q2, isInsideCircle, ray0pos, ray0dir, pc, r);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc.x, pc.y, r, GetColor(0, 0, 255), FALSE); // 円(中心点:pc)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光線ray0を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(ray0pos.x, ray0pos.y, 0, 0, ray0pos.x + ray0dir.x, ray0pos.y + ray0dir.y, 0.8f, 1.0f, <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // レイ光線の始点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(ray0pos.x, ray0pos.y, 3, GetColor(255, 165, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string ray0_String = "ray0=(" + std::to_string((int)ray0pos.x) + "," + std::to_string((int)ray0pos.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(ray0pos.x, ray0pos.y, ray0_String.c_str(), GetColor(255, 165, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision01)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 交点Q1を描く(最初に交わる点)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q1.x, Q1.y, 3, GetColor(255, 165, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q1_String = "Q1=(" + std::to_string(Q1.x) + "," + std::to_string(Q1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q1.x, Q1.y-5, Q1_String.c_str(), GetColor(255, 165, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 交点Q2を描く(後ろ側で交わる点)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Q2 != Q1) // (Q2 が Q1と違う点ならば)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q2.x, Q2.y, 3, GetColor(255, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q2_String = "Q2=(" + std::to_string(Q2.x) + "," + std::to_string(Q2.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q2.x, Q2.y-10, Q2_String.c_str(), GetColor(255, 255, 0));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？光線ray0の方向に円があったときに、矢印が赤色に表示されて、最初に交わる交点Q1がオレンジ色に、後ろ側で交わる交点Q2が黄色に 表示されましたか?<br>
      つぎに、円の内側にray0の始点があるときの実験もしておきましょう。 <br>
      <br>
      <br>
      <br>
      <p><code>main.cpp</code>の光線ray0の始点を変更して、光線ray0の始点 が 円の内側にあるときに 光線の始点が水色で表示されるか、実験表示してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ray0光線レイ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0pos{ <em>1,2</em> }; // レイ光線の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0dir{ 2,1 }; // レイ光線の方向<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc{ 5,5 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 2.0f; // 円の半径r<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isInsideCircle = false; // レイの始点が円の内側のときはtrueになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q1, Q2; // 光線ray0と円の交点(Q1が最初に円とぶつかる点、Q2が後ろ側でぶつかる点)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::RayCircleCollision(Q1, Q2, isInsideCircle, ray0pos, ray0dir, pc, r);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc.x, pc.y, r, GetColor(0, 0, 255), FALSE); // 円(中心点:pc)を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光線ray0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(ray0pos.x, ray0pos.y, 0, 0, ray0pos.x + ray0dir.x, ray0pos.y + ray0dir.y, 0.8f, 1.0f, <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // レイ光線の始点<em>(円の外側だったらオレンジ、円の内側だったら水色になる)</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(ray0pos.x, ray0pos.y, 3, <em>(isInsideCircle)? GetColor(0, 255, 255) : </em>GetColor(255, 165, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string ray0_String = "ray0=(" + std::to_string((int)ray0pos.x) + "," + std::to_string((int)ray0pos.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(ray0pos.x, ray0pos.y, ray0_String.c_str(), <em>(isInsideCircle) ? GetColor(0, 255, 255) : </em>GetColor(255, 165, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision01)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 交点Q1を描く(最初に交わる点)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q1.x, Q1.y, 3, GetColor(255, 165, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q1_String = "Q1=(" + std::to_string(Q1.x) + "," + std::to_string(Q1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q1.x, Q1.y-5, Q1_String.c_str(), GetColor(255, 165, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 交点Q2を描く(後ろ側で交わる点)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Q2 != Q1) // (Q2 が Q1と違う点ならば)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q2.x, Q2.y, 3, GetColor(255, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q2_String = "Q2=(" + std::to_string(Q2.x) + "," + std::to_string(Q2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q2.x, Q2.y-10, Q2_String.c_str(), GetColor(255, 255, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？光線ray0の始点が円の内側にあるときに、始点が水色で表示され、光線ray0の方向に円があったときに、最初に交わる交点Q1がオレンジ色に 表示されましたか?<br>
      厳密には、円の内側にray0の始点があるときには、光線は黄色の点Q2とは当たっていない(始点より後ろ側にある)ので、交点Q2は isInsideCircle == false かどうかで表示させないようにしたほうがよいでしょう。<br>
      <br>
      <p><code>main.cpp</code>を変更して、光線ray0の始点 が 円の内側にあるときには 交点Q2は表示しないようにしてみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ray0光線レイ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0pos{ 1,2 }; // レイ光線の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0dir{ 2,1 }; // レイ光線の方向<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc{ 5,5 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 2.0f; // 円の半径r<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isInsideCircle = false; // レイの始点が円の内側のときはtrueになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q1, Q2; // 光線ray0と円の交点(Q1が最初に円とぶつかる点、Q2が後ろ側でぶつかる点)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::RayCircleCollision(Q1, Q2, isInsideCircle, ray0pos, ray0dir, pc, r);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc.x, pc.y, r, GetColor(0, 0, 255), FALSE); // 円(中心点:pc)を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光線ray0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(ray0pos.x, ray0pos.y, 0, 0, ray0pos.x + ray0dir.x, ray0pos.y + ray0dir.y, 0.8f, 1.0f, <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // レイ光線の始点(円の外側だったらオレンジ、円の内側だったら水色になる)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(ray0pos.x, ray0pos.y, 3, (isInsideCircle)? GetColor(0, 255, 255) : GetColor(255, 165, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string ray0_String = "ray0=(" + std::to_string((int)ray0pos.x) + "," + std::to_string((int)ray0pos.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(ray0pos.x, ray0pos.y, ray0_String.c_str(), (isInsideCircle) ? GetColor(0, 255, 255) : GetColor(255, 165, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision01)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 交点Q1を描く(最初に交わる点)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q1.x, Q1.y, 3, GetColor(255, 165, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q1_String = "Q1=(" + std::to_string(Q1.x) + "," + std::to_string(Q1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q1.x, Q1.y-5, Q1_String.c_str(), GetColor(255, 165, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 交点Q2を描く(後ろ側で交わる点)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Q2 != Q1<em> &amp;&amp; isInsideCircle == false</em>) // (Q2 が Q1と違う点<em>で光線の始点が円の内側にはないとき</em>)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q2.x, Q2.y, 3, GetColor(255, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q2_String = "Q2=(" + std::to_string(Q2.x) + "," + std::to_string(Q2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q2.x, Q2.y-10, Q2_String.c_str(), GetColor(255, 255, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？これで、円の内側に光線ray0の始点がある場合でも、正しくレイと円の当たり判定ができるようになりました。<br>
      ゲームで使う分には、基本は 交点Q1(result1) を使うようにしていれば、円とレイの当たり判定としては十分かもしれません。<br>
      (交点Q2をあえて使うとしたら、銃で撃たれて、貫通したときのような表現のときに使うようなケースがあるかもしれません)<br>
      <br>
      <br>
      <br>
    </a> <a id="mozTocId0017" class="mozTocH1">
      <h1>Matrix3x3で点を行列で平行移動(translate)させる</h1>
      <code>Matrix3x3.hを新規作成</code>して3×3の配列[3][3]を内部に持つ行列を定義しましょう。<br>
      <p class="source">#ifndef MATRIX3X3_H_<br>
        #define MATRIX3X3_H_<br>
        <br>
        #include "Vector2.h" // 2Dのベクトル<br>
        <br>
        #include &lt;ostream&gt;<br>
        #include &lt;cmath&gt;<br>
        <br>
        // 行列(3×3)　2Dにも3Dにも使う<br>
        struct Matrix3x3<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 行列[行][列]の順 (行優先) https://qiita.com/suzuryo3893/items/9e543cdf8bc64dc7002a<br>
        &nbsp;&nbsp;&nbsp; union<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m[3][3]{}; // 3×3の配列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;std::array&lt;float, 3&gt;, 3&gt; mArr; // std::array型ベースなら少し便利<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(float*)キャストすればデータ配列 m の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator float* () const { return (float*)m; }<br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(const float*)キャストすればデータ配列 m の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator const float* () const { return (const float*)m; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3() = default;<br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3(float m11, float m12, float m13,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m21, float m22, float m23,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m31, float m32, float m33)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : m{ {m11, m12, m13}, {m21, m22, m23}, { m31, m32, m33} } {};<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ (std::arrayで初期化版)<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3(std::array&lt;std::array&lt;float, 3&gt;, 3&gt;&amp; matArr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m[i][j] = matArr[i][j];<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        <br>
        // 行列の出力<br>
        inline std::ostream&amp; operator &lt;&lt; (std::ostream&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; right.m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j &lt; 3 - 1) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; " ";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; std::endl;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return left;<br>
        };<br>
        <br>
        <br>
        #endif<br>
      </p>
      基本は<b>float m[3][3]{}; // 3×3の配列</b> のように[3][3]の配列をベースにした構造体です。<br>
      これに足し算や引き算や掛け算や割り算などの基本計算をoperatorで定義して行列の計算ができるように改造していきます。<br>
      <br>
      <br>
      <code>Matrix3x3.h</code>を変更し、operatorをオーバーロードして行列の足し算や引き算や掛け算や割り算などの基本計算を定義しましょう。<br>
      <p class="source">#ifndef MATRIX3X3_H_<br>
        #define MATRIX3X3_H_<br>
        <br>
        #include "Vector2.h" // 2Dのベクトル<br>
        <br>
        #include &lt;ostream&gt;<br>
        #include &lt;cmath&gt;<br>
        <br>
        // 行列(3×3)　2Dにも3Dにも使う<br>
        struct Matrix3x3<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 行列[行][列]の順 (行優先) https://qiita.com/suzuryo3893/items/9e543cdf8bc64dc7002a<br>
        &nbsp;&nbsp;&nbsp; union<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m[3][3]{}; // 3×3の配列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;std::array&lt;float, 3&gt;, 3&gt; mArr; // std::array型ベースなら少し便利<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(float*)キャストすればデータ配列 m の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator float* () const { return (float*)m; }<br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(const float*)キャストすればデータ配列 m の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator const float* () const { return (const float*)m; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3() = default;<br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3(float m11, float m12, float m13,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m21, float m22, float m23,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m31, float m32, float m33)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : m{ {m11, m12, m13}, {m21, m22, m23}, { m31, m32, m33} } {};<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ (std::arrayで初期化版)<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3(std::array&lt;std::array&lt;float, 3&gt;, 3&gt;&amp; matArr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m[i][j] = matArr[i][j];<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>/*-----　演算子オーバーロード　-----*/<br>
          <br>
          &nbsp;&nbsp;&nbsp; inline Matrix3x3 operator + () const { return *this; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // マイナスの符号を単体の行列につけたとき<br>
          &nbsp;&nbsp;&nbsp; inline Matrix3x3 operator -() const<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = -this-&gt;m[i][j];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
          &nbsp;&nbsp;&nbsp; };<br>
          <br>
          &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator += (const Matrix3x3&amp; add)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] + add.m[i][j];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator -= (const Matrix3x3&amp; sub)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] - sub.m[i][j];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator *= (const Matrix3x3&amp; mul)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 tmp; // 値を一時保管<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp.m[i][j] = this-&gt;m[i][j];<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = 0;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int k = 0; k &lt; 3; ++k)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] += tmp.m[i][k] * mul.m[k][j];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator *= (float multiply_num)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] * multiply_num;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator /= (float divide_num)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] / divide_num;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 一致演算子 行列の中身が全部一致するか 一つでも違えばfalse<br>
          &nbsp;&nbsp;&nbsp; inline bool operator == (const Matrix3x3&amp; other)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;m[i][j] != other.m[i][j]) return false;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; true;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 不一致演算子<br>
          &nbsp;&nbsp;&nbsp; inline bool operator != (const Matrix3x3&amp; other)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(*this == other);<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        };<br>
        <br>
        <em>// 行列の加算<br>
          inline Matrix3x3 operator + (const Matrix3x3&amp; left, const Matrix3x3&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
          &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left.m[i][j] + right.m[i][j];<br>
          <br>
          &nbsp;&nbsp;&nbsp; return result;<br>
          };<br>
          <br>
          // 行列の減算<br>
          inline Matrix3x3 operator - (const Matrix3x3&amp; left, const Matrix3x3&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
          &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left.m[i][j] - right.m[i][j];<br>
          <br>
          &nbsp;&nbsp;&nbsp; return result;<br>
          };<br>
          <br>
          // 行列のスカラー倍 (スカラー×行列）<br>
          inline Matrix3x3 operator * (float left, const Matrix3x3&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
          &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left * right.m[i][j];<br>
          <br>
          &nbsp;&nbsp;&nbsp; return result;<br>
          };<br>
          <br>
          // 行列のスカラー倍 (行列×スカラー）<br>
          inline Matrix3x3 operator * (const Matrix3x3&amp; left, float right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
          &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left.m[i][j] * right;<br>
          <br>
          &nbsp;&nbsp;&nbsp; return result;<br>
          };<br>
          <br>
          // 行列の積<br>
          inline Matrix3x3 operator * (const Matrix3x3&amp; left, const Matrix3x3&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
          &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = 0;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int k = 0; k &lt; 3; ++k)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] += left.m[i][k] * right.m[k][j];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; return result;<br>
          };<br>
          <br>
          //[2D]ベクトルと行列の積<br>
          inline Vector2 operator * (const Vector2&amp; left, const Matrix3x3&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; float x = left.x * right.m[0][0] + left.y * right.m[1][0] + right.m[2][0];<br>
          &nbsp;&nbsp;&nbsp; float y = left.x * right.m[0][1] + left.y * right.m[1][1] + right.m[2][1];<br>
          &nbsp;&nbsp;&nbsp; return Vector2{ x, y };<br>
          };<br>
          <br>
          inline const Matrix3x3 operator / (const Matrix3x3&amp; left, const float right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; return left * (1.0f / right);<br>
          }</em><br>
        <br>
        // 行列の出力<br>
        inline std::ostream&amp; operator &lt;&lt; (std::ostream&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; right.m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j &lt; 3 - 1) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; " ";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; std::endl;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return left;<br>
        };<br>
        <br>
        <br>
        #endif<br>
      </p>
      これで行列の足し算や引き算や掛け算や割り算などの基本計算はできるようになりました。<br>
      さらに、<b>数字における 0 や 1 などの行列版</b>として、<b>ゼロ行列(zero) や 単位行列E(identity:アイデンティティ)</b>も追加しておきましょう。<br>
      <br>
      <code>Matrix3x3.h</code>を変更し、operatorをオーバーロードして行列の足し算や引き算や掛け算や割り算などの基本計算を定義しましょう。<br>
      <p class="source">#ifndef MATRIX3X3_H_<br>
        #define MATRIX3X3_H_<br>
        <br>
        #include "Vector2.h" // 2Dのベクトル<br>
        <br>
        #include &lt;ostream&gt;<br>
        #include &lt;cmath&gt;<br>
        <br>
        // 行列(3×3)　2Dにも3Dにも使う<br>
        struct Matrix3x3<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 行列[行][列]の順 (行優先) https://qiita.com/suzuryo3893/items/9e543cdf8bc64dc7002a<br>
        &nbsp;&nbsp;&nbsp; union<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m[3][3]{}; // 3×3の配列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;std::array&lt;float, 3&gt;, 3&gt; mArr; // std::array型ベースなら少し便利<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(float*)キャストすればデータ配列 m の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator float* () const { return (float*)m; }<br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(const float*)キャストすればデータ配列 m の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator const float* () const { return (const float*)m; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3() = default;<br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3(float m11, float m12, float m13,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m21, float m22, float m23,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m31, float m32, float m33)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : m{ {m11, m12, m13}, {m21, m22, m23}, { m31, m32, m33} } {};<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ (std::arrayで初期化版)<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3(std::array&lt;std::array&lt;float, 3&gt;, 3&gt;&amp; matArr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m[i][j] = matArr[i][j];<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>// ゼロ行列を返す<br>
          &nbsp;&nbsp;&nbsp; static Matrix3x3 zero()<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Matrix3x3{ 0.0f, 0.0f, 0.0f,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 0.0f,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 0.0f };<br>
          &nbsp;&nbsp;&nbsp; };<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 単位行列を返す<br>
          &nbsp;&nbsp;&nbsp; static Matrix3x3 identity()<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Matrix3x3{ 1.0f, 0.0f, 0.0f,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 1.0f, 0.0f,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 1.0f };<br>
          &nbsp;&nbsp;&nbsp; };</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; /*-----　演算子オーバーロード　-----*/<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3 operator + () const { return *this; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // マイナスの符号を単体の行列につけたとき<br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3 operator -() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = -this-&gt;m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator += (const Matrix3x3&amp; add)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] + add.m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator -= (const Matrix3x3&amp; sub)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] - sub.m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator *= (const Matrix3x3&amp; mul)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 tmp; // 値を一時保管<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp.m[i][j] = this-&gt;m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int k = 0; k &lt; 3; ++k)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] += tmp.m[i][k] * mul.m[k][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator *= (float multiply_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] * multiply_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator /= (float divide_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] / divide_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 一致演算子 行列の中身が全部一致するか 一つでも違えばfalse<br>
        &nbsp;&nbsp;&nbsp; inline bool operator == (const Matrix3x3&amp; other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;m[i][j] != other.m[i][j]) return false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 不一致演算子<br>
        &nbsp;&nbsp;&nbsp; inline bool operator != (const Matrix3x3&amp; other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(*this == other);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        // 行列の加算<br>
        inline Matrix3x3 operator + (const Matrix3x3&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left.m[i][j] + right.m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列の減算<br>
        inline Matrix3x3 operator - (const Matrix3x3&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left.m[i][j] - right.m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列のスカラー倍 (スカラー×行列）<br>
        inline Matrix3x3 operator * (float left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left * right.m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列のスカラー倍 (行列×スカラー）<br>
        inline Matrix3x3 operator * (const Matrix3x3&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left.m[i][j] * right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列の積<br>
        inline Matrix3x3 operator * (const Matrix3x3&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int k = 0; k &lt; 3; ++k)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] += left.m[i][k] * right.m[k][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        //[2D]ベクトルと行列の積<br>
        inline Vector2 operator * (const Vector2&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float x = left.x * right.m[0][0] + left.y * right.m[1][0] + right.m[2][0];<br>
        &nbsp;&nbsp;&nbsp; float y = left.x * right.m[0][1] + left.y * right.m[1][1] + right.m[2][1];<br>
        &nbsp;&nbsp;&nbsp; return Vector2{ x, y };<br>
        };<br>
        <br>
        inline const Matrix3x3 operator / (const Matrix3x3&amp; left, const float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return left * (1.0f / right);<br>
        }<br>
        <br>
        // 行列の出力<br>
        inline std::ostream&amp; operator &lt;&lt; (std::ostream&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; right.m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j &lt; 3 - 1) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; " ";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; std::endl;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return left;<br>
        };<br>
        <br>
        <br>
        #endif<br>
      </p>
      これで行列の基本計算は万全になりました。<br>
      それではためしに、<b>点(位置ベクトル) に 平行移動行列 を 掛け算</b>して、<b>点の位置を行列の計算を通して平行移動</b>させてみましょう。<br>
      <br>
      <p><code>main.cpp</code>を一旦、きれいにまっさらにリセットしましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>// ray0光線レイ<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0pos{ 1,2 }; // レイ光線の始点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0dir{ 2,1 }; // レイ光線の方向<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc{ 5,5 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 2.0f; // 円の半径r<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isInsideCircle = false; // レイの始点が円の内側のときはtrueになる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q1, Q2; // 光線ray0と円の交点(Q1が最初に円とぶつかる点、Q2が後ろ側でぶつかる点)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::RayCircleCollision(Q1, Q2, isInsideCircle, ray0pos, ray0dir, pc, r);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc.x, pc.y, r, GetColor(0, 0, 255), FALSE); // 円(中心点:pc)を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光線ray0を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(ray0pos.x, ray0pos.y, 0, 0, ray0pos.x + ray0dir.x, ray0pos.y + ray0dir.y, 0.8f, 1.0f, <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // レイ光線の始点(円の外側だったらオレンジ、円の内側だったら水色になる)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(ray0pos.x, ray0pos.y, 3, (isInsideCircle)? GetColor(0, 255, 255) : GetColor(255, 165, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string ray0_String = "ray0=(" + std::to_string((int)ray0pos.x) + "," + std::to_string((int)ray0pos.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(ray0pos.x, ray0pos.y, ray0_String.c_str(), (isInsideCircle) ? GetColor(0, 255, 255) : GetColor(255, 165, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision01)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 交点Q1を描く(最初に交わる点)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q1.x, Q1.y, 3, GetColor(255, 165, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q1_String = "Q1=(" + std::to_string(Q1.x) + "," + std::to_string(Q1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q1.x, Q1.y-5, Q1_String.c_str(), GetColor(255, 165, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 交点Q2を描く(後ろ側で交わる点)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Q2 != Q1 &amp;&amp; isInsideCircle == false) // (Q2 が Q1と違う点で光線の始点が円の内側にはないとき)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q2.x, Q2.y, 3, GetColor(255, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q2_String = "Q2=(" + std::to_string(Q2.x) + "," + std::to_string(Q2.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q2.x, Q2.y-10, Q2_String.c_str(), GetColor(255, 255, 0));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      <p><code>main.cpp</code>を変更して、点p0{1,1} を <b>平行移動行列(translate:トランスレート)</b> で x方向に+2 y方向に+3 平行移動してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        <em>#include "Matrix3x3.h"</em><br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Vector2 p0{ 1,1 }; // 点p0<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 translate{ 1,0,0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,1,0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>2,3</b>,1 }; // 平行移動行列<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1 = p0 * translate; // 点p0×translate (平行移動行列を右から掛け算)すると平行移動する<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 矢印p0→p1を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, GetColor(255, 255, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p0を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 255, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 255, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(255, 0, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(255, 0, 0));</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？<b>行列の左下の方の 2,3 の数字</b>が効いて、<b>点p0{1,1} が {+2,+3} 移動して { 1+2, 1+3 } = { 3,4 }に移動</b>したでしょうか？<br>
      では、今度はこの数字を{ +4, +5 }に変えて実験してみましょう。<br>
      <br>
      <p><code>main.cpp</code>を変更して、点p0{1,1} を 平行移動行列(translate:トランスレート) で <b>x方向に+4 y方向に+5 平行移動</b>してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "Matrix3x3.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 1,1 }; // 点p0<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 translate{ 1,0,0,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,1,0,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>4,5</em>,1 }; // 平行移動行列<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1 = p0 * translate; // 点p0×translate (平行移動行列を右から掛け算)すると平行移動する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 矢印p0→p1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？<b>こんどは行列の左下の方の 4,5 の数字</b>が効いて、<b>点p0{1,1} が {+4,+5} 移動して { 1+4, 1+5 } = { 5,6 }に移動</b>したでしょうか？<br>
      このように3×3の行列の<b>左下の2か所は「平行移動成分」</b>となっていますので、この[2][0]、[2][1]すなわち2行目0列、2行目1列の数字を取り出したり書き換えたりすれば、<br>
      平行移動する移動先を操作することができるのです。このように行列の各箇所にはゲームを描画する際に、<b>点がどのように移動するかなどの数値情報の「成分」</b>が入っているわけです。<br>
      ただし、要注意なのは、<b>DXライブラリは「DirectX」をベースにした3D行列</b>での描画を採用しています(UnityもDirectX系)が、<br>
      ネット上には3D描画行列の例として<b>「OpenGL系」をベースにした3D行列</b>でゲームを作成している例も沢山載っています。<br>
      この<b>「OpenGL系」をベースにした3D行列の場合は「行と列が逆になります！！」</b>ので以下のような行列が平行移動の行列となってしまいます。<br>
      <p class="source"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 translate{ 1,0,<b>3</b>,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,1,<b>4</b>,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,1 }; // 平行移動行列{+3,+4}(OpenGL系)<br>
      </p>
      はい、位置が<b>斜め方向 1,1,1 を境にして逆</b>ですね。<br>
      このように、<b>「DirectX」をベースにした3D行列</b>を<b>「OpenGL系」をベースにした3D行列</b>に使うためには<b>数字の位置の「転置(tranpose:トランポーズ)」</b>が必要になります。<br>
      つまり、計算の過程で数値の位置を斜め方向に鏡のように逆にする「転置」の処理が必要になることがあります。<br>
      このために、Matrix3x3.hに<b>「転置」処理としてtranspose関数も準備</b>しておきましょう。<br>
      <br>
      <code>Matrix3x3.h</code>を変更し、<b>転置処理をするtranspose関数を定義</b>しましょう。<br>
      ついでに毎回、手打ちで平行移動行列を定義しなくて済むように<b>平行移動行列を返すtranslate関数(DirectX系対応ver.)も定義</b>して便利にしておきましょう。<br>
      <p class="source">#ifndef MATRIX3X3_H_<br>
        #define MATRIX3X3_H_<br>
        <br>
        #include "Vector2.h" // 2Dのベクトル<br>
        <br>
        #include &lt;ostream&gt;<br>
        #include &lt;cmath&gt;<br>
        <br>
        // 行列(3×3)　2Dにも3Dにも使う<br>
        struct Matrix3x3<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 行列[行][列]の順 (行優先) https://qiita.com/suzuryo3893/items/9e543cdf8bc64dc7002a<br>
        &nbsp;&nbsp;&nbsp; union<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m[3][3]{}; // 3×3の配列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;std::array&lt;float, 3&gt;, 3&gt; mArr; // std::array型ベースなら少し便利<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(float*)キャストすればデータ配列 m の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator float* () const { return (float*)m; }<br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(const float*)キャストすればデータ配列 m の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator const float* () const { return (const float*)m; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3() = default;<br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3(float m11, float m12, float m13,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m21, float m22, float m23,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m31, float m32, float m33)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : m{ {m11, m12, m13}, {m21, m22, m23}, { m31, m32, m33} } {};<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ (std::arrayで初期化版)<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3(std::array&lt;std::array&lt;float, 3&gt;, 3&gt;&amp; matArr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m[i][j] = matArr[i][j];<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ゼロ行列を返す<br>
        &nbsp;&nbsp;&nbsp; static Matrix3x3 zero()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Matrix3x3{ 0.0f, 0.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 0.0f };<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 単位行列を返す<br>
        &nbsp;&nbsp;&nbsp; static Matrix3x3 identity()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Matrix3x3{ 1.0f, 0.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 1.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 1.0f };<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>//[2D]平行移動行列を返す(2D向け) (DirectX系)<br>
          &nbsp;&nbsp;&nbsp; static Matrix3x3 translate(const Vector2&amp; t)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Matrix3x3{ 1.0, 0.0f, 0.0f,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0, 1.0f, 0.0f,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.x,&nbsp; t.y, 1.0f };<br>
          &nbsp;&nbsp;&nbsp; };</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>// 転置行列を返す(メンバ関数版)<br>
          &nbsp;&nbsp;&nbsp; inline Matrix3x3 transpose()<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = this-&gt;m[j][i]; // 行i と 列j を 行j と 列i に交換<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
          &nbsp;&nbsp;&nbsp; };</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; /*-----　演算子オーバーロード　-----*/<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3 operator + () const { return *this; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // マイナスの符号を単体の行列につけたとき<br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3 operator -() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = -this-&gt;m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator += (const Matrix3x3&amp; add)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] + add.m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator -= (const Matrix3x3&amp; sub)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] - sub.m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator *= (const Matrix3x3&amp; mul)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 tmp; // 値を一時保管<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp.m[i][j] = this-&gt;m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int k = 0; k &lt; 3; ++k)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] += tmp.m[i][k] * mul.m[k][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator *= (float multiply_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] * multiply_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator /= (float divide_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] / divide_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 一致演算子 行列の中身が全部一致するか 一つでも違えばfalse<br>
        &nbsp;&nbsp;&nbsp; inline bool operator == (const Matrix3x3&amp; other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;m[i][j] != other.m[i][j]) return false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 不一致演算子<br>
        &nbsp;&nbsp;&nbsp; inline bool operator != (const Matrix3x3&amp; other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(*this == other);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        // 行列の加算<br>
        inline Matrix3x3 operator + (const Matrix3x3&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left.m[i][j] + right.m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列の減算<br>
        inline Matrix3x3 operator - (const Matrix3x3&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left.m[i][j] - right.m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列のスカラー倍 (スカラー×行列）<br>
        inline Matrix3x3 operator * (float left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left * right.m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列のスカラー倍 (行列×スカラー）<br>
        inline Matrix3x3 operator * (const Matrix3x3&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left.m[i][j] * right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列の積<br>
        inline Matrix3x3 operator * (const Matrix3x3&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int k = 0; k &lt; 3; ++k)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] += left.m[i][k] * right.m[k][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        //[2D]ベクトルと行列の積<br>
        inline Vector2 operator * (const Vector2&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float x = left.x * right.m[0][0] + left.y * right.m[1][0] + right.m[2][0];<br>
        &nbsp;&nbsp;&nbsp; float y = left.x * right.m[0][1] + left.y * right.m[1][1] + right.m[2][1];<br>
        &nbsp;&nbsp;&nbsp; return Vector2{ x, y };<br>
        };<br>
        <br>
        inline const Matrix3x3 operator / (const Matrix3x3&amp; left, const float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return left * (1.0f / right);<br>
        }<br>
        <br>
        <em>// 転置行列を返す<br>
          inline Matrix3x3 transpose(const Matrix3x3&amp; mat)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
          &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = mat.m[j][i]; // 行i と 列j を 行j と 列i に交換<br>
          <br>
          &nbsp;&nbsp;&nbsp; return result;<br>
          };</em><br>
        <br>
        // 行列の出力<br>
        inline std::ostream&amp; operator &lt;&lt; (std::ostream&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; right.m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j &lt; 3 - 1) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; " ";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; std::endl;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return left;<br>
        };<br>
        <br>
        <br>
        #endif<br>
      </p>
      では、平行移動行列を返すtranslate関数(DirectX系対応ver.)を利用して、main.cppで点を手軽に平行移動してみましょう。<br>
      <br>
      <p><code>main.cpp</code>を変更して、点p0{1,1} を 平行移動行列を<b>translate関数を使って初期化</b>して <b>x方向に+4 y方向に+5 平行移動</b>してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "Matrix3x3.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 1,1 }; // 点p0<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>Matrix3x3 translate{ 1,0,0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,1,0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4,5,1 }; // 平行移動行列</u><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Matrix3x3 translate = Matrix3x3::translate(Vector2{ 4,5 }); // 平行移動行列</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1 = p0 * translate; // 点p0×translate (平行移動行列を右から掛け算)すると平行移動する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 矢印p0→p1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？translate関数を使えば、手打ちで行列を3行ぶん書くよりは手軽に平行移動の行列をゲットすることができますね。<br>
      ただし、勉強のためには、ちゃんと1回は自分で行列を「手で打つ」練習をしておかないと、行列って何??というのがわからないままになっちゃいます。<br>
      行列をイメージできないまま使うのではなく、実際の3x3の行列をイメージして、数値データをイメージして使うことが勉強としては大事です。<br>
      そうでなければ、例えば、DirectX系の環境なのに、OpenGL系のネット上のプログラムサンプルを使ってしまったときに、<br>
      行列の中身の数字を見て「数値の要素がひっくり返っている」ことになかなか気づけない状況になったりすることがあるかもしれません。<br>
      便利なものを「基礎知識」があるうえで使いこなすのと「もやもやを抱えたまま、よく知らないままただ使う」のとは全然違うということです。<br>
      <br>
    </a> <a id="mozTocId0018" class="mozTocH1">
      <h1>Matrix3x3で点を行列でスケール(拡大縮小)させる</h1>
      <p><code>main.cpp</code>を変更して、点p0{1,1} を <b>スケール行列{×3倍,×4倍}を使って、x方向に×3倍 y方向に×4倍 スケーリング</b>してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "Matrix3x3.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 1,1 }; // 点p0<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Matrix3x3 scale{ 2,0,0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,3,0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,1 }; // スケール(拡大縮小)行列</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>Matrix3x3 translate = Matrix3x3::translate(Vector2{ 4,5 }); // 平行移動行列</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1 = p0 * <em>scale</em>; // 点p0×<em>scale</em> (<em>スケール</em>行列を右から掛け算)すると<em>拡大縮小</em>する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 矢印p0→p1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？今回は、<b>行列の斜め方向成分の 1,1,1 を 2,3,1 にすることで点の位置をx方向に2倍、y方向に3倍することができる</b>ことが実感できたでしょうか?<br>
      1点だけだとあまり、スケールアップした実感がわかないかもしれませんので、こんどは3点をまとめてスケールアップして三角形をスケールアップしてみましょう。<br>
      <br>
      <p><code>main.cpp</code>を一旦、きれいにまっさらにリセットしましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "Matrix3x3.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>Vector2 p0{ 1,1 }; // 点p0<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 scale{ 2,0,0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,3,0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,1 }; // スケール(拡大縮小)行列<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1 = p0 * scale; // 点p0×scale (スケール行列を右から掛け算)すると拡大縮小する<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 矢印p0→p1を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, GetColor(255, 255, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p0を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 255, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 255, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(255, 0, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(255, 0, 0));</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      <p><code>main.cpp</code>を変更して、3点p0{1,1} 点p1{3,4} 点p2{5,2} を <b>スケール行列{×2倍,×5倍}を使って、x方向に×2倍 y方向に×5倍 スケーリング</b>してみましょう。</p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "Matrix3x3.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Vector2 p0{ 1,1 }; // 点p0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 3,4 }; // 点p1<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,2 }; // 点p2<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 scale{ 2,0,0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,5,0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,1 }; // スケール(拡大縮小)行列<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0,q1,q2<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q0 = p0 * scale; // 点p0×scale (スケール行列を右から掛け算)すると拡大縮小する<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q1 = p1 * scale; // 点p1×scale (スケール行列を右から掛け算)すると拡大縮小する<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q2 = p2 * scale; // 点p2×scale (スケール行列を右から掛け算)すると拡大縮小する<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形p0,p1,p2を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, p1.x, p1.y, GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p2.x, p2.y, p0.x, p0.y, GetColor(255, 255, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スケール後の三角形q0,q1,q2を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q0.x, q0.y, q1.x, q1.y, GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q1.x, q1.y, q2.x, q2.y, GetColor(255, 255, 255));<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q2.x, q2.y, q0.x, q0.y, GetColor(255, 255, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スケール前の3点を描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p0を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p2を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スケールしたあとの3点を描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q0.x, q0.y, 3, GetColor(255, 0, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q0_String = "q0=(" + std::to_string(q0.x) + "," + std::to_string(q0.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q0.x, q0.y, q0_String.c_str(), GetColor(255, 0, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q1を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q1.x, q1.y, 3, GetColor(0, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q1_String = "q1=(" + std::to_string(q1.x) + "," + std::to_string(q1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q1.x, q1.y, q1_String.c_str(), GetColor(0, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q2を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q2.x, q2.y, 3, GetColor(0, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q2_String = "q2=(" + std::to_string(q2.x) + "," + std::to_string(q2.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q2.x, q2.y, q2_String.c_str(), GetColor(0, 0, 255));</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？三角形をスケーリングすることで拡大していることが実感できたでしょうか?<br>
      <b>xとyの拡大率が違う</b>ので、もとの三角形と比べて、縦方向にぐいーんと<b>ゆがんでスケーリング</b>されていることにも着目しておいてください。<br>
      <br>
      では、今回も今後を手軽にするために、Matrix3x3.hにスケール行列を得る関数を追加して行列の数字を全部は手打ちせずにスケーリング行列をゲットできるようにしておきましょう。<br>
      <br>
      <code>Matrix3x3.h</code>を変更してスケール行列をゲットするためのscale関数を定義しましょう。<br>
      <p class="source">#ifndef MATRIX3X3_H_<br>
        #define MATRIX3X3_H_<br>
        <br>
        #include "Vector2.h" // 2Dのベクトル<br>
        <br>
        #include &lt;ostream&gt;<br>
        #include &lt;cmath&gt;<br>
        <br>
        // 行列(3×3)　2Dにも3Dにも使う<br>
        struct Matrix3x3<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 行列[行][列]の順 (行優先) https://qiita.com/suzuryo3893/items/9e543cdf8bc64dc7002a<br>
        &nbsp;&nbsp;&nbsp; union<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m[3][3]{}; // 3×3の配列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;std::array&lt;float, 3&gt;, 3&gt; mArr; // std::array型ベースなら少し便利<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(float*)キャストすればデータ配列 m の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator float* () const { return (float*)m; }<br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(const float*)キャストすればデータ配列 m の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator const float* () const { return (const float*)m; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3() = default;<br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3(float m11, float m12, float m13,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m21, float m22, float m23,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m31, float m32, float m33)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : m{ {m11, m12, m13}, {m21, m22, m23}, { m31, m32, m33} } {};<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ (std::arrayで初期化版)<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3(std::array&lt;std::array&lt;float, 3&gt;, 3&gt;&amp; matArr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m[i][j] = matArr[i][j];<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ゼロ行列を返す<br>
        &nbsp;&nbsp;&nbsp; static Matrix3x3 zero()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Matrix3x3{ 0.0f, 0.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 0.0f };<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 単位行列を返す<br>
        &nbsp;&nbsp;&nbsp; static Matrix3x3 identity()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Matrix3x3{ 1.0f, 0.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 1.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 1.0f };<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>//[2D]拡大縮小行列を返す(2D向け)<br>
          &nbsp;&nbsp;&nbsp; static Matrix3x3 scale(const Vector2&amp; s)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Matrix3x3{ s.x,&nbsp; 0.0f, 0.0f,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp; s.y, 0.0f,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 1.0f };<br>
          &nbsp;&nbsp;&nbsp; };</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; //[2D]平行移動行列を返す(2D向け) (DirectX系)<br>
        &nbsp;&nbsp;&nbsp; static Matrix3x3 translate(const Vector2&amp; t)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Matrix3x3{ 1.0, 0.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0, 1.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.x,&nbsp; t.y, 1.0f };<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 転置行列を返す(メンバ関数版)<br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3 transpose()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = this-&gt;m[j][i]; // 行i と 列j を 行j と 列i に交換<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; /*-----　演算子オーバーロード　-----*/<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3 operator + () const { return *this; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // マイナスの符号を単体の行列につけたとき<br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3 operator -() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = -this-&gt;m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator += (const Matrix3x3&amp; add)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] + add.m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator -= (const Matrix3x3&amp; sub)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] - sub.m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator *= (const Matrix3x3&amp; mul)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 tmp; // 値を一時保管<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp.m[i][j] = this-&gt;m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int k = 0; k &lt; 3; ++k)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] += tmp.m[i][k] * mul.m[k][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator *= (float multiply_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] * multiply_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator /= (float divide_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] / divide_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 一致演算子 行列の中身が全部一致するか 一つでも違えばfalse<br>
        &nbsp;&nbsp;&nbsp; inline bool operator == (const Matrix3x3&amp; other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;m[i][j] != other.m[i][j]) return false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 不一致演算子<br>
        &nbsp;&nbsp;&nbsp; inline bool operator != (const Matrix3x3&amp; other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(*this == other);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        // 行列の加算<br>
        inline Matrix3x3 operator + (const Matrix3x3&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left.m[i][j] + right.m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列の減算<br>
        inline Matrix3x3 operator - (const Matrix3x3&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left.m[i][j] - right.m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列のスカラー倍 (スカラー×行列）<br>
        inline Matrix3x3 operator * (float left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left * right.m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列のスカラー倍 (行列×スカラー）<br>
        inline Matrix3x3 operator * (const Matrix3x3&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left.m[i][j] * right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列の積<br>
        inline Matrix3x3 operator * (const Matrix3x3&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int k = 0; k &lt; 3; ++k)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] += left.m[i][k] * right.m[k][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        //[2D]ベクトルと行列の積<br>
        inline Vector2 operator * (const Vector2&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float x = left.x * right.m[0][0] + left.y * right.m[1][0] + right.m[2][0];<br>
        &nbsp;&nbsp;&nbsp; float y = left.x * right.m[0][1] + left.y * right.m[1][1] + right.m[2][1];<br>
        &nbsp;&nbsp;&nbsp; return Vector2{ x, y };<br>
        };<br>
        <br>
        inline const Matrix3x3 operator / (const Matrix3x3&amp; left, const float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return left * (1.0f / right);<br>
        }<br>
        <br>
        // 転置行列を返す<br>
        inline Matrix3x3 transpose(const Matrix3x3&amp; mat)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = mat.m[j][i]; // 行i と 列j を 行j と 列i に交換<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列の出力<br>
        inline std::ostream&amp; operator &lt;&lt; (std::ostream&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; right.m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j &lt; 3 - 1) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; " ";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; std::endl;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return left;<br>
        };<br>
        <br>
        <br>
        #endif<br>
      </p>
      <br>
      <p><code>main.cpp</code>を変更して、3点p0{1,1} 点p1{3,4} 点p2{5,2} を <b>scale関数でゲットしたスケール行列</b>{×2倍,×5倍}を使って、x方向に×2倍 y方向に×5倍 スケーリングしてみましょう。</p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "Matrix3x3.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 1,1 }; // 点p0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 3,4 }; // 点p1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,2 }; // 点p2<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>Matrix3x3 scale{ 2,0,0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,5,0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,1 }; // スケール(拡大縮小)行列</u><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Matrix3x3 scale = Matrix3x3::scale(Vector2{ -2,5 }); // スケール(拡大縮小)行列</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0,q1,q2<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q0 = p0 * scale; // 点p0×scale (スケール行列を右から掛け算)すると拡大縮小する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q1 = p1 * scale; // 点p1×scale (スケール行列を右から掛け算)すると拡大縮小する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q2 = p2 * scale; // 点p2×scale (スケール行列を右から掛け算)すると拡大縮小する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形p0,p1,p2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, p1.x, p1.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p2.x, p2.y, p0.x, p0.y, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スケール後の三角形q0,q1,q2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q0.x, q0.y, q1.x, q1.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q1.x, q1.y, q2.x, q2.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q2.x, q2.y, q0.x, q0.y, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スケール前の3点を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スケールしたあとの3点を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q0.x, q0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q0_String = "q0=(" + std::to_string(q0.x) + "," + std::to_string(q0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q0.x, q0.y, q0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q1.x, q1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q1_String = "q1=(" + std::to_string(q1.x) + "," + std::to_string(q1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q1.x, q1.y, q1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q2.x, q2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q2_String = "q2=(" + std::to_string(q2.x) + "," + std::to_string(q2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q2.x, q2.y, q2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？これで手軽にスケーリング行列を得ることができるようになりました。<br>
      もう1点の注目ポイントとして、今回は{ ×2倍,×5倍 }ではなく、<b>{ ×-2倍,×5倍 }という形でx軸方向をマイナス倍</b>にしてみました。<br>
      <b>x方向をマイナス倍すると、Y軸(縦軸)を鏡にして、左右が反転</b>します。<br>
      <b>y方向をマイナス倍すると、X軸(横軸)を鏡にして、上下が反転</b>します。<br>
      <b>x方向とy方向の両方をマイナス倍すると、原点(0,0)を境にして、上下左右が反転</b>します。<br>
      このマイナス倍の関係性は自分で数値を変えてみて実験しておいてください。<br>
      <br>
      次は回転行列にトライしてみましょう。<br>
      <br>
    </a> <a id="mozTocId0019" class="mozTocH1">
      <h1>Matrix3x3で点を行列で回転(rotate:ローテーション)させる</h1>
      <p><code>main.cpp</code>を変更して、3点p0{1,1} 点p1{3,4} 点p2{5,2} を <b>回転行列で原点(0,0)を中心に反時計回りに60度(θ=60°)回転して</b>してみましょう。</p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "Matrix3x3.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 1,1 }; // 点p0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 3,4 }; // 点p1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,2 }; // 点p2<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>constexpr float pi = 3.14159265359f;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float rad = 60 * (pi / 180.0f);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 rotate{ std::cosf(rad),std::sinf(rad), 0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -std::sinf(rad),std::cosf(rad), 0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 1 }; // 回転行列</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>Matrix3x3 scale = Matrix3x3::scale(Vector2{ -2,5 }); // スケール(拡大縮小)行列</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0,q1,q2<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q0 = p0 * <em>rotate</em>; // 点p0×<em>rotate</em> (<em>回転</em>行列を右から掛け算)すると<em>原点を中心に回転</em>する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q1 = p1 * <em>rotate</em>; // 点p1×<em>rotate</em> (<em>回転</em>行列を右から掛け算)すると<em>原点を中心に回転</em>する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q2 = p2 * <em>rotate</em>; // 点p2×<em>rotate</em> (<em>回転</em>行列を右から掛け算)すると<em>原点を中心に回転</em>する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形p0,p1,p2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, p1.x, p1.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p2.x, p2.y, p0.x, p0.y, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <em>回転</em>後の三角形q0,q1,q2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q0.x, q0.y, q1.x, q1.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q1.x, q1.y, q2.x, q2.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q2.x, q2.y, q0.x, q0.y, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <em>回転</em>前の3点を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <em>回転</em>したあとの3点を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q0.x, q0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q0_String = "q0=(" + std::to_string(q0.x) + "," + std::to_string(q0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q0.x, q0.y, q0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q1.x, q1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q1_String = "q1=(" + std::to_string(q1.x) + "," + std::to_string(q1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q1.x, q1.y, q1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q2.x, q2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q2_String = "q2=(" + std::to_string(q2.x) + "," + std::to_string(q2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q2.x, q2.y, q2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？原点(0,0)を中心として三角形が60度回転したでしょうか？<br>
      std::cosf関数やstd::sinf関数は<b>ラジアンで角度を入力する必要</b>があるので、円周率piを使って60度を、float rad = 60 * (pi / 180.0f); のように単位:ラジアンに変換してます。<br>
      <br>
      では、今回も今後を手軽にするために、Matrix3x3.hに回転行列を得る関数を追加して行列の数字を全部は手打ちせずに回転行列をゲットできるようにしておきましょう。<br>
      <br>
      <code>Matrix3x3.h</code>を変更して回転行列をゲットするための関数を定義しましょう。<br>
      <p class="source">#ifndef MATRIX3X3_H_<br>
        #define MATRIX3X3_H_<br>
        <br>
        #include "Vector2.h" // 2Dのベクトル<br>
        <br>
        #include &lt;ostream&gt;<br>
        #include &lt;cmath&gt;<br>
        <br>
        // 行列(3×3)　2Dにも3Dにも使う<br>
        struct Matrix3x3<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 行列[行][列]の順 (行優先) https://qiita.com/suzuryo3893/items/9e543cdf8bc64dc7002a<br>
        &nbsp;&nbsp;&nbsp; union<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m[3][3]{}; // 3×3の配列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;std::array&lt;float, 3&gt;, 3&gt; mArr; // std::array型ベースなら少し便利<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(float*)キャストすればデータ配列 m の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator float* () const { return (float*)m; }<br>
        &nbsp;&nbsp;&nbsp; // float型のポインタへ(const float*)キャストすればデータ配列 m の先頭のアドレスを返す<br>
        &nbsp;&nbsp;&nbsp; inline operator const float* () const { return (const float*)m; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3() = default;<br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3(float m11, float m12, float m13,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m21, float m22, float m23,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float m31, float m32, float m33)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : m{ {m11, m12, m13}, {m21, m22, m23}, { m31, m32, m33} } {};<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンストラクタ (std::arrayで初期化版)<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3(std::array&lt;std::array&lt;float, 3&gt;, 3&gt;&amp; matArr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m[i][j] = matArr[i][j];<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ゼロ行列を返す<br>
        &nbsp;&nbsp;&nbsp; static Matrix3x3 zero()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Matrix3x3{ 0.0f, 0.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 0.0f };<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 単位行列を返す<br>
        &nbsp;&nbsp;&nbsp; static Matrix3x3 identity()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Matrix3x3{ 1.0f, 0.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 1.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 1.0f };<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; //[2D]拡大縮小行列を返す(2D向け)<br>
        &nbsp;&nbsp;&nbsp; static Matrix3x3 scale(const Vector2&amp; s)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Matrix3x3{ s.x,&nbsp; 0.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp; s.y, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 0.0f, 1.0f };<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>//[2D]回転行列を返す(2D向け) degree:角度(°) (DirectX系)<br>
          &nbsp;&nbsp;&nbsp; static Matrix3x3 rotate(float degree)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float pi = 3.14159265359f;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float rad = degree * (pi / 180.0f);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float cos_theta = std::cos(rad), sin_theta = std::sin(rad);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Matrix3x3{ cos_theta, sin_theta, 0.0f,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -sin_theta, cos_theta, 0.0f,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0f, 1.0f };<br>
          &nbsp;&nbsp;&nbsp; };</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; //[2D]平行移動行列を返す(2D向け) (DirectX系)<br>
        &nbsp;&nbsp;&nbsp; static Matrix3x3 translate(const Vector2&amp; t)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Matrix3x3{ 1.0, 0.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0, 1.0f, 0.0f,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.x,&nbsp; t.y, 1.0f };<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 転置行列を返す(メンバ関数版)<br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3 transpose()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = this-&gt;m[j][i]; // 行i と 列j を 行j と 列i に交換<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; /*-----　演算子オーバーロード　-----*/<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3 operator + () const { return *this; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // マイナスの符号を単体の行列につけたとき<br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3 operator -() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = -this-&gt;m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator += (const Matrix3x3&amp; add)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] + add.m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator -= (const Matrix3x3&amp; sub)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] - sub.m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator *= (const Matrix3x3&amp; mul)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 tmp; // 値を一時保管<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp.m[i][j] = this-&gt;m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int k = 0; k &lt; 3; ++k)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] += tmp.m[i][k] * mul.m[k][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator *= (float multiply_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] * multiply_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; inline Matrix3x3&amp; operator /= (float divide_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;m[i][j] = this-&gt;m[i][j] / divide_num;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 一致演算子 行列の中身が全部一致するか 一つでも違えばfalse<br>
        &nbsp;&nbsp;&nbsp; inline bool operator == (const Matrix3x3&amp; other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;m[i][j] != other.m[i][j]) return false;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 不一致演算子<br>
        &nbsp;&nbsp;&nbsp; inline bool operator != (const Matrix3x3&amp; other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(*this == other);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        // 行列の加算<br>
        inline Matrix3x3 operator + (const Matrix3x3&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left.m[i][j] + right.m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列の減算<br>
        inline Matrix3x3 operator - (const Matrix3x3&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left.m[i][j] - right.m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列のスカラー倍 (スカラー×行列）<br>
        inline Matrix3x3 operator * (float left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left * right.m[i][j];<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列のスカラー倍 (行列×スカラー）<br>
        inline Matrix3x3 operator * (const Matrix3x3&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = left.m[i][j] * right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列の積<br>
        inline Matrix3x3 operator * (const Matrix3x3&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int k = 0; k &lt; 3; ++k)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] += left.m[i][k] * right.m[k][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        //[2D]ベクトルと行列の積<br>
        inline Vector2 operator * (const Vector2&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; float x = left.x * right.m[0][0] + left.y * right.m[1][0] + right.m[2][0];<br>
        &nbsp;&nbsp;&nbsp; float y = left.x * right.m[0][1] + left.y * right.m[1][1] + right.m[2][1];<br>
        &nbsp;&nbsp;&nbsp; return Vector2{ x, y };<br>
        };<br>
        <br>
        inline const Matrix3x3 operator / (const Matrix3x3&amp; left, const float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return left * (1.0f / right);<br>
        }<br>
        <br>
        // 転置行列を返す<br>
        inline Matrix3x3 transpose(const Matrix3x3&amp; mat)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Matrix3x3 result;<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.m[i][j] = mat.m[j][i]; // 行i と 列j を 行j と 列i に交換<br>
        <br>
        &nbsp;&nbsp;&nbsp; return result;<br>
        };<br>
        <br>
        // 行列の出力<br>
        inline std::ostream&amp; operator &lt;&lt; (std::ostream&amp; left, const Matrix3x3&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 3; ++i) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; 3; ++j) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; right.m[i][j];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j &lt; 3 - 1) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; " ";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left &lt;&lt; std::endl;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return left;<br>
        };<br>
        <br>
        <br>
        #endif<br>
      </p>
      <p><code>main.cpp</code>を変更して、3点p0{1,1} 点p1{3,4} 点p2{5,2} を <b>手軽にrotate関数でゲットした</b>回転行列で原点(0,0)を中心に反時計回りに60度(θ=60°)回転してみましょう。</p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "Matrix3x3.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 1,1 }; // 点p0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 3,4 }; // 点p1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,2 }; // 点p2<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>constexpr float pi = 3.14159265359f;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float rad = 60 * (pi / 180.0f);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 rotate{ std::cosf(rad),std::sinf(rad), 0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -std::sinf(rad),std::cosf(rad), 0,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 1 }; // 回転行列</u><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Matrix3x3 rotate = Matrix3x3::rotate(60); // 回転行列</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0,q1,q2<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q0 = p0 * rotate; // 点p0×rotate (回転行列を右から掛け算)すると原点を中心に回転する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q1 = p1 * rotate; // 点p1×rotate (回転行列を右から掛け算)すると原点を中心に回転する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q2 = p2 * rotate; // 点p2×rotate (回転行列を右から掛け算)すると原点を中心に回転する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形p0,p1,p2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, p1.x, p1.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p2.x, p2.y, p0.x, p0.y, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 回転後の三角形q0,q1,q2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q0.x, q0.y, q1.x, q1.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q1.x, q1.y, q2.x, q2.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q2.x, q2.y, q0.x, q0.y, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 回転前の3点を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 回転したあとの3点を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q0.x, q0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q0_String = "q0=(" + std::to_string(q0.x) + "," + std::to_string(q0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q0.x, q0.y, q0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q1.x, q1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q1_String = "q1=(" + std::to_string(q1.x) + "," + std::to_string(q1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q1.x, q1.y, q1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q2.x, q2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q2_String = "q2=(" + std::to_string(q2.x) + "," + std::to_string(q2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q2.x, q2.y, q2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？原点(0,0)を中心として三角形が60度回転したでしょうか？<br>
      rotete関数の引数degreeの方は<b>60度の角度のまま入力できるように</b>してあるので、お手軽に好きな角度で回転行列をゲットできるようにしてあります。<br>
      <br>
    </a> <a id="mozTocId0020" class="mozTocH1">
      <h1>Matrix3x3で点を組み合わせ行列(transform行列)で回転、スケール、平行移動させる</h1>
      <p><code>main.cpp</code>を変更して、3点p0{1,1} 点p1{3,4} 点p2{5,2} を <b>transform行列でまずはscale行列だけを設定して、</b>原点(0,0)を中心にスケーリングしてみましょう。</p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "Matrix3x3.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ <em>0, 1</em> }; // 点p0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{<em>-2,-1</em> }; // 点p1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ <em>2,-1</em> }; // 点p2<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Matrix3x3 translate = Matrix3x3::translate(Vector2{ 2,3 }); // 平行移動行列<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 scale = Matrix3x3::scale(Vector2{ 4,6 }); // スケール行列</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 rotate = Matrix3x3::rotate(<em>45</em>); // 回転行列<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Matrix3x3 transform = scale; // 組み合わせ行列(スケール)</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0,q1,q2<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q0 = p0 * transform; // 点p0×<em>transform</em> (組み合わせ行列を右から掛け算)すると<em>スケール</em>する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q1 = p1 * transform; // 点p1×<em>transform</em> (組み合わせ行列を右から掛け算)すると<em>スケール</em>する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q2 = p2 * transform; // 点p2×<em>transform</em> (組み合わせ行列を右から掛け算)すると<em>スケール</em>する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形p0,p1,p2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, p1.x, p1.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p2.x, p2.y, p0.x, p0.y, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <em>組み合わせ変換(transform)</em>後の三角形q0,q1,q2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q0.x, q0.y, q1.x, q1.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q1.x, q1.y, q2.x, q2.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q2.x, q2.y, q0.x, q0.y, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <em>組み合わせ変換(transform)</em>前の3点を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <em>組み合わせ変換(transform)</em>したあとの3点を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q0.x, q0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q0_String = "q0=(" + std::to_string(q0.x) + "," + std::to_string(q0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q0.x, q0.y, q0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q1.x, q1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q1_String = "q1=(" + std::to_string(q1.x) + "," + std::to_string(q1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q1.x, q1.y, q1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q2.x, q2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q2_String = "q2=(" + std::to_string(q2.x) + "," + std::to_string(q2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q2.x, q2.y, q2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？まずは原点(0,0)を中心として三角形がスケール(拡大)したでしょうか？<br>
      つぎは、組み合わせ行列(transform行列)に回転行列を「<b>右側から掛け算</b>して、<b>スケール→回転、の順</b>に変換」してみましょう。<br>
      <br>
      <p><code>main.cpp</code>を変更して、3点p0{1,1} 点p1{3,4} 点p2{5,2} を <b>transform行列に右側からrotate行列を掛け算して、</b>原点(0,0)を中心に<b>スケール→回転、の順に拡大回転</b>してみましょう。</p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "Matrix3x3.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 0, 1 }; // 点p0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{-2,-1 }; // 点p1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 2,-1 }; // 点p2<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 translate = Matrix3x3::translate(Vector2{ 2,3 }); // 平行移動行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 scale = Matrix3x3::scale(Vector2{ 4,6 }); // スケール行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 rotate = Matrix3x3::rotate(45); // 回転行列<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 transform = scale<em> * rotate</em>; // 組み合わせ行列(スケール<em>→回転</em>)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0,q1,q2<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q0 = p0 * transform; // 点p0×transform (組み合わせ行列を右から掛け算)するとスケール<em>→回転</em>する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q1 = p1 * transform; // 点p1×transform (組み合わせ行列を右から掛け算)するとスケール<em>→回転</em>する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q2 = p2 * transform; // 点p2×transform (組み合わせ行列を右から掛け算)するとスケール<em>→回転</em>する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形p0,p1,p2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, p1.x, p1.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p2.x, p2.y, p0.x, p0.y, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 組み合わせ変換(transform)後の三角形q0,q1,q2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q0.x, q0.y, q1.x, q1.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q1.x, q1.y, q2.x, q2.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q2.x, q2.y, q0.x, q0.y, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 組み合わせ変換(transform)前の3点を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 組み合わせ変換(transform)したあとの3点を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q0.x, q0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q0_String = "q0=(" + std::to_string(q0.x) + "," + std::to_string(q0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q0.x, q0.y, q0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q1.x, q1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q1_String = "q1=(" + std::to_string(q1.x) + "," + std::to_string(q1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q1.x, q1.y, q1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q2.x, q2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q2_String = "q2=(" + std::to_string(q2.x) + "," + std::to_string(q2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q2.x, q2.y, q2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？三角形が、拡大してから→45度回転 したでしょうか？<br>
      このように<b>transform行列に順番にスケールや回転行列を掛け合わせる</b>ことが、様々な<b>位置や角度や大きさなどの姿勢</b>をゲーム内に表示されるオブジェクトに適用している計算の正体なのです。<br>
      Unityで普段、gameobjectのtransformにx,y,zの位置や角度を設定していると思いますが、<b>このtransfromの正体こそが組み合わせ行列にあたる</b>とイメージにとどめておきましょう。<br>
      (厳密にいうと<b>3Dの角度については回転行列ではなく、その上位互換の「クオータニオン」を使っています</b>。)<br>
      <br>
      では、実験のために今度は<b>掛け算の順番をひっくり返し、rotate * scaleの順</b>にして <b>rotateで回転してから→scaleで回転</b>、するとどうなるかやってみましょう。<br>
      <br>
      <p><code>main.cpp</code>を変更して、3点p0{1,1} 点p1{3,4} 点p2{5,2} を <b>transform行列に右側からrotate行列を掛け算して、</b>原点(0,0)を中心に<b>スケール→回転、の順に拡大回転</b>してみましょう。</p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "Matrix3x3.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 0, 1 }; // 点p0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{-2,-1 }; // 点p1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 2,-1 }; // 点p2<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 translate = Matrix3x3::translate(Vector2{ 2,3 }); // 平行移動行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 scale = Matrix3x3::scale(Vector2{ 4,6 }); // スケール行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 rotate = Matrix3x3::rotate(45); // 回転行列<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 transform = <em>rotate * scale</em>; // 組み合わせ行列(<em>回転→スケール</em>)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0,q1,q2<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q0 = p0 * transform; // 点p0×transform (組み合わせ行列を右から掛け算)すると<em>回転→スケール</em>する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q1 = p1 * transform; // 点p1×transform (組み合わせ行列を右から掛け算)すると<em>回転→スケール</em>する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q2 = p2 * transform; // 点p2×transform (組み合わせ行列を右から掛け算)すると<em>回転→スケール</em>する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形p0,p1,p2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, p1.x, p1.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p2.x, p2.y, p0.x, p0.y, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 組み合わせ変換(transform)後の三角形q0,q1,q2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q0.x, q0.y, q1.x, q1.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q1.x, q1.y, q2.x, q2.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q2.x, q2.y, q0.x, q0.y, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 組み合わせ変換(transform)前の3点を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 組み合わせ変換(transform)したあとの3点を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q0.x, q0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q0_String = "q0=(" + std::to_string(q0.x) + "," + std::to_string(q0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q0.x, q0.y, q0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q1.x, q1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q1_String = "q1=(" + std::to_string(q1.x) + "," + std::to_string(q1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q1.x, q1.y, q1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q2.x, q2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q2_String = "q2=(" + std::to_string(q2.x) + "," + std::to_string(q2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q2.x, q2.y, q2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかかでしょう？行列の掛け算の順番を変えると、組み合わせ行列でtransformした結果が変わりました。<br>
      このように、行列の掛け算する順番で結果が変わるので、<b>掛け算する順番の意味をプログラミングする人はわかっていないと思った通りの動かし方を実現できません</b>。<br>
      <br>
      Unityなどでは、<b>スケール→回転→平行移動の順に行列が掛け算されています</b>。<br>
      掛け算で書くなら<b>scale * rotate * translate;</b>の順番ですね。<br>
      <br>
      では、次はこの順番で掛け算をしてみましょう。<br>
      <br>
      <p><code>main.cpp</code>を変更して、<b>transform行列に右側から順にscale、rotate、translate行列を掛け算して、</b>原点(0,0)を中心に<b>スケール→回転→平行移動、の順に行列変換</b>してみましょう。</p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "Matrix3x3.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 0, 1 }; // 点p0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{-2,-1 }; // 点p1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 2,-1 }; // 点p2<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 translate = Matrix3x3::translate(Vector2{ 2,3 }); // 平行移動行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 scale = Matrix3x3::scale(Vector2{ 4,6 }); // スケール行列<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 rotate = Matrix3x3::rotate(45); // 回転行列<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix3x3 transform = <em>scale * rotate * translate</em>; // 組み合わせ行列(<em>スケール→回転→平行移動</em>)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0,q1,q2<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q0 = p0 * transform; // 点p0×transform (組み合わせ行列を右から掛け算)すると<em>スケール→回転→平行移動</em>する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q1 = p1 * transform; // 点p1×transform (組み合わせ行列を右から掛け算)すると<em>スケール→回転→平行移動</em>する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 q2 = p2 * transform; // 点p2×transform (組み合わせ行列を右から掛け算)すると<em>スケール→回転→平行移動</em>する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角形p0,p1,p2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, p1.x, p1.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p2.x, p2.y, p0.x, p0.y, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 組み合わせ変換(transform)後の三角形q0,q1,q2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q0.x, q0.y, q1.x, q1.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q1.x, q1.y, q2.x, q2.y, GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(q2.x, q2.y, q0.x, q0.y, GetColor(255, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 組み合わせ変換(transform)前の3点を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点p2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 組み合わせ変換(transform)したあとの3点を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q0を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q0.x, q0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q0_String = "q0=(" + std::to_string(q0.x) + "," + std::to_string(q0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q0.x, q0.y, q0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q1.x, q1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q1_String = "q1=(" + std::to_string(q1.x) + "," + std::to_string(q1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q1.x, q1.y, q1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 点q2を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(q2.x, q2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string q2_String = "q2=(" + std::to_string(q2.x) + "," + std::to_string(q2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(q2.x, q2.y, q2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
    いかがでしょう？これでゲームで<b>一般的な「スケール→回転→平行移動」のtransform変換</b>でゲーム内の<b>オブジェクトの姿勢が制御できる</b>ようになりました。<br>
      こういった行列の組み合わせの計算でゲーム内のキャラクターなどの位置や回転や平行移動の情報データが取り扱われているという確かなイメージを頭の中に持っておくことが大切です。<br>
      くれぐれも、ゲームのエンジンの手軽さに慣れて<b>「ゲームとそれを支える数字の世界のつながりが、ミッシングリンクにならないように..」</b><br>
      行列やベクトルなどを意識せずとも、Unityは使いこなせますが、<br>
      少し踏み込んだプログラミングをしているサイトの記事に出会ったときに、行列やベクトルの知識不足が足かせとなる日が必ず来るはずです。<br>
      <b>普段使いする、transformだからこそ、石橋をたたくように、その基礎知識こそ「あたりまえとして」強化しておく必要</b>があります。<br>
      <br>
    </a>
    
  </body>
</html>
