<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>[C++]ベクトルの練習</title>
    <link rel="stylesheet" href="style.css">
    <style>
      
    </style>
  </head>
  <body>
    <p class="title">[C++]ベクトルの練習</p>
    <br>
    <p>先にシューティングのページを参考にプロジェクトの初期設定↓とScreen.hの導入まではやっておいた前提で進めます <br>
      <a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/">https://yonezawashin.github.io/yonezawashin.github.io-2020c/</a><br>
    </p>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId0001">Vector2を使って簡単な直線を描いてみる</a></li>
      <li><a href="#mozTocId0002">operator +などを定義して、Vector2どうしの足し算などができるようにする</a></li>
      <li><a href="#mozTocId0003">Unityの定義に習って、zeroベクトルupベクトルなどの定義を追加</a></li>
      <li><a href="#mozTocId0004">数学グラフクラスを作成して数学っぽいマス目を引いたり画面上y方向プラス、画面中心(0,0)、(x,y)が(3,9)のとき(30,90)など拡大した位置に描く</a></li>
    </ol>
    <a id="mozTocId0001" class="mozTocH1"><h1>Vector2を使って簡単な直線などを描いてみる</h1>
    まずは2Dで(x,y)座標の2つのfloat型を保持する構造体Vector2を作成しましょう。<br>
    <p><code>Vector2.hの簡易版を新規作成</code>して以下のコードを実装します。</p>
    <p class="source">#ifndef VECTOR2_H_<br>
      #define VECTOR2_H_<br>
      <br>
      #include &lt;array&gt; //基本配列と同じ(有限個数)。生配列より便利な機能がある.size()関数とかstd::vector系関数が使える<br>
      <br>
      <br>
      //【注意】std::vectorとは全く違う。数学で習う【ベクトル】です。ごっちゃにしないで。<br>
      <br>
      //★【UnityのVector演算コード】https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector2.cs<br>
      //★【UnityのMath演算コード】https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Math/Mathf.cs<br>
      <br>
      <br>
      // 2変数x,yを持つ構造体。2つの数字をまとめて扱うならXY座標以外にも使えるよ。x,y別々に足したり引いたり面倒でしょう。 <br>
      struct Vector2<br>
      {<br>
      &nbsp;&nbsp; &nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float y;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }; //[匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 2&gt; xy; // float xy[2];と同じ意味 float 2個ぶんのデータサイズでx,y 2個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp; &nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y分けて記述するの面倒なとき配列xy[2]をfor文i=0～2で回せる<br>
      <br>
      &nbsp;&nbsp; &nbsp;// float型のポインタへ(float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
      &nbsp;&nbsp; &nbsp;inline operator float* () const { return (float*)this; }<br>
      &nbsp;&nbsp; &nbsp;// float型のポインタへ(const float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
      &nbsp;&nbsp; &nbsp;inline operator const float* () const { return (const float*)this; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;Vector2(float x = 0.0f, float y = 0.0f) //初期化<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; this-&gt;xy = { x,y }; // たった1行で書ける<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;x = x;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;y = y; 2行が上のxyzの様にたった1行で書けるようになる<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>main.cppを作成</code>して以下のコードでVector2を使って直線や円を描いてみます。 </p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Screen.h"<br>
      #include "Vector2.h"<br>
      <br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 100,100 }; // (x,y) = (100,100)の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 200,200 }; // (x,y) = (200,200)の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 300,300 }; // (x,y) = (300,300)の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 30; // 円の半径<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255)); // 線分p1p2を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawCircle(p3.x, p3.y, r, GetColor(255, 0, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    どうでしょうか？線と円が表示されましたか？ <br>
    <br>
    <a id="mozTocId0002" class="mozTocH1"><h1>operator +などを定義して、Vector2どうしの足し算などができるようにする</h1>
    こんどはVector2どうしの足し算などができるように足し算オペレーターoperator +などを定義してみましょう。<br>
    <p><code>Vector2.h</code>に以下のoperator関連のコードを追加します。</p>
    <p class="source">#ifndef VECTOR2_H_<br>
      #define VECTOR2_H_<br>
      <br>
      #include &lt;array&gt; //基本配列と同じ(有限個数)。生配列より便利な機能がある.size()関数とかstd::vector系関数が使える<br>
      <br>
      <br>
      //【注意】std::vectorとは全く違う。数学で習う【ベクトル】です。ごっちゃにしないで。<br>
      <br>
      //★【UnityのVector演算コード】https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector2.cs<br>
      //★【UnityのMath演算コード】https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Math/Mathf.cs<br>
      <br>
      <br>
      // 2変数x,yを持つ構造体。2つの数字をまとめて扱うならXY座標以外にも使えるよ。x,y別々に足したり引いたり面倒でしょう。 <br>
      struct Vector2<br>
      {<br>
      &nbsp;&nbsp; &nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float y;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }; //[匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 2&gt; xy; // float xy[2];と同じ意味 float 2個ぶんのデータサイズでx,y 2個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp; &nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y分けて記述するの面倒なとき配列xy[2]をfor文i=0～2で回せる<br>
      <br>
      &nbsp;&nbsp; &nbsp;// float型のポインタへ(float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
      &nbsp;&nbsp; &nbsp;inline operator float* () const { return (float*)this; }<br>
      &nbsp;&nbsp; &nbsp;// float型のポインタへ(const float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
      &nbsp;&nbsp; &nbsp;inline operator const float* () const { return (const float*)this; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;Vector2(float x = 0.0f, float y = 0.0f) //初期化<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; this-&gt;xy = { x,y }; // たった1行で書ける<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;x = x;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;y = y; 2行が上のxyzの様にたった1行で書けるようになる<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>/*-----　演算子オーバーロード　-----*/<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 逆ベクトル<br>
        &nbsp;&nbsp;&nbsp; inline Vector2 operator -() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ -this-&gt;x, -this-&gt;y };<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // Vectorをそのまま足し合わせる<br>
        &nbsp;&nbsp;&nbsp; inline Vector2 operator + () const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator += (const Vector2 add_v2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x += add_v2.x;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y += add_v2.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this; //*thisを返すことで v1 + v2 + v3見たく数珠繋ぎできる<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator -= (const Vector2 minus_v2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x -= minus_v2.x;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y -= minus_v2.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator *= (float multiply_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x *= multiply_num;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y *= multiply_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 0.fで割ったときは±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; inline Vector2&amp; operator /= (float divide_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (divide_num == 0.0f) // 0で割ったら±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *this = Vector2{ ((this-&gt;x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;((this-&gt;y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x /= divide_num;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y /= divide_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 代入演算子 x,y,zを全部 change_numに変える<br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator = (float change_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x = change_num;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y = change_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 一致演算子 x,y,zを全部一致するか 一つでも違えばfalse<br>
        &nbsp;&nbsp;&nbsp; bool operator == (const Vector2&amp; v2_other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;x != v2_other.x) return false;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;y != v2_other.y) return false;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 不一致演算子 x,y,zを全部不一致か 一つでも同じならfalse<br>
        &nbsp;&nbsp;&nbsp; bool operator != (const Vector2&amp; v2_other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;x == v2_other.x) return false;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;y == v2_other.y) return false;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      };<br>
      <br>
      <br>
      <em>// Vector2どうしの足し算 割り算 掛け算 割り算などの 基本演算の グローバル定義<br>
        <br>
        // Vector同士の足し算 x,y個別に足し合わせる<br>
        inline Vector2 operator + (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 + vec2のとき vec1の数値が書き変わったら嫌だからv3を新たに用意<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x + right.x; //[コレはダメ] left.x = left.x + right.x;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y + right.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // Vector同士の引き算 x,y個別に足し合わせる<br>
        inline Vector2 operator - (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 - vec2のとき vec1の数値が書き変わったら嫌だからv2を新たに用意<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x - right.x; //[コレはダメ] left.x = left.x - right.x;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y - right.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // Vectorと数値の掛け算 x,y個別に掛け合わせる<br>
        inline Vector2 operator * (const Vector2&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x * right;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y * right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        <br>
        // 数値とVectorの掛け算 x,y個別に掛け合わせる<br>
        inline Vector2 operator * (float left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
        &nbsp;&nbsp;&nbsp; v2.x = left * right.x;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left * right.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // Vectorと数値の割り算 x,y,z個別に割り合わせる<br>
        // 0.fで割ると±無限大を返す<br>
        inline Vector2 operator / (const Vector2&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (right == 0.0f) // 0で割ったら±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ ((left.x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ((left.y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x / right;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y / right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // 比較不等号 &lt; 演算子<br>
        inline bool operator &lt; (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &lt; right.x;<br>
        &nbsp;&nbsp;&nbsp; return left.y &lt; right.y;<br>
        }<br>
        <br>
        // 比較不等号 &gt; 演算子<br>
        inline bool operator &gt; (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &gt; right.x;<br>
        &nbsp;&nbsp;&nbsp; return left.y &gt; right.y;<br>
        }<br>
        <br>
        // 比較不等号 &lt;= 演算子<br>
        inline bool operator &lt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &gt; right);<br>
        }<br>
        <br>
        // 比較不等号 &gt;= 演算子<br>
        inline bool operator &gt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &lt; right);<br>
        }</em><br>
      <br>
      <br>
      #endif</p>
    <br>
    <br>
    <p><code>main.cpp</code>を変更してVector2どうしの足し算や引き算を使って線を描いてみます。 </p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Screen.h"<br>
      #include "Vector2.h"<br>
      <br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 100,100 }; // (x,y) = (100,100)の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 200,200 }; // (x,y) = (200,200)の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 300,300 }; // (x,y) = (300,300)の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 30; // 円の半径<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>DxLib::DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の<b>2倍</b>した線を描く</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine(p1.x, p1.y, <em>p1.x + v13.x, p1.y + v13.y</em>, GetColor(255, 255, 255)); // 線分p1<em>p3</em>を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawCircle(p3.x, p3.y, r, GetColor(255, 0, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    いかがでしょうか？ベクトルを足したり、引いたり、掛け算したりするとどうなるか理解できましたか？<br>
    ベクトルの 終点 - 始点 の計算をすると 始点→終点に向かう方向ベクトルとなり、<br>
    ベクトルの始点 + 方向ベクトル すると 終点に到着することが理解できたらOKです。<br>
    また、方向ベクトル×2 すると線の長さが2倍になっていることも直感的に理解できるとよいです。<br>
    <br>
    <br>
    <a id="mozTocId0003" class="mozTocH1"><h1>Unityの定義に習って、zeroベクトルupベクトルなどの定義を追加する</h1>
    UnityのVector2の定義は以下のサイトでコードが見れたりしますので参考にしてzeroやupなどをC#ではなくC++として定義してましょう。<br>
    <a href="https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector2.cs">https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector2.cs</a> <br>
    <p><code>Vector2.h</code>に以下のzeroベクトルupベクトルなどの定義のコードを追加します。</p>
    <p class="source">#ifndef VECTOR2_H_<br>
      #define VECTOR2_H_<br>
      <br>
      #include &lt;array&gt; //基本配列と同じ(有限個数)。生配列より便利な機能がある.size()関数とかstd::vector系関数が使える<br>
      <br>
      <br>
      //【注意】std::vectorとは全く違う。数学で習う【ベクトル】です。ごっちゃにしないで。<br>
      <br>
      //★【UnityのVector演算コード】https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
      //★【UnityのMath演算コード】https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Math/Mathf.cs<br>
      <br>
      <br>
      // 2変数x,yを持つ構造体。2つの数字をまとめて扱うならXY座標以外にも使えるよ。x,y別々に足したり引いたり面倒でしょう。 <br>
      struct Vector2<br>
      {<br>
      &nbsp;&nbsp; &nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float y;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }; //[匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 2&gt; xy; // float xy[2];と同じ意味 float 2個ぶんのデータサイズでx,y 2個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp; &nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y分けて記述するの面倒なとき配列xy[2]をfor文i=0～2で回せる<br>
      <br>
      &nbsp;&nbsp; &nbsp;// float型のポインタへ(float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
      &nbsp;&nbsp; &nbsp;inline operator float* () const { return (float*)this; }<br>
      &nbsp;&nbsp; &nbsp;// float型のポインタへ(const float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
      &nbsp;&nbsp; &nbsp;inline operator const float* () const { return (const float*)this; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;Vector2(float x = 0.0f, float y = 0.0f) //初期化<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; this-&gt;xy = { x,y }; // たった1行で書ける<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;x = x;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;y = y; 2行が上のxyzの様にたった1行で書けるようになる<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 zero;// = { 0.f,&nbsp; 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 one; // = { 1.f,&nbsp; 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 up;&nbsp; // = { 0.f,&nbsp; 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 down;// = { 0.f, -1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 left; // = { -1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 right;// = { 1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; //[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 negativeInfinity;// = { -std::numeric_limits&lt;float&gt;::infinity(), .. };<br>
        &nbsp;&nbsp;&nbsp; //[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 positiveInfinity;// = { std::numeric_limits&lt;float&gt;::infinity(), .. };</em><br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; /*-----　演算子オーバーロード　-----*/<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 逆ベクトル<br>
      &nbsp;&nbsp;&nbsp; inline Vector2 operator -() const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ -this-&gt;x, -this-&gt;y };<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Vectorをそのまま足し合わせる<br>
      &nbsp;&nbsp;&nbsp; inline Vector2 operator + () const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; Vector2&amp; operator += (const Vector2 add_v2)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x += add_v2.x;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y += add_v2.y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this; //*thisを返すことで v1 + v2 + v3見たく数珠繋ぎできる<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; Vector2&amp; operator -= (const Vector2 minus_v2)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x -= minus_v2.x;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y -= minus_v2.y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; Vector2&amp; operator *= (float multiply_num)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x *= multiply_num;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y *= multiply_num;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 0.fで割ったときは±無限大を返す<br>
      &nbsp;&nbsp;&nbsp; inline Vector2&amp; operator /= (float divide_num)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (divide_num == 0.0f) // 0で割ったら±無限大を返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *this = Vector2{ ((this-&gt;x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;((this-&gt;y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x /= divide_num;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y /= divide_num;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 代入演算子 x,y,zを全部 change_numに変える<br>
      &nbsp;&nbsp;&nbsp; Vector2&amp; operator = (float change_num)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x = change_num;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y = change_num;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 一致演算子 x,y,zを全部一致するか 一つでも違えばfalse<br>
      &nbsp;&nbsp;&nbsp; bool operator == (const Vector2&amp; v2_other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;x != v2_other.x) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;y != v2_other.y) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 不一致演算子 x,y,zを全部不一致か 一つでも同じならfalse<br>
      &nbsp;&nbsp;&nbsp; bool operator != (const Vector2&amp; v2_other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;x == v2_other.x) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;y == v2_other.y) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      <br>
      // Vector2どうしの足し算 割り算 掛け算 割り算などの 基本演算の グローバル定義<br>
      <br>
      // Vector同士の足し算 x,y個別に足し合わせる<br>
      inline Vector2 operator + (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 + vec2のとき vec1の数値が書き変わったら嫌だからv3を新たに用意<br>
      &nbsp;&nbsp;&nbsp; v2.x = left.x + right.x; //[コレはダメ] left.x = left.x + right.x;<br>
      &nbsp;&nbsp;&nbsp; v2.y = left.y + right.y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return v2;<br>
      }<br>
      <br>
      // Vector同士の引き算 x,y個別に足し合わせる<br>
      inline Vector2 operator - (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 - vec2のとき vec1の数値が書き変わったら嫌だからv2を新たに用意<br>
      &nbsp;&nbsp;&nbsp; v2.x = left.x - right.x; //[コレはダメ] left.x = left.x - right.x;<br>
      &nbsp;&nbsp;&nbsp; v2.y = left.y - right.y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return v2;<br>
      }<br>
      <br>
      // Vectorと数値の掛け算 x,y個別に掛け合わせる<br>
      inline Vector2 operator * (const Vector2&amp; left, float right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
      &nbsp;&nbsp;&nbsp; v2.x = left.x * right;<br>
      &nbsp;&nbsp;&nbsp; v2.y = left.y * right;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return v2;<br>
      }<br>
      <br>
      <br>
      // 数値とVectorの掛け算 x,y個別に掛け合わせる<br>
      inline Vector2 operator * (float left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
      &nbsp;&nbsp;&nbsp; v2.x = left * right.x;<br>
      &nbsp;&nbsp;&nbsp; v2.y = left * right.y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return v2;<br>
      }<br>
      <br>
      // Vectorと数値の割り算 x,y,z個別に割り合わせる<br>
      // 0.fで割ると±無限大を返す<br>
      inline Vector2 operator / (const Vector2&amp; left, float right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (right == 0.0f) // 0で割ったら±無限大を返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ ((left.x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ((left.y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
      <br>
      &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
      &nbsp;&nbsp;&nbsp; v2.x = left.x / right;<br>
      &nbsp;&nbsp;&nbsp; v2.y = left.y / right;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return v2;<br>
      }<br>
      <br>
      // 比較不等号 &lt; 演算子<br>
      inline bool operator &lt; (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &lt; right.x;<br>
      &nbsp;&nbsp;&nbsp; return left.y &lt; right.y;<br>
      }<br>
      <br>
      // 比較不等号 &gt; 演算子<br>
      inline bool operator &gt; (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &gt; right.x;<br>
      &nbsp;&nbsp;&nbsp; return left.y &gt; right.y;<br>
      }<br>
      <br>
      // 比較不等号 &lt;= 演算子<br>
      inline bool operator &lt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &gt; right);<br>
      }<br>
      <br>
      // 比較不等号 &gt;= 演算子<br>
      inline bool operator &gt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &lt; right);<br>
      }<br>
      <br>
      <br>
      #endif</p>
    <br>
    <p><code>Vector2.cppを新規作成して</code>以下のzeroベクトルやupベクトルなどの数値の初期化のコードを追加します(static定義した変数はcppでしか初期化できないので)。</p>
    <p class="source">#include "Vector2.h"<br>
      <br>
      // Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
      Vector2 const Vector2::zero = Vector2(0.f, 0.f);<br>
      Vector2 const Vector2::one = Vector2(1.f, 1.f);<br>
      Vector2 const Vector2::up = Vector2(0.f, 1.f);<br>
      Vector2 const Vector2::down = Vector2(0.f, -1.f);<br>
      Vector2 const Vector2::left = Vector2(-1.f, 0.f);<br>
      Vector2 const Vector2::right = Vector2(1.f, 0.f);<br>
      //[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
      Vector2 const Vector2::negativeInfinity = Vector2(-std::numeric_limits&lt;float&gt;::infinity(), -std::numeric_limits&lt;float&gt;::infinity());<br>
      //[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
      Vector2 const Vector2::positiveInfinity = Vector2(std::numeric_limits&lt;float&gt;::infinity(), std::numeric_limits&lt;float&gt;::infinity());<br>
      <br>
    </p>
    <br>
    <br>
    <p><code>main.cpp</code>を変更して上方向upベクトルを水色の線で描いてみます。 </p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Screen.h"<br>
      #include "Vector2.h"<br>
      <br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 100,100 }; // (x,y) = (100,100)の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 200,200 }; // (x,y) = (200,200)の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 300,300 }; // (x,y) = (300,300)の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 30; // 円の半径<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>DxLib::DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * 30, p1.y + Vector2::up.y * 30, GetColor(0, 255, 255)); // upベクトルを30倍した線を描く</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawCircle(p3.x, p3.y, r, GetColor(255, 0, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    いかがでしょうか？あれっ？上方向のupベクトルの描画したつもりが水色の線が下方向に出てしましました。<br>
    実は2Dのスクリーンに図形を描画する関数は左上が(x,y)=(0,0)でyの下方向がプラス方向となっていますが、3D空間はy上方向がプラスで逆になっています。<br>
    数学の教科書とかも基本的にはyが上方向がプラスなので非常にわかりにくくなっていますよね。<br>
    都度、yを描くときに - マイナスをつけてやればよいですが、今は数学のベクトルを勉強しているのでもうちょっと直感的に描画したいですよね。<br>
    次の項では数学っぽく画面の中心が原点(0,0)で、y上方向がプラスになるように描くクラスを実装して見やすくしてベクトルを数学的に考えやすく描画できるようにしてみましょう。<br>
    <br>
    <br>
    <a id="mozTocId0004" class="mozTocH1"><h1>数学グラフクラスを作成して数学っぽいマス目を引いたり、画面上y方向プラス、画面中心(0,0)、(x,y)が(3,9)のとき(30,90)など拡大した位置に描く</h1>
    <code>MathGraph2D.hを新規作成して</code>数学っぽいマス目グリッドを描いたり、画面上方向がy方向プラスにしたり、<br>
    (x,y)が(3,9)のときに(30,90)など拡大した位置に描いて見やすくできるようにグラフのスケールを設定できるようにするクラスのコードを追加します。
    <p class="source">#ifndef MATHGRAPH_H_<br>
      #define MATHGRAPH_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Vector2.h"<br>
      #include "Screen.h"<br>
      #include &lt;cmath&gt;<br>
      <br>
      // 数学のグラフを描く(DXで普通に描くと左上 0,0 で↓方向が+なので数学らしくないので)<br>
      class MathGraph2D<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;Vector2 pos; // グラフを描く起点(100,100なら左上から→に100,↓に100の位置がグラフの原点)<br>
      &nbsp;&nbsp; &nbsp;//Vector2 origin; // グラフ原点<br>
      &nbsp;&nbsp; &nbsp;float scale; // グラフのスケール(1/10 なら10ドットで1目盛りぶん)<br>
      &nbsp;&nbsp; &nbsp;Vector2 grid; // (10,10)なら10おきにグリッドを描く<br>
      &nbsp;&nbsp; &nbsp;MathGraph2D(Vector2 position, float scale = 5.0f, Vector2 grid = { 5.0f,5.0f })<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; : pos{ Vector2((int)position.x,(int)position.y)}, scale{scale}, grid{ Vector2((int)grid.x,(int)grid.y) }<br>
      &nbsp;&nbsp; &nbsp;{}<br>
      <br>
      &nbsp;&nbsp; &nbsp;virtual ~MathGraph2D(){};<br>
      <br>
      &nbsp;&nbsp; &nbsp;inline Vector2 graphPos(Vector2 mousePos) { return Vector2{ (mousePos.x - pos.x) / scale, (-mousePos.y + pos.y) / scale }; }<br>
      &nbsp;&nbsp; &nbsp;inline Vector2 graphPosInt(Vector2 mousePos) { return Vector2{ (float)((int)((mousePos.x - pos.x) / scale)), (float)((int)((-mousePos.y + pos.y) / scale)) }; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;int DrawString(float x, float y, const TCHAR* String, unsigned int Color, unsigned int EdgeColor DEFAULTPARAM(= 0))<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawString(pos.x + x * scale, pos.y - y * scale, String, Color, EdgeColor);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;int DrawLine(float x1, float y1, float x2, float y2, unsigned int Color, int Thickness DEFAULTPARAM(= 1))<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawLine(pos.x + x1 * scale, pos.y - y1 * scale, pos.x + x2 * scale, pos.y - y2 * scale, Color, Thickness);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp; int DrawTriangle(float x1, float y1, float x2, float y2, float x3, float y3, unsigned int Color, int FillFlag DEFAULTPARAM(= TRUE))<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return DxLib::DrawTriangle(pos.x + x1 * scale, pos.y - y1 * scale, <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos.x + x2 * scale, pos.y - y2 * scale, <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos.x + x3 * scale, pos.y - y3 * scale, Color, FillFlag);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 矢印→を線のかわりに描く<br>
      &nbsp;&nbsp; &nbsp;int DrawArrow(float x1, float y1, float w1, float h1, float x2, float y2, float w2, float h2, unsigned int Color, int Thickness DEFAULTPARAM(= 1))<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //[矢印の描きかた] https://ameblo.jp/tomi-omiya/entry-12641374677.html<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (w1 != 0.0f &amp;&amp; h1 != 0.0f)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float theta1 = -std::atan2(y1 - y2, x1 - x2), cos1 = std::cosf(theta1), sin1 = std::sinf(theta1);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float angle = theta1 / DX_PI * 180;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawTriangle(x1, y1, x1 - h1 * cos1 - w1 / 2 * sin1, y1 + h1 * sin1 - w1 / 2 * cos1,<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; x1 - h1 * cos1 + w1 / 2 * sin1, y1 + h1 * sin1 + w1 / 2 * cos1, Color, TRUE);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (w2 != 0.0f &amp;&amp; h2 != 0.0f)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float theta2 = -std::atan2(y2 - y1, x2 - x1), cos2 = std::cosf(theta2), sin2 = std::sinf(theta2);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawTriangle(x2, y2, x2 - h2 * cos2 - w2 / 2 * sin2, y2 + h2 * sin2 - w2 / 2 * cos2,<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x2 - h2 * cos2 + w2 / 2 * sin2, y2 + h2 * sin2 + w2 / 2 * cos2, Color, TRUE);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawLine(pos.x + x1 * scale, pos.y - y1 * scale, pos.x + x2 * scale, pos.y - y2 * scale, Color, Thickness);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;int DrawLineBox(float x1, float y1, float x2, float y2, unsigned int Color)<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawLineBox(pos.x + x1 * scale, pos.y - y1 * scale, pos.x + x2 * scale, pos.y - y2 * scale, Color);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;int DrawFillBox(float x1, float y1, float x2, float y2, unsigned int Color)<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawFillBox(pos.x + x1 * scale, pos.y - y1 * scale, pos.x + x2 * scale, pos.y - y2 * scale, Color);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;int&nbsp;&nbsp; &nbsp;DrawCircle(float x, float y, int r, unsigned int Color, int FillFlag DEFAULTPARAM(= TRUE), int LineThickness DEFAULTPARAM(= 1))<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawCircle(pos.x + x * scale, pos.y - y * scale, r * scale, Color, FillFlag, LineThickness);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;int&nbsp;&nbsp; &nbsp;DrawPoint(float x, float y, int r, unsigned int Color, int FillFlag DEFAULTPARAM(= TRUE), int LineThickness DEFAULTPARAM(= 1))<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawCircle(pos.x + x * scale, pos.y - y * scale, r, Color, FillFlag, LineThickness);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// グラフの目盛りの縦横グリッドを描く<br>
      &nbsp;&nbsp; &nbsp;void DrawGrid(unsigned int Color, int Thickness DEFAULTPARAM(= 1))<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; float test = std::fmodf(pos.x, grid.x * scale);<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; for (int x = std::fmodf(pos.x, grid.x * scale); x &lt; Screen::Width; x += grid.x * scale)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine(x, 0, x, Screen::Height,<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (x == (int)pos.x) ? GetColor(255,0,0) : // グラフの原点を通る線は色を変える<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((x-(int)pos.x) % (int)(grid.x * scale * 10) == 0) ? GetColor(255, 255, 255) : Color, // 10マスおきに色を変える<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Thickness);<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; for (int y = std::fmodf(pos.y, grid.y * scale); y &lt;= Screen::Height; y += grid.y * scale)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine(0, y, Screen::Width, y,<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (y == (int)pos.y) ? GetColor(0, 0, 255) : // グラフの原点を通る線は色を変える<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ((y - (int)pos.y) % (int)(grid.y * scale * 10) == 0) ? GetColor(255, 255, 255) : Color, // 10マスおきに色を変える<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Thickness);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      };<br>
      <br>
      #endif</p>
    <br>
    <br>
    <br>
    <p><code>main.cpp</code>を変更して数学グラフクラスMathGraph2Dを通して円や線を描いてみます。 </p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Screen.h"<br>
      #include "Vector2.h"<br>
      <em>#include "MathGraph2D.h"</em><br>
      <br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
      </em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ <em>1,1</em> }; // (x,y) = <em>(1,1)</em>の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ <em>2,2</em> }; // (x,y) = <em>(2,2)</em>の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ <em>3,3</em> }; // (x,y) = <em>(3,3)</em>の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = <em>1</em>; // 円の半径<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.</em>DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * <em>3</em>, p1.y + Vector2::up.y * <em>3</em>, GetColor(0, 255, 255)); // upベクトルを<em>3倍</em>した線を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.</em>DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.</em>DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.</em>DrawCircle(p3.x, p3.y, r, GetColor(255, 0, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    いかがでしょうか？これで水色のup上方向ベクトルも上向きになり、ベクトルの数字も(1,1)など手で計算しやすいスケール感に収めることができ、算数しやすくなったと思います。<br>
    <br>
    <h1>プロジェクトの作成</h1>
    <h2>まずはDXライブラリ公式のC++のライブラリをダウンロード</h2>
    以下のDXライブラリの公式サイトからC++のDXライブラリをダウンロードしてください。<br>
    <a href="https://dxlib.xsrv.jp/dxdload.html">https://dxlib.xsrv.jp/dxdload.html</a> <br>
    ダウンロードできたらzipファイルを【C:ドライブ直下に展開】してください<br>
    <p> <img src="image/img_dxdownload.png" alt=""></p>
    <br>
    <br>
    <h2>ダウンロードできたらzipファイルを【C:ドライブ直下に展開】</h2>
    <p> <img src="image/img_dxlibextract_c_drive.png" alt=""></p>
    <br>
    <br>
    <h2>プロジェクト作成</h2>
    Visual Studio 2019を起動してください。<br>
    <br>
    起動したら、<code>新しいプロジェクトの作成</code>をクリック<br>
    <br>
    <code>C++ 空のプロジェクト</code>を選択して次へ
    <p> <img src="image/making_cpp_prj.png" alt="" style="width: 1156px; height: 853px;"></p>
    <p>今回のプロジェクト名は【1】「自分の作るゲーム名」か【2】毎回C++のプロジェクトを作るのが面倒な人は今回作るプロジェクトをフォルダごと量産するとして「DXLibGameBase」(ゲームの基礎ベース、コピペで量産用プロジェクト)にしましょう。</p>
    <p>プロジェクトが作成されたら、まず【main.cpp】作りましょう。</p>
    <br>
    <p>少なくとも一つ【～.cpp】作らないと出てこない次にやる設定↓で【出てこない項目】があります(【C/C++全般】が出てこない！)</p>
    <br>
    <h2>次にプロジェクトのややこしい設定をしっかりやる</h2>
    プロジェクトの【設定を開く前に】最低限一つだけでもcppファイルがプロジェクトにないと【出てこない設定項目がある】ので新しい項目を追加でC++ソースファイル(.cpp)のファイルを一つ作成しておく。<br>
    <br>
    <p> <img src="image/need_one_cpp.png" alt="" style="width: 1152px; height: 713px;"></p>
    <br>
    <br>
    表示モードを切り替えてみて、main.cppができたかを確認する。<br>
    <p> <img src="image/foldermode1.png" alt=""></p>
    <br>
    一つだけcppファイルを作成した後、プロジェクトを右クリックして<code>プロパティ</code>をクリック<br>
    <br>
    <p> <img src="image/open_setting.png" alt="" style="width: 1128px; height: 642px;"></p>
    <br>
    <h2>【設定】マルチバイト文字セットを使用</h2>
    <br>
    設定画面の【構成プロパティ】→【詳細】の【文字セット】を<code>マルチバイト文字セットを使用</code>に変更<br>
    <p> <img src="image/setting_multibyte_moji.png" alt="" style="width: 982px; height: 682px;"></p>
    <br>
    <h2>【設定】C/C++→全般→追加のインクルードディレクトリにDXライブラリのフォルダ位置(PATH)を追加</h2>
    <br>
    設定画面の【C/C++全般】→【全般】の【追加のインクルードディレクトリ】に<code>DXライブラリのフォルダ位置(PATH)</code>を設定<br>
    <p> <img src="image/setting_cpp_add_include_dir.png" alt="" style="width: 1047px; height: 682px;"></p>
    <br>
    フォルダのパス(位置)文字列は以下のgifアニメのようにコピーして貼り付け<br>
    <p> <img src="image/setting_howto_copy_dir.gif" alt="" style="width: 892px; height: 554px;"></p>
    <br>
    <h2>【設定】リンカ→全般→追加のライブラリディレクトリにDXライブラリのフォルダ位置(PATH)を追加</h2>
    <br>
    設定画面の【リンカー】→【全般】の【追加のライブラリディレクトリ】に<code>DXライブラリのフォルダ位置(PATH)</code>を設定<br>
    <p> <img src="image/setting_linker_add_lib_dir.png" alt="" style="width: 1046px; height: 682px;"></p>
    <br>
    フォルダのパス(位置)文字列は以下のgifアニメのようにコピーしたものを貼り付け<br>
    <p> <img src="image/setting_howto_paste_dir.gif" alt="" style="width: 1075px; height: 805px;"></p>
    <br>
    <br>
    <h2>【設定】リンカ→システム→サブシステムをウィンドウに(コンソールのままだと黒画面の文字ベースシステムになる)</h2>
    <br>
    設定画面の【リンカー】→【システム】の【サブシステム】を<code>Windows(SUBSYSTEM:WINDOWS)</code>に設定<br>
    この設定をするとプログラムの開始位置(エントリポイントという)がWinMainというところから始まるようになる。(Consoleの場合はMain)<br>
    <p> <img src="image/setting_entry_point.png" alt="" style="width: 985px; height: 682px;"></p>
    <br>
    <br>
    以上で設定項目は終わり。OKをおして設定を反映しよう<br>
    <br>
    <br>
    <h2>設定を反映させたらサンプルプログラムをmain.cppにコピペして動作を確認</h2>
    <p>以下の【ウィンドウを出すだけの最小限サンプル】を動かして設定を確認しましょう</p>
    <p><code>main.cpp【ウィンドウを出すだけの最小限サンプル】</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode( 960 , 540 , 32 ) ; // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(960, 540);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// この位置にウィンドウの中に画像を描く処理などを書く<br>
      &nbsp;&nbsp;// DXライブラリ公式の色々なサンプルを試してみよう！<br>
      &nbsp;&nbsp;// https://dxlib.xsrv.jp/dxfunc.html<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <h2>解像度の定義</h2>
    <p>【C++で】画面解像度を定義するクラスを作ってみましょう。ソリューションエクスプローラーのプロジェクトを右クリックし、追加＞ヘッダファイル(.h)<br>
      Screen.hという名前でヘッダファイルを生成し、そのファイルにクラスを記述します。</p>
    <p><code>Screen.h</code>を編集します：</p>
    <p class="source">#ifndef _SCREEN_H<br>
      #define _SCREEN_H<br>
      // ＃ifndefは「_SCREEN_H」がifもしもn(not) def(定義)されていないなら＃endifに挟まれたコードまでを有効化する(だから2度目以降は無効になる)<br>
      // 二重定義を防止するために＃から始まる【プリプロセッサ】を使っている<br>
      //　【プリプロセッサ】はビルドする段階でコード自体に【前処理】として影響を与える<br>
      // たとえば<br>
      // ・ファイルの読み込み (including) →＃includeがこれ<br>
      // ・マクロの展開（シンボルを、あらかじめ定義された規則に従って置換する）<br>
      // ・コンパイル条件によるソースコードの部分的選択→【＃ifndef　～ ＃endifに囲まれた部分】は一度(＃defineで)定義されると無効化<br>
      // ・コメントの削除 【&nbsp;//&nbsp;】のコメントの削除も【プリプロセス＝前段階で行われる】<br>
      <br>
      // 画面解像度<br>
      class Screen<br>
      {<br>
      public: //publicはC＃と違いpublic:以下にまとめて書かれるスタイル<br>
      &nbsp;&nbsp;static const int Width = 960; // 幅<br>
      &nbsp;&nbsp;static const int Height = 540; // 高さ C＃と違いstaticクラスではなく個々の【すべての変数にstaticをつけて】staticなクラスとする<br>
      };// C＃と違ってクラスの定義も;セミコロンで終わる<br>
      #endif</p>
    <br>
    <br>
    <br>
    <p><code>main.cpp</code>を編集してScreen.hを読み込ませます：</p>
    <p class="source">#include "DxLib.h"<br>
      <em>#include "Screen.h"</em><br>
      // ↑＃includeで別ファイルのヘッダファイル.hをこのコード内に読み込む<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode( <em>Screen::Width, Screen::Height,</em> 32 ) ; // 画面サイズWidth×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(<em>Screen::Width, Screen::Height</em>);// ウィンドウサイズWidth×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      <br>
      <br>
      &nbsp;&nbsp;// (中略).....................................<br>
      <br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
  </body>
</html>
