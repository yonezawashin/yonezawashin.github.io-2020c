<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>[C++]ベクトルの練習</title>
    <link rel="stylesheet" href="style.css">
    <style>
      
    </style>
  </head>
  <body>
    <p class="title">[C++]ベクトルの練習</p>
    <br>
    <p>先にシューティングのページを参考にプロジェクトの初期設定↓とScreen.hの導入まではやっておいた前提で進めます <br>
      <a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/">https://yonezawashin.github.io/yonezawashin.github.io-2020c/</a><br>
    </p>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId0001">Vector2を使って簡単な直線を描いてみる</a></li>
      <li><a href="#mozTocId0002">operator +などを定義して、Vector2どうしの足し算などができるようにする</a></li>
      <li><a href="#mozTocId0003">Unityの定義に習って、zeroベクトルupベクトルなどの定義を追加</a></li>
      <li><a href="#mozTocId0004">数学グラフクラスを作成して数学っぽいマス目を引いたり画面上y方向プラス、画面中心(0,0)、 (x,y)が(3,9)のとき(30,90)など拡大した位置に描く</a></li>
      <li><a href="#mozTocId0005">数学クラスMyMathを作成して円と円の当たり判定をしてみる</a></li>
      <li><a href="#mozTocId0006">Vector2にベクトルの大きさを三平方の定理で計算するmagnitude関数を追加する</a></li>
      <li><a href="#mozTocId0007">Vector2に内積dotと外積cross関数を追加してMyMathクラスで円と線の当たり判 定をできるようにする</a></li>
      <li><a href="#mozTocId0008">MyMathクラスで円と線が当たったら線に沿って押し戻す処理ができるようにする</a></li>
      <li><a href="#mozTocId0009">MyMathクラスで線に垂直に下した点の影(射影)位置と線と点の最短距離を求める</a></li>
      <li><a href="#mozTocId0010">MyMathクラスで線と線が交差するか判定する</a></li>
      <li><a href="#mozTocId0011">MyMathクラスでレイ(光線)と線分(壁や床など)が交差するか判定する</a></li>
    </ol>
    <a id="mozTocId0001" class="mozTocH1">
      <h1>Vector2を使って簡単な直線などを描いてみる</h1>
      まずは2Dで(x,y)座標の2つのfloat型を保持する構造体Vector2を作成しましょう。<br>
      <p><code>Vector2.hの簡易版を新規作成</code>して以下のコードを実装します。</p>
      <p class="source">#ifndef VECTOR2_H_<br>
        #define VECTOR2_H_<br>
        <br>
        #include &lt;array&gt; //基本配列と同じ(有限個数)。生配列より便利な機能がある.size()関数とかstd::vector系関数が使える<br>
        #include &lt;limits&gt; // std::numeric_limitsで無限大などを使う https://cpprefjp.github.io/reference/limits/numeric_limits.html<br>
        #include &lt;cmath&gt; // std::の数学系関数に必要<br>
        <br>
        //【注意】std::vectorとは全く違う。数学で習う【ベクトル】です。ごっちゃにしないで。<br>
        <br>
        //★【UnityのVector演算コード】https://github.com/Unity-Technologies /UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector2.cs<br>
        //★【UnityのMath演算コード】https://github.com/Unity-Technologies /UnityCsReference/blob/master/Runtime/Export/Math/Mathf.cs<br>
        <br>
        <br>
        // 2変数x,yを持つ構造体。2つの数字をまとめて扱うならXY座標以外にも使えるよ。x,y別々に足したり引いたり面倒でしょう。 <br>
        struct Vector2<br>
        {<br>
        &nbsp;&nbsp; &nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float y;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }; //[匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 2&gt; xy; // float xy[2];と同じ意味 float 2個ぶんのデータサイズでx,y 2個ぶんと一致するので★unionで共用<br>
        &nbsp;&nbsp; &nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y分けて記述するの面倒なとき配列xy[2]をfor文i=0～2で回せる<br>
        <br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator float* () const { return (float*)this; }<br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(const float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator const float* () const { return (const float*)this; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;// 初期化コンストラクタ<br>
        &nbsp;&nbsp; &nbsp;Vector2(float x = 0.0f, float y = 0.0f) //初期化<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; this-&gt;xy = { x,y }; // たった1行で書ける<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;x = x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;y = y; 2行が上のxyzの様にたった1行で書けるようになる<br>
        &nbsp;&nbsp; &nbsp;}<br>
        };<br>
        <br>
        <br>
        #endif</p>
      <br>
      <br>
      <p><code>main.cppを作成</code>して以下のコードでVector2を使って直線や円を描いてみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 100,100 }; // (x,y) = (100,100)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 200,200 }; // (x,y) = (200,200)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 300,300 }; // (x,y) = (300,300)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 30; // 円の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255)); // 線分p1p2を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      どうでしょうか？線と円が表示されましたか？ <br>
      <br>
    </a><a id="mozTocId0002" class="mozTocH1">
      <h1>operator +などを定義して、Vector2どうしの足し算などができるようにする</h1>
      こんどはVector2どうしの足し算などができるように足し算オペレーターoperator +などを定義してみましょう。<br>
      <p><code>Vector2.h</code>に以下のoperator関連のコードを追加します。</p>
      <p class="source">#ifndef VECTOR2_H_<br>
        #define VECTOR2_H_<br>
        <br>
        #include &lt;array&gt; //基本配列と同じ(有限個数)。生配列より便利な機能がある.size()関数とかstd::vector系関数が使える<br>
        #include &lt;limits&gt; // std::numeric_limitsで無限大などを使う https://cpprefjp.github.io/reference/limits/numeric_limits.html<br>
        #include &lt;cmath&gt; // std::の数学系関数に必要<br>
        <br>
        <br>
        //【注意】std::vectorとは全く違う。数学で習う【ベクトル】です。ごっちゃにしないで。<br>
        <br>
        //★【UnityのVector演算コード】https://github.com/Unity-Technologies /UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector2.cs<br>
        //★【UnityのMath演算コード】https://github.com/Unity-Technologies /UnityCsReference/blob/master/Runtime/Export/Math/Mathf.cs<br>
        <br>
        <br>
        // 2変数x,yを持つ構造体。2つの数字をまとめて扱うならXY座標以外にも使えるよ。x,y別々に足したり引いたり面倒でしょう。 <br>
        struct Vector2<br>
        {<br>
        &nbsp;&nbsp; &nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float y;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }; //[匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 2&gt; xy; // float xy[2];と同じ意味 float 2個ぶんのデータサイズでx,y 2個ぶんと一致するので★unionで共用<br>
        &nbsp;&nbsp; &nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y分けて記述するの面倒なとき配列xy[2]をfor文i=0～2で回せる<br>
        <br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator float* () const { return (float*)this; }<br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(const float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator const float* () const { return (const float*)this; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;// 初期化コンストラクタ<br>
        &nbsp;&nbsp; &nbsp;Vector2(float x = 0.0f, float y = 0.0f) //初期化<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; this-&gt;xy = { x,y }; // たった1行で書ける<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;x = x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;y = y; 2行が上のxyzの様にたった1行で書けるようになる<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>/*-----　演算子オーバーロード　-----*/<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 逆ベクトル<br>
          &nbsp;&nbsp;&nbsp; inline Vector2 operator -() const<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ -this-&gt;x, -this-&gt;y };<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // Vectorをそのまま足し合わせる<br>
          &nbsp;&nbsp;&nbsp; inline Vector2 operator + () const<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; Vector2&amp; operator += (const Vector2 add_v2)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x += add_v2.x;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y += add_v2.y;<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this; //*thisを返すことで v1 + v2 + v3見たく数珠繋ぎできる<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; Vector2&amp; operator -= (const Vector2 minus_v2)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x -= minus_v2.x;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y -= minus_v2.y;<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; Vector2&amp; operator *= (float multiply_num)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x *= multiply_num;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y *= multiply_num;<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 0.fで割ったときは±無限大を返す<br>
          &nbsp;&nbsp;&nbsp; inline Vector2&amp; operator /= (float divide_num)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (divide_num == 0.0f) // 0で割ったら±無限大を返す<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *this = Vector2{ ((this-&gt;x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;((this-&gt;y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x /= divide_num;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y /= divide_num;<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 代入演算子 x,y,zを全部 change_numに変える<br>
          &nbsp;&nbsp;&nbsp; Vector2&amp; operator = (float change_num)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x = change_num;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y = change_num;<br>
          <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 一致演算子 x,y,zを全部一致するか 一つでも違えばfalse<br>
          &nbsp;&nbsp;&nbsp; bool operator == (const Vector2&amp; v2_other)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;x != v2_other.x) return false;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;y != v2_other.y) return false;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
          &nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp; // 不一致演算子 一致演算子の逆<br>
          &nbsp;&nbsp;&nbsp; bool operator != (const Vector2&amp; v2_other)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return !(*this == v2_other);<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        };<br>
        <br>
        <br>
        <em>// Vector2どうしの足し算 割り算 掛け算 割り算などの 基本演算の グローバル定義<br>
          <br>
          // Vector同士の足し算 x,y個別に足し合わせる<br>
          inline Vector2 operator + (const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 + vec2のとき vec1の数値が書き変わったら嫌だからv3を新たに用意<br>
          &nbsp;&nbsp;&nbsp; v2.x = left.x + right.x; //[コレはダメ] left.x = left.x + right.x;<br>
          &nbsp;&nbsp;&nbsp; v2.y = left.y + right.y;<br>
          <br>
          &nbsp;&nbsp;&nbsp; return v2;<br>
          }<br>
          <br>
          // Vector同士の引き算 x,y個別に足し合わせる<br>
          inline Vector2 operator - (const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 - vec2のとき vec1の数値が書き変わったら嫌だからv2を新たに用意<br>
          &nbsp;&nbsp;&nbsp; v2.x = left.x - right.x; //[コレはダメ] left.x = left.x - right.x;<br>
          &nbsp;&nbsp;&nbsp; v2.y = left.y - right.y;<br>
          <br>
          &nbsp;&nbsp;&nbsp; return v2;<br>
          }<br>
          <br>
          // Vectorと数値の掛け算 x,y個別に掛け合わせる<br>
          inline Vector2 operator * (const Vector2&amp; left, float right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
          &nbsp;&nbsp;&nbsp; v2.x = left.x * right;<br>
          &nbsp;&nbsp;&nbsp; v2.y = left.y * right;<br>
          <br>
          &nbsp;&nbsp;&nbsp; return v2;<br>
          }<br>
          <br>
          <br>
          // 数値とVectorの掛け算 x,y個別に掛け合わせる<br>
          inline Vector2 operator * (float left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
          &nbsp;&nbsp;&nbsp; v2.x = left * right.x;<br>
          &nbsp;&nbsp;&nbsp; v2.y = left * right.y;<br>
          <br>
          &nbsp;&nbsp;&nbsp; return v2;<br>
          }<br>
          <br>
          // Vectorと数値の割り算 x,y,z個別に割り合わせる<br>
          // 0.fで割ると±無限大を返す<br>
          inline Vector2 operator / (const Vector2&amp; left, float right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; if (right == 0.0f) // 0で割ったら±無限大を返す<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ ((left.x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ((left.y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
          <br>
          &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
          &nbsp;&nbsp;&nbsp; v2.x = left.x / right;<br>
          &nbsp;&nbsp;&nbsp; v2.y = left.y / right;<br>
          <br>
          &nbsp;&nbsp;&nbsp; return v2;<br>
          }<br>
          <br>
          // 比較不等号 &lt; 演算子<br>
          inline bool operator &lt; (const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &lt; right.x;<br>
          &nbsp;&nbsp;&nbsp; return left.y &lt; right.y;<br>
          }<br>
          <br>
          // 比較不等号 &gt; 演算子<br>
          inline bool operator &gt; (const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &gt; right.x;<br>
          &nbsp;&nbsp;&nbsp; return left.y &gt; right.y;<br>
          }<br>
          <br>
          // 比較不等号 &lt;= 演算子<br>
          inline bool operator &lt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &gt; right);<br>
          }<br>
          <br>
          // 比較不等号 &gt;= 演算子<br>
          inline bool operator &gt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &lt; right);<br>
          }</em><br>
        <br>
        <br>
        #endif</p>
      <br>
      <br>
      <p><code>main.cpp</code>を変更してVector2どうしの足し算や引き算を使って線を描いてみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 100,100 }; // (x,y) = (100,100)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 200,200 }; // (x,y) = (200,200)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 300,300 }; // (x,y) = (300,300)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 30; // 円の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>DxLib::DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の<b>2倍</b>した線を描く</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine(p1.x, p1.y, <em>p1.x + v13.x, p1.y + v13.y</em>, GetColor(255, 255, 255)); // 線分p1<em>p3</em>を 描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょうか？ベクトルを足したり、引いたり、掛け算したりするとどうなるか理解できましたか？<br>
      ベクトルの 終点 - 始点 の計算をすると 始点→終点に向かう方向ベクトルとなり、<br>
      ベクトルの始点 + 方向ベクトル すると 終点に到着することが理解できたらOKです。<br>
      また、方向ベクトル×2 すると線の長さが2倍になっていることも直感的に理解できるとよいです。<br>
      <br>
      <br>
    </a><a id="mozTocId0003" class="mozTocH1">
      <h1>Unityの定義に習って、zeroベクトルupベクトルなどの定義を追加する</h1>
      UnityのVector2の定義は以下のサイトでコードが見れたりしますので参考にしてzeroやupなどをC#ではなくC++として定義してましょう。<br>
    </a><a href="https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector2.cs">https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector2.cs</a> <br>
    <p><code>Vector2.h</code>に以下のzeroベクトルupベクトルなどの定義のコードを追加します。</p>
    <p class="source">#ifndef VECTOR2_H_<br>
      #define VECTOR2_H_<br>
      <br>
      #include &lt;array&gt; //基本配列と同じ(有限個数)。生配列より便利な機能がある.size()関数とかstd::vector系関数が使える<br>
      #include &lt;limits&gt; // std::numeric_limitsで無限大などを使う https://cpprefjp.github.io/reference/limits/numeric_limits.html<br>
      #include &lt;cmath&gt; // std::の数学系関数に必要<br>
      <br>
      <br>
      //【注意】std::vectorとは全く違う。数学で習う【ベクトル】です。ごっちゃにしないで。<br>
      <br>
      //★【UnityのVector演算コード】https://github.com/Unity-Technologies /UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
      //★【UnityのMath演算コード】https://github.com/Unity-Technologies/UnityCsReference /blob/master/Runtime/Export/Math/Mathf.cs<br>
      <br>
      <br>
      // 2変数x,yを持つ構造体。2つの数字をまとめて扱うならXY座標以外にも使えるよ。x,y別々に足したり引いたり面倒でしょう。 <br>
      struct Vector2<br>
      {<br>
      &nbsp;&nbsp; &nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float y;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }; //[匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 2&gt; xy; // float xy[2];と同じ意味 float 2個ぶんのデータサイズでx,y 2個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp; &nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y分けて記述するの面倒なとき配列xy[2]をfor文i=0～2で回せる<br>
      <br>
      &nbsp;&nbsp; &nbsp;// float型のポインタへ(float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
      &nbsp;&nbsp; &nbsp;inline operator float* () const { return (float*)this; }<br>
      &nbsp;&nbsp; &nbsp;// float型のポインタへ(const float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
      &nbsp;&nbsp; &nbsp;inline operator const float* () const { return (const float*)this; }<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 初期化コンストラクタ<br>
      &nbsp;&nbsp; &nbsp;Vector2(float x = 0.0f, float y = 0.0f) //初期化<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; this-&gt;xy = { x,y }; // たった1行で書ける<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;x = x;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;y = y; 2行が上のxyzの様にたった1行で書けるようになる<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 zero;// = { 0.f,&nbsp; 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 one; // = { 1.f,&nbsp; 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 up;&nbsp; // = { 0.f,&nbsp; 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 down;// = { 0.f, -1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 left; // = { -1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 right;// = { 1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; //[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 negativeInfinity;// = { -std::numeric_limits&lt;float&gt;::infinity(), .. };<br>
        &nbsp;&nbsp;&nbsp; //[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 positiveInfinity;// = { std::numeric_limits&lt;float&gt;::infinity(), .. };</em><br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; /*-----　演算子オーバーロード　-----*/<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 逆ベクトル<br>
      &nbsp;&nbsp;&nbsp; inline Vector2 operator -() const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ -this-&gt;x, -this-&gt;y };<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Vectorをそのまま足し合わせる<br>
      &nbsp;&nbsp;&nbsp; inline Vector2 operator + () const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; Vector2&amp; operator += (const Vector2 add_v2)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x += add_v2.x;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y += add_v2.y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this; //*thisを返すことで v1 + v2 + v3見たく数珠繋ぎできる<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; Vector2&amp; operator -= (const Vector2 minus_v2)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x -= minus_v2.x;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y -= minus_v2.y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; Vector2&amp; operator *= (float multiply_num)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x *= multiply_num;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y *= multiply_num;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 0.fで割ったときは±無限大を返す<br>
      &nbsp;&nbsp;&nbsp; inline Vector2&amp; operator /= (float divide_num)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (divide_num == 0.0f) // 0で割ったら±無限大を返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *this = Vector2{ ((this-&gt;x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;((this-&gt;y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x /= divide_num;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y /= divide_num;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 代入演算子 x,y,zを全部 change_numに変える<br>
      &nbsp;&nbsp;&nbsp; Vector2&amp; operator = (float change_num)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x = change_num;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y = change_num;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 一致演算子 x,y,zを全部一致するか 一つでも違えばfalse<br>
      &nbsp;&nbsp;&nbsp; bool operator == (const Vector2&amp; v2_other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;x != v2_other.x) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;y != v2_other.y) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 不一致演算子 一致演算子の逆<br>
      &nbsp;&nbsp;&nbsp; bool operator != (const Vector2&amp; v2_other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return !(*this == v2_other);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      <br>
      // Vector2どうしの足し算 割り算 掛け算 割り算などの 基本演算の グローバル定義<br>
      <br>
      // Vector同士の足し算 x,y個別に足し合わせる<br>
      inline Vector2 operator + (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 + vec2のとき vec1の数値が書き変わったら嫌だからv3を新たに用意<br>
      &nbsp;&nbsp;&nbsp; v2.x = left.x + right.x; //[コレはダメ] left.x = left.x + right.x;<br>
      &nbsp;&nbsp;&nbsp; v2.y = left.y + right.y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return v2;<br>
      }<br>
      <br>
      // Vector同士の引き算 x,y個別に足し合わせる<br>
      inline Vector2 operator - (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 - vec2のとき vec1の数値が書き変わったら嫌だからv2を新たに用意<br>
      &nbsp;&nbsp;&nbsp; v2.x = left.x - right.x; //[コレはダメ] left.x = left.x - right.x;<br>
      &nbsp;&nbsp;&nbsp; v2.y = left.y - right.y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return v2;<br>
      }<br>
      <br>
      // Vectorと数値の掛け算 x,y個別に掛け合わせる<br>
      inline Vector2 operator * (const Vector2&amp; left, float right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
      &nbsp;&nbsp;&nbsp; v2.x = left.x * right;<br>
      &nbsp;&nbsp;&nbsp; v2.y = left.y * right;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return v2;<br>
      }<br>
      <br>
      <br>
      // 数値とVectorの掛け算 x,y個別に掛け合わせる<br>
      inline Vector2 operator * (float left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
      &nbsp;&nbsp;&nbsp; v2.x = left * right.x;<br>
      &nbsp;&nbsp;&nbsp; v2.y = left * right.y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return v2;<br>
      }<br>
      <br>
      // Vectorと数値の割り算 x,y,z個別に割り合わせる<br>
      // 0.fで割ると±無限大を返す<br>
      inline Vector2 operator / (const Vector2&amp; left, float right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (right == 0.0f) // 0で割ったら±無限大を返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ ((left.x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ((left.y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
      <br>
      &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
      &nbsp;&nbsp;&nbsp; v2.x = left.x / right;<br>
      &nbsp;&nbsp;&nbsp; v2.y = left.y / right;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return v2;<br>
      }<br>
      <br>
      // 比較不等号 &lt; 演算子<br>
      inline bool operator &lt; (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &lt; right.x;<br>
      &nbsp;&nbsp;&nbsp; return left.y &lt; right.y;<br>
      }<br>
      <br>
      // 比較不等号 &gt; 演算子<br>
      inline bool operator &gt; (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &gt; right.x;<br>
      &nbsp;&nbsp;&nbsp; return left.y &gt; right.y;<br>
      }<br>
      <br>
      // 比較不等号 &lt;= 演算子<br>
      inline bool operator &lt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &gt; right);<br>
      }<br>
      <br>
      // 比較不等号 &gt;= 演算子<br>
      inline bool operator &gt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &lt; right);<br>
      }<br>
      <br>
      <br>
      #endif</p>
    <br>
    <p><code>Vector2.cppを新規作成して</code>以下のzeroベクトルやupベクトルなどの数値の初期化のコードを追加します (static定義した変数はcppでしか初期化できないので)。</p>
    <p class="source">#include "Vector2.h"<br>
      <br>
      // Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
      Vector2 const Vector2::zero = Vector2(0.f, 0.f);<br>
      Vector2 const Vector2::one = Vector2(1.f, 1.f);<br>
      Vector2 const Vector2::up = Vector2(0.f, 1.f);<br>
      Vector2 const Vector2::down = Vector2(0.f, -1.f);<br>
      Vector2 const Vector2::left = Vector2(-1.f, 0.f);<br>
      Vector2 const Vector2::right = Vector2(1.f, 0.f);<br>
      //[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
      Vector2 const Vector2::negativeInfinity = Vector2(-std::numeric_limits&lt;float&gt;::infinity(), -std::numeric_limits&lt;float&gt;::infinity());<br>
      //[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits /lowest.html<br>
      Vector2 const Vector2::positiveInfinity = Vector2(std::numeric_limits&lt;float&gt;::infinity(), std::numeric_limits&lt;float&gt;::infinity());<br>
      <br>
    </p>
    <br>
    <br>
    <p><code>main.cpp</code>を変更して上方向upベクトルを水色の線で描いてみます。 </p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Screen.h"<br>
      #include "Vector2.h"<br>
      <br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
      &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
      &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
      &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
      <br>
      &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 100,100 }; // (x,y) = (100,100)の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 200,200 }; // (x,y) = (200,200)の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 300,300 }; // (x,y) = (300,300)の位置の点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 30; // 円の半径<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>DxLib::DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * 30, p1.y + Vector2::up.y * 30, GetColor(0, 255, 255)); // upベクトルを30倍した線を描く</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; WaitKey();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib_End();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    いかがでしょうか？あれっ？上方向のupベクトルの描画したつもりが水色の線が下方向に出てしましました。<br>
    実は2Dのスクリーンに図形を描画する関数は左上が(x,y)=(0,0)でyの下方向がプラス方向となっていますが、3D空間はy上方向がプラスで逆になってい ます。<br>
    数学の教科書とかも基本的にはyが上方向がプラスなので非常にわかりにくくなっていますよね。<br>
    都度、yを描くときに - マイナスをつけてやればよいですが、今は数学のベクトルを勉強しているのでもうちょっと直感的に描画したいですよね。<br>
    次の項では数学っぽく画面の中心が原点(0,0)で、y上方向がプラスになるように描くクラスを実装して見やすくしてベクトルを数学的に考えやすく描画できるよう にしてみましょう。<br>
    <br>
    <br>
    <a id="mozTocId0004" class="mozTocH1">
      <h1>数学グラフクラスを作成して数学っぽいマス目を引いたり、画面上y方向プラス、画面中心(0,0)、(x,y)が(3,9)のとき(30,90)など 拡大した位置に描く</h1>
      <code>MathGraph2D.hを新規作成して</code>数学っぽいマス目グリッドを描いたり、画面上方向がy方向プラスにしたり、<br>
      (x,y)が(3,9)のときに(30,90)など拡大した位置に描いて見やすくできるようにグラフのスケールを設定できるようにするクラスのコードを追加し ます。
      <p class="source">#ifndef MATHGRAPH_H_<br>
        #define MATHGRAPH_H_<br>
        <br>
        #include "DxLib.h"<br>
        #include "Vector2.h"<br>
        #include "Screen.h"<br>
        #include &lt;cmath&gt;<br>
        #include &lt;string&gt;<br>
        <br>
        // 数学のグラフを描く(DXで普通に描くと左上 0,0 で↓方向が+なので数学らしくないので)<br>
        class MathGraph2D<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;Vector2 pos; // グラフを描く起点(100,100なら左上から→に100,↓に100の位置がグラフの原点)<br>
        &nbsp;&nbsp; &nbsp;//Vector2 origin; // グラフ原点<br>
        &nbsp;&nbsp; &nbsp;float scale; // グラフのスケール(1/10 なら10ドットで1目盛りぶん)<br>
        &nbsp;&nbsp; &nbsp;Vector2 grid; // (10,10)なら10おきにグリッドを描く<br>
        &nbsp;&nbsp; &nbsp;MathGraph2D(Vector2 position, float scale = 5.0f, Vector2 grid = { 5.0f,5.0f })<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; : pos{ Vector2((int)position.x,(int)position.y)}, scale{scale}, grid{ Vector2((int)grid.x,(int)grid.y) }<br>
        &nbsp;&nbsp; &nbsp;{}<br>
        <br>
        &nbsp;&nbsp; &nbsp;virtual ~MathGraph2D(){};<br>
        <br>
        &nbsp;&nbsp; &nbsp;inline Vector2 graphPos(Vector2 mousePos) { return Vector2{ (mousePos.x - pos.x) / scale, (-mousePos.y + pos.y) / scale }; }<br>
        &nbsp;&nbsp; &nbsp;inline Vector2 graphPosInt(Vector2 mousePos) { return Vector2{ (float)((int)((mousePos.x - pos.x) / scale)), (float)((int)((-mousePos.y + pos.y) / scale)) }; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;int DrawString(float x, float y, const TCHAR* String, unsigned int Color, unsigned int EdgeColor DEFAULTPARAM(= 0))<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawString(pos.x + x * scale, pos.y - y * scale, String, Color, EdgeColor);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;int DrawLine(float x1, float y1, float x2, float y2, unsigned int Color, int Thickness DEFAULTPARAM(= 1))<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawLine(pos.x + x1 * scale, pos.y - y1 * scale, pos.x + x2 * scale, pos.y - y2 * scale, Color, Thickness);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp;&nbsp; int DrawTriangle(float x1, float y1, float x2, float y2, float x3, float y3, unsigned int Color, int FillFlag DEFAULTPARAM(= TRUE))<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return DxLib::DrawTriangle(pos.x + x1 * scale, pos.y - y1 * scale, <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos.x + x2 * scale, pos.y - y2 * scale, <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos.x + x3 * scale, pos.y - y3 * scale, Color, FillFlag);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;// 矢印→を線のかわりに描く<br>
        &nbsp;&nbsp; &nbsp;int DrawArrow(float x1, float y1, float w1, float h1, float x2, float y2, float w2, float h2, unsigned int Color, int Thickness DEFAULTPARAM(= 1))<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //[矢印の描きかた] https://ameblo.jp/tomi-omiya/entry-12641374677.html<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (w1 != 0.0f &amp;&amp; h1 != 0.0f)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float theta1 = -std::atan2(y1 - y2, x1 - x2), cos1 = std::cosf(theta1), sin1 = std::sinf(theta1);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float angle = theta1 / DX_PI * 180;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawTriangle(x1, y1, x1 - h1 * cos1 - w1 / 2 * sin1, y1 + h1 * sin1 - w1 / 2 * cos1,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; x1 - h1 * cos1 + w1 / 2 * sin1, y1 + h1 * sin1 + w1 / 2 * cos1, Color, TRUE);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (w2 != 0.0f &amp;&amp; h2 != 0.0f)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float theta2 = -std::atan2(y2 - y1, x2 - x1), cos2 = std::cosf(theta2), sin2 = std::sinf(theta2);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DrawTriangle(x2, y2, x2 - h2 * cos2 - w2 / 2 * sin2, y2 + h2 * sin2 - w2 / 2 * cos2,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;x2 - h2 * cos2 + w2 / 2 * sin2, y2 + h2 * sin2 + w2 / 2 * cos2, Color, TRUE);<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawLine(pos.x + x1 * scale, pos.y - y1 * scale, pos.x + x2 * scale, pos.y - y2 * scale, Color, Thickness);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;int DrawLineBox(float x1, float y1, float x2, float y2, unsigned int Color)<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawLineBox(pos.x + x1 * scale, pos.y - y1 * scale, pos.x + x2 * scale, pos.y - y2 * scale, Color);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;int DrawFillBox(float x1, float y1, float x2, float y2, unsigned int Color)<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawFillBox(pos.x + x1 * scale, pos.y - y1 * scale, pos.x + x2 * scale, pos.y - y2 * scale, Color);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;int&nbsp;&nbsp; &nbsp;DrawCircle(float x, float y, int r, unsigned int Color, int FillFlag DEFAULTPARAM(= TRUE), int LineThickness DEFAULTPARAM(= 1))<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawCircle(pos.x + x * scale, pos.y - y * scale, r * scale, Color, FillFlag, LineThickness);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;int&nbsp;&nbsp; &nbsp;DrawPoint(float x, float y, int r, unsigned int Color, int FillFlag DEFAULTPARAM(= TRUE), int LineThickness DEFAULTPARAM(= 1))<br>
        &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// y方向にはマイナス - をつけて上方向↑がプラスになるようにして描く<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawCircle(pos.x + x * scale, pos.y - y * scale, r, Color, FillFlag, LineThickness);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp; &nbsp;// グラフの目盛りの縦横グリッドを描く<br>
        &nbsp;&nbsp; &nbsp;void DrawGrid(unsigned int Color, int Thickness DEFAULTPARAM(= 1))<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; float test = std::fmodf(pos.x, grid.x * scale);<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; for (int x = std::fmodf(pos.x, grid.x * scale); x &lt; Screen::Width; x += grid.x * scale)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine(x, 0, x, Screen::Height,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (x == (int)pos.x) ? GetColor(255,0,0) : // グラフの原点を通る線は色を変える<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((x-(int)pos.x) % (int)(grid.x * scale * 10) == 0) ? GetColor(255, 255, 255) : Color, // 10マスおきに色を変える<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Thickness);<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; for (int y = std::fmodf(pos.y, grid.y * scale); y &lt;= Screen::Height; y += grid.y * scale)<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine(0, y, Screen::Width, y,<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (y == (int)pos.y) ? GetColor(0, 0, 255) : // グラフの原点を通る線は色を変える<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ((y - (int)pos.y) % (int)(grid.y * scale * 10) == 0) ? GetColor(255, 255, 255) : Color, // 10マスおきに色を変える<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Thickness);<br>
        &nbsp;&nbsp; &nbsp;}<br>
        };<br>
        <br>
        #endif</p>
      <br>
      <br>
      <br>
      <p><code>main.cpp</code>を変更して数学グラフクラスMathGraph2Dを通して円や線を描いてみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        <em>#include "MathGraph2D.h"</em><br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>// 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
          &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        </em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ <em>1,1</em> }; // (x,y) = <em>(1,1)</em>の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ <em>2,2</em> }; // (x,y) = <em>(2,2)</em>の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ <em>3,3</em> }; // (x,y) = <em>(3,3)</em>の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = <em>1</em>; // 円の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.</em>DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * <em>3</em>, p1.y + Vector2::up.y * <em>3</em>, GetColor(0, 255, 255)); // upベクトルを<em>3倍</em>した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.</em>DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.</em>DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.</em>DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょうか？これで水色のup上方向ベクトルも上向きになり、ベクトルの数字も(1,1)など手で計算しやすいスケール感に収めることができ、算数しや すくなったと思います。<br>
      <br>
      <br>
    </a><a id="mozTocId0005" class="mozTocH1">
      <h1>数学クラスMyMathを作成して円と円の当たり判定をしてみる</h1>
      <code>MyMath.hを新規作成して</code>πなどの定義や円と円の当たり判定の関数を定義します。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と円が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc1"&gt;円1の中心pc1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc2"&gt;円2の中心pc2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1, float radius1,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2, float radius2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((pc1.x - pc2.x) * (pc1.x - pc2.x) + (pc1.y - pc2.y) * (pc1.y - pc2.y))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt; ((radius1 + radius2) * (radius1 + radius2));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        #endif</p>
      <br>
      <code>MyMath.cppを新規作成して</code>πなどのstatic定義の初期値を設定します。<br>
      <p class="source">#include "MyMath.h"<br>
        <br>
        const float MyMath::Sqrt2 = 1.41421356237f;//(floatは有効桁は実質7桁まで正確だがそれ以降は環境によって誤差出るよ)<br>
        <br>
        const float MyMath::PI = 3.14159265359f; // 円周率<br>
        const float MyMath::Deg2Rad = PI / 180; // 度からラジアンに変換する定数<br>
        <br>
      </p>
      <br>
      <br>
      <br>
      <p><code>main.cpp</code>を変更して円と円の当たり判定を試してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        <em>#include "MyMath.h"</em><br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 1,1 }; // (x,y) = (1,1)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 2,2 }; // (x,y) = (2,2)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 3,3 }; // (x,y) = (3,3)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 1; // 円の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Vector2 pc1{ 6,5 }; // 円1の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r1 = 2; // 円1の半径<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2{ 10,9 }; // 円2の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r2 = 3; // 円1の半径</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 円1と円2が当たっているかの判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision12 = MyMath::CircleCircleIntersection(pc1, r1, pc2, r2);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc1.x, pc1.y, r1, (isCollision12) ? GetColor(255, 0, 0): GetColor(255, 255, 255), FALSE); // 円1を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc2.x, pc2.y, r2, (isCollision12) ? GetColor(255, 0, 0) : GetColor(255, 255, 255), FALSE); // 円2を描く</em><br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * 3, p1.y + Vector2::up.y * 3, GetColor(0, 255, 255)); // upベクトルを3倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      さて、円1と円2は触れていないので白色GetColor(255,255,255)で描かれているはずです。<br>
      こんどは円2の中心を{10,9}ではなく{8,9}に変えてみましょう。<br>
      <p><code>main.cpp</code>を変更して円2の中心を{10,9}ではなく{8,9}に変えます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 1,1 }; // (x,y) = (1,1)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 2,2 }; // (x,y) = (2,2)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 3,3 }; // (x,y) = (3,3)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 1; // 円の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1{ 6,5 }; // 円1の中心<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r1 = 2; // 円1の半径<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2{ <em>8</em>,9 }; // 円2の中心<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r2 = 3; // 円1の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円1と円2が当たっているかの判定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision12 = MyMath::CircleCircleIntersection(pc1, r1, pc2, r2);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc1.x, pc1.y, r1, (isCollision12) ? GetColor(255, 0, 0): GetColor(255, 255, 255), FALSE); // 円1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc2.x, pc2.y, r2, (isCollision12) ? GetColor(255, 0, 0) : GetColor(255, 255, 255), FALSE); // 円2を描く<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * 3, p1.y + Vector2::up.y * 3, GetColor(0, 255, 255)); // upベクトルを3倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      さて、こんどは円1と円2は触れいるので赤色GetColor(255,0,0)で描かれているはずです。<br>
      円と円の当たり判定をMyMathクラスで正しくできたことが確認できました。<br>
      <br>
      <br>
    </a><a id="mozTocId0006" class="mozTocH1">
      <h1>Vector2にベクトルの大きさを三平方の定理で計算するmagnitude関数を追加する</h1>
      <code>Vector2.h</code>に関数を追加で定義します。<br>
      <p class="source">#ifndef VECTOR2_H_<br>
        #define VECTOR2_H_<br>
        <br>
        #include &lt;array&gt; //基本配列と同じ(有限個数)。生配列より便利な機能がある.size()関数とかstd::vector系関数が使える<br>
        #include &lt;limits&gt; // std::numeric_limitsで無限大などを使う https://cpprefjp.github.io/reference/limits/numeric_limits.html<br>
        #include &lt;cmath&gt; // std::の数学系関数に必要<br>
        <br>
        <br>
        //【注意】std::vectorとは全く違う。数学で習う【ベクトル】です。ごっちゃにしないで。<br>
        <br>
        //★【UnityのVector演算コード】https://github.com/Unity-Technologies /UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
        //★【UnityのMath演算コード】https://github.com/Unity-Technologies /UnityCsReference /blob/master/Runtime/Export/Math/Mathf.cs<br>
        <br>
        <br>
        // 2変数x,yを持つ構造体。2つの数字をまとめて扱うならXY座標以外にも使えるよ。x,y別々に足したり引いたり面倒でしょう。 <br>
        struct Vector2<br>
        {<br>
        &nbsp;&nbsp; &nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float y;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }; //[匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 2&gt; xy; // float xy[2];と同じ意味 float 2個ぶんのデータサイズでx,y 2個ぶんと一致するので★unionで共用<br>
        &nbsp;&nbsp; &nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y分けて記述するの面倒なとき配列xy[2]をfor文i=0～2で回せる<br>
        <br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator float* () const { return (float*)this; }<br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(const float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator const float* () const { return (const float*)this; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;// 初期化コンストラクタ<br>
        &nbsp;&nbsp; &nbsp;Vector2(float x = 0.0f, float y = 0.0f) //初期化<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; this-&gt;xy = { x,y }; // たった1行で書ける<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;x = x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;y = y; 2行が上のxyzの様にたった1行で書けるようになる<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp;&nbsp; // Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 zero;// = { 0.f,&nbsp; 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 one; // = { 1.f,&nbsp; 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 up;&nbsp; // = { 0.f,&nbsp; 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 down;// = { 0.f, -1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 left; // = { -1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 right;// = { 1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; //[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 negativeInfinity;// = { -std::numeric_limits&lt;float&gt;::infinity(), .. };<br>
        &nbsp;&nbsp;&nbsp; //[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 positiveInfinity;// = { std::numeric_limits&lt;float&gt;::infinity(), .. };<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>// ベクトルの長さ(0から点(x,y,z)までの距離)<br>
          &nbsp;&nbsp;&nbsp; inline float magnitude() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return std::sqrt(x * x + y * y); // √(x*x + y*y)<br>
          &nbsp;&nbsp;&nbsp; };<br>
          <br>
          &nbsp;&nbsp;&nbsp; // ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)<br>
          &nbsp;&nbsp;&nbsp; inline float sqrMagnitude() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return x * x + y * y; // x*x + y*y <br>
          &nbsp;&nbsp;&nbsp; };</em><br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; /*-----　演算子オーバーロード　-----*/<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 逆ベクトル<br>
        &nbsp;&nbsp;&nbsp; inline Vector2 operator -() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ -this-&gt;x, -this-&gt;y };<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // Vectorをそのまま足し合わせる<br>
        &nbsp;&nbsp;&nbsp; inline Vector2 operator + () const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator += (const Vector2 add_v2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x += add_v2.x;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y += add_v2.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this; //*thisを返すことで v1 + v2 + v3見たく数珠繋ぎできる<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator -= (const Vector2 minus_v2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x -= minus_v2.x;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y -= minus_v2.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator *= (float multiply_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x *= multiply_num;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y *= multiply_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 0.fで割ったときは±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; inline Vector2&amp; operator /= (float divide_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (divide_num == 0.0f) // 0で割ったら±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *this = Vector2{ ((this-&gt;x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;((this-&gt;y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x /= divide_num;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y /= divide_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 代入演算子 x,y,zを全部 change_numに変える<br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator = (float change_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x = change_num;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y = change_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 一致演算子 x,y,zを全部一致するか 一つでも違えばfalse<br>
        &nbsp;&nbsp;&nbsp; bool operator == (const Vector2&amp; v2_other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;x != v2_other.x) return false;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;y != v2_other.y) return false;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 不一致演算子 一致演算子の逆<br>
        &nbsp;&nbsp;&nbsp; bool operator != (const Vector2&amp; v2_other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return !(*this == v2_other);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        <br>
        // Vector2どうしの足し算 割り算 掛け算 割り算などの 基本演算の グローバル定義<br>
        <br>
        // Vector同士の足し算 x,y個別に足し合わせる<br>
        inline Vector2 operator + (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 + vec2のとき vec1の数値が書き変わったら嫌だからv3を新たに用意<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x + right.x; //[コレはダメ] left.x = left.x + right.x;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y + right.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // Vector同士の引き算 x,y個別に足し合わせる<br>
        inline Vector2 operator - (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 - vec2のとき vec1の数値が書き変わったら嫌だからv2を新たに用意<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x - right.x; //[コレはダメ] left.x = left.x - right.x;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y - right.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // Vectorと数値の掛け算 x,y個別に掛け合わせる<br>
        inline Vector2 operator * (const Vector2&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x * right;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y * right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        <br>
        // 数値とVectorの掛け算 x,y個別に掛け合わせる<br>
        inline Vector2 operator * (float left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
        &nbsp;&nbsp;&nbsp; v2.x = left * right.x;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left * right.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // Vectorと数値の割り算 x,y,z個別に割り合わせる<br>
        // 0.fで割ると±無限大を返す<br>
        inline Vector2 operator / (const Vector2&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (right == 0.0f) // 0で割ったら±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ ((left.x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ((left.y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x / right;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y / right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // 比較不等号 &lt; 演算子<br>
        inline bool operator &lt; (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &lt; right.x;<br>
        &nbsp;&nbsp;&nbsp; return left.y &lt; right.y;<br>
        }<br>
        <br>
        // 比較不等号 &gt; 演算子<br>
        inline bool operator &gt; (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &gt; right.x;<br>
        &nbsp;&nbsp;&nbsp; return left.y &gt; right.y;<br>
        }<br>
        <br>
        // 比較不等号 &lt;= 演算子<br>
        inline bool operator &lt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &gt; right);<br>
        }<br>
        <br>
        // 比較不等号 &gt;= 演算子<br>
        inline bool operator &gt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &lt; right);<br>
        }<br>
        <br>
        <em>// ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)<br>
          inline float sqrMagnitude(const Vector2&amp; vec)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; return vec.x * vec.x + vec.y * vec.y; // x*x + y*y<br>
          }<br>
          <br>
          // ベクトルの長さ(原点0から点(x,y)までの距離)<br>
          inline float magnitude(const Vector2&amp; vec)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; return std::sqrt(sqrMagnitude(vec)); // √x*x + y*y<br>
          }</em><br>
        <br>
        #endif</p>
      <br>
      <code>MyMath.h</code>を変更して円と円の距離をsqrMagnitude関数(円どうしの距離の2乗)を使った形に置き換えてみましょ う。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と円が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc1"&gt;円1の中心pc1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc2"&gt;円2の中心pc2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1, float radius1,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2, float radius2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <em>(pc1 - pc2).sqrMagnitude()</em> &lt; ((radius1 + radius2) * (radius1 + radius2));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        #endif </p>
      さて、だいぶ式がすっきりしましたが、これでもちゃんと円どうしの当たり判定を計算できます。<br>
      magnitude系関数はつまり「三平方の定理」の距離を求める処理を関数という機能に置き換えた便利ツールと考えるとイメージしやすいかもしれません。<br>
      <br>
    </a> <a id="mozTocId0007" class="mozTocH1">
      <h1>Vector2に内積dotと外積cross関数を追加してMyMathクラスで円と線の当たり判定をできるようにする</h1>
      <code>Vector2.h</code>に関数を追加で定義します。<br>
      <p class="source">#ifndef VECTOR2_H_<br>
        #define VECTOR2_H_<br>
        <br>
        #include &lt;array&gt; //基本配列と同じ(有限個数)。生配列より便利な機能がある.size()関数とかstd::vector系関数が使える<br>
        #include &lt;limits&gt; // std::numeric_limitsで無限大などを使う https://cpprefjp.github.io/reference/limits/numeric_limits.html<br>
        #include &lt;cmath&gt; // std::の数学系関数に必要<br>
        <br>
        <br>
        //【注意】std::vectorとは全く違う。数学で習う【ベクトル】です。ごっちゃにしないで。<br>
        <br>
        //★【UnityのVector演算コード】https://github.com/Unity-Technologies /UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
        //★【UnityのMath演算コード】https://github.com/Unity-Technologies /UnityCsReference /blob/master/Runtime/Export/Math/Mathf.cs<br>
        <br>
        <br>
        // 2変数x,yを持つ構造体。2つの数字をまとめて扱うならXY座標以外にも使えるよ。x,y別々に足したり引いたり面倒でしょう。 <br>
        struct Vector2<br>
        {<br>
        &nbsp;&nbsp; &nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float y;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }; //[匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 2&gt; xy; // float xy[2];と同じ意味 float 2個ぶんのデータサイズでx,y 2個ぶんと一致するので★unionで共用<br>
        &nbsp;&nbsp; &nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y分けて記述するの面倒なとき配列xy[2]をfor文i=0～2で回せる<br>
        <br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator float* () const { return (float*)this; }<br>
        &nbsp;&nbsp; &nbsp;// float型のポインタへ(const float*)キャストすればx,yデータの配列の先頭のアドレスを返す<br>
        &nbsp;&nbsp; &nbsp;inline operator const float* () const { return (const float*)this; }<br>
        <br>
        &nbsp;&nbsp; &nbsp;// 初期化コンストラクタ<br>
        &nbsp;&nbsp; &nbsp;Vector2(float x = 0.0f, float y = 0.0f) //初期化<br>
        &nbsp;&nbsp; &nbsp;{<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; this-&gt;xy = { x,y }; // たった1行で書ける<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;x = x;<br>
        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;y = y; 2行が上のxyzの様にたった1行で書けるようになる<br>
        &nbsp;&nbsp; &nbsp;}<br>
        <br>
        &nbsp;&nbsp;&nbsp; // Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 zero;// = { 0.f,&nbsp; 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 one; // = { 1.f,&nbsp; 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 up;&nbsp; // = { 0.f,&nbsp; 1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 down;// = { 0.f, -1.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 left; // = { -1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 right;// = { 1.f, 0.f };<br>
        &nbsp;&nbsp;&nbsp; //[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 negativeInfinity;// = { -std::numeric_limits&lt;float&gt;::infinity(), .. };<br>
        &nbsp;&nbsp;&nbsp; //[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
        &nbsp;&nbsp;&nbsp; static const Vector2 positiveInfinity;// = { std::numeric_limits&lt;float&gt;::infinity(), .. };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ベクトルの長さ(0から点(x,y,z)までの距離)<br>
        &nbsp;&nbsp;&nbsp; inline float magnitude() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return std::sqrt(x * x + y * y); // √(x*x + y*y)<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)<br>
        &nbsp;&nbsp;&nbsp; inline float sqrMagnitude() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return x * x + y * y; // x*x + y*y <br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>// 正規化したベクトルを返す<br>
          &nbsp;&nbsp;&nbsp; Vector2 normalized() const //[後ろにconstをつけないと..] https://www7b.biglobe.ne.jp/~robe/cpphtml/html02/cpp02010.html<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float mag = magnitude();<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (mag &lt; 0.00001f) // ほぼ0ベクトルか？<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ x / mag, y / mag }; // x / |x|, y / |y|<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        &nbsp;&nbsp;&nbsp; /*-----　演算子オーバーロード　-----*/<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 逆ベクトル<br>
        &nbsp;&nbsp;&nbsp; inline Vector2 operator -() const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ -this-&gt;x, -this-&gt;y };<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // Vectorをそのまま足し合わせる<br>
        &nbsp;&nbsp;&nbsp; inline Vector2 operator + () const<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator += (const Vector2 add_v2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x += add_v2.x;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y += add_v2.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this; //*thisを返すことで v1 + v2 + v3見たく数珠繋ぎできる<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator -= (const Vector2 minus_v2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x -= minus_v2.x;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y -= minus_v2.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator *= (float multiply_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x *= multiply_num;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y *= multiply_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 0.fで割ったときは±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; inline Vector2&amp; operator /= (float divide_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (divide_num == 0.0f) // 0で割ったら±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *this = Vector2{ ((this-&gt;x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;((this-&gt;y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x /= divide_num;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y /= divide_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 代入演算子 x,y,zを全部 change_numに変える<br>
        &nbsp;&nbsp;&nbsp; Vector2&amp; operator = (float change_num)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;x = change_num;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;y = change_num;<br>
        <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 一致演算子 x,y,zを全部一致するか 一つでも違えばfalse<br>
        &nbsp;&nbsp;&nbsp; bool operator == (const Vector2&amp; v2_other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;x != v2_other.x) return false;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;y != v2_other.y) return false;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 不一致演算子 一致演算子の逆<br>
        &nbsp;&nbsp;&nbsp; bool operator != (const Vector2&amp; v2_other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return !(*this == v2_other);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        };<br>
        <br>
        <br>
        // Vector2どうしの足し算 割り算 掛け算 割り算などの 基本演算の グローバル定義<br>
        <br>
        // Vector同士の足し算 x,y個別に足し合わせる<br>
        inline Vector2 operator + (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 + vec2のとき vec1の数値が書き変わったら嫌だからv3を新たに用意<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x + right.x; //[コレはダメ] left.x = left.x + right.x;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y + right.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // Vector同士の引き算 x,y個別に足し合わせる<br>
        inline Vector2 operator - (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2; //注意 vec1 = vec1 - vec2のとき vec1の数値が書き変わったら嫌だからv2を新たに用意<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x - right.x; //[コレはダメ] left.x = left.x - right.x;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y - right.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // Vectorと数値の掛け算 x,y個別に掛け合わせる<br>
        inline Vector2 operator * (const Vector2&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x * right;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y * right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        <br>
        // 数値とVectorの掛け算 x,y個別に掛け合わせる<br>
        inline Vector2 operator * (float left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
        &nbsp;&nbsp;&nbsp; v2.x = left * right.x;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left * right.y;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // Vectorと数値の割り算 x,y,z個別に割り合わせる<br>
        // 0.fで割ると±無限大を返す<br>
        inline Vector2 operator / (const Vector2&amp; left, float right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (right == 0.0f) // 0で割ったら±無限大を返す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector2{ ((left.x &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity(),<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ((left.y &lt; 0) ? 1 : -1) * std::numeric_limits&lt;float&gt;::infinity() };<br>
        <br>
        &nbsp;&nbsp;&nbsp; Vector2 v2;<br>
        &nbsp;&nbsp;&nbsp; v2.x = left.x / right;<br>
        &nbsp;&nbsp;&nbsp; v2.y = left.y / right;<br>
        <br>
        &nbsp;&nbsp;&nbsp; return v2;<br>
        }<br>
        <br>
        // 比較不等号 &lt; 演算子<br>
        inline bool operator &lt; (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &lt; right.x;<br>
        &nbsp;&nbsp;&nbsp; return left.y &lt; right.y;<br>
        }<br>
        <br>
        // 比較不等号 &gt; 演算子<br>
        inline bool operator &gt; (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (left.x != right.x) return left.x &gt; right.x;<br>
        &nbsp;&nbsp;&nbsp; return left.y &gt; right.y;<br>
        }<br>
        <br>
        // 比較不等号 &lt;= 演算子<br>
        inline bool operator &lt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &gt; right);<br>
        }<br>
        <br>
        // 比較不等号 &gt;= 演算子<br>
        inline bool operator &gt;= (const Vector2&amp; left, const Vector2&amp; right)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;&nbsp; !(left &lt; right);<br>
        }<br>
        <br>
        // ベクトルの 2 乗の長さを返します(平方根しないぶん計算速い)<br>
        inline float sqrMagnitude(const Vector2&amp; vec)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return vec.x * vec.x + vec.y * vec.y; // x*x + y*y<br>
        }<br>
        <br>
        // ベクトルの長さ(原点0から点(x,y)までの距離)<br>
        inline float magnitude(const Vector2&amp; vec)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; return std::sqrt(sqrMagnitude(vec)); // √x*x + y*y<br>
        }<br>
        <br>
        <em>// 2つのベクトルの内積<br>
          inline float dot(const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; return left.x * right.x + left.y * right.y; //普通にx同士,y同士掛けるだけ<br>
          }<br>
          <br>
          // 2つのベクトルの外積<br>
          inline float cross(const Vector2&amp; left, const Vector2&amp; right)<br>
          {<br>
          &nbsp;&nbsp;&nbsp; return left.x * right.y - left.y * right.x;// 外積のたすき掛け<br>
          }</em><br>
        <br>
        #endif</p>
      <br>
      <code>MyMath.h</code>を変更して円と線が接触しているか判定する関数CircleSegment関数を追加してみましょ う。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と円が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc1"&gt;円1の中心pc1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc2"&gt;円2の中心pc2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1, float radius1,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2, float radius2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (pc1 - pc2).sqrMagnitude() &lt; ((radius1 + radius2) * (radius1 + radius2));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>/// &lt;summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// 円と線が重なっているかを調べる<br>
          &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="pc"&gt;円の中心&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="r"&gt;円の半径&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;線の端p1&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;線の端p2&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
          &nbsp;&nbsp;&nbsp; static bool CircleSegment(Vector2 pc, float r, Vector2 p1, Vector2 p2)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v12 = p2 - p1; // 線p1p2の始点p1から終点p2へ向かうベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = pc - p1; // 点p1から円の中心pcへ向かうベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v2 = pc - p2; // 点p2から円の中心pcへ向かうベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ev12 = v12.normalized(); // 単位ベクトル 線p1p2のp1からp2へ向かう単位ベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L; // 円と線の距離<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //円の中心pcが線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(v12, v1) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v1.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-v1, v2) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v2.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //外積を求めれば点pcと直線p1_p2の距離Lが求まる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = std::abs(cross(ev12, v1)); // |外積| (外積の絶対値をabsで求める)<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (L &lt; r) //衝突条件　L &lt; r(L &lt;= rにするかは地面から丁度半径r離れた位置で触れていると判定したいか次第)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        };<br>
        <br>
        #endif </p>
      下図で上記コードのv12をvに、ev12をevに置き換えて式との対応関係を確認してみてください。<br>
      <p> <img src="image/circle_line_collision1.png" alt=""></p>
      <br>
      <br>
      <p><code>main.cpp</code>を変更して円と線の当たり判定をしてみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 1,1 }; // (x,y) = (1,1)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ <em>7,13</em> }; // (x,y) = (<em>7,13</em>)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 3,3 }; // (x,y) = (3,3)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 1; // 円の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1{ 6,5 }; // 円1の中心<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r1 = 2; // 円1の半径<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2{ 8,9 }; // 円2の中心<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r2 = 3; // 円1の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円1と円2が当たっているかの判定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision12 = MyMath::CircleCircleIntersection(pc1, r1, pc2, r2);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 円1と線p1p2が当たっているかの判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision1_12 = MyMath::CircleSegment(pc1, r1, p1, p2);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円2と線p1p2が当たっているかの判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision2_12 = MyMath::CircleSegment(pc2, r2, p1, p2);</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc1.x, pc1.y, r1, (<em>isCollision1_12</em>) ? GetColor(255, 0, 0): GetColor(255, 255, 255), FALSE); // 円1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc2.x, pc2.y, r2, (<em>isCollision2_12</em>) ? GetColor(255, 0, 0) : GetColor(255, 255, 255), FALSE); // 円2を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, (isCollision1_12 || isCollision2_12) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分p1p2<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(255, 0, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(255, 0, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p0_String.c_str(), GetColor(0, 0, 255));</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * 3, p1.y + Vector2::up.y * 3, GetColor(0, 255, 255)); // upベクトルを3倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかかでしょう? こんどは 円1 と 円2 と 線分p1p2 の当たり判定をして、円2と線が接触して赤色になっていますか。<br>
      内積dotで (点p1→p2)・(点p1→円中心) &lt; 0 以下なら 内積のcosθが±90度を超えるので円の中心は線の外側p1サイドの外側になり、距離Lはmagnitudeで求まる<br>
      内積dotで (点p1←円中心)・(点p2→円中心) &lt; 0 以下なら 内積のcosθが±90度を超えるので円の中心は線の外側p2サイドの外側で、 距離Lはmagnitudeで求まる<br>
      円の中心が線p1とp2の間の空中にあるのなら円と線の距離Lは外積=円の中心から線p1p2へ垂直に下した線の長さで求まる<br>
      というふうに内積dotで角度を判別して、大きさmagunitudeや外積crossと正規化normalizedの組み合わせで円と線の距離が求まってい ます。<br>
      ゲームの当たり判定に、内積dot、外積cross、大きさmagnitude、単位ベクトルnormalizedが活躍していることが実感できたでしょう か?<br>
      <br>
    </a> <a id="mozTocId0008" class="mozTocH1">
      <h1>MyMathクラスで円と線が当たったら線に沿って押し戻す処理ができるようにする</h1>
      <code>MyMath.h</code>を変更して円と線が接触したら押し戻した位置をreturnする関数CircleBoundを追加してみましょ う。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と円が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc1"&gt;円1の中心pc1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc2"&gt;円2の中心pc2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1, float radius1,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2, float radius2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (pc1 - pc2).sqrMagnitude() &lt; ((radius1 + radius2) * (radius1 + radius2));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と線が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc"&gt;円の中心&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="r"&gt;円の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;線の端p1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;線の端p2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleSegment(Vector2 pc, float r, Vector2 p1, Vector2 p2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v12 = p2 - p1; // 線p1p2の始点p1から終点p2へ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = pc - p1; // 点p1から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v2 = pc - p2; // 点p2から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ev12 = v12.normalized(); // 単位ベクトル 線p1p2のp1からp2へ向かう単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L; // 円と線の距離<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //円の中心pcが線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(v12, v1) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v1.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-v1, v2) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v2.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //外積を求めれば点pcと直線p1_p2の距離Lが求まる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = std::abs(cross(ev12, v1)); // |外積| (外積の絶対値をabsで求める)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (L &lt; r) //衝突条件　L &lt; r(L &lt;= rにするかは地面から丁度半径r離れた位置で触れていると判定したいか次第)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>/// &lt;summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// 円と線が重なっているかを調べる<br>
          &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="pc"&gt;円の中心&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="r"&gt;円の半径&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;線の端p1&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;線の端p2&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;押し戻しした円の中心の点&lt;/returns&gt;<br>
          &nbsp;&nbsp;&nbsp; static Vector2 CircleBound(Vector2 pc, float r, Vector2 p1, Vector2 p2)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v12 = p2 - p1; // 線p1p2の始点p1から終点p2へ向かうベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = pc - p1; // 点p1から円の中心pcへ向かうベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v2 = pc - p2; // 点p2から円の中心pcへ向かうベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ev12 = v12.normalized(); // 単位ベクトル 線p1p2のp1からp2へ向かう単位ベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //円の中心pcが線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(v12, v1) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p1 + v1.normalized() * (r + 0.001f); // 半径よりちょっとだけ0.001f離れた位置まで押し戻す<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-v1, v2) &lt; 0) //点p0が線p1p2の外側にあるときは 内積 &lt; 0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p2 + v2.normalized() * (r + 0.001f); // 半径よりちょっとだけ0.001f離れた位置まで押し戻す<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //外積を求めれば点pcと直線p1_p2の距離Lが求まる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = dot(ev12, v1); // 内積で点p1から交点Qまでの距離を求める<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q = p1 + L * ev12; // 円と線の衝突点Q<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 e = (pc - Q).normalized(); // 跳ね返り方向のの半径1の単位ベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Q + e * (r + 0.001f); // 押し戻し処理<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        };<br>
        <br>
        #endif </p>
      下図で上記コードのv12をvに、ev12をevに置き換えて式との対応関係を確認してみてください。<br>
      <p> <img src="image/circle_line_collision2.png" alt=""></p>
      <br>
      <br>
      <p><code>main.cpp</code>を変更して円と線の当たり判定をして接触している際はMyMath::CircleBoundで円を押し戻 した位置を描く処理を追加してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 1,1 }; // (x,y) = (1,1)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ <em>8,8</em> }; // (x,y) = (<em>8,8</em>)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 3,3 }; // (x,y) = (3,3)の位置の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 1; // 円の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1{ 6,5 }; // 円1の中心<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r1 = 2; // 円1の半径<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2{ 8,9 }; // 円2の中心<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r2 = 3; // 円1の半径<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円1と円2が当たっているかの判定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision12 = MyMath::CircleCircleIntersection(pc1, r1, pc2, r2);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円1と線p1p2が当たっているかの判定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision1_12 = MyMath::CircleSegment(pc1, r1, p1, p2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円2と線p1p2が当たっているかの判定<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision2_12 = MyMath::CircleSegment(pc2, r2, p1, p2);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Vector2 pb1 = pc1; // 線に押し戻された円1の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision1_12) <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb1 = MyMath::CircleBound(pc1, r1, p1, p2);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pb2 = pc2; // 線に押し戻された円2の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision2_12)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb2 = MyMath::CircleBound(pc2, r2, p1, p2);</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc1.x, pc1.y, r1, (isCollision1_12) ? GetColor(255, 0, 0): GetColor(255, 255, 255), FALSE); // 円1を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc2.x, pc2.y, r2, (isCollision2_12) ? GetColor(255, 0, 0) : GetColor(255, 255, 255), FALSE); // 円2を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if (pb1 != pc1) // 線に当たって押し戻された円1を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pb1.x, pb1.y, r1, GetColor(255, 0, 255), FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pb2 != pc2) // 線に当たって押し戻された円2を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pb2.x, pb2.y, r2, GetColor(255, 0, 255), FALSE);</em><br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, (isCollision1_12 || isCollision2_12) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分p1p2<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p0_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * 3, p1.y + Vector2::up.y * 3, GetColor(0, 255, 255)); // upベクトルを3倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかかでしょう? 線と 円1 と 円2 の両方が接触して 押し戻されて線にぴったり沿う位置に円が描かれていますか。<br>
      <br>
      <br>
    </a> <a id="mozTocId0009" class="mozTocH1">
      <h1>MyMathクラスで線に垂直に下した点の影(射影)位置と線と点の最短距離を求める</h1>
      <code>MyMath.h</code>を変更して線p1p2に対して点p0から垂直に下した交点Qとp0からQへの距離Lと点p0から線p1p2への最 短距離Hを求める関数LineProjectionを追加してみましょ う。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と円が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc1"&gt;円1の中心pc1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc2"&gt;円2の中心pc2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1, float radius1,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2, float radius2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (pc1 - pc2).sqrMagnitude() &lt; ((radius1 + radius2) * (radius1 + radius2));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と線が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc"&gt;円の中心&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="r"&gt;円の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;線の端p1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;線の端p2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleSegment(Vector2 pc, float r, Vector2 p1, Vector2 p2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v12 = p2 - p1; // 線p1p2の始点p1から終点p2へ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = pc - p1; // 点p1から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v2 = pc - p2; // 点p2から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ev12 = v12.normalized(); // 単位ベクトル 線p1p2のp1からp2へ向かう単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L; // 円と線の距離<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //円の中心pcが線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(v12, v1) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v1.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-v1, v2) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v2.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //外積を求めれば点pcと直線p1_p2の距離Lが求まる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = std::abs(cross(ev12, v1)); // |外積| (外積の絶対値をabsで求める)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (L &lt; r) //衝突条件　L &lt; r(L &lt;= rにするかは地面から丁度半径r離れた位置で触れていると判定したいか次第)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と線が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc"&gt;円の中心&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="r"&gt;円の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;線の端p1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;線の端p2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;押し戻しした円の中心の点&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static Vector2 CircleBound(Vector2 pc, float r, Vector2 p1, Vector2 p2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v12 = p2 - p1; // 線p1p2の始点p1から終点p2へ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = pc - p1; // 点p1から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v2 = pc - p2; // 点p2から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ev12 = v12.normalized(); // 単位ベクトル 線p1p2のp1からp2へ向かう単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //円の中心pcが線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(v12, v1) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p1 + v1.normalized() * (r + 0.001f); // 半径よりちょっとだけ0.001f離れた位置まで押し戻す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-v1, v2) &lt; 0) //点p0が線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p2 + v2.normalized() * (r + 0.001f); // 半径よりちょっとだけ0.001f離れた位置まで押し戻す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //外積を求めれば点pcと直線p1_p2の距離Lが求まる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = dot(ev12, v1); // 内積で点p1から交点Qまでの距離を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q = p1 + L * ev12; // 円と線の衝突点Q<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 e = (pc - Q).normalized(); // 跳ね返り方向のの半径1の単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Q + e * (r + 0.001f); // 押し戻し処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em><br>
          &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// 斜面a(線p1→p2),線b(p1→p0)のとき斜面a上に点p0から垂直に下した射影点(点Q)の位置とp0からQへの長さLとp0と線aとの距離Hを求める<br>
          &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="p0"&gt;線bの先っぽp0&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;aとbの起点p1&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;斜面aの端p2&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="L"&gt;p1からQまでの距離&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="H"&gt;p0と直線p1p2の距離(= 高さ[線の内側]か端っこの点からの半径[線の外側])&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;線aに線bから下した交点Q&lt;/returns&gt;<br>
          &nbsp;&nbsp;&nbsp; static Vector2 LineProjection(Vector2 p0, Vector2 p1, Vector2 p2, float&amp; L, float&amp; H, Vector2&amp; nearest)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ベクトルaとベクトルbを求める。ただマイナスするだけ。<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 a = p2 - p1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 b = p0 - p1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 c = p0 - p2; // p2→p0のベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 正規化ベクトルを求める<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ea = a.normalized(); // a / |a|<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isOutside = false; // p0が線の外側か?<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //点p0が線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(a, b) &lt; 0) // 点p0が線p1p2の外側にあるときは 内積 &lt; 0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; H = b.magnitude(); // 点p0と直線p1p2の距離は単なるベクトルbの直線距離でいい<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearest = p1; // 一番近い点はp1<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isOutside = true; // p1側の外側<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-a, c) &lt; 0) // 点p0が線p1p2の外側にあるときは 内積 &lt; 0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; H = c.magnitude(); // 点p0と直線p1p2の距離は単なるベクトルcの直線距離でいい<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearest = p2; // 一番近い点はp2<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isOutside = true; // p2側の外側<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 外積を求めれば点p0と直線p1_p2の距離Lが求まる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ea_cross_b = cross(ea, b);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; H = ea_cross_b.magnitude();<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = dot(ea, b); // 長さLは内積で求まる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 resultQ = p1 + L * ea;<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isOutside)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearest = resultQ; // 一番近い点はQ<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return resultQ;<br>
          &nbsp;&nbsp;&nbsp; }<br>
        </em><br>
        <br>
        };<br>
        <br>
        #endif </p>
      下図で上記コードの式との対応関係を確認してみてください。<br>
      <p> <img src="image/circle_line_collision3.png" alt=""></p>
      <br>
      <br>
      <p><code>main.cpp</code>がちらかってきたので一旦、今まで書いてきたVector関連のコードを消してから今回のコードを入れま しょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        <u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 1,1 }; // (x,y) = (1,1)の位置の点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 8,8 }; // (x,y) = (8,8)の位置の点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 3,3 }; // (x,y) = (3,3)の位置の点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r = 1; // 円の半径<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1{ 6,5 }; // 円1の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r1 = 2; // 円1の半径<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2{ 8,9 }; // 円2の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r2 = 3; // 円1の半径<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v13 = p3 - p1; // 終点p3 から 始点p1を引くとp1からp3へ向かう方向ベクトルになる<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円1と円2が当たっているかの判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision12 = MyMath::CircleCircleIntersection(pc1, r1, pc2, r2);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円1と線p1p2が当たっているかの判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision1_12 = MyMath::CircleSegment(pc1, r1, p1, p2);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 円2と線p1p2が当たっているかの判定<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision2_12 = MyMath::CircleSegment(pc2, r2, p1, p2);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pb1 = pc1; // 線に押し戻された円1の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision1_12) <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb1 = MyMath::CircleBound(pc1, r1, p1, p2);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pb2 = pc2; // 線に押し戻された円2の中心<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollision2_12)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb2 = MyMath::CircleBound(pc2, r2, p1, p2);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc1.x, pc1.y, r1, (isCollision1_12) ? GetColor(255, 0, 0): GetColor(255, 255, 255), FALSE); // 円1を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pc2.x, pc2.y, r2, (isCollision2_12) ? GetColor(255, 0, 0) : GetColor(255, 255, 255), FALSE); // 円2を描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pb1 != pc1) // 線に当たって押し戻された円1を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pb1.x, pb1.y, r1, GetColor(255, 0, 255), FALSE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pb2 != pc2) // 線に当たって押し戻された円2を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(pb2.x, pb2.y, r2, GetColor(255, 0, 255), FALSE);<br>
          <br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, (isCollision1_12 || isCollision2_12) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分p1p2<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(255, 0, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(255, 0, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p0_String.c_str(), GetColor(0, 0, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + Vector2::up.x * 3, p1.y + Vector2::up.y * 3, GetColor(0, 255, 255)); // upベクトルを3倍した線を描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x * 2, p1.y + v13.y * 2, GetColor(255, 0, 255)); // 線分p1p3の2倍した線を描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p1.x + v13.x, p1.y + v13.y, GetColor(255, 255, 255)); // 線分p1p3を描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawCircle(p3.x, p3.y, r, GetColor(0, 255, 0), FALSE); // 半径rの円(中心:p3)を描く(FALSEで塗りつぶし無し)</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      <p><code>main.cpp</code>を変更してMyMath::LineProjectionで線に点から垂直に下した位置と最短距離の表示処 理を追加してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Vector2 p0{ 5,8 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 2,2 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 10,3 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = 0; // 点p1から交点Qへの距離<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float H = 0; // 線分p1p2と点p0の最短距離H<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 nearest; // 点p0から一番近い直線p1p2上の点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q = MyMath::LineProjection(p0,p1,p2,L,H, nearest); // 点p0から線分p1p2に垂直に下した交点Q<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255)); // 線分p1p2<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p0.x, p0.y, GetColor(150, 150, 150)); // 線分p1p0<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, nearest.x, nearest.y, GetColor(255, 255, 0)); // p0からの最短距離を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, Q.x, Q.y, GetColor(0, 255, 255)); // p0からQへの距離Lを描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y-5, Q_String.c_str(), GetColor(255, 0, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string H_String = "最短距離H=" + std::to_string(H);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(nearest.x, nearest.y - 10, H_String.c_str(), GetColor(255, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string L_String = "L=" + std::to_string(L);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 3, L_String.c_str(), GetColor(0, 255, 255));</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      いかがですか？最短距離が表示されましたか?<br>
      念のため、p1側の外側の場合の最短距離も試しておきましょう。<br>
      <br>
      <p><code>main.cpp</code>の数値を変更してp1側の外側の場合の最短距離も試しておきましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ <em>-3</em>,8 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 2,2 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 10,3 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = 0; // 点p1から交点Qへの距離<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float H = 0; // 線分p1p2と点p0の最短距離H<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 nearest; // 点p0から一番近い直線p1p2上の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q = MyMath::LineProjection(p0,p1,p2,L,H, nearest); // 点p0から線分p1p2に垂直に下した交点Q<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255)); // 線分p1p2<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p0.x, p0.y, GetColor(150, 150, 150)); // 線分p1p0<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, nearest.x, nearest.y, GetColor(255, 255, 0)); // p0からの最短距離を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, Q.x, Q.y, GetColor(0, 255, 255)); // p0からQへの距離Lを描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y-5, Q_String.c_str(), GetColor(255, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string H_String = "最短距離H=" + std::to_string(H);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(nearest.x, nearest.y - 10, H_String.c_str(), GetColor(255, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string L_String = "L=" + std::to_string(L);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 3, L_String.c_str(), GetColor(0, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      いかがですか？p1側の外側の場合の最短距離が表示されましたか?<br>
      念のため、p2側の外側の場合の最短距離も試しておきましょう。<br>
      <br>
      <p><code>main.cpp</code>の数値を変更してp2側の外側の場合の最短距離も試しておきましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ <em>15</em>,8 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 2,2 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 10,3 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = 0; // 点p1から交点Qへの距離<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float H = 0; // 線分p1p2と点p0の最短距離H<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 nearest; // 点p0から一番近い直線p1p2上の点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q = MyMath::LineProjection(p0,p1,p2,L,H, nearest); // 点p0から線分p1p2に垂直に下した交点Q<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255)); // 線分p1p2<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p0.x, p0.y, GetColor(150, 150, 150)); // 線分p1p0<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, nearest.x, nearest.y, GetColor(255, 255, 0)); // p0からの最短距離を描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, Q.x, Q.y, GetColor(0, 255, 255)); // p0からQへの距離Lを描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y-5, Q_String.c_str(), GetColor(255, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string H_String = "最短距離H=" + std::to_string(H);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(nearest.x, nearest.y - 10, H_String.c_str(), GetColor(255, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string L_String = "L=" + std::to_string(L);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 3, L_String.c_str(), GetColor(0, 255, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょうか？この最短距離の処理は2Dのカプセルコライダーの点との当たり判定の場合分けの条件と同じです。<br>
      カプセルコライダーは複雑そうに思えて、実はシンプルな内積や外積の場合分けの計算で高速に計算できるのです。<br>
      計算時間が早く、当たり判定の伸縮性がありゲームの当たり判定はカプセルコライダーを多用して制作されているのです。<br>
      <br>
      <br>
    </a> <a id="mozTocId0010" class="mozTocH1">
      <h1>MyMathクラスで線と線が交差するか判定する</h1>
      <code>MyMath.h</code>を変更して線分line0と線分line1が交差するかを求める関数LineIntersection(判定のみ ver.)を追加してみましょう。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と円が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc1"&gt;円1の中心pc1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius1"&gt;円1の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc2"&gt;円2の中心pc2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="radius2"&gt;円2の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleCircleIntersection(<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc1, float radius1,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 pc2, float radius2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (pc1 - pc2).sqrMagnitude() &lt; ((radius1 + radius2) * (radius1 + radius2));<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と線が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc"&gt;円の中心&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="r"&gt;円の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;線の端p1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;線の端p2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;重なっていればtrue、重なっていなければfalseを返却する&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool CircleSegment(Vector2 pc, float r, Vector2 p1, Vector2 p2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v12 = p2 - p1; // 線p1p2の始点p1から終点p2へ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = pc - p1; // 点p1から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v2 = pc - p2; // 点p2から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ev12 = v12.normalized(); // 単位ベクトル 線p1p2のp1からp2へ向かう単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L; // 円と線の距離<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //円の中心pcが線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(v12, v1) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v1.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-v1, v2) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = v2.magnitude(); //点pcと直線p1p2の距離は単なる直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //外積を求めれば点pcと直線p1_p2の距離Lが求まる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = std::abs(cross(ev12, v1)); // |外積| (外積の絶対値をabsで求める)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (L &lt; r) //衝突条件　L &lt; r(L &lt;= rにするかは地面から丁度半径r離れた位置で触れていると判定したいか次第)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 円と線が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="pc"&gt;円の中心&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="r"&gt;円の半径&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;線の端p1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;線の端p2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;押し戻しした円の中心の点&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static Vector2 CircleBound(Vector2 pc, float r, Vector2 p1, Vector2 p2)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v12 = p2 - p1; // 線p1p2の始点p1から終点p2へ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = pc - p1; // 点p1から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v2 = pc - p2; // 点p2から円の中心pcへ向かうベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ev12 = v12.normalized(); // 単位ベクトル 線p1p2のp1からp2へ向かう単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //円の中心pcが線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(v12, v1) &lt; 0) //点pcが線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p1 + v1.normalized() * (r + 0.001f); // 半径よりちょっとだけ0.001f離れた位置まで押し戻す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-v1, v2) &lt; 0) //点p0が線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p2 + v2.normalized() * (r + 0.001f); // 半径よりちょっとだけ0.001f離れた位置まで押し戻す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //外積を求めれば点pcと直線p1_p2の距離Lが求まる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = dot(ev12, v1); // 内積で点p1から交点Qまでの距離を求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q = p1 + L * ev12; // 円と線の衝突点Q<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 e = (pc - Q).normalized(); // 跳ね返り方向のの半径1の単位ベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Q + e * (r + 0.001f); // 押し戻し処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em><br>
        </em>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 斜面a(線p1→p2),線b(p1→p0)のとき斜面a上に点p0から垂直に下した射影点(点Q)の位置とp0からQへの長さLとp0と線aとの距離Hを求める<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p0"&gt;線bの先っぽp0&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p1"&gt;aとbの起点p1&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="p2"&gt;斜面aの端p2&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="L"&gt;p1からQまでの距離&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="H"&gt;p0と直線p1p2の距離(= 高さ[線の内側]か端っこの点からの半径[線の外側])&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;線aに線bから下した交点Q&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static Vector2 LineProjection(Vector2 p0, Vector2 p1, Vector2 p2, float&amp; L, float&amp; H, Vector2&amp; nearest)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ベクトルaとベクトルbを求める。ただマイナスするだけ。<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 a = p2 - p1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 b = p0 - p1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 c = p0 - p2; // p2→p0のベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 正規化ベクトルを求める<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ea = a.normalized(); // a / |a|<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isOutside = false; // p0が線の外側か?<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //点p0が線p1p2の外側にあるかの判定のため内積を計算して線の外側の場合を考慮する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dot(a, b) &lt; 0) // 点p0が線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; H = b.magnitude(); // 点p0と直線p1p2の距離は単なるベクトルbの直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearest = p1; // 一番近い点はp1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isOutside = true; // p1側の外側<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dot(-a, c) &lt; 0) // 点p0が線p1p2の外側にあるときは 内積 &lt; 0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; H = c.magnitude(); // 点p0と直線p1p2の距離は単なるベクトルcの直線距離でいい<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearest = p2; // 一番近い点はp2<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isOutside = true; // p2側の外側<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 外積を求めれば点p0と直線p1_p2の距離Lが求まる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ea_cross_b = cross(ea, b);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; H = ea_cross_b.magnitude();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = dot(ea, b); // 長さLは内積で求まる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 resultQ = p1 + L * ea;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isOutside)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nearest = resultQ; // 一番近い点はQ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return resultQ;<br>
        &nbsp;&nbsp;&nbsp; }<em><br>
        </em><br>
        <em>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// 線line0と線line1が重なっているかを調べる<br>
          &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="line0start"&gt;線line0の始点&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="line0end"&gt;線line0の終点&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="line1start"&gt;線line1の始点&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="line1end"&gt;線line1の終点&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;線line0と線line1が交差しているならtrue,してないならfalse&lt;/returns&gt;<br>
          &nbsp;&nbsp;&nbsp; static bool LineIntersection(Vector2 line0start, Vector2 line0end, Vector2 line1start, Vector2 line1end)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v0 = line0end - line0start; // line0の始点startから終点endへのベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = line1end - line1start; // line1の始点startから終点endへのベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v01 = line1start - line0start; // line0の始点からline1の始点へのベクトル 0start→1start<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t1 = cross(v01, v0) / cross(v0, v1);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t0 = cross(v01, v1) / cross(v0, v1);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line0と線分line1が【交差しているか判定】<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0 &lt; t1 &amp;&amp; t1 &lt; 1 &amp;&amp; 0 &lt; t0 &amp;&amp; t0 &lt; 1) return true; //【交差している】<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 線分line0と線分line1は【交差していない】<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        };<br>
        <br>
        #endif </p>
      下図で上記コードの式との対応関係を確認してみてください。(ベクトルaをv0に ベクトルbをv1に ベクトルcをv01に 置き換えてみよう[ピンクの部分])<br>
      <p> <img src="image/circle_line_collision4.png" alt=""></p>
      <br>
      <br>
      <p><code>main.cpp</code>がちらかってきたので一旦、今まで書いてきたVector関連のコードを消してから今回のコードを入れま しょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        <u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 15,8 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 2,2 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 10,3 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float L = 0; // 点p1から交点Qへの距離<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float H = 0; // 線分p1p2と点p0の最短距離H<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 nearest; // 点p0から一番近い直線p1p2上の点<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q = MyMath::LineProjection(p0,p1,p2,L,H, nearest); // 点p0から線分p1p2に垂直に下した交点Q<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p2.x, p2.y, GetColor(255, 255, 255)); // 線分p1p2<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, p0.x, p0.y, GetColor(150, 150, 150)); // 線分p1p0<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p0.x, p0.y, nearest.x, nearest.y, GetColor(255, 255, 0)); // p0からの最短距離を描く<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawLine(p1.x, p1.y, Q.x, Q.y, GetColor(0, 255, 255)); // p0からQへの距離Lを描く<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y-5, Q_String.c_str(), GetColor(255, 0, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string H_String = "最短距離H=" + std::to_string(H);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(nearest.x, nearest.y - 10, H_String.c_str(), GetColor(255, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string L_String = "L=" + std::to_string(L);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 3, L_String.c_str(), GetColor(0, 255, 255));</u><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      <p><code>main.cpp</code>を変更してMyMath::LineIntersectionで線分line0と線分line1が交差する かの判定を追加してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 線分line0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 5,5 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,11 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,6 };<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineIntersection(p0, p3, p2, p1);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      いかがですか？線line0と線line1が交差しているので線が赤色で表示されましたか?<br>
      念のため、交差しない場合も試しておきましょう。<br>
      <br>
      <br>
      <p><code>main.cpp</code>の点p1の位置を変更して線分line0と線分line1が交差しない場合(t0 &lt; 0)の判定を試してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ <em>11,9</em> };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,11 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineIntersection(p0, p3, p2, p1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      <br>
      いかがですか？線line0と線line1が交差していていない(t0 &lt; 0)ので線が白色で表示されましたか?<br>
      念のため、別の交差しない場合(1 &lt; t0のとき)も試しておきましょう。<br>
      <br>
      <br>
      <p><code>main.cpp</code>の点p1の位置を変更して線分line0と線分line1が交差しない場合(1 &lt; t0)の判定を試してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ <em>5,5</em> };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ <em>9,7</em> };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineIntersection(p0, p3, p2, p1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがですか？線line0と線line1が交差していていない(1 &lt; t0)ので線が白色で表示されましたか?<br>
      念のため、別の交差しない場合(t1 &lt; 0のとき)も試しておきましょう。<br>
      <br>
      <br>
      <p><code>main.cpp</code>の点p1の位置を変更して線分line0と線分line1が交差しない場合(t1 &lt; 0)の判定を試してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 5,5 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ <em>15,11</em> };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ <em>12,8</em> };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineIntersection(p0, p3, p2, p1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがですか？線line0と線line1が交差していていない(t1 &lt; 0)ので線が白色で表示されましたか?<br>
      念のため、別の交差しない場合(1 &lt; t1のとき)も試しておきましょう。<br>
      <br>
      <br>
      <p><code>main.cpp</code>の点p1の位置を変更して線分line0と線分line1が交差しない場合(1 &lt; t1)の判定を試してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p0{ 5,5 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p3{ 15,11 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ <em>5,10</em> };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ <em>9,9</em> };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::LineIntersection(p0, p3, p2, p1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p0.x, p0.y, 0, 0, p3.x, p3.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p0.x, p0.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "p0=(" + std::to_string((int)p0.x) + "," + std::to_string((int)p0.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p0.x, p0.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがですか？線line0と線line1が交差していていない(1 &lt; t1)ので線が白色で表示されましたか?<br>
      これで、t1 &lt; 0、1 &lt; t1、t0 &lt; 0、1 &lt; t0 の4種類の交差しないパターンを試すことができました。<br>
      線と線の交差判定は、2Dゲームのレイ(光線)と壁や地面の直線との交差判定に使えますね。<br>
      ただし、その場合はレイ(光線)は有限の直線ではなくて片方に無限の直線なので、点p0をレイ(光線)の始点とするなら、<br>
      上記の<b>「t0 &lt; 1 の判定をあえてせずに」</b>t0 が 1以上でもレイ(光線)があたっている、と判定する必要があります。<br>
      ではMyMathのLineIntersection関数を「t0 &lt; 1 の判定をあえてしないように」改造してレイ(光線)の当たり判定を実現してみましょう。<br>
      <br>
    </a> <a id="mozTocId0011" class="mozTocH1">
      <h1>MyMathクラスでレイ(光線)と線分(壁や床など)が交差するか判定する</h1>
      <code>MyMath.h</code>を変更して光線ray0と線分line1が交差するかを求める関数RayLineCollision(判定のみ ver.)を追加してみましょう。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp; &nbsp;(中略).....<br>
        <br>
        &nbsp;&nbsp;&nbsp; <em>/// &lt;summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// 光線ray0と線line1が重なっているかを調べる<br>
          &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="ray0start"&gt;光線ray0の始点&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="ray0dir"&gt;光線ray0の方向ベクトル&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="line1start"&gt;線line1の始点&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;param name="line1end"&gt;線line1の終点&lt;/param&gt;<br>
          &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;光線ray0と線line1が交差しているならtrue,してないならfalse&lt;/returns&gt;<br>
          &nbsp;&nbsp;&nbsp; static bool RayLineCollision(Vector2 ray0start, Vector2 ray0dir, Vector2 line1start, Vector2 line1end)<br>
          &nbsp;&nbsp;&nbsp; {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v0 = ray0dir; // 光線ray0のベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = line1end - line1start; // line1の始点startから終点endへのベクトル<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v01 = line1start - ray0start; // line0の始点からline1の始点へのベクトル 0start→1start<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t1 = cross(v01, v0) / cross(v0, v1);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t0 = cross(v01, v1) / cross(v0, v1);<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光線ray0と線分line1が【交差しているか判定】<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0 &lt; t1 &amp;&amp; t1 &lt; 1 &amp;&amp; 0 &lt; t0) return true; //【交差している】<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 光線ray0と線分line1は【交差していない】<br>
          &nbsp;&nbsp;&nbsp; }</em><br>
        <br>
        };<br>
        <br>
        #endif </p>
      <br>
      下図で上記コードの式との対応関係を確認してみてください。(v0をray0startに v1の代わりにray0dirに置き換えてみよう[オレンジの部分])<br>
      <p> <img src="image/circle_line_collision4.png" alt=""></p>
      <br>
      <br>
      <p><code>main.cpp</code>の点p0をray0posに、点p1の代わりにレイ光線の方向ray0dirに変更して、線分line1と交差するかの判定を試してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <em>ray0光線レイ</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 <em>ray0pos</em>{ 5,5 }; <em>// レイ光線の始点</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 <em>ray0dir</em>{ <em>1,1</em> }; <em>// レイ光線の方向</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ <em>15,6</em> };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::<em>RayLineCollision</em>(<em>ray0pos, ray0dir</em>, p2, p1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(<em>ray0pos</em>.x, <em>ray0pos</em>.y, 0, 0, <em>ray0pos.x + ray0dir.x</em>, <em>ray0pos.y + ray0dir.y</em>, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // <em>光線ray0</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(<em>ray0pos</em>.x, <em>ray0pos</em>.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "<em>ray0</em>=(" + std::to_string((int)<em>ray0pos</em>.x) + "," + std::to_string((int)<em>ray0pos</em>.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(<em>ray0pos</em>.x, <em>ray0pos</em>.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>mathGraph.DrawPoint(p3.x, p3.y, 3, GetColor(0, 255, 255), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p3_String = "p3=(" + std::to_string((int)p3.x) + "," + std::to_string((int)p3.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p3.x, p3.y, p3_String.c_str(), GetColor(0, 255, 255));</u><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？レイの方向に有限の線分(壁や床)があるときに、線が赤色で表示されたでしょうか？<br>
      念のため、こんどはレイの方向を変えて、(-1,1) x方向に-1、y方向に+1の方向、<br>
      つまり、90°+45°=135°の方向のレイに変えた場合に光線と線分(壁や床)との当たり判定もためしてみましょう。<br>
      <p><code>main.cpp</code>のレイ光線の方向ray0dirを(-1,1)=135°の方向に変更して、線分line1と交差するかの 判定を試してみます。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ray0光線レイ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0pos{ 5,5 }; // レイ光線の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0dir{ <em>-1</em>,1 }; // レイ光線の方向<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::RayLineCollision(ray0pos, ray0dir, p2, p1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(ray0pos.x, ray0pos.y, 0, 0, ray0pos.x + ray0dir.x, ray0pos.y + ray0dir.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 光線ray0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(ray0pos.x, ray0pos.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "ray0=(" + std::to_string((int)ray0pos.x) + "," + std::to_string((int)ray0pos.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(ray0pos.x, ray0pos.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？こんどはレイ光線の方向に線分(壁や床)がないので線が白色で表示されましたでしょうか？<br>
      <br>
      このように、数学の式の理解をすると、数式を少しだけ変えて(1 &lt; t0)&nbsp; t0 の1以上の判定 をしないだけで、<br>
      ゲームに実際に使えるようなレイの判定をできることが実感できたでしょうか?<br>
      <br>
      Unityに最初から用意されている機能に頼ってしまうと、このようなゲームを支える数学の基礎を学ぶ機会のないまま、就職活動をすることになってしまいま す。<br>
      すると、「Unityだけ」でゲームを作っている人は「ベクトルとか当たり判定の基礎の知識が薄い」のではないかとベテランのプログラマからは見られているわ けです。<br>
      2010年代以降の「Unity以降」世代と2010年以前の「自力勉強世代」との間の「ゲーム数学の勉強する機会格差」が生じてしまっています。<br>
      結果として、「自作ゲームは作れる」のに「ゲームプログラマ」としては就職に苦労する「世代ギャップ」が生じています。<br>
      「Unity」などのゲームエンジンの便利さにより、ゲームプログラマの「基礎的な数学力」の足腰とモチベーションをぐらつかせているという意味で、<br>
      Unityの教育の手軽さに対する「反作用」がでてきているともいえます。<br>
      (最近だと、デザイナー系や美大の学科なんかも自力でUnity勉強して、かっこいいゲーム作ってきちゃうので、差別化が大変なのです)<br>
      デザイナー系や美大の学科が、絶対に勉強してこない(勉強したくない)ような分野の代表が「ベクトルや当たり判定」なのです。<br>
      <br>
      <br>
    </a> <a id="mozTocId0012" class="mozTocH1">
      <h1>MyMathクラスでレイ(光線)と線分(壁や床など)の交点を求める</h1>
      <code>MyMath.h</code>を変更して光線ray0と線分line1の交点を求める関数RayLineCollision(交点も求める ver.)を変更してみましょう。<br>
      <p class="source">#ifndef MYMATH_H_<br>
        #define MYMATH_H_<br>
        <br>
        #include "Vector2.h" // 線との当たり判定にVector2を使う<br>
        <br>
        #include &lt;cmath&gt;<br>
        <br>
        // 数学関連クラス<br>
        class MyMath<br>
        {<br>
        public:<br>
        &nbsp;&nbsp; &nbsp;static const float Sqrt2; // = 1.41421356237f;　// √2<br>
        <br>
        &nbsp;&nbsp; &nbsp;static const float PI; // = 3.14159265359f; // 円周率<br>
        &nbsp;&nbsp; &nbsp;static const float Deg2Rad; // = PI / 180f; // 度からラジアンに変換する定数<br>
        <br>
        &nbsp;&nbsp; &nbsp;(中略).....<br>
        <br>
        &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>
        &nbsp;&nbsp;&nbsp; /// 光線ray0と線line1が重なっているかを調べる<br>
        &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>
        &nbsp;&nbsp;&nbsp; <em>/// &lt;param name="result"光線ray0と線line1の交点を求めてresultで返す&lt;/param&gt;</em><br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="ray0start"&gt;光線ray0の始点&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="ray0dir"&gt;光線ray0の方向ベクトル&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="line1start"&gt;線line1の始点&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;param name="line1end"&gt;線line1の終点&lt;/param&gt;<br>
        &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;光線ray0と線line1が交差しているならtrue,してないならfalse&lt;/returns&gt;<br>
        &nbsp;&nbsp;&nbsp; static bool RayLineCollision(<em>Vector2&amp; result, </em>Vector2 ray0start, Vector2 ray0dir, Vector2 line1start, Vector2 line1end)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v0 = ray0dir; // 光線ray0のベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v1 = line1end - line1start; // line1の始点startから終点endへのベクトル<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 v01 = line1start - ray0start; // line0の始点からline1の始点へのベクトル 0start→1start<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t1 = cross(v01, v0) / cross(v0, v1);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float t0 = cross(v01, v1) / cross(v0, v1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>result = ray0start + v0 * t0; //交点resultを求めて【&amp;result参照で返却】</em><br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光線ray0と線分line1が【交差しているか判定】<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0 &lt; t1 &amp;&amp; t1 &lt; 1 &amp;&amp; 0 &lt; t0) return true; //【交差している】<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 光線ray0と線分line1は【交差していない】<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        };<br>
        <br>
        #endif </p>
      <br>
      下図で上記コードの式との対応関係を確認してみてください。<br>
      <p> <img src="image/circle_line_collision4.png" alt=""></p>
      <br>
      <p><code>main.cpp</code>に交点Qを追加して関数の引数に渡して、線分line1と光線ray0の交点を求めて表示してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ray0光線レイ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0pos{ 5,5 }; // レイ光線の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0dir{ -1,1 }; // レイ光線の方向<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Vector2 Q; // 光線ray0とline1の交点</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::RayLineCollision(<em>Q, </em>ray0pos, ray0dir, p2, p1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(ray0pos.x, ray0pos.y, 0, 0, ray0pos.x + ray0dir.x, ray0pos.y + ray0dir.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 光線ray0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(ray0pos.x, ray0pos.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "ray0=(" + std::to_string((int)ray0pos.x) + "," + std::to_string((int)ray0pos.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(ray0pos.x, ray0pos.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 165, 0), TRUE);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 10, Q_String.c_str(), GetColor(255, 165, 0));</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？なるほど、レイ光線の方向に線分(壁や床)がないときは、線分line0の延長線上に交点Qが求まるのですね。<br>
      では、光線の方向が壁と逆方向(-1,-1)の場合はどうなるか実験してみましょう。 <br>
      <br>
      <p><code>main.cpp</code>の交点Qが光線ray0と逆方向(-1,-1)の場合の交点を表示してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ray0光線レイ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0pos{ 5,5 }; // レイ光線の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0dir{ -1,<em>-1</em> }; // レイ光線の方向<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q; // 光線ray0とline1の交点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::RayLineCollision(Q, ray0pos, ray0dir, p2, p1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(ray0pos.x, ray0pos.y, 0, 0, ray0pos.x + ray0dir.x, ray0pos.y + ray0dir.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 光線ray0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(ray0pos.x, ray0pos.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "ray0=(" + std::to_string((int)ray0pos.x) + "," + std::to_string((int)ray0pos.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(ray0pos.x, ray0pos.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 165, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 10, Q_String.c_str(), GetColor(255, 165, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？なるほど、逆方向の場合はレイ光線の後ろ側に交点が数学的に求まって、表示されるのですね。<br>
      では、今度こそレイ光線が壁(線分)にヒットするときの実験をしてみましょう。<br>
      <br>
      <p><code>main.cpp</code>を変更して、光線ray0の方向が(1,1)で壁(線)とぶつかる場合にその交点Qを表示してみましょう。 </p>
      <p class="source">#include "DxLib.h"<br>
        <br>
        #include "Screen.h"<br>
        #include "Vector2.h"<br>
        #include "MathGraph2D.h"<br>
        #include "MyMath.h"<br>
        <br>
        int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
        &nbsp;&nbsp;&nbsp; SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
        &nbsp;&nbsp;&nbsp; SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
        &nbsp;&nbsp;&nbsp; SetMainWindowText("数学のベクトルの練習");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
        &nbsp;&nbsp;&nbsp; ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
        &nbsp;&nbsp;&nbsp; SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させる<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
        &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // エラーが発生したら直ちに終了<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
        &nbsp;&nbsp;&nbsp; //表示しているスクリーンの後ろで隠れて次に描く画像を先に描くモード<br>
        &nbsp;&nbsp;&nbsp; // これとペアでScreenFlip();でつぎのページと入れ替えでちらつきを防ぐ<br>
        &nbsp;&nbsp;&nbsp; SetDrawScreen(DX_SCREEN_BACK);<br>
        &nbsp;&nbsp;&nbsp; SetUseTransColor(FALSE); // 画像の指定色を透過する機能を無効化<br>
        <br>
        &nbsp;&nbsp;&nbsp; ScreenFlip();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 数学っぽくわかりやすくマス目を描いて、原点を画面の中心にして、10倍のスケールでみやすく描く<br>
        &nbsp;&nbsp;&nbsp; MathGraph2D mathGraph{ {Screen::Width / 2 ,Screen::Height / 2 },10.0f,{1.0f,1.0f} };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
        &nbsp;&nbsp;&nbsp; while (ProcessMessage() == 0)<br>
        &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearDrawScreen(); // 画面をまっさらにリセット<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawGrid(GetColor(100, 100, 100)); // 100,100,100のグレーのグリッドでマス目を描く<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ray0光線レイ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0pos{ 5,5 }; // レイ光線の始点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 ray0dir{ <em>1,1</em> }; // レイ光線の方向<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 線分line1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p2{ 5,10 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 p1{ 15,6 };<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector2 Q; // 光線ray0とline1の交点<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollision01 = MyMath::RayLineCollision(Q, ray0pos, ray0dir, p2, p1);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(ray0pos.x, ray0pos.y, 0, 0, ray0pos.x + ray0dir.x, ray0pos.y + ray0dir.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 光線ray0<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawArrow(p2.x, p2.y, 0, 0, p1.x, p1.y, 0.8f, 1.0f, (isCollision01) ? GetColor(255, 0, 0) : GetColor(255, 255, 255)); // 線分line1<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(ray0pos.x, ray0pos.y, 3, GetColor(255, 0, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p0_String = "ray0=(" + std::to_string((int)ray0pos.x) + "," + std::to_string((int)ray0pos.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(ray0pos.x, ray0pos.y, p0_String.c_str(), GetColor(255, 0, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p1.x, p1.y, 3, GetColor(0, 255, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p1_String = "p1=(" + std::to_string((int)p1.x) + "," + std::to_string((int)p1.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p1.x, p1.y, p1_String.c_str(), GetColor(0, 255, 0));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(p2.x, p2.y, 3, GetColor(0, 0, 255), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string p2_String = "p2=(" + std::to_string((int)p2.x) + "," + std::to_string((int)p2.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(p2.x, p2.y, p2_String.c_str(), GetColor(0, 0, 255));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawPoint(Q.x, Q.y, 3, GetColor(255, 165, 0), TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string Q_String = "Q=(" + std::to_string(Q.x) + "," + std::to_string(Q.y) + ")";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mathGraph.DrawString(Q.x, Q.y - 10, Q_String.c_str(), GetColor(255, 165, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたスクリーンを表画面にフリップ入れ替え<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
        &nbsp;&nbsp;&nbsp; WaitKey();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
        &nbsp;&nbsp;&nbsp; DxLib_End();<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
        &nbsp;&nbsp;&nbsp; return 0;<br>
        }</p>
      いかがでしょう？つまり、この設計した関数を使う場合は、isCollision01でMyMath::RayLineCollisionの結果をbool型で受けて、<br>
      レイ光線がぶつかったかどうかと、セットで交点Qを使う必要があるのですね。<br>
      逆に言えば、isCollision01を無視すれば、壁や床が無限の長さのときの交点を求めるのにも、この関数は応用できるということですね。<br>
      <br>
    </a>
  </body>
</html>
