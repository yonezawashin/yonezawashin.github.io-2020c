<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>[C++]基本練習</title>
    <link rel="stylesheet" href="style.css">
    <style>
      
    </style>
  </head>
  <body>
    <p class="title">[C++]基本練習</p>
    <ol id="mozToc">
    <!--mozToc h1 1-->
      <li><a href="#mozTocId0001">静止したキャラを出すだけのプログラム</a></li>
      <li><a href="#mozTocId0002">キャラを上下左右キーで動かせるプログラム</a></li>
      <li><a href="#mozTocId0003">キャラを左右キーで加速移動させるプログラム</a></li>
      <li><a href="#mozTocId0004">キャラをZキーでジャンプさせるプログラム</a></li>
      <li><a href="#mozTocId0005">初代マリオ風のふわっとジャンプ(上昇と下降フェーズの引力を別々に設定できる)プログラム</a></li>
      <li><a href="#mozTocId0006">ダッシュ中にジャンプすると高く飛べる(加速段階によって複数のジャンプパラメータを持てる)プログラム</a></li>
      <li><a href="#mozTocId0007">ダッシュで2速状態でジャンプすると空で羽ばたけるプログラム</a></li>
      <li><a href="#mozTocId0008">キャラチップ配列アニメで「左右ダッシュ」と「2速状態ジャンプでキャラを±60度回転させ空を飛ぶ」プログラム</a></li>
      <li><a href="#mozTocId0009">ジャンプの効果音を鳴らすプログラム</a></li>
      <li><a href="#mozTocId0010">地形ファイルを読み込むプログラム</a></li>
      <li><a href="#mozTocId0011">地形マップチップを画面に描くプログラム</a></li>
      <li><a href="#mozTocId0012">地形マップチップの当たり判定(めり込みの余りのぶんだけ押し戻す)プログラム</a></li>
    </ol>
    <h1><a id="mozTocId0001" class="mozTocH1"></a>静止したキャラを出すだけのプログラム</h1>
    <br>
    まずは最小限のプログラムでif文などの練習をしていきましょう<br>
    <p>以下の【キャラを出すだけの最小限サンプル】でキャラクターが出るかを確認しましょう</p>
    <a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId0003">GIMPでのキャラ画像の作り方はこちらを参考にしてください</a></p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      <em>#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用</em><br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode( 960 , 540 , 32 ) ; // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(960, 540);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = 100; // 初期位置</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1.0f, 0, playerImage, TRUE);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    キャラクターが出なかった人はImageフォルダにPlayer.pngファイルがちゃんとあるか確かめてみてください。<br>
<br>
    <h1><a id="mozTocId0002" class="mozTocH1"></a>キャラを上下左右キーで動かせるプログラム</h1>
<br>
    <p>では次は【Screen.h、Input.hとInput.cppを追加してキャラを上下左右キーで動かせる】ようにしてみましょう</p>
    <a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId00021">Screen.hの作り方はこちらを参考にしてください</a></p>
    <a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId00061">Input.hとInput.cppの作り方はこちらを参考にしてください</a></p>
    <br>
    <p>以下の【キャラを上下左右ボタンで動かすだけの最小限サンプル】でキャラクターを動かせるかを確認しましょう</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      <em>#include "Screen.h"</em><br>
      <em>#include "Input.h"</em><br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(<em>Screen::Width</em>, <em>Screen::Height</em>, 32 ) ; // 画面サイズ<em>をScreenクラスに合わせて</em>設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(<em>Screen::Width</em>, <em>Screen::Height</em>);// ウィンドウサイズをScreenクラスに合わせて設定</em>(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = 100; // 初期位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>float vx = 0, vy = 0; // プレイヤの速度</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>Input::Init(); // Inputクラスの初期化</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>vx = 0; // 速度を毎ターンリセット初期化(しない場合はどんどん加速)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy = 0;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -5; // Xマイナス方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 5; // Xプラス方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -5; // Yマイナス方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 5; // Yプラス方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1.0f, 0, playerImage, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    どうでしょう、キーボードの上下左右キーでキャラを動かすことができたでしょうか？<br>
    うまく反応しない場合は<em>Input::Update();</em>を忘れていることが多いです。<br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0003" class="mozTocH1"></a>キャラを左右キーで加速移動させるプログラム</h1>
<br>
    <br>
    <p>今度は【キャラを左右キーで加速させる】ように改造してみましょう</p>
    <br>
    <p>以下の【キャラを左右キーで加速させるだけの最小限サンプル】でキャラクターを加速させられるか挑戦しましょう</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = <em>Screen::Height</em>; // 初期位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>float vxSpeedMax = 15; // X左右方向の限界速度</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerImage, &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>vx = 0; // 速度を毎ターンリセット初期化(しない場合はどんどん加速)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy = 0;</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>vx = -5; // Xマイナス方向の速度</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>vx = 5; // Xプラス方向の速度</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -5; // Yマイナス方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 5; // Yプラス方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>vx *= 0.97f; // 減速率</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x<em> - imgSizeX / 2</em>, y<em> - imgSizeY / 2</em>, 1.0f, 0, playerImage, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    さて、いかがでしょうか？氷が床の表面を滑るような動きができたでしょうか？<br>
    DrawRotaGraphF(x<em> - imgSizeX / 2</em>, y<em> - imgSizeY / 2</em>.. として<b><em>imgSizeX / 2</em>を引いているのは<br>
    DrawRotaGraphF関数は画像を描く基準点が画像の中心なので、画像の縦と横の幅の1/2を引くことで中心のぶんのつじつまを合わせるため</b>です。<br>
    単純なプログラムですが、<br>
    <b>突き詰めると、スマホのiPhoneのSafariの【ブラウザのスクロールの気持ちよさ】のような独自のブランディング(差別化)</b>につながるわけですから、あなどれません。<br>
    <b>たかが加速、されど加速</b>。<b>減速率やvxMaxSpeedなどの数字を色々変えながら自分の気持ちいい数値を探してみて</b>ください。<br>
    <br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0004" class="mozTocH1"></a>キャラをZキーでジャンプさせるプログラム</h1>
<br>
    <br>
    さて、こうなったら横方向だけではなく、縦方向のジャンプにも挑戦してみましょう<br>
    <br>
    <p>以下の【キャラをZキーでジャンプさせるサンプル】でキャラクターをジャンプさせられるか挑戦しましょう</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;<em>float vyJumpSpeed = 16, vyDownSpeedMax = 16; // ジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyGravity = 0.8f;<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerImage, &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &lt; 0 &amp;&amp; Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // ジャンプで上昇中(vy &gt; 0)にボタンを離すと勢いが止まる(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if(!isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy += vyGravity; // 重力で下方向に加速</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (vy &gt;= vyDownSpeedMax) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0, playerImage, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f\n", y, vy);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    <br>
    <br>
    いかがでしょう、うまくジャンプできましたか？<br>
    bool isGroundがtrueのとき(着地状態のとき)にボタンを押した瞬間にジャンプ力の数値をvyに設定して、<br>
    if (!isGround)のとき(isGroundがfalseのとき)に毎ターン vy += vyGravity;することで下方向に重力がかかるようにしています。<br>
    vyJumpSpeed = 16 やvyDownSpeedMax = 16 や yGravity = 0.8fなどの<b>数字を自分で変えてみてイメージにあうジャンプを調整してみましょう</b>。<br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0005" class="mozTocH1"></a>初代マリオ風のふわっとジャンプ(上昇と下降フェーズの引力を別々に設定できる)プログラム</h1>
<br>
    <br>
    さて、<a href="https://qiita.com/morian-bisco/items/4c659d9f940c7e3a2099">さらに凝ったプログラム</a>にトライして、初代マリオのようなジャンプ処理に挑戦してみましょう<br>
    <br>
    <p>以下の【初代マリオ風の処理(小数のbit演算を省いた簡易化したもの)】でジャンプさせられるか挑戦しましょう</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;<em>float yJumpStart = 0; // ジャンプした瞬間のyの位置</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed = 16, vyDownSpeedMax = 16; // ジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;<em>float vyForce = 0;</em><br>
      &nbsp;&nbsp;float <em>vyForceJump = 0.5f, </em>vyGravity = 0.8f;<em> // 上昇フェーズと下落フェーズの力を別々に設定できるようになった</em><br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerImage, &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>vyForce = vyForceJump; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>else if (vy &lt; 0 &amp;&amp; Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // ジャンプで上昇中(vy &gt; 0)にボタンを離すと勢いが止まる(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>vy += vyForce; // 勢い(力・フォースを加算)</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>if(!isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy += vyGravity; // 重力で下方向に加速</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>vyForce = 0;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0, playerImage, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f\n", y, vy);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょう、一番の違いは<em>上昇フェーズと下落フェーズの力を別々に設定できるようになった</em>ことです。<br>
    たしかに、上昇フェーズは伸びがあるようにして、下落フェーズではストンと落としたいなど、<br>
    力・フォースを<em>上昇と下落2つのフェーズで切り替えられる</em>ほうが<b>表現力のバリエーションの作りこみがより深まります</b>よね。<br>
    <br>
    <b>こういった細かいこだわりまでをプログラミングで表現できたこと</b>こそが、<br>
    Nintendoの家庭用ファミコンが日本国内を席巻するだけでなく、<br>
    かつてアップルのジョブスも若き時代在籍した<b>米国のアタリ社がぶっ壊しかけた家庭用ゲーム機市場を復活・開拓できた勝因</b>かもしれません。<br>
    (任天堂に先んじて家庭用ゲーム機を出したが<b>アタリショック:粗悪ソフトの大量在庫余りで米国クリスマス商戦でそのゲーム機が大爆死</b>を引き起こした)<br>
    <br>
    今の時代もスマホアプリは粗悪な課金アプリであふれていますが、アップル自体はソフトの在庫を抱えず審査するビジネスモデルを作りあげました(そこにゲームや音楽ソフトへの愛はあるでしょうか)。<br>
    (ジョブズがアタリショックからも学んだかどうかはわかりませんが<b>ゲームも音楽もソフトが売れたら巨大IT側にパーセンテージを、売れなくてもアカウント費を払う時代</b>です)<br>
    そう、今の時代は機器メーカー側ではなく、作り手側が絶対的なリスクを負わされている時代にまた戻ったわけです。<br>
    <br>
    いつかゲーム制作<b>企業に勤めれば、こだわれるなどと考えるのは甘い</b>です。<br>
    プログラムなんて勉強するつもりもないようなプランナやプロデューサーたちが牛耳っている現代の制作現場おいては、<br>
    こだわる時間と愛と余裕のあるのはゲームの制作を学んでいるフェーズの学生ぐらいです。<b>今しかこだわれないと常に思うこと</b>です。<br>
    <br>
    学者タイプの秀才に言わせれば、上昇フェーズも下降フェーズも重力加速度は同じはずだ(ドヤ)となりますが、<br>
    それにとらわれず、<b>上昇と下落フェーズで別の力を設定できたほうが面白くなるかも</b>、とのこだわりを表現できたプログラマと開発現場があの時代の日本の片隅にあったことは確かです。<br>
    <br>
    「ただのゲーム好き」が最初期のゲーム業界を支えていったの<b>ではなく</b>、<br>
    雑誌を見ながらプログラムを打ち込んだ<b>「プログラミング好き」な人がゲームを作っていった</b>のです。<br>
    ゲームプログラマは本当は「ゲーム<b>も</b>好きだけど<b>プログラミングがもっと好き</b>」な人が向いている仕事かもしれません。<br>
    (世代を経るごとに日本のゲーム開発力はどんどん空洞化していくでしょうが、次世代にささやかな希望を託す意味をこめて、少し踏み込んだことを書きました)<br>
    <br>
    <br>
<br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0006" class="mozTocH1"></a>ダッシュ中にジャンプすると高く飛べる(加速段階によって複数のジャンプパラメータを持てる)プログラム</h1>
<br>
    <br>
さて、次はダッシュ中にジャンプすると高く飛べる仕組みにトライしてみましょう<br>
    <br>
    <p>以下の【ダッシュの加速段階によってパラメータを切り替えるサンプル】でダッシュの段階に応じた高さでジャンプさせられるか挑戦しましょう</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>int vx_idx = 0; // 横方向の加速の段階</em><br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed<em>[] = { 14, 15, 16 }</em>, vyDownSpeedMax<em>[] = { 16, 16, 16 }</em>; // <em>ダッシュの段階に応じた複数の</em>ジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump<em>[] = { 0.5f,0.4f,0.3f }</em>, vyGravity<em>[] = { 0.8f,0.8f,0.8f }</em>; // <em>ダッシュ段階に応じた複数のパラメータを持つように</em><br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerImage, &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed<em>[vx_idx]</em>; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump<em>[vx_idx]</em>; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity<em>[vx_idx]</em>; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity<em>[vx_idx]</em>; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax<em>[vx_idx]</em>) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax<em>[vx_idx]</em>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>vx_idx = 0;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0, playerImage, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f<em> idx:%d</em>\n", y, vy<em>, vx_idx</em>);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょう、ダッシュして加速している状態のときのジャンプの高さと、その場でダッシュせずにジャンプした時のジャンプの高さの違いが出れば成功です。<br>
    float vyForceJump<em>[] = { 0.5f,0.4f,0.3f }</em>, vyGravity<em>[] = { 0.8f,0.8f,0.8f }</em>;のように<br>
    複数のパラメータを持ち、それをvyForce = vyGravity<em>[vx_idx]</em>;のように、<em>vx_idx</em>で切り替えているのがポイントです。<br>
    加速の段階はジャンプする瞬間に<em>if (vx_abs &gt; 6) ++vx_idx;</em>のようにif(vx_abs &gt; <em>6</em>)やif(vx_abs > <em>9</em>)で現在の加速度の大きさで段階を切り替えています。<br>
    <br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0007" class="mozTocH1"></a>ダッシュで2速状態でジャンプすると空で羽ばたけるプログラム</h1>
<br>
    <br>
    さて、次はダッシュで2速状態でジャンプすると空で羽ばたける仕組みにトライしてみましょう。<br>
    <br>
    <p>以下の【ダッシュで2速状態でジャンプすると空で羽ばたけるサンプル】で2速でダッシュして飛んだら空で羽ばたく仕組みに挑戦しましょう</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16<em>, 4</em> }, vyDownSpeedMax[] = { 16, 16, 16<em>, 8</em> }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f<em>,0.1f</em> }, vyGravity[] = { 0.8f,0.8f,0.8f<em>,0.8f</em> }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;<em>bool isFlying = false; // 飛行モード</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerImage, &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying && Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>isFlying = false;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0, playerImage, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    <br>
    いかがでしょう、空でパタパタ羽ばたく感じが出せたでしょうか？<br>
    パラメーターを自分で変えてみて<b>自分なりの羽ばたきを実験</b>してみてください。<br>
    ( ぼくはvyJumpSpeed[]を<b>あえて少なめ</b>の4にして、<b>たくさん連打しても上に上がりすぎない</b>ように調理して、<br>
    vyForceJump[]もそれに比例して少なくすることで、<b>長押しで羽ばたくとギュンと上に伸び</b>をだせるようにしました )<br>
    <br>
    昔のプログラマは<b>少しのアイデア</b>と少しのコード変更でUnityの物理機能に頼らずとも、<b>独創性を発揮してきた</b>ようですね。<br>
    こういった小ネタだけでも<a href="https://flappybird.io/">Flappy Bird</a>のように人を熱中させ<a href="https://ja.wikipedia.org/wiki/Flappy_Bird">大ヒットすることもある</a>わけです。<br>
    <br>
    シンプルな面白さの発見は、<b>日々プログラミングしていてこそ生み出される可能性があります</b>。<br>
    ついつい、連打したくなる、とか、グイっと伸びて気持ちいいとか、<b>そういう手触りは頭でっかちの企画書ベースの開発では生み出されません</b>。<br>
    <br>
    自分なりの<b>手触りやパラメーターや面白さの体感は自分のオリジナル料理の大事なレシピとなるうる</b>のです。<br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0008" class="mozTocH1"></a>キャラチップ配列アニメで「左右ダッシュ」と「2速状態ジャンプでキャラを±60度回転させ空を飛ぶ」プログラム</h1>
<br>
    <br>
    さて、次はキャラクターをアニメーションさせる表現にトライしてみましょう。<br>
    RPGなどのキャラチップ自作ツール<a href="https://pipoya.notion.site/CharaMEL-6fb3b97cc5f643e7a8025fce608e7050">キャラメル-CharaMEL-</a>をダウンロードして<a href="https://pipoya.notion.site/65954b63976d40e9b9a1a77f0f90e1d6">いろいろな機能を駆使してキャラを自作</a>すれば再配布自由な自作キャラが完成です。<br>
    作るのが面倒な人向けに自作したファイルを以下に置いておきます。<br>
    <a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/pikkoron.Json">キャラの設定jsonファイル</a><b>[←リンクを右クリックして名前を付けてリンク保存からダウンロード]</b>(CharaMELアプリメニューのファイル→キャラクタのインポートから読込可能)<br>
    <a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/pikkoron.png">書き出したpng画像ファイル</a>(メニュー下のpng↓ボタンから書き出せる)<br>
    <br>
    書き出したpngファイルを私は「Image/pikkoron.png」として<b>DXライブラリのImageフォルダ</b>に保存(またはコピー)しておきました。<br>
    このキャラチップ画像ファイルを<b>パラパラアニメさせる</b>ことで「キャラクターをダッシュさせたり、空を飛行させたり」してみましょう。<br>
    <br>
    キャラチップ画像のキャラは32×32(書き出し時のサイズによる)などに分割されており、それをDXライブラリのLoadDivGraph関数で読み取る際に対応する画像番号の見極めが必要です。(GIMPでグリッドを引いて番号を見極めましょう)<br>
    <p> <img src="image/charachip_grid.png" alt="" style="width: 692px; height: 292px;"></p>
    <br>
    <p>以下の【キャラチップ配列のダッシュ左<b>[3][4][5]</b>、右<b>[6][7][8]</b>と立ち(左右)<b>[4][7]</b>を±60度回転させ空を飛ぶサンプル】でキャラチップ画像をパラパラアニメさせてみましょう。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;<u>int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</u><br>
      &nbsp;&nbsp;<em>int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;<em>enum Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(<em>playerChips[0]</em>, &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>direction = Direction::Left;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>direction = Direction::Right;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying && Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0, playerImage, TRUE);</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[6 + animeStep], TRUE);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょう、キャラクタがパラパラとアニメされて走っているように見えるようになりましたか？<br>
    <br>
    キャラクタが小さくて見にくいという人は描画処理のコードの以下の部分を変更すれば、<b>キャラを2倍の大きさで表示</b>させられます。<br>
<p class="source">
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - <em>imgSizeX</em>, y - <em>imgSizeY</em>, <em>2.0f</em>,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - <em>imgSizeX</em>, y - <em>imgSizeY</em>, <em>2.0f</em>, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - <em>imgSizeX</em>, y - <em>imgSizeY</em>, <em>2.0f</em>, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - <em>imgSizeX</em>, y - <em>imgSizeY</em>, <em>2.0f</em>, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      </p>
    <br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0009" class="mozTocH1"></a>ジャンプの効果音を鳴らすプログラム</h1>
<br>
    <br>
    <br>
    まずは、せっかくなのでジャンプの効果音を<a href="https://jfxr.frozenfractal.com/">ブラウザで動くシンセサイザーJFXR</a>で作ってみましょう。<br>
    <a href="https://2dgames.jp/jfxr/">簡単な使い方だけなら以下のサイトが参考になります。</a><br>
    シンセの調節に慣れてきたら<a href="https://apps.apple.com/jp/app/audiokit-synth-one-synthesizer/id1371050497">iPhone用のシンセ</a>で夜、寝転がりながらスマホで効果音制作にも挑戦だ。<br>
    <a href="https://daw-jones.hatenablog.com/entry/2019/04/14/154502">結構本格的なシンセ機能があるのでDAWのユーザーも結構おすすめ↑してる</a><br>
    <br>
    シンセの基本は下記の動画を<b>暇な夜の時間のあるときにみておく</b>と音づくりのスタート地点に立てると思います(センスのある天才肌なら開眼するはず)。<br>
    <a href="https://youtu.be/7tMbJ6f6qf0?t=341">https://youtu.be/7tMbJ6f6qf0?t=341</a><br>
    <br>
    まあ、ジャンプ音ぐらいなら下記画像のボタンやバーを適当にいじれば音の知識がゼロからでも、なんとなくセンスがつかめるはず。<br>
    <p> <img src="image/synth_jfxr_jump.png" alt=""></p>
    <br>
    <br>
    <br>
    例として、わたくしの引き当てたジャンプ音のシンセ調節ファイルを下記リンクに共有します。<br>
    <a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/Jump.jfxr">わたくしの引き当てたジャンプ音のシンセ調節ファイル</a>←右クリックで[名前をつけてリンク先を保存]でダウンロードして<br>
    ↑ダウンロードしたファイルを<a href="https://jfxr.frozenfractal.com/">ブラウザで動くシンセJFXR</a>の左上の[Open]ボタンから開いてみよう<br>
    <p> <img src="image/synth_jump_open.png" alt=""></p>
    <br>
    まずは「小ジャンプ」の効果音として下記設定をして、[Export]ボタンから<b>Jump0.wavというファイル名</b>で<b>DXライブラリのプロジェクトにSEフォルダを作って</b>そこに保存しましょう。<br>
    <audio controls src="sozai/Jump0.wav" type="audio/wav">小ジャンプ</audio><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/Jump0.wav">Jump0.wav</a>←右クリックで[名前をつけてリンク先を保存]でダウンロード<br>
    <p> <img src="image/synth_jump0.png" alt=""></p>
    <br>
    つぎは「大ジャンプ」の効果音として下記設定をして、[Export]ボタンから<b>Jump1.wavというファイル名</b>で<b>DXライブラリのプロジェクトのSEフォルダに保存</b>しましょう。<br>
    <audio controls src="sozai/Jump1.wav" type="audio/wav">大ジャンプ</audio><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/Jump1.wav">Jump1.wav</a>←右クリックで[名前をつけてリンク先を保存]でダウンロード<br>
    <p> <img src="image/synth_jump1.png" alt=""></p>
    <br>
    今度は「空を飛び始める」効果音として下記設定をして、[Export]ボタンから<b>Jump2.wavというファイル名</b>で<b>DXライブラリのプロジェクトのSEフォルダに保存</b>しましょう。<br>
    <audio controls src="sozai/Jump2.wav" type="audio/wav">空を飛び始める</audio><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/Jump2.wav">Jump2.wav</a>←右クリックで[名前をつけてリンク先を保存]でダウンロード<br>
    <p> <img src="image/synth_jump2.png" alt=""></p>
    <br>
    最後は「空でホップする」効果音として下記設定をして、[Export]ボタンから<b>Jump3.wavというファイル名</b>で<b>DXライブラリのプロジェクトのSEフォルダに保存</b>しましょう。<br>
    <audio controls src="sozai/Jump3.wav" type="audio/wav">空でホップする</audio><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/Jump3.wav">Jump3.wav</a>←右クリックで[名前をつけてリンク先を保存]でダウンロード<br>
    <p> <img src="image/synth_jump3.png" alt=""></p>
    <br>
    <br>
    <p>あとは以下の【効果音をSEフォルダから読み込んで大小ジャンプと空を飛ぶ音を出すサンプル】でキャラの動きに合わせて効果音を出してみましょう。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4<br>
      &nbsp;&nbsp;int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying && Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょう、ジャンプ音が鳴りましたか？<br>
    うまくいかない人は、音のファイルを<b>DXのプロジェクトのSEフォルダに入れてありますか？</b><br>
    ジャンプ音のファイル名はちゃんとJump1.wavが<b>大文字のJから始まっていますか？</b>Jump 1.wavのように<b>スペースが開いてませんか？</b><br>
    <br>
    コード自体の変更は少ないですが、理想のジャンプ音に出会えるまで繰り返し色んな音を試しているだけですぐに時間は過ぎてゆくはずです。<br>
    WEBでひとさまの作った効果音を漁るのと、シンセで理想のジャンプ音を自作するのと、どちらを選んでも結局、時間がかかると思います。<br>
    クリエイターの端くれとしては、ぼくは自分でシンセをいじってイメージどおりの音を探る作業のほうが楽しいかもしれません。<br>
    <br>
    たかがジャンプの効果音一つと思うでしょうか？<br>
    <b>ゲームの手触り感の50%は効果音で決まるとぼくは思っています。</b><br>
    どんなにプログラミングや企画にこだわったゲームでも効果音が気持ちよくないゲームはメリハリがなくて眠くなってしまいます。<br>
    <br>
    マリオワールドの効果音をはじめて聞いたとき、ぼくは<a href="https://www.youtube.com/watch?v=tWfN2aCge8U">ゲームというより「楽器」を感じました</a>。<br>
    ひとつひとつの効果音が高周波が効いて目覚ましのような<a href="https://youtu.be/UEJMve_-FmE?t=14">目の覚める音だと思います</a>。<br>
    <br>
    おそらく、ぼくが最近のマリオや任天堂作品と昔の作品を比べて、昔のほうが逆にきらきらしてると感じるのは<a href="https://ja.wikipedia.org/wiki/%E8%BF%91%E8%97%A4%E6%B5%A9%E6%B2%BB">「効果音」の作者が変わったから</a>なのかな..と思います。<br>
    ポケモンも最近の作品は<a href="https://ja.wikipedia.org/wiki/%E5%A2%97%E7%94%B0%E9%A0%86%E4%B8%80">昔の作品と変わって</a>なぜかバトル中の音楽で眠くなってしまうのは...曲のメリハリの問題？..(それともぼくの老化か)<br>
    <br>
    ゲームの<b>快適さも、手触りも、メリハリも</b>、簡単に見えて<b>音の影響はかなり大きい</b>と思います。<br>
    <br>
    <br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0010" class="mozTocH1"></a>地形ファイルを読み込むプログラム</h1>
<br>
    <br>
    <br>
    つぎは地形ファイルを読み込むプログラムに挑戦してみましょう。<br>
    地形のマップチップはGIMPで1ブロック32×32として自作してみました。自作したファイルを下記リンクに共有しておきます。<br>
    ・<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/mapchip.xcf">mapchip.xcf(GIMPの編集ファイル)</a>←右クリック[名前をつけてリンク先を保存]でダウンロードすればGIMPで自作ブロックを書き足せる<br>
    ・<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/mapchip.png">mapchip.png(↑GIMPから名前をつけてエクスポートしたpng画像ファイル)</a>←右クリック[名前をつけてリンク先を保存]でダウンロード<br>
    <p> <img src="sozai/mapchip.png" alt=""></p>
    <br>
    地形のマップチップは<a href="https://thorbjorn.itch.io/tiled">タイルマップエディタ</a>で配置して[ファイル→名前をつけてエクスポート]からcsvファイルで書き出せます。<br>
    下記リンクの2つのファイルをダウンロードして、mapchip.pngと同じフォルダに置いた状態でタイルマップエディタで[ファイル→Open File or Project]でstage.tmxを開けばマップを編集できます。<br>
    ・<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/mapchip.tsx">mapchip.tsx(png画像の32×32など「グリッド分割設定など」の保存ファイル)</a>←右クリック[名前をつけてリンク先を保存]でダウンロード<br>
    ・<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/stage.tmx">stage.tmx(タイルマップ編集ファイル)</a>←右クリック[名前をつけてリンク先を保存]でダウンロード<br>
    <br>
    <br>
    タイルマップエディタで[ファイル→名前をつけてエクスポート]から書き出したcsvファイルを下記リンクに共有しておきます。<br>
    ・<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/stage.csv">stage.csv(地形番号カンマ区切りで書き出したファイル)</a>←右クリック[名前をつけてリンク先を保存]でダウンロード<br>
    書き出したcsvファイル↑は<b>DXのプロジェクトのフォルダにMapフォルダを作ってMap/stage.csvとして保存</b>してください。<br>
    <br>
    <br>
    <p>さてまずは【地形csvファイルをMapフォルダから読み込んで地形番号を表示させるサンプル】でcsvファイルの中身には地形番号がカンマ区切りで書き出されていることを実感しましょう。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      <em>#include &lt;vector&gt;&nbsp;// csvを2次元vector配列に格納<br>
      #include &lt;string&gt;&nbsp;// 文字列std::stringに必要<br>
      #include &lt;fstream&gt;&nbsp;// ファイル読み出しstd::ifstreamに必要<br>
      #include &lt;sstream&gt;&nbsp;// 文字列ストリームに必要 ss &gt;&gt; num;で文字列から数字に変換できる</em><br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4<br>
      &nbsp;&nbsp;int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>int CellSize = 32; // マップの1マスのピクセル数</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>std::vector&lt;std::vector&lt;int&gt;&gt; mapData;// タイルマップデータ<br>
      &nbsp;&nbsp;std::ifstream ifs_csv_file("Map/stage.csv"); // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int Width = 0, Height = 0; // マップデータの横(Width) 縦(Height)のマスの数<br>
      &nbsp;&nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp;std::string line; // 1行単位ごとにcsvファイルから文字列をstd::getlineで読み込んで受け取る<br>
      &nbsp;&nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; valuelist; // 1行ぶんの数字リスト配列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::istringstream linestream( line ); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::string comma_part; // カンマで分割された文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int widthCount = 0; // カンマで区切られた行の数字の数(各行の幅)をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (std::getline(linestream, comma_part, { ',' })) // 1行をgetlineでカンマで区切って列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istringstream ss( comma_part ); // カンマで区切られた文字をssを通して&gt;&gt;で数字に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行の数字の数がMAX記録を更新するかチェック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (widthCount &gt; MaxWidth)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxWidth = widthCount; // 暫定Maxの列の幅を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行ぶんの数字の配列をとりまとめてmapDataに1行ずつ追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (valuelist.size() != 0) // 配列に数字が1つでもあるなら.size() != 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData.emplace_back(valuelist); // mapDataに1行ずつ数字配列valuelistを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;++Height; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;Width = MaxWidth; // マップの幅Widthは一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp;// ↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp;assert(Width &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;assert(Height &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying && Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// 地形マップを[ 行のfor文×列のfor文 ]の2重ループで描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0, ySize = mapData.size(); cellY &lt; ySize; ++cellY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0, xSize = mapData[cellY].size(); cellX &lt; xSize; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[cellY][cellX]; // [行][列] の位置のcsvの地形番号(チップ番号)を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id < 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ]用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawString(chip_x, chip_y, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょうか？このようにcsvの中身は地形のチップ番号が,カンマ区切りで書き出されています。<br>
    <p> <img src="image/csv_stage_comma.png" alt=""></p>
    <br>
    <br>
    プログラムではそのcsvファイルを<em>std::ifstream ifs_csv_file("Map/stage.csv");</em>で読みだして<br>
    カンマ区切りを<b>while文とstd::getline</b>を使い<em>while (std::getline(linestream, comma_part, { ',' }))</em>で分割して<br>
    分割したcomma_partを<b>文字列ストリーム</b>ssを使い<em>std::istringstream ss( comma_part );</em><br>
    <b>ストリーム演算子&gt;&gt; を通してint型のnumに変換</b>して<em>ss &gt;&gt; num;</em><br>
    その数字numを<b>まずは1次元配列std::vector&lt;int&gt;型のvaluelist</b>に<em>valuelist.emplace_back(num);</em>で<b>1つずつ入れて、</b><br>
    その<b>数字配列の1行ぶん(valuelist)を2次元数字配列std::vector&lt;std::vector&lt;int&gt;&gt;型のmapData</b>へ <em>mapData.emplace_back(valuelist);</em>で<b>行単位で1行ずつ格納</b>しています。<br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0011" class="mozTocH1"></a>地形マップチップを画面に描くプログラム</h1>
<br>
    <br>
    <br>
    <p>さてつぎは【地形のマップチップMap/mapchip.pngを読み込んだstage.csvの地形番号にあわせて描き出すサンプル】で画面に地形を描き出しましょう<b>(注意:まだ当たり判定はない)</b>。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      #include &lt;vector&gt;&nbsp;// csvを2次元vector配列に格納<br>
      #include &lt;string&gt;&nbsp;// 文字列std::stringに必要<br>
      #include &lt;fstream&gt;&nbsp;// ファイル読み出しstd::ifstreamに必要<br>
      #include &lt;sstream&gt;&nbsp;// 文字列ストリームに必要 ss &gt;&gt; num;で文字列から数字に変換できる<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4<br>
      &nbsp;&nbsp;int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;<em>int mapChips[64]; // マップのチップのグリッドの分割数に応じて8×8 = 64など配列で確保<br>
      &nbsp;&nbsp;LoadDivGraph("Map/mapchip.png", 64, 8, 8, CellSize, CellSize, mapChips); // マップのチップのサイズは32×32(=CellSize)<br>
      &nbsp;&nbsp;assert(mapChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; mapData;// タイルマップデータ<br>
      &nbsp;&nbsp;std::ifstream ifs_csv_file("Map/stage.csv"); // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int Width = 0, Height = 0; // マップデータの横(Width) 縦(Height)のマスの数<br>
      &nbsp;&nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp;std::string line; // 1行単位ごとにcsvファイルから文字列をstd::getlineで読み込んで受け取る<br>
      &nbsp;&nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; valuelist; // 1行ぶんの数字リスト配列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::istringstream linestream( line ); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::string comma_part; // カンマで分割された文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int widthCount = 0; // カンマで区切られた行の数字の数(各行の幅)をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (std::getline(linestream, comma_part, { ',' })) // 1行をgetlineでカンマで区切って列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istringstream ss( comma_part ); // カンマで区切られた文字をssを通して&gt;&gt;で数字に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行の数字の数がMAX記録を更新するかチェック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (widthCount &gt; MaxWidth)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxWidth = widthCount; // 暫定Maxの列の幅を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行ぶんの数字の配列をとりまとめてmapDataに1行ずつ追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (valuelist.size() != 0) // 配列に数字が1つでもあるなら.size() != 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData.emplace_back(valuelist); // mapDataに1行ずつ数字配列valuelistを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;++Height; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;Width = MaxWidth; // マップの幅Widthは一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp;// ↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp;assert(Width &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;assert(Height &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying && Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2; // DrawRotaGraphF関数は画像の真ん中が起点なので1/2ずらした位置計算</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 地形マップを[ 行のfor文×列のfor文 ]の2重ループで描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0, ySize = mapData.size(); cellY &lt; ySize; ++cellY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0, xSize = mapData[cellY].size(); cellX &lt; xSize; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[cellY][cellX]; // [行][列] の位置のcsvの地形番号(チップ番号)を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id < 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>// マップチップを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x + rotaShiftX, chip_y + rotaShiftY, 1.0f, 0.0f, mapChips[id], TRUE);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ]用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawString(chip_x, chip_y, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょう、マップ地形が画面に描かれたでしょうか？<br>
    <br>
    チップを描く起点の座標(x,y)=(chip_x, chip_y)は、マス目番号×32(CellSize:チップ画像の分割サイズ)で求められます。<br>
    float chip_y = (float)(<em>cellY * CellSize</em>); // マス目Y(行)番号×マス目サイズ<br>
    float chip_x = (float)(<em>cellX * CellSize</em>); // マス目X(列)番号×マス目サイズ<br>
    <br>
    下図はマス目の1マス(セル)のサイズが32の場合の位置の計算方法のイメージです。<br>
    <p> <img src="image/csv_stage_cellsize.png" alt=""></p>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0012" class="mozTocH1"></a>地形マップチップの当たり判定(めり込みの余りのぶんだけ押し戻す)プログラム</h1>
<br>
    <br>
    <br>
    <p>さてつぎは【キャラの四隅が壁のマップチップか調べて、めり込みの余りのぶんだけ押し戻すサンプル】で地形のブロックの当たり判定でブロックに乗れるようにしましょう。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      #include &lt;vector&gt;&nbsp;// csvを2次元vector配列に格納<br>
      #include &lt;string&gt;&nbsp;// 文字列std::stringに必要<br>
      #include &lt;fstream&gt;&nbsp;// ファイル読み出しstd::ifstreamに必要<br>
      #include &lt;sstream&gt;&nbsp;// 文字列ストリームに必要 ss &gt;&gt; num;で文字列から数字に変換できる<br>
      <em>#include &lt;unordered_map&gt;&nbsp;// std::unordered_map 高速辞書配列に必要(チップ番号から壁などを表すビットへ変換する辞書)</em><br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4<br>
      &nbsp;&nbsp;int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;int mapChips[64]; // マップのチップのグリッドの分割数に応じて8×8 = 64など配列で確保<br>
      &nbsp;&nbsp;LoadDivGraph("Map/mapchip.png", 64, 8, 8, CellSize, CellSize, mapChips); // マップのチップのサイズは32×32(=CellSize)<br>
      &nbsp;&nbsp;assert(mapChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; mapData;// タイルマップデータ<br>
      &nbsp;&nbsp;std::ifstream ifs_csv_file("Map/stage.csv"); // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int Width = 0, Height = 0; // マップデータの横(Width) 縦(Height)のマスの数<br>
      &nbsp;&nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp;std::string line; // 1行単位ごとにcsvファイルから文字列をstd::getlineで読み込んで受け取る<br>
      &nbsp;&nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; valuelist; // 1行ぶんの数字リスト配列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::istringstream linestream( line ); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::string comma_part; // カンマで分割された文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int widthCount = 0; // カンマで区切られた行の数字の数(各行の幅)をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (std::getline(linestream, comma_part, { ',' })) // 1行をgetlineでカンマで区切って列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istringstream ss( comma_part ); // カンマで区切られた文字をssを通して&gt;&gt;で数字に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行の数字の数がMAX記録を更新するかチェック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (widthCount &gt; MaxWidth)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxWidth = widthCount; // 暫定Maxの列の幅を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行ぶんの数字の配列をとりまとめてmapDataに1行ずつ追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (valuelist.size() != 0) // 配列に数字が1つでもあるなら.size() != 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData.emplace_back(valuelist); // mapDataに1行ずつ数字配列valuelistを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;++Height; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;Width = MaxWidth; // マップの幅Widthは一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp;// ↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp;assert(Width &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;assert(Height &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height<em> - 100</em>; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>int hitOffsetLeft = 2; // 当たり判定の左端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetRight = 2; // 当たり判定の右端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetTop = 1; // 当たり判定の上端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetBottom = 0; // 当たり判定の下端のオフセット</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 当たり判定のはしっこを計算するための一時関数<br>
      &nbsp;&nbsp;auto getLeft  = [&amp;hitOffsetLeft](float worldX) { return worldX + hitOffsetLeft; };<br>
      &nbsp;&nbsp;auto getTop   = [&amp;hitOffsetTop](float worldY) { return worldY + hitOffsetTop; };<br>
      &nbsp;&nbsp;auto getRight  = [&amp;hitOffsetRight, &amp;imgSizeX](float worldX) { return worldX + imgSizeX - hitOffsetRight; };<br>
      &nbsp;&nbsp;auto getBottom = [&amp;hitOffsetBottom, &imgSizeY](float worldY) { return worldY + imgSizeY - hitOffsetBottom; };</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>enum BlockBit // ブロックの特性を32桁のビットで表現<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None = 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Wall   = 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;};</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>std::unordered_map&lt;int, unsigned int&gt; blockBits = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{-1,BlockBit::None},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 0,BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 2,BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 3,BlockBit::Wall}<br>
      &nbsp;&nbsp;};</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 指定された座標(worldX,worldY)の地形が 壁 や ダメージブロックかなどをチェックする一時関数<br>
      &nbsp;&nbsp;auto checkID = [&amp;blockBits, &amp;CellSize](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain, float worldX, float worldY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int terrainID = -1; // 指定された座標の地形のID<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (worldX &lt; 0 || worldY &lt; 0) return false; // 負の座標が指定された場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = (int)(worldX / CellSize), mapY = (int)(worldY / CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 二次元配列の範囲内か判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapY &lt; terrain.size() && mapX &lt; terrain[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terrainID = terrain[mapY][mapX]; // 二次元配列から地形IDを取り出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (checkBit &amp; blockBits[terrainID]) != 0; // ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>float debug_x = -1, debug_y = -1; // [デバッグ] めり込みすぎのラインを記録しておく変数</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying && Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>{//←スコープ{}で下記xLeftなど、変数名が{}の外側でリセットされてかぶっても大丈夫なようにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yMiddle) || // 左中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) )  // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xLeft; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// std::fmodで小数点の余りを計算 めり込みすぎの余り = std::fmod(xLeft, CellSize)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallRight = xLeft + CellSize - (float)std::fmod(xLeft, CellSize); // 壁の右端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallRight - hitOffsetLeft; // 左端を壁の右端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓右端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) || // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yMiddle) || // 右中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xRight; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallLeft = xRight - (float)std::fmod(xRight, CellSize); // 壁の左端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallLeft + hitOffsetRight - imgSizeX; // 右端を壁の左端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>{//←スコープ{}で下記xLeftなど、変数名が{}の外側でリセットされてかぶっても大丈夫なようにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yTop) || // 中上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) )  // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yTop; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallBottom = yTop + CellSize - (float)std::fmod(yTop, CellSize); // 壁の下側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallBottom - hitOffsetTop; // 頭を壁の下端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) || // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yBottom) || // 中下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yBottom; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallTop = yBottom - (float)std::fmod(yBottom, CellSize); // 壁の上側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallTop + hitOffsetBottom - imgSizeX; // 足元を壁の上端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 床に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ブロックに当たってないからfalseにして落下するように<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x <em>+ imgSizeX / 2</em>, y <em>+ imgSizeY / 2</em>, <em>1.0f</em>,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x <em>+ imgSizeX / 2</em>, y <em>+ imgSizeY / 2</em>, <em>1.0f</em>, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x <em>+ imgSizeX / 2</em>, y <em>+ imgSizeY / 2</em>, <em>1.0f</em>, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x <em>+ imgSizeX / 2</em>, y <em>+ imgSizeY / 2</em>, <em>1.0f</em>, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2; // DrawRotaGraphF関数は画像の真ん中が起点なので1/2ずらした位置計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 地形マップを[ 行のfor文×列のfor文 ]の2重ループで描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0, ySize = mapData.size(); cellY &lt; ySize; ++cellY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0, xSize = mapData[cellY].size(); cellX &lt; xSize; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[cellY][cellX]; // [行][列] の位置のcsvの地形番号(チップ番号)を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id < 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップチップを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x + rotaShiftX, chip_y + rotaShiftY, 1.0f, 0.0f, mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ]用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawString(chip_x, chip_y, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// [デバッグ] 当たり判定の四隅を赤枠で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawBox(getLeft(x), getTop(y), getRight(x), getBottom(y), GetColor(255, 0, 0), FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] キャラ原点(x,y)を緑丸で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawCircle(x, y, 2, GetColor(0, 255, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たった際の行き過ぎの めりこみ座標(debug_x,debug_y) を青線で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_x != -1) DrawLine(debug_x, 0, debug_x, Screen::Height, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_y != -1) DrawLine(0, debug_y, Screen::Width, debug_y, GetColor(0, 0, 255));</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょう、マップ地形のブロックに当たったら立てるようになりましたか？<br>
    <br>
    キャラによって当たり判定のオフセットの数字を変えてキャラの背の高さや幅にフィットさせるようにするとよいでしょう。<br>
    int hitOffsetLeft = <em>2</em>; // 当たり判定の左端のオフセット<br>
    int hitOffsetRight = <em>2</em>; // 当たり判定の右端のオフセット<br>
    int hitOffsetTop = <em>1</em>; // 当たり判定の上端のオフセット<br>
    int hitOffsetBottom = <em>0</em>; // 当たり判定の下端のオフセット<br>
    <br>
    <p> <img src="image/csv_stage_chara_offset.png" alt=""></p>
    <br>
    <br>
    <br>
  </body>
</html>
