<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>[C++]基本練習</title>
    <link rel="stylesheet" href="style.css">
    <style>
      
    </style>
  </head>
  <body>
    <p class="title">[C++]基本練習</p>
    <ol id="mozToc">
    <!--mozToc h1 1-->
      <li><a href="#mozTocId0001">静止したキャラを出すだけのプログラム</a></li>
      <li><a href="#mozTocId0002">キャラを上下左右キーで動かせるプログラム</a></li>
      <li><a href="#mozTocId0003">キャラを左右キーで加速移動させるプログラム</a></li>
      <li><a href="#mozTocId0004">キャラをZキーでジャンプさせるプログラム</a></li>
      <li><a href="#mozTocId0005">初代マリオ風のふわっとジャンプ(上昇と下降フェーズの引力を別々に設定できる)プログラム</a></li>
      <li><a href="#mozTocId0006">ダッシュ中にジャンプすると高く飛べる(加速段階によって複数のジャンプパラメータを持てる)プログラム</a></li>
      <li><a href="#mozTocId0007">ダッシュで2速状態でジャンプすると空で羽ばたけるプログラム</a></li>
      <li><a href="#mozTocId0008">キャラチップ配列アニメで「左右ダッシュ」と「2速状態ジャンプでキャラを±60度回転させ空を飛ぶ」プログラム</a></li>
      <li><a href="#mozTocId0009">ジャンプの効果音を鳴らすプログラム</a></li>
      <li><a href="#mozTocId0010">地形ファイルを読み込むプログラム</a></li>
      <li><a href="#mozTocId0011">地形マップチップを画面に描くプログラム</a></li>
      <li><a href="#mozTocId0012">地形マップチップの当たり判定(めり込みの余りのぶんだけ押し戻す)プログラム</a></li>
      <li><a href="#mozTocId0013">キャラの移動に連動したcamera_x,camera_yで「描く地形のほうをスクロールでずらす」プログラム</a></li>
      <li><a href="#mozTocId0014">トゲトゲに当たったらキャラがくるくる回ってから下に落ちて最初のスタート位置に戻されるプログラム</a></li>
      <li><a href="#mozTocId0015">ブロックを下から叩いたらy位置をアニメさせてバウンスするプログラム</a></li>
      <li><a href="#mozTocId0016">ブロックidを辞書で変化させて叩いたらidが3 → 2 → -1 に変化してブロックを壊せるプログラム</a></li>
      <li><a href="#mozTocId0017">for文で複数ブロックidを辞書で変化させてON OFFブロックを叩いたらidが12⇔13、14⇔15にスイッチできるプログラム</a></li>
      <li><a href="#mozTocId0018">Imageのロードをclass分けして画像のロード処理をファイル分けするプログラム</a></li>
      <li><a href="#mozTocId0019">Soundのロードをclass分けして音声のロード処理をファイル分けするプログラム</a></li>
      <li><a href="#mozTocId0020">Cameraの描画ずらし処理をclass分けしてファイル分けしてさらにズーム機能を付加するプログラム</a></li>
      <li><a href="#mozTocId0021">地形をBlock(アニメ機能付き)とTile(データ読込とブロック描画)という概念に切り分けたプログラム</a></li>
    </ol>
    <h1><a id="mozTocId0001" class="mozTocH1"></a>静止したキャラを出すだけのプログラム</h1>
    <br>
    まずは最小限のプログラムでif文などの練習をしていきましょう<br>
    <p>以下の【キャラを出すだけの最小限サンプル】でキャラクターが出るかを確認しましょう</p>
    <a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId0003">GIMPでのキャラ画像の作り方はこちらを参考にしてください</a></p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      <em>#include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用</em><br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode( 960 , 540 , 32 ) ; // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(960, 540);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = 100; // 初期位置</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1.0f, 0, playerImage, TRUE);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    キャラクターが出なかった人はImageフォルダにPlayer.pngファイルがちゃんとあるか確かめてみてください。<br>
<br>
    <h1><a id="mozTocId0002" class="mozTocH1"></a>キャラを上下左右キーで動かせるプログラム</h1>
<br>
    <p>では次は【Screen.h、Input.hとInput.cppを追加してキャラを上下左右キーで動かせる】ようにしてみましょう</p>
    <a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId00021">Screen.hの作り方はこちらを参考にしてください</a></p>
    <a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId00061">Input.hとInput.cppの作り方はこちらを参考にしてください</a></p>
    <br>
    <p>以下の【キャラを上下左右ボタンで動かすだけの最小限サンプル】でキャラクターを動かせるかを確認しましょう</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      <em>#include "Screen.h"</em><br>
      <em>#include "Input.h"</em><br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(<em>Screen::Width</em>, <em>Screen::Height</em>, 32 ) ; // 画面サイズ<em>をScreenクラスに合わせて</em>設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(<em>Screen::Width</em>, <em>Screen::Height</em>);// ウィンドウサイズをScreenクラスに合わせて設定</em>(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = 100; // 初期位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>float vx = 0, vy = 0; // プレイヤの速度</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>Input::Init(); // Inputクラスの初期化</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>vx = 0; // 速度を毎ターンリセット初期化(しない場合はどんどん加速)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy = 0;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = -5; // Xマイナス方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 5; // Xプラス方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -5; // Yマイナス方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 5; // Yプラス方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x, y, 1.0f, 0, playerImage, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    どうでしょう、キーボードの上下左右キーでキャラを動かすことができたでしょうか？<br>
    うまく反応しない場合は<em>Input::Update();</em>を忘れていることが多いです。<br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0003" class="mozTocH1"></a>キャラを左右キーで加速移動させるプログラム</h1>
<br>
    <br>
    <p>今度は【キャラを左右キーで加速させる】ように改造してみましょう</p>
    <br>
    <p>以下の【キャラを左右キーで加速させるだけの最小限サンプル】でキャラクターを加速させられるか挑戦しましょう</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = <em>Screen::Height</em>; // 初期位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>float vxSpeedMax = 15; // X左右方向の限界速度</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerImage, &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>vx = 0; // 速度を毎ターンリセット初期化(しない場合はどんどん加速)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy = 0;</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>vx = -5; // Xマイナス方向の速度</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>vx = 5; // Xプラス方向の速度</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>if (Input::GetButton(PAD_INPUT_UP))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -5; // Yマイナス方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_DOWN))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 5; // Yプラス方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>vx *= 0.97f; // 減速率</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x<em> - imgSizeX / 2</em>, y<em> - imgSizeY / 2</em>, 1.0f, 0, playerImage, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    さて、いかがでしょうか？氷が床の表面を滑るような動きができたでしょうか？<br>
    DrawRotaGraphF(x<em> - imgSizeX / 2</em>, y<em> - imgSizeY / 2</em>.. として<b><em>imgSizeX / 2</em>を引いているのは<br>
    DrawRotaGraphF関数は画像を描く基準点が画像の中心なので、画像の縦と横の幅の1/2を引くことで中心のぶんのつじつまを合わせるため</b>です。<br>
    単純なプログラムですが、<br>
    <b>突き詰めると、スマホのiPhoneのSafariの【ブラウザのスクロールの気持ちよさ】のような独自のブランディング(差別化)</b>につながるわけですから、あなどれません。<br>
    <b>たかが加速、されど加速</b>。<b>減速率やvxMaxSpeedなどの数字を色々変えながら自分の気持ちいい数値を探してみて</b>ください。<br>
    <br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0004" class="mozTocH1"></a>キャラをZキーでジャンプさせるプログラム</h1>
<br>
    <br>
    さて、こうなったら横方向だけではなく、縦方向のジャンプにも挑戦してみましょう<br>
    <br>
    <p>以下の【キャラをZキーでジャンプさせるサンプル】でキャラクターをジャンプさせられるか挑戦しましょう</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;<em>float vyJumpSpeed = 16, vyDownSpeedMax = 16; // ジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyGravity = 0.8f;<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerImage, &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &lt; 0 &amp;&amp; Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // ジャンプで上昇中(vy &gt; 0)にボタンを離すと勢いが止まる(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if(!isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy += vyGravity; // 重力で下方向に加速</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (vy &gt;= vyDownSpeedMax) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0, playerImage, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f\n", y, vy);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    <br>
    <br>
    いかがでしょう、うまくジャンプできましたか？<br>
    bool isGroundがtrueのとき(着地状態のとき)にボタンを押した瞬間にジャンプ力の数値をvyに設定して、<br>
    if (!isGround)のとき(isGroundがfalseのとき)に毎ターン vy += vyGravity;することで下方向に重力がかかるようにしています。<br>
    vyJumpSpeed = 16 やvyDownSpeedMax = 16 や yGravity = 0.8fなどの<b>数字を自分で変えてみてイメージにあうジャンプを調整してみましょう</b>。<br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0005" class="mozTocH1"></a>初代マリオ風のふわっとジャンプ(上昇と下降フェーズの引力を別々に設定できる)プログラム</h1>
<br>
    <br>
    さて、<a href="https://qiita.com/morian-bisco/items/4c659d9f940c7e3a2099">さらに凝ったプログラム</a>にトライして、初代マリオのようなジャンプ処理に挑戦してみましょう<br>
    <br>
    <p>以下の【初代マリオ風の処理(小数のbit演算を省いた簡易化したもの)】でジャンプさせられるか挑戦しましょう</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;<em>float yJumpStart = 0; // ジャンプした瞬間のyの位置</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed = 16, vyDownSpeedMax = 16; // ジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;<em>float vyForce = 0;</em><br>
      &nbsp;&nbsp;float <em>vyForceJump = 0.5f, </em>vyGravity = 0.8f;<em> // 上昇フェーズと下落フェーズの力を別々に設定できるようになった</em><br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerImage, &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>vyForce = vyForceJump; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>else if (vy &lt; 0 &amp;&amp; Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // ジャンプで上昇中(vy &gt; 0)にボタンを離すと勢いが止まる(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>vy += vyForce; // 勢い(力・フォースを加算)</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>if(!isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy += vyGravity; // 重力で下方向に加速</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>vyForce = 0;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0, playerImage, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f\n", y, vy);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょう、一番の違いは<em>上昇フェーズと下落フェーズの力を別々に設定できるようになった</em>ことです。<br>
    たしかに、上昇フェーズは伸びがあるようにして、下落フェーズではストンと落としたいなど、<br>
    力・フォースを<em>上昇と下落2つのフェーズで切り替えられる</em>ほうが<b>表現力のバリエーションの作りこみがより深まります</b>よね。<br>
    <br>
    <b>こういった細かいこだわりまでをプログラミングで表現できたこと</b>こそが、<br>
    Nintendoの家庭用ファミコンが日本国内を席巻するだけでなく、<br>
    かつてアップルのジョブスも若き時代在籍した<b>米国のアタリ社がぶっ壊しかけた家庭用ゲーム機市場を復活・開拓できた勝因</b>かもしれません。<br>
    (任天堂に先んじて家庭用ゲーム機を出したが<b>アタリショック:粗悪ソフトの大量在庫余りで米国クリスマス商戦でそのゲーム機が大爆死</b>を引き起こした)<br>
    <br>
    今の時代もスマホアプリは粗悪な課金アプリであふれていますが、アップル自体はソフトの在庫を抱えず審査するビジネスモデルを作りあげました(そこにゲームや音楽ソフトへの愛はあるでしょうか)。<br>
    (ジョブズがアタリショックからも学んだかどうかはわかりませんが<b>ゲームも音楽もソフトが売れたら巨大IT側にパーセンテージを、売れなくてもアカウント費を払う時代</b>です)<br>
    そう、今の時代は機器メーカー側ではなく、作り手側が絶対的なリスクを負わされている時代にまた戻ったわけです。<br>
    <br>
    いつかゲーム制作<b>企業に勤めれば、こだわれるなどと考えるのは甘い</b>です。<br>
    プログラムなんて勉強するつもりもないようなプランナやプロデューサーたちが牛耳っている現代の制作現場おいては、<br>
    こだわる時間と愛と余裕のあるのはゲームの制作を学んでいるフェーズの学生ぐらいです。<b>今しかこだわれないと常に思うこと</b>です。<br>
    <br>
    学者タイプの秀才に言わせれば、上昇フェーズも下降フェーズも重力加速度は同じはずだ(ドヤ)となりますが、<br>
    それにとらわれず、<b>上昇と下落フェーズで別の力を設定できたほうが面白くなるかも</b>、とのこだわりを表現できたプログラマと開発現場があの時代の日本の片隅にあったことは確かです。<br>
    <br>
    「ただのゲーム好き」が最初期のゲーム業界を支えていったの<b>ではなく</b>、<br>
    雑誌を見ながらプログラムを打ち込んだ<b>「プログラミング好き」な人がゲームを作っていった</b>のです。<br>
    ゲームプログラマは本当は「ゲーム<b>も</b>好きだけど<b>プログラミングがもっと好き</b>」な人が向いている仕事かもしれません。<br>
    (世代を経るごとに日本のゲーム開発力はどんどん空洞化していくでしょうが、次世代にささやかな希望を託す意味をこめて、少し踏み込んだことを書きました)<br>
    <br>
    <br>
<br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0006" class="mozTocH1"></a>ダッシュ中にジャンプすると高く飛べる(加速段階によって複数のジャンプパラメータを持てる)プログラム</h1>
<br>
    <br>
さて、次はダッシュ中にジャンプすると高く飛べる仕組みにトライしてみましょう<br>
    <br>
    <p>以下の【ダッシュの加速段階によってパラメータを切り替えるサンプル】でダッシュの段階に応じた高さでジャンプさせられるか挑戦しましょう</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>int vx_idx = 0; // 横方向の加速の段階</em><br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed<em>[] = { 14, 15, 16 }</em>, vyDownSpeedMax<em>[] = { 16, 16, 16 }</em>; // <em>ダッシュの段階に応じた複数の</em>ジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump<em>[] = { 0.5f,0.4f,0.3f }</em>, vyGravity<em>[] = { 0.8f,0.8f,0.8f }</em>; // <em>ダッシュ段階に応じた複数のパラメータを持つように</em><br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerImage, &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed<em>[vx_idx]</em>; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump<em>[vx_idx]</em>; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity<em>[vx_idx]</em>; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity<em>[vx_idx]</em>; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax<em>[vx_idx]</em>) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax<em>[vx_idx]</em>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>vx_idx = 0;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0, playerImage, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f<em> idx:%d</em>\n", y, vy<em>, vx_idx</em>);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょう、ダッシュして加速している状態のときのジャンプの高さと、その場でダッシュせずにジャンプした時のジャンプの高さの違いが出れば成功です。<br>
    float vyForceJump<em>[] = { 0.5f,0.4f,0.3f }</em>, vyGravity<em>[] = { 0.8f,0.8f,0.8f }</em>;のように<br>
    複数のパラメータを持ち、それをvyForce = vyGravity<em>[vx_idx]</em>;のように、<em>vx_idx</em>で切り替えているのがポイントです。<br>
    加速の段階はジャンプする瞬間に<em>if (vx_abs &gt; 6) ++vx_idx;</em>のようにif(vx_abs &gt; <em>6</em>)やif(vx_abs > <em>9</em>)で現在の加速度の大きさで段階を切り替えています。<br>
    <br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0007" class="mozTocH1"></a>ダッシュで2速状態でジャンプすると空で羽ばたけるプログラム</h1>
<br>
    <br>
    さて、次はダッシュで2速状態でジャンプすると空で羽ばたける仕組みにトライしてみましょう。<br>
    <br>
    <p>以下の【ダッシュで2速状態でジャンプすると空で羽ばたけるサンプル】で2速でダッシュして飛んだら空で羽ばたく仕組みに挑戦しましょう</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16<em>, 4</em> }, vyDownSpeedMax[] = { 16, 16, 16<em>, 8</em> }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f<em>,0.1f</em> }, vyGravity[] = { 0.8f,0.8f,0.8f<em>,0.8f</em> }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;<em>bool isFlying = false; // 飛行モード</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerImage, &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>isFlying = false;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0, playerImage, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    <br>
    いかがでしょう、空でパタパタ羽ばたく感じが出せたでしょうか？<br>
    パラメーターを自分で変えてみて<b>自分なりの羽ばたきを実験</b>してみてください。<br>
    ( ぼくはvyJumpSpeed[]を<b>あえて少なめ</b>の4にして、<b>たくさん連打しても上に上がりすぎない</b>ように調理して、<br>
    vyForceJump[]もそれに比例して少なくすることで、<b>長押しで羽ばたくとギュンと上に伸び</b>をだせるようにしました )<br>
    <br>
    昔のプログラマは<b>少しのアイデア</b>と少しのコード変更でUnityの物理機能に頼らずとも、<b>独創性を発揮してきた</b>ようですね。<br>
    こういった小ネタだけでも<a href="https://flappybird.io/">Flappy Bird</a>のように人を熱中させ<a href="https://ja.wikipedia.org/wiki/Flappy_Bird">大ヒットすることもある</a>わけです。<br>
    <br>
    シンプルな面白さの発見は、<b>日々プログラミングしていてこそ生み出される可能性があります</b>。<br>
    ついつい、連打したくなる、とか、グイっと伸びて気持ちいいとか、<b>そういう手触りは頭でっかちの企画書ベースの開発では生み出されません</b>。<br>
    <br>
    自分なりの<b>手触りやパラメーターや面白さの体感は自分のオリジナル料理の大事なレシピとなるうる</b>のです。<br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0008" class="mozTocH1"></a>キャラチップ配列アニメで「左右ダッシュ」と「2速状態ジャンプでキャラを±60度回転させ空を飛ぶ」プログラム</h1>
<br>
    <br>
    さて、次はキャラクターをアニメーションさせる表現にトライしてみましょう。<br>
    RPGなどのキャラチップ自作ツール<a href="https://pipoya.notion.site/CharaMEL-6fb3b97cc5f643e7a8025fce608e7050">キャラメル-CharaMEL-</a>をダウンロードして<a href="https://pipoya.notion.site/65954b63976d40e9b9a1a77f0f90e1d6">いろいろな機能を駆使してキャラを自作</a>すれば再配布自由な自作キャラが完成です。<br>
    作るのが面倒な人向けに自作したファイルを以下に置いておきます。<br>
    <a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/pikkoron.Json">キャラの設定jsonファイル</a><b>[←リンクを右クリックして名前を付けてリンク保存からダウンロード]</b>(CharaMELアプリメニューのファイル→キャラクタのインポートから読込可能)<br>
    <a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/pikkoron.png">書き出したpng画像ファイル</a>(メニュー下のpng↓ボタンから書き出せる)<br>
    <br>
    書き出したpngファイルを私は「Image/pikkoron.png」として<b>DXライブラリのImageフォルダ</b>に保存(またはコピー)しておきました。<br>
    このキャラチップ画像ファイルを<b>パラパラアニメさせる</b>ことで「キャラクターをダッシュさせたり、空を飛行させたり」してみましょう。<br>
    <br>
    キャラチップ画像のキャラは32×32(書き出し時のサイズによる)などに分割されており、それをDXライブラリのLoadDivGraph関数で読み取る際に対応する画像番号の見極めが必要です。(GIMPでグリッドを引いて番号を見極めましょう)<br>
    <p> <img src="image/charachip_grid.png" alt="" style="width: 692px; height: 292px;"></p>
    <br>
    <p>以下の【キャラチップ配列のダッシュ左<b>[3][4][5]</b>、右<b>[6][7][8]</b>と立ち(左右)<b>[4][7]</b>を±60度回転させ空を飛ぶサンプル】でキャラチップ画像をパラパラアニメさせてみましょう。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;<u>int playerImage = -1;<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</u><br>
      &nbsp;&nbsp;<em>int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;<em>enum Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(<em>playerChips[0]</em>, &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>direction = Direction::Left;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>direction = Direction::Right;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0, playerImage, TRUE);</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[6 + animeStep], TRUE);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょう、キャラクタがパラパラとアニメされて走っているように見えるようになりましたか？<br>
    <br>
    キャラクタが小さくて見にくいという人は描画処理のコードの以下の部分を変更すれば、<b>キャラを2倍の大きさで表示</b>させられます。<br>
<p class="source">
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - <em>imgSizeX</em>, y - <em>imgSizeY</em>, <em>2.0f</em>,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - <em>imgSizeX</em>, y - <em>imgSizeY</em>, <em>2.0f</em>, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - <em>imgSizeX</em>, y - <em>imgSizeY</em>, <em>2.0f</em>, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - <em>imgSizeX</em>, y - <em>imgSizeY</em>, <em>2.0f</em>, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      </p>
    <br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0009" class="mozTocH1"></a>ジャンプの効果音を鳴らすプログラム</h1>
<br>
    <br>
    <br>
    まずは、せっかくなのでジャンプの効果音を<a href="https://jfxr.frozenfractal.com/">ブラウザで動くシンセサイザーJFXR</a>で作ってみましょう。<br>
    <a href="https://2dgames.jp/jfxr/">簡単な使い方だけなら以下のサイトが参考になります。</a><br>
    シンセの調節に慣れてきたら<a href="https://apps.apple.com/jp/app/audiokit-synth-one-synthesizer/id1371050497">iPhone用のシンセ</a>で夜、寝転がりながらスマホで効果音制作にも挑戦だ。<br>
    <a href="https://daw-jones.hatenablog.com/entry/2019/04/14/154502">結構本格的なシンセ機能があるのでDAWのユーザーも結構おすすめ↑してる</a><br>
    <br>
    シンセの基本は下記の動画を<b>暇な夜の時間のあるときにみておく</b>と音づくりのスタート地点に立てると思います(センスのある天才肌なら開眼するはず)。<br>
    <a href="https://youtu.be/7tMbJ6f6qf0?t=341">https://youtu.be/7tMbJ6f6qf0?t=341</a><br>
    <br>
    まあ、ジャンプ音ぐらいなら下記画像のボタンやバーを適当にいじれば音の知識がゼロからでも、なんとなくセンスがつかめるはず。<br>
    <p> <img src="image/synth_jfxr_jump.png" alt=""></p>
    <br>
    <br>
    <br>
    例として、わたくしの引き当てたジャンプ音のシンセ調節ファイルを下記リンクに共有します。<br>
    <a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/Jump.jfxr">わたくしの引き当てたジャンプ音のシンセ調節ファイル</a>←右クリックで[名前をつけてリンク先を保存]でダウンロードして<br>
    ↑ダウンロードしたファイルを<a href="https://jfxr.frozenfractal.com/">ブラウザで動くシンセJFXR</a>の左上の[Open]ボタンから開いてみよう<br>
    <p> <img src="image/synth_jump_open.png" alt=""></p>
    <br>
    まずは「小ジャンプ」の効果音として下記設定をして、[Export]ボタンから<b>Jump0.wavというファイル名</b>で<b>DXライブラリのプロジェクトにSEフォルダを作って</b>そこに保存しましょう。<br>
    <audio controls src="sozai/Jump0.wav" type="audio/wav">小ジャンプ</audio><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/Jump0.wav">Jump0.wav</a>←右クリックで[名前をつけてリンク先を保存]でダウンロード<br>
    <p> <img src="image/synth_jump0.png" alt=""></p>
    <br>
    つぎは「大ジャンプ」の効果音として下記設定をして、[Export]ボタンから<b>Jump1.wavというファイル名</b>で<b>DXライブラリのプロジェクトのSEフォルダに保存</b>しましょう。<br>
    <audio controls src="sozai/Jump1.wav" type="audio/wav">大ジャンプ</audio><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/Jump1.wav">Jump1.wav</a>←右クリックで[名前をつけてリンク先を保存]でダウンロード<br>
    <p> <img src="image/synth_jump1.png" alt=""></p>
    <br>
    今度は「空を飛び始める」効果音として下記設定をして、[Export]ボタンから<b>Jump2.wavというファイル名</b>で<b>DXライブラリのプロジェクトのSEフォルダに保存</b>しましょう。<br>
    <audio controls src="sozai/Jump2.wav" type="audio/wav">空を飛び始める</audio><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/Jump2.wav">Jump2.wav</a>←右クリックで[名前をつけてリンク先を保存]でダウンロード<br>
    <p> <img src="image/synth_jump2.png" alt=""></p>
    <br>
    最後は「空でホップする」効果音として下記設定をして、[Export]ボタンから<b>Jump3.wavというファイル名</b>で<b>DXライブラリのプロジェクトのSEフォルダに保存</b>しましょう。<br>
    <audio controls src="sozai/Jump3.wav" type="audio/wav">空でホップする</audio><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/Jump3.wav">Jump3.wav</a>←右クリックで[名前をつけてリンク先を保存]でダウンロード<br>
    <p> <img src="image/synth_jump3.png" alt=""></p>
    <br>
    <br>
    <p>あとは以下の【効果音をSEフォルダから読み込んで大小ジャンプと空を飛ぶ音を出すサンプル】でキャラの動きに合わせて効果音を出してみましょう。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4<br>
      &nbsp;&nbsp;int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょう、ジャンプ音が鳴りましたか？<br>
    うまくいかない人は、音のファイルを<b>DXのプロジェクトのSEフォルダに入れてありますか？</b><br>
    ジャンプ音のファイル名はちゃんとJump1.wavが<b>大文字のJから始まっていますか？</b>Jump 1.wavのように<b>スペースが開いてませんか？</b><br>
    <br>
    コード自体の変更は少ないですが、理想のジャンプ音に出会えるまで繰り返し色んな音を試しているだけですぐに時間は過ぎてゆくはずです。<br>
    WEBでひとさまの作った効果音を漁るのと、シンセで理想のジャンプ音を自作するのと、どちらを選んでも結局、時間がかかると思います。<br>
    クリエイターの端くれとしては、ぼくは自分でシンセをいじってイメージどおりの音を探る作業のほうが楽しいかもしれません。<br>
    <br>
    たかがジャンプの効果音一つと思うでしょうか？<br>
    <b>ゲームの手触り感の50%は効果音で決まるとぼくは思っています。</b><br>
    どんなにプログラミングや企画にこだわったゲームでも効果音が気持ちよくないゲームはメリハリがなくて眠くなってしまいます。<br>
    <br>
    マリオワールドの効果音をはじめて聞いたとき、ぼくは<a href="https://www.youtube.com/watch?v=tWfN2aCge8U">ゲームというより「楽器」を感じました</a>。<br>
    ひとつひとつの効果音が高周波が効いて目覚ましのような<a href="https://youtu.be/UEJMve_-FmE?t=14">目の覚める音だと思います</a>。<br>
    <br>
    おそらく、ぼくが最近のマリオや任天堂作品と昔の作品を比べて、昔のほうが逆にきらきらしてると感じるのは<a href="https://ja.wikipedia.org/wiki/%E8%BF%91%E8%97%A4%E6%B5%A9%E6%B2%BB">「効果音」の作者が変わったから</a>なのかな..と思います。<br>
    ポケモンも最近の作品は<a href="https://ja.wikipedia.org/wiki/%E5%A2%97%E7%94%B0%E9%A0%86%E4%B8%80">昔の作品と変わって</a>なぜかバトル中の音楽で眠くなってしまうのは...曲のメリハリの問題？..(それともぼくの老化か)<br>
    <br>
    ゲームの<b>快適さも、手触りも、メリハリも</b>、簡単に見えて<b>音の影響はかなり大きい</b>と思います。<br>
    <br>
    <br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0010" class="mozTocH1"></a>地形ファイルを読み込むプログラム</h1>
<br>
    <br>
    <br>
    つぎは地形ファイルを読み込むプログラムに挑戦してみます。<br>
    <br>
    まずはGIMPでためしに簡単な32×32のブロックを描いてみましょう。<br>
    <br>
    <b>[ファイル] → [新しい画像]</b>から256×256、256×512..など<b>2の何乗かのサイズでキャンバスを作成</b>しましょう。<br>
    <p> <img src="image/gimp_mapchip_new_image.png" alt=""></p>
    <br>
    <b>右下のレイヤの上で右クリックして[アルファチャンネルの追加]してから[消しゴムで背景を消して透明]</b>にしましょう。<br>
    <p> <img src="image/gimp_mapchip_alfa.png" alt=""></p>
    <br>
    <b>[画像] → [グリッドの設定]</b>から16×16,32×32,64×64..などマップで<b>描きたいブロックのサイズにグリッド補助線表示の大きさの設定</b>をしましょう。<br>
    <p> <img src="image/gimp_mapchip_grid.png" alt=""></p>
    <br>
    <b>[表示] → [グリッドの表示]</b>でグリッドを表示させて、<b>[表示] → [表示倍率]</b>でドットを描きやすいように<b>800%ほどに拡大表示</b>をしましょう。<br>
    <p> <img src="image/gimp_mapchip_grid_zoom.png" alt=""></p>
    <br>
    <b>範囲選択でぬりつぶしたい32×32の四角形を選択</b>して、黒色でぬりつぶしましょう。<br>
    <p> <img src="image/gimp_mapchip_grid_black.png" alt=""></p>
    <br>
    <b>ぬりつぶした黒色の内側を範囲選択でべつの色でぬりつぶし</b>て、ブロックの<b>内側に色の層を積み重ね</b>ましょう。<br>
    <p> <img src="image/gimp_mapchip_grid_black_inside1.png" alt=""></p>
    <br>
    <b>さらに内側を範囲選択でべつの色でぬりつぶし</b>て、ブロックの<b>色の層を積み重ねて立体感を出し</b>ましょう。<br>
    <p> <img src="image/gimp_mapchip_grid_black_inside2.png" alt=""></p>
    <br>
    <b>マウス長押しで鉛筆を選択して内側に白いドットでテカリを描い</b>て、ブロックの<b>テカリによる立体感を出し</b>ましょう。<br>
    <p> <img src="image/gimp_mapchip_grid_black_inside3.png" alt=""></p>
    <br>
    <b>同じような手順で好きな色のブロックを自作</b>して、自分のオリジナル色のブロックのバリエーションを増やしましょう。<br>
    <br>
    マップチップを自作出来たらGIMPファイルをmaphip.xcfで、画像ファイルをmapchip.pngというファイル名でエクスポートしましょう。<br>
    <br>
    <br>
    <br>
    GIMPが苦手な人向けに私の自作したマップチップを以下に共有しておきます。<br>
    以下の地形のマップチップはGIMPで1ブロック32×32として自作してみました。自作したGIMPファイルとエクスポート画像を下記リンクに共有しておきます。<br>
    ・<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/mapchip.xcf">mapchip.xcf(GIMPの編集ファイル)</a>←右クリック[名前をつけてリンク先を保存]でダウンロードすればGIMPで自作ブロックを書き足せる<br>
    ・<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/mapchip.png">mapchip.png(↑GIMPから名前をつけてエクスポートしたpng画像ファイル)</a>←右クリック[名前をつけてリンク先を保存]でダウンロード<br>
    <p> <img src="sozai/mapchip.png" alt=""></p>
    <br>
    地形のマップチップは<a href="https://thorbjorn.itch.io/tiled">タイルマップエディタ</a>で配置して[ファイル→名前をつけてエクスポート]からcsvファイルで書き出せます。<br>
    下記リンクの2つのファイルをダウンロードして、mapchip.pngと同じフォルダに置いた状態でタイルマップエディタで[ファイル→Open File or Project]でstage.tmxを開けばマップを編集できます。<br>
    ・<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/mapchip.tsx">mapchip.tsx(png画像の32×32など「グリッド分割設定など」の保存ファイル)</a>←右クリック[名前をつけてリンク先を保存]でダウンロード<br>
    ・<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/stage.tmx">stage.tmx(タイルマップ編集ファイル)</a>←右クリック[名前をつけてリンク先を保存]でダウンロード<br>
    <br>
    <br>
    タイルマップエディタで[ファイル→名前をつけてエクスポート]から書き出したcsvファイルを下記リンクに共有しておきます。<br>
    ・<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/sozai/stage.csv">stage.csv(地形番号カンマ区切りで書き出したファイル)</a>←右クリック[名前をつけてリンク先を保存]でダウンロード<br>
    書き出したcsvファイル↑は<b>DXのプロジェクトのフォルダにMapフォルダを作ってMap/stage.csvとして保存</b>してください。<br>
    <br>
    <br>
    <p>さてまずは【地形csvファイルをMapフォルダから読み込んで地形番号を表示させるサンプル】でcsvファイルの中身には地形番号がカンマ区切りで書き出されていることを実感しましょう。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      <em>#include &lt;vector&gt;&nbsp;// csvを2次元vector配列に格納<br>
      #include &lt;string&gt;&nbsp;// 文字列std::stringに必要<br>
      #include &lt;fstream&gt;&nbsp;// ファイル読み出しstd::ifstreamに必要<br>
      #include &lt;sstream&gt;&nbsp;// 文字列ストリームに必要 ss &gt;&gt; num;で文字列から数字に変換できる</em><br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4<br>
      &nbsp;&nbsp;int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>int CellSize = 32; // マップの1マスのピクセル数</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>std::vector&lt;std::vector&lt;int&gt;&gt; mapData;// タイルマップデータ<br>
      &nbsp;&nbsp;std::ifstream ifs_csv_file("Map/stage.csv"); // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int Width = 0, Height = 0; // マップデータの横(Width) 縦(Height)のマスの数<br>
      &nbsp;&nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp;std::string line; // 1行単位ごとにcsvファイルから文字列をstd::getlineで読み込んで受け取る<br>
      &nbsp;&nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; valuelist; // 1行ぶんの数字リスト配列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::istringstream linestream( line ); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::string comma_part; // カンマで分割された文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int widthCount = 0; // カンマで区切られた行の数字の数(各行の幅)をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (std::getline(linestream, comma_part, { ',' })) // 1行をgetlineでカンマで区切って列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istringstream ss( comma_part ); // カンマで区切られた文字をssを通して&gt;&gt;で数字に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行の数字の数がMAX記録を更新するかチェック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (widthCount &gt; MaxWidth)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxWidth = widthCount; // 暫定Maxの列の幅を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行ぶんの数字の配列をとりまとめてmapDataに1行ずつ追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (valuelist.size() != 0) // 配列に数字が1つでもあるなら.size() != 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData.emplace_back(valuelist); // mapDataに1行ずつ数字配列valuelistを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;++Height; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;Width = MaxWidth; // マップの幅Widthは一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp;// ↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp;assert(Width &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;assert(Height &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// 地形マップを[ 行のfor文×列のfor文 ]の2重ループで描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0, ySize = mapData.size(); cellY &lt; ySize; ++cellY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0, xSize = mapData[cellY].size(); cellX &lt; xSize; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[cellY][cellX]; // [行][列] の位置のcsvの地形番号(チップ番号)を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id < 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ]用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawString(chip_x, chip_y, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょうか？このようにcsvの中身は地形のチップ番号が,カンマ区切りで書き出されています。<br>
    <p> <img src="image/csv_stage_comma.png" alt=""></p>
    <br>
    <br>
    プログラムではそのcsvファイルを <em>std::ifstream ifs_csv_file("Map/stage.csv");</em> で読みだして<br>
    カンマ区切りを<b>while文とstd::getline</b>を使い <em>while (std::getline(linestream, comma_part, { ',' }))</em> で分割して<br>
    分割したcomma_partを<b>文字列ストリーム</b>ssを使い <em>std::istringstream ss( comma_part );</em><br>
    <b>ストリーム演算子&gt;&gt; を通してint型のnumに変換</b> <em>ss &gt;&gt; num;</em> して<br>
    その数字numを<b>まずは1次元配列std::vector&lt;int&gt;型のvaluelist</b>に <em>valuelist.emplace_back(num);</em> で<b>1つずつ入れて、</b><br>
    その<b>数字配列の1行ぶん(valuelist)を2次元数字配列std::vector&lt;std::vector&lt;int&gt;&gt;型のmapData</b>へ <em>mapData.emplace_back(valuelist);</em> で<b>行単位で1行ずつ格納</b>しています。<br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0011" class="mozTocH1"></a>地形マップチップを画面に描くプログラム</h1>
<br>
    <br>
    <br>
    <p>さてつぎは【地形のマップチップMap/mapchip.pngを読み込んだstage.csvの地形番号にあわせて描き出すサンプル】で画面に地形を描き出しましょう<b>(注意:まだ当たり判定はない)</b>。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      #include &lt;vector&gt;&nbsp;// csvを2次元vector配列に格納<br>
      #include &lt;string&gt;&nbsp;// 文字列std::stringに必要<br>
      #include &lt;fstream&gt;&nbsp;// ファイル読み出しstd::ifstreamに必要<br>
      #include &lt;sstream&gt;&nbsp;// 文字列ストリームに必要 ss &gt;&gt; num;で文字列から数字に変換できる<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4<br>
      &nbsp;&nbsp;int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;<em>int mapChips[64]; // マップのチップのグリッドの分割数に応じて8×8 = 64など配列で確保<br>
      &nbsp;&nbsp;LoadDivGraph("Map/mapchip.png", 64, 8, 8, CellSize, CellSize, mapChips); // マップのチップのサイズは32×32(=CellSize)<br>
      &nbsp;&nbsp;assert(mapChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; mapData;// タイルマップデータ<br>
      &nbsp;&nbsp;std::ifstream ifs_csv_file("Map/stage.csv"); // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int Width = 0, Height = 0; // マップデータの横(Width) 縦(Height)のマスの数<br>
      &nbsp;&nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp;std::string line; // 1行単位ごとにcsvファイルから文字列をstd::getlineで読み込んで受け取る<br>
      &nbsp;&nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; valuelist; // 1行ぶんの数字リスト配列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::istringstream linestream( line ); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::string comma_part; // カンマで分割された文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int widthCount = 0; // カンマで区切られた行の数字の数(各行の幅)をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (std::getline(linestream, comma_part, { ',' })) // 1行をgetlineでカンマで区切って列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istringstream ss( comma_part ); // カンマで区切られた文字をssを通して&gt;&gt;で数字に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行の数字の数がMAX記録を更新するかチェック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (widthCount &gt; MaxWidth)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxWidth = widthCount; // 暫定Maxの列の幅を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行ぶんの数字の配列をとりまとめてmapDataに1行ずつ追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (valuelist.size() != 0) // 配列に数字が1つでもあるなら.size() != 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData.emplace_back(valuelist); // mapDataに1行ずつ数字配列valuelistを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;++Height; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;Width = MaxWidth; // マップの幅Widthは一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp;// ↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp;assert(Width &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;assert(Height &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - imgSizeX / 2, y - imgSizeY / 2, 1.0f, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2; // DrawRotaGraphF関数は画像の真ん中が起点なので1/2ずらした位置計算</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 地形マップを[ 行のfor文×列のfor文 ]の2重ループで描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0, ySize = mapData.size(); cellY &lt; ySize; ++cellY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0, xSize = mapData[cellY].size(); cellX &lt; xSize; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[cellY][cellX]; // [行][列] の位置のcsvの地形番号(チップ番号)を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id < 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>// マップチップを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x + rotaShiftX, chip_y + rotaShiftY, 1.0f, 0.0f, mapChips[id], TRUE);</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ]用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawString(chip_x, chip_y, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょう、マップ地形が画面に描かれたでしょうか？<br>
    <br>
    チップを描く起点の座標(x,y)=(chip_x, chip_y)は、マス目番号×32(CellSize:チップ画像の分割サイズ)で求められます。<br>
    <b>float chip_y = (float)(<em>cellY * CellSize</em>); // マス目Y(行)番号×マス目サイズ</b><br>
    <b>float chip_x = (float)(<em>cellX * CellSize</em>); // マス目X(列)番号×マス目サイズ</b><br>
    <br>
    下図はマス目の1マス(セル)のサイズが32の場合の位置の計算方法のイメージです。<br>
    <p> <img src="image/csv_stage_cellsize.png" alt=""></p>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0012" class="mozTocH1"></a>地形マップチップの当たり判定(めり込みの余りのぶんだけ押し戻す)プログラム</h1>
<br>
    <br>
    <br>
    <p>さてつぎは【キャラの四隅が壁のマップチップか調べて、めり込みの余りのぶんだけ押し戻すサンプル】で地形のブロックの当たり判定でブロックに乗れるようにしましょう。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      #include &lt;vector&gt;&nbsp;// csvを2次元vector配列に格納<br>
      #include &lt;string&gt;&nbsp;// 文字列std::stringに必要<br>
      #include &lt;fstream&gt;&nbsp;// ファイル読み出しstd::ifstreamに必要<br>
      #include &lt;sstream&gt;&nbsp;// 文字列ストリームに必要 ss &gt;&gt; num;で文字列から数字に変換できる<br>
      <em>#include &lt;unordered_map&gt;&nbsp;// std::unordered_map 高速辞書配列に必要(チップ番号から壁などを表すビットへ変換する辞書)</em><br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4<br>
      &nbsp;&nbsp;int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;int mapChips[64]; // マップのチップのグリッドの分割数に応じて8×8 = 64など配列で確保<br>
      &nbsp;&nbsp;LoadDivGraph("Map/mapchip.png", 64, 8, 8, CellSize, CellSize, mapChips); // マップのチップのサイズは32×32(=CellSize)<br>
      &nbsp;&nbsp;assert(mapChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; mapData;// タイルマップデータ<br>
      &nbsp;&nbsp;std::ifstream ifs_csv_file("Map/stage.csv"); // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int Width = 0, Height = 0; // マップデータの横(Width) 縦(Height)のマスの数<br>
      &nbsp;&nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp;std::string line; // 1行単位ごとにcsvファイルから文字列をstd::getlineで読み込んで受け取る<br>
      &nbsp;&nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; valuelist; // 1行ぶんの数字リスト配列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::istringstream linestream( line ); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::string comma_part; // カンマで分割された文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int widthCount = 0; // カンマで区切られた行の数字の数(各行の幅)をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (std::getline(linestream, comma_part, { ',' })) // 1行をgetlineでカンマで区切って列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istringstream ss( comma_part ); // カンマで区切られた文字をssを通して&gt;&gt;で数字に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行の数字の数がMAX記録を更新するかチェック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (widthCount &gt; MaxWidth)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxWidth = widthCount; // 暫定Maxの列の幅を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行ぶんの数字の配列をとりまとめてmapDataに1行ずつ追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (valuelist.size() != 0) // 配列に数字が1つでもあるなら.size() != 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData.emplace_back(valuelist); // mapDataに1行ずつ数字配列valuelistを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;++Height; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;Width = MaxWidth; // マップの幅Widthは一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp;// ↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp;assert(Width &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;assert(Height &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height<em> - 100</em>; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>int hitOffsetLeft = 2; // 当たり判定の左端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetRight = 2; // 当たり判定の右端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetTop = 1; // 当たり判定の上端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetBottom = 0; // 当たり判定の下端のオフセット</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 当たり判定のはしっこを計算するための一時関数<br>
      &nbsp;&nbsp;auto getLeft  = [&amp;hitOffsetLeft](float worldX) { return worldX + hitOffsetLeft; };<br>
      &nbsp;&nbsp;auto getTop   = [&amp;hitOffsetTop](float worldY) { return worldY + hitOffsetTop; };<br>
      &nbsp;&nbsp;auto getRight  = [&amp;hitOffsetRight, &amp;imgSizeX](float worldX) { return worldX + imgSizeX - hitOffsetRight; };<br>
      &nbsp;&nbsp;auto getBottom = [&amp;hitOffsetBottom, &imgSizeY](float worldY) { return worldY + imgSizeY - hitOffsetBottom; };</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>enum BlockBit // ブロックの特性を32桁のビットで表現<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None = 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Wall   = 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;};</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>std::unordered_map&lt;int, unsigned int&gt; blockBits = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{-1,BlockBit::None},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 0,BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 2,BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 3,BlockBit::Wall},<br>
      &nbsp;&nbsp;};</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 指定された座標(worldX,worldY)の地形が 壁 や ダメージブロックかなどをチェックする一時関数<br>
      &nbsp;&nbsp;auto checkID = [&amp;blockBits, &amp;CellSize](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain, float worldX, float worldY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int terrainID = -1; // 指定された座標の地形のID<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (worldX &lt; 0 || worldY &lt; 0) return false; // 負の座標が指定された場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = (int)(worldX / CellSize), mapY = (int)(worldY / CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 二次元配列の範囲内か判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapY &lt; terrain.size() && mapX &lt; terrain[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terrainID = terrain[mapY][mapX]; // 二次元配列から地形IDを取り出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (checkBit &amp; blockBits[terrainID]) != 0; // ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>float debug_x = -1, debug_y = -1; // [デバッグ] めり込みすぎのラインを記録しておく変数</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>{//←スコープ{}で下記xLeftなどの変数名を{}の内側でリセットして、外側でかぶっても大丈夫なようにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yMiddle) || // 左中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) )  // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xLeft; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// std::fmodで小数点の余りを計算 めり込みすぎの余り = std::fmod(xLeft, CellSize)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallRight = xLeft + CellSize - (float)std::fmod(xLeft, CellSize); // 壁の右端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallRight - hitOffsetLeft; // 左端を壁の右端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓右端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) || // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yMiddle) || // 右中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xRight; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallLeft = xRight - (float)std::fmod(xRight, CellSize); // 壁の左端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallLeft + hitOffsetRight - imgSizeX; // 右端を壁の左端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>{//←スコープ{}で下記xLeftなどの変数名を{}の内側でリセットして、外側でかぶっても大丈夫なようにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yTop) || // 中上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) )  // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yTop; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallBottom = yTop + CellSize - (float)std::fmod(yTop, CellSize); // 壁の下側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallBottom - hitOffsetTop; // 頭を壁の下端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) || // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yBottom) || // 中下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yBottom; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallTop = yBottom - (float)std::fmod(yBottom, CellSize); // 壁の上側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallTop + hitOffsetBottom - imgSizeX; // 足元を壁の上端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 床に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ブロックに当たってないからfalseにして落下するように<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>// 着地判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (y &gt; Screen::Height)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Screen::Height; // この行が無いと勢いで地面にめり込んだぶんを地面の位置に沿わせられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x <em>+ imgSizeX / 2</em>, y <em>+ imgSizeY / 2</em>, <em>1.0f</em>,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x <em>+ imgSizeX / 2</em>, y <em>+ imgSizeY / 2</em>, <em>1.0f</em>, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x <em>+ imgSizeX / 2</em>, y <em>+ imgSizeY / 2</em>, <em>1.0f</em>, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x <em>+ imgSizeX / 2</em>, y <em>+ imgSizeY / 2</em>, <em>1.0f</em>, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2; // DrawRotaGraphF関数は画像の真ん中が起点なので1/2ずらした位置計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 地形マップを[ 行のfor文×列のfor文 ]の2重ループで描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0, ySize = mapData.size(); cellY &lt; ySize; ++cellY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0, xSize = mapData[cellY].size(); cellX &lt; xSize; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[cellY][cellX]; // [行][列] の位置のcsvの地形番号(チップ番号)を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id < 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップチップを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x + rotaShiftX, chip_y + rotaShiftY, 1.0f, 0.0f, mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ]用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawString(chip_x, chip_y, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>// [デバッグ] 当たり判定の四隅を赤枠で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawBox(getLeft(x), getTop(y), getRight(x), getBottom(y), GetColor(255, 0, 0), FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] キャラ原点(x,y)を緑丸で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawCircle(x, y, 2, GetColor(0, 255, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たった際の行き過ぎの めりこみ座標(debug_x,debug_y) を青線で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_x != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(debug_x, 0, debug_x, Screen::Height, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_y != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(0, debug_y, Screen::Width, debug_y, GetColor(0, 0, 255));</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょう、マップ地形のブロックに当たったら立てるようになりましたか？<br>
    <br>
    キャラによって当たり判定のオフセットの数字を変えてキャラの背の高さや幅にフィットさせるようにするとよいでしょう。<br>
    int hitOffsetLeft = <em>2</em>; // 当たり判定の左端のオフセット<br>
    int hitOffsetRight = <em>2</em>; // 当たり判定の右端のオフセット<br>
    int hitOffsetTop = <em>1</em>; // 当たり判定の上端のオフセット<br>
    int hitOffsetBottom = <em>0</em>; // 当たり判定の下端のオフセット<br>
    <br>
    <p> <img src="image/csv_stage_chara_offset.png" alt=""></p>
    <br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0013" class="mozTocH1"></a>キャラの移動に連動したcamera_x,camera_yで「描く地形のほうをスクロールでずらす」プログラム</h1>
<br>
    <br>
    <br>
    <p>さてつぎは【キャラの<b>x座標からスクリーンの幅の1/2を引いたぶん(camera_x)</b>だけ背後の<b>地形を描く起点をずらす</b>サンプル】で地形のスクロールに挑戦しましょう。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      #include &lt;vector&gt;&nbsp;// csvを2次元vector配列に格納<br>
      #include &lt;string&gt;&nbsp;// 文字列std::stringに必要<br>
      #include &lt;fstream&gt;&nbsp;// ファイル読み出しstd::ifstreamに必要<br>
      #include &lt;sstream&gt;&nbsp;// 文字列ストリームに必要 ss &gt;&gt; num;で文字列から数字に変換できる<br>
      #include &lt;unordered_map&gt;&nbsp;// std::unordered_map 高速辞書配列に必要(チップ番号から壁などを表すビットへ変換する辞書)<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4<br>
      &nbsp;&nbsp;int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;int mapChips[64]; // マップのチップのグリッドの分割数に応じて8×8 = 64など配列で確保<br>
      &nbsp;&nbsp;LoadDivGraph("Map/mapchip.png", 64, 8, 8, CellSize, CellSize, mapChips); // マップのチップのサイズは32×32(=CellSize)<br>
      &nbsp;&nbsp;assert(mapChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; mapData;// タイルマップデータ<br>
      &nbsp;&nbsp;std::ifstream ifs_csv_file("Map/stage.csv"); // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int Width = 0, Height = 0; // マップデータの横(Width) 縦(Height)のマスの数<br>
      &nbsp;&nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp;std::string line; // 1行単位ごとにcsvファイルから文字列をstd::getlineで読み込んで受け取る<br>
      &nbsp;&nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; valuelist; // 1行ぶんの数字リスト配列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::istringstream linestream( line ); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::string comma_part; // カンマで分割された文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int widthCount = 0; // カンマで区切られた行の数字の数(各行の幅)をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (std::getline(linestream, comma_part, { ',' })) // 1行をgetlineでカンマで区切って列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istringstream ss( comma_part ); // カンマで区切られた文字をssを通して&gt;&gt;で数字に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行の数字の数がMAX記録を更新するかチェック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (widthCount &gt; MaxWidth)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxWidth = widthCount; // 暫定Maxの列の幅を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行ぶんの数字の配列をとりまとめてmapDataに1行ずつ追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (valuelist.size() != 0) // 配列に数字が1つでもあるなら.size() != 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData.emplace_back(valuelist); // mapDataに1行ずつ数字配列valuelistを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;++Height; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;Width = MaxWidth; // マップの幅Widthは一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp;// ↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp;assert(Width &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;assert(Height &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height - 100; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int hitOffsetLeft = 2; // 当たり判定の左端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetRight = 2; // 当たり判定の右端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetTop = 1; // 当たり判定の上端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetBottom = 0; // 当たり判定の下端のオフセット<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 当たり判定のはしっこを計算するための一時関数<br>
      &nbsp;&nbsp;auto getLeft  = [&amp;hitOffsetLeft](float worldX) { return worldX + hitOffsetLeft; };<br>
      &nbsp;&nbsp;auto getTop   = [&amp;hitOffsetTop](float worldY) { return worldY + hitOffsetTop; };<br>
      &nbsp;&nbsp;auto getRight  = [&amp;hitOffsetRight, &amp;imgSizeX](float worldX) { return worldX + imgSizeX - hitOffsetRight; };<br>
      &nbsp;&nbsp;auto getBottom = [&amp;hitOffsetBottom, &imgSizeY](float worldY) { return worldY + imgSizeY - hitOffsetBottom; };<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;enum BlockBit // ブロックの特性を32桁のビットで表現<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None = 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Wall   = 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, unsigned int&gt; blockBits = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{-1,BlockBit::None},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 0,BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 2,BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 3,BlockBit::Wall},<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 指定された座標(worldX,worldY)の地形が 壁 や ダメージブロックかなどをチェックする一時関数<br>
      &nbsp;&nbsp;auto checkID = [&amp;blockBits, &amp;CellSize](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain, float worldX, float worldY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int terrainID = -1; // 指定された座標の地形のID<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (worldX &lt; 0 || worldY &lt; 0) return false; // 負の座標が指定された場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = (int)(worldX / CellSize), mapY = (int)(worldY / CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 二次元配列の範囲内か判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapY &lt; terrain.size() &amp;&amp; mapX &lt; terrain[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terrainID = terrain[mapY][mapX]; // 二次元配列から地形IDを取り出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (checkBit &amp; blockBits[terrainID]) != 0; // ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>float camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Width * CellSize - Screen::Width &lt;= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float debug_x = -1, debug_y = -1; // [デバッグ] めり込みすぎのラインを記録しておく変数<br>
      &nbsp;&nbsp;<em>float debug_x_yTop = -1, debug_x_yBottom = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の上下端も記録</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{//←スコープ{}で下記xLeftなどの変数名を{}の内側でリセットして、外側でかぶっても大丈夫なようにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yMiddle) || // 左中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) )  // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xLeft; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// std::fmodで小数点の余りを計算 めり込みすぎの余り = std::fmod(xLeft, CellSize)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallRight = xLeft + CellSize - (float)std::fmod(xLeft, CellSize); // 壁の右端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallRight - hitOffsetLeft; // 左端を壁の右端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓右端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) || // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yMiddle) || // 右中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xRight; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallLeft = xRight - (float)std::fmod(xRight, CellSize); // 壁の左端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallLeft + hitOffsetRight - imgSizeX; // 右端を壁の左端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{//←スコープ{}で下記xLeftなどの変数名を{}の内側でリセットして、外側でかぶっても大丈夫なようにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yTop) || // 中上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) )  // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yTop; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallBottom = yTop + CellSize - (float)std::fmod(yTop, CellSize); // 壁の下側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallBottom - hitOffsetTop; // 頭を壁の下端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) || // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yBottom) || // 中下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yBottom; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallTop = yBottom - (float)std::fmod(yBottom, CellSize); // 壁の上側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallTop + hitOffsetBottom - imgSizeX; // 足元を壁の上端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 床に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ブロックに当たってないからfalseにして落下するように<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Width * CellSize - Screen::Width &lt;= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x <em>- camera_x</em> + imgSizeX / 2, y + imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x <em>- camera_x</em> + imgSizeX / 2, y + imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x <em>- camera_x</em> + imgSizeX / 2, y + imgSizeY / 2, 1.0f, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x <em>- camera_x</em> + imgSizeX / 2, y + imgSizeY / 2, 1.0f, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2; // DrawRotaGraphF関数は画像の真ん中が起点なので1/2ずらした位置計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 地形マップを[ 行のfor文×列のfor文 ]の2重ループで描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0, ySize = mapData.size(); cellY &lt; ySize; ++cellY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0, xSize = mapData[cellY].size(); cellX &lt; xSize; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[cellY][cellX]; // [行][列] の位置のcsvの地形番号(チップ番号)を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id < 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップチップを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x<em> - camera_x</em> + rotaShiftX, chip_y + rotaShiftY, 1.0f, 0.0f, mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ]用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawString(chip_x<em> - camera_x</em>, chip_y, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たり判定の四隅を赤枠で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawBox(getLeft(x)<em> - camera_x</em>, getTop(y), getRight(x)<em> - camera_x</em>, getBottom(y), GetColor(255, 0, 0), FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] キャラ原点(x,y)を緑丸で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawCircle(x<em> - camera_x</em>, y, 2, GetColor(0, 255, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たった際の行き過ぎの めりこみ座標(debug_x,debug_y) を青線で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_x != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(debug_x<em> - camera_x</em>, <em>debug_x_yTop</em>, debug_x<em> - camera_x</em>, <em>debug_x_yBottom</em>, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_y != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(<em>-camera_x</em>, debug_y, Screen::Width<em> - camera_x</em>, debug_y, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょうか、キャラが右端に行こうとすると画面がスクロールするようになりましたか？<br>
    <br>
    今回のプログラムは一番の昔のマリオ形式のように地形が横方向(x方向)のみにスクロールするように限定しました。<br>
    つぎは地形をタイルエディタで書き足して、縦方向(y方向)にもスクロールするように改造してみましょう。<br>
    <br>
    <br>
    <br>
    <br>
    <p>さてつぎは【キャラの<b>y座標からスクリーンの高さの1/2を引いたぶん(camera_y)</b>だけ背後の<b>地形を描く起点をずらす</b>サンプル】で地形のスクロールに挑戦しましょう。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      #include &lt;vector&gt;&nbsp;// csvを2次元vector配列に格納<br>
      #include &lt;string&gt;&nbsp;// 文字列std::stringに必要<br>
      #include &lt;fstream&gt;&nbsp;// ファイル読み出しstd::ifstreamに必要<br>
      #include &lt;sstream&gt;&nbsp;// 文字列ストリームに必要 ss &gt;&gt; num;で文字列から数字に変換できる<br>
      #include &lt;unordered_map&gt;&nbsp;// std::unordered_map 高速辞書配列に必要(チップ番号から壁などを表すビットへ変換する辞書)<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4<br>
      &nbsp;&nbsp;int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;int mapChips[64]; // マップのチップのグリッドの分割数に応じて8×8 = 64など配列で確保<br>
      &nbsp;&nbsp;LoadDivGraph("Map/mapchip.png", 64, 8, 8, CellSize, CellSize, mapChips); // マップのチップのサイズは32×32(=CellSize)<br>
      &nbsp;&nbsp;assert(mapChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; mapData;// タイルマップデータ<br>
      &nbsp;&nbsp;std::ifstream ifs_csv_file("Map/stage.csv"); // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int Width = 0, Height = 0; // マップデータの横(Width) 縦(Height)のマスの数<br>
      &nbsp;&nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp;std::string line; // 1行単位ごとにcsvファイルから文字列をstd::getlineで読み込んで受け取る<br>
      &nbsp;&nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; valuelist; // 1行ぶんの数字リスト配列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::istringstream linestream( line ); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::string comma_part; // カンマで分割された文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int widthCount = 0; // カンマで区切られた行の数字の数(各行の幅)をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (std::getline(linestream, comma_part, { ',' })) // 1行をgetlineでカンマで区切って列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istringstream ss( comma_part ); // カンマで区切られた文字をssを通して&gt;&gt;で数字に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行の数字の数がMAX記録を更新するかチェック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (widthCount &gt; MaxWidth)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxWidth = widthCount; // 暫定Maxの列の幅を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行ぶんの数字の配列をとりまとめてmapDataに1行ずつ追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (valuelist.size() != 0) // 配列に数字が1つでもあるなら.size() != 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData.emplace_back(valuelist); // mapDataに1行ずつ数字配列valuelistを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;++Height; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;Width = MaxWidth; // マップの幅Widthは一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp;// ↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp;assert(Width &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;assert(Height &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float x = 200, y = Screen::Height - 100; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int hitOffsetLeft = 2; // 当たり判定の左端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetRight = 2; // 当たり判定の右端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetTop = 1; // 当たり判定の上端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetBottom = 0; // 当たり判定の下端のオフセット<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 当たり判定のはしっこを計算するための一時関数<br>
      &nbsp;&nbsp;auto getLeft  = [&amp;hitOffsetLeft](float worldX) { return worldX + hitOffsetLeft; };<br>
      &nbsp;&nbsp;auto getTop   = [&amp;hitOffsetTop](float worldY) { return worldY + hitOffsetTop; };<br>
      &nbsp;&nbsp;auto getRight  = [&amp;hitOffsetRight, &amp;imgSizeX](float worldX) { return worldX + imgSizeX - hitOffsetRight; };<br>
      &nbsp;&nbsp;auto getBottom = [&amp;hitOffsetBottom, &imgSizeY](float worldY) { return worldY + imgSizeY - hitOffsetBottom; };<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;enum BlockBit // ブロックの特性を32桁のビットで表現<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None = 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Wall   = 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, unsigned int&gt; blockBits = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{-1,BlockBit::None},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 0,BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 2,BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 3,BlockBit::Wall},<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 指定された座標(worldX,worldY)の地形が 壁 や ダメージブロックかなどをチェックする一時関数<br>
      &nbsp;&nbsp;auto checkID = [&amp;blockBits, &amp;CellSize](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain, float worldX, float worldY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int terrainID = -1; // 指定された座標の地形のID<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (worldX &lt; 0 || worldY &lt; 0) return false; // 負の座標が指定された場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = (int)(worldX / CellSize), mapY = (int)(worldY / CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 二次元配列の範囲内か判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapY &lt; terrain.size() &amp;&amp; mapX &lt; terrain[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terrainID = terrain[mapY][mapX]; // 二次元配列から地形IDを取り出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (checkBit &amp; blockBits[terrainID]) != 0; // ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Width * CellSize - Screen::Width &lt;= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;<em>float camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float debug_x = -1, debug_y = -1; // [デバッグ] めり込みすぎのラインを記録しておく変数<br>
      &nbsp;&nbsp;float debug_x_yTop = -1, debug_x_yBottom = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の上下端も記録<br>
      &nbsp;&nbsp;<em>float debug_y_xLeft = -1, debug_y_xRight = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の左右端も記録</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{//←スコープ{}で下記xLeftなどの変数名を{}の内側でリセットして、外側でかぶっても大丈夫なようにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yMiddle) || // 左中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) )  // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xLeft; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// std::fmodで小数点の余りを計算 めり込みすぎの余り = std::fmod(xLeft, CellSize)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallRight = xLeft + CellSize - (float)std::fmod(xLeft, CellSize); // 壁の右端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallRight - hitOffsetLeft; // 左端を壁の右端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓右端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) || // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yMiddle) || // 右中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xRight; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallLeft = xRight - (float)std::fmod(xRight, CellSize); // 壁の左端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallLeft + hitOffsetRight - imgSizeX; // 右端を壁の左端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{//←スコープ{}で下記xLeftなどの変数名を{}の内側でリセットして、外側でかぶっても大丈夫なようにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yTop) || // 中上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) )  // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yTop; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallBottom = yTop + CellSize - (float)std::fmod(yTop, CellSize); // 壁の下側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallBottom - hitOffsetTop; // 頭を壁の下端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) || // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yBottom) || // 中下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yBottom; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallTop = yBottom - (float)std::fmod(yBottom, CellSize); // 壁の上側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallTop + hitOffsetBottom - imgSizeX; // 足元を壁の上端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 床に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ブロックに当たってないからfalseにして落下するように<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Width * CellSize - Screen::Width &lt;= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y <em>- camera_y</em> + imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y <em>- camera_y</em> + imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y <em>- camera_y</em> + imgSizeY / 2, 1.0f, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y <em>- camera_y</em> + imgSizeY / 2, 1.0f, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2; // DrawRotaGraphF関数は画像の真ん中が起点なので1/2ずらした位置計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 地形マップを[ 行のfor文×列のfor文 ]の2重ループで描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0, ySize = mapData.size(); cellY &lt; ySize; ++cellY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0, xSize = mapData[cellY].size(); cellX &lt; xSize; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[cellY][cellX]; // [行][列] の位置のcsvの地形番号(チップ番号)を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id < 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップチップを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x - camera_x + rotaShiftX, chip_y <em>- camera_y</em> + rotaShiftY, 1.0f, 0.0f, mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ]用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawString(chip_x - camera_x, chip_y <em>- camera_y</em>, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たり判定の四隅を赤枠で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawBox(getLeft(x) - camera_x, getTop(y)<em> - camera_y</em>, getRight(x) - camera_x, getBottom(y)<em> - camera_y</em>, GetColor(255, 0, 0), FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] キャラ原点(x,y)を緑丸で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawCircle(x - camera_x, y<em> - camera_y</em>, 2, GetColor(0, 255, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たった際の行き過ぎの めりこみ座標(debug_x,debug_y) を青線で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_x != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(debug_x - camera_x, debug_x_yTop<em>- camera_y</em>, debug_x - camera_x, debug_x_yBottom<em> - camera_y</em>, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_y != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(<em>debug_y_xLeft - camera_x</em>, debug_y<em> - camera_y</em>, <em>debug_y_xRight</em> - camera_x, debug_y<em> - camera_y</em>, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょう、キャラが上下移動したら上下方向にスクロールするようになりましたか？<br>
    スクロールしない人は、地形ファイルが横長で、上下縦長の方向に地形がないのでタイルマップエディタで地形を書き足す必要がありそうです。<br>
    スクリーンのサイズが<b>960×540ならば、タイル32×17個=544と比べると、タイルは少なくとも18以上の縦方向のタイルの数があれば</b>スクロールするようになるはずです。<br>
    <br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0014" class="mozTocH1"></a>トゲトゲに当たったらキャラがくるくる回ってから下に落ちて最初のスタート位置に戻されるプログラム</h1>
<br>
    <br>
    <br>
    <p>さてつぎは【トゲトゲに当たると<b>isDeadフラグをtrue</b>にしてキャラをくるくる回しながら、ミス位置で少し浮かせて<b>(yAnim0 ～ yAnim1)</b>下に落ちて<b>(yAnim1 ～ yAnim2)</b>最初のスタート位置に戻るサンプル】でプレイヤーのミスの処理を実現しましょう。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      #include &lt;vector&gt;&nbsp;// csvを2次元vector配列に格納<br>
      #include &lt;string&gt;&nbsp;// 文字列std::stringに必要<br>
      #include &lt;fstream&gt;&nbsp;// ファイル読み出しstd::ifstreamに必要<br>
      #include &lt;sstream&gt;&nbsp;// 文字列ストリームに必要 ss &gt;&gt; num;で文字列から数字に変換できる<br>
      #include &lt;unordered_map&gt;&nbsp;// std::unordered_map 高速辞書配列に必要(チップ番号から壁などを表すビットへ変換する辞書)<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4<br>
      &nbsp;&nbsp;int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;int mapChips[64]; // マップのチップのグリッドの分割数に応じて8×8 = 64など配列で確保<br>
      &nbsp;&nbsp;LoadDivGraph("Map/mapchip.png", 64, 8, 8, CellSize, CellSize, mapChips); // マップのチップのサイズは32×32(=CellSize)<br>
      &nbsp;&nbsp;assert(mapChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; mapData;// タイルマップデータ<br>
      &nbsp;&nbsp;std::ifstream ifs_csv_file("Map/stage.csv"); // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int Width = 0, Height = 0; // マップデータの横(Width) 縦(Height)のマスの数<br>
      &nbsp;&nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp;std::string line; // 1行単位ごとにcsvファイルから文字列をstd::getlineで読み込んで受け取る<br>
      &nbsp;&nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; valuelist; // 1行ぶんの数字リスト配列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::istringstream linestream( line ); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::string comma_part; // カンマで分割された文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int widthCount = 0; // カンマで区切られた行の数字の数(各行の幅)をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (std::getline(linestream, comma_part, { ',' })) // 1行をgetlineでカンマで区切って列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istringstream ss( comma_part ); // カンマで区切られた文字をssを通して&gt;&gt;で数字に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行の数字の数がMAX記録を更新するかチェック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (widthCount &gt; MaxWidth)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxWidth = widthCount; // 暫定Maxの列の幅を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行ぶんの数字の配列をとりまとめてmapDataに1行ずつ追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (valuelist.size() != 0) // 配列に数字が1つでもあるなら.size() != 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData.emplace_back(valuelist); // mapDataに1行ずつ数字配列valuelistを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;++Height; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;Width = MaxWidth; // マップの幅Widthは一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp;// ↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp;assert(Width &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;assert(Height &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>float xStart = 200, yStart = Screen::Height - 100; // キャラの初期スタート(ミス後の再開位置)</em><br>
      &nbsp;&nbsp;float x = <em>xStart</em>, y = <em>yStart</em>; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>bool isDead = false; // キャラがやられたかどうか<br>
      &nbsp;&nbsp;int deadAnimeTime = 0; // やられたときのアニメ時間</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int hitOffsetLeft = 2; // 当たり判定の左端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetRight = 2; // 当たり判定の右端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetTop = 1; // 当たり判定の上端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetBottom = 0; // 当たり判定の下端のオフセット<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 当たり判定のはしっこを計算するための一時関数<br>
      &nbsp;&nbsp;auto getLeft  = [&amp;hitOffsetLeft](float worldX) { return worldX + hitOffsetLeft; };<br>
      &nbsp;&nbsp;auto getTop   = [&amp;hitOffsetTop](float worldY) { return worldY + hitOffsetTop; };<br>
      &nbsp;&nbsp;auto getRight  = [&amp;hitOffsetRight, &amp;imgSizeX](float worldX) { return worldX + imgSizeX - hitOffsetRight; };<br>
      &nbsp;&nbsp;auto getBottom = [&amp;hitOffsetBottom, &imgSizeY](float worldY) { return worldY + imgSizeY - hitOffsetBottom; };<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;enum BlockBit // ブロックの特性を32桁のビットで表現<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None = 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Wall &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>Damage = 0b0000'0000'0000'0000'0000'0000'0000'0010,</em><br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, unsigned int&gt; blockBits = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{-1,BlockBit::None},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 0,BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>{ 1,BlockBit::Damage},</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 2,BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 3,BlockBit::Wall},<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 指定された座標(worldX,worldY)の地形が 壁 や ダメージブロックかなどをチェックする一時関数<br>
      &nbsp;&nbsp;auto checkID = [&amp;blockBits, &amp;CellSize](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain, float worldX, float worldY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int terrainID = -1; // 指定された座標の地形のID<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (worldX &lt; 0 || worldY &lt; 0) return false; // 負の座標が指定された場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = (int)(worldX / CellSize), mapY = (int)(worldY / CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 二次元配列の範囲内か判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapY &lt; terrain.size() &amp;&amp; mapX &lt; terrain[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terrainID = terrain[mapY][mapX]; // 二次元配列から地形IDを取り出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (checkBit &amp; blockBits[terrainID]) != 0; // ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// [x方向左右]地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheckX = [&amp;checkID](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yTop))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yMiddle))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; // 左中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; // 左下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 右端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yTop))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yMiddle))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; // 右中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// [y方向上下]地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheckY = [&amp;checkID](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yTop))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xMiddle, yTop))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; // 中上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yTop))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; // 左下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xMiddle, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; // 中下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// 地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheck = [&amp;hitcheckX, &amp;hitcheckY](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return hitcheckX(checkBit,terrain,xLeft,xMiddle,xRight,yTop,yMiddle,yBottom)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| hitcheckY(checkBit,terrain,xLeft,xMiddle,xRight,yTop,yMiddle,yBottom);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Width * CellSize - Screen::Width &lt;= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;float camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float debug_x = -1, debug_y = -1; // [デバッグ] めり込みすぎのラインを記録しておく変数<br>
      &nbsp;&nbsp;float debug_x_yTop = -1, debug_x_yBottom = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の上下端も記録<br>
      &nbsp;&nbsp;float debug_y_xLeft = -1, debug_y_xRight = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の左右端も記録<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (!isDead) // やられたときは移動を停止</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;&nbsp;</em>x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (!isDead) // やられたときは当たり判定も停止</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<u>//←スコープ{}で下記xLeftなどの変数名を{}の内側でリセットして、外側でかぶっても大丈夫なようにする</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>if(hitcheck(BlockBit::Damage, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // やられたフラグをtrueに</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yMiddle) || // 左中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) )  // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xLeft; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// std::fmodで小数点の余りを計算 めり込みすぎの余り = std::fmod(xLeft, CellSize)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallRight = xLeft + CellSize - (float)std::fmod(xLeft, CellSize); // 壁の右端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallRight - hitOffsetLeft; // 左端を壁の右端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓右端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) || // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yMiddle) || // 右中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xRight; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallLeft = xRight - (float)std::fmod(xRight, CellSize); // 壁の左端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallLeft + hitOffsetRight - imgSizeX; // 右端を壁の左端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (!isDead) // やられたときは移動を停止</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;&nbsp;</em>y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (!isDead) // やられたときは当たり判定も停止</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<u>//←スコープ{}で下記xLeftなどの変数名を{}の内側でリセットして、外側でかぶっても大丈夫なようにする</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>if (hitcheck(BlockBit::Damage, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // やられたフラグをtrueに</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yTop) || // 中上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) )  // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yTop; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallBottom = yTop + CellSize - (float)std::fmod(yTop, CellSize); // 壁の下側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallBottom - hitOffsetTop; // 頭を壁の下端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) || // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yBottom) || // 中下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yBottom; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallTop = yBottom - (float)std::fmod(yBottom, CellSize); // 壁の上側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallTop + hitOffsetBottom - imgSizeX; // 足元を壁の上端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 床に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ブロックに当たってないからfalseにして落下するように<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Width * CellSize - Screen::Width &lt;= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (isDead) // やられたときの描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiss = y - camera_y + imgSizeY / 2; // ミスったy起点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim0 = yMiss; // アニメy位置0 始まりのy位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim1 = yMiss - 10; // アニメy位置1 アニメの途中少し上方向に 10 浮く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim2 = Screen::Height + 32; // アニメy位置2 最終y位置 画面の高さ+32で画面外へ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yDeadAnim; // やられた際にはyの位置をアニメさせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 直線的な比例アニメの式(t=時刻)  位置1×(終時刻 - t) / アニメの長さ  +  位置2×(t - 始時刻) / アニメの長さ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (deadAnimeTime &lt; 40) // やられアニメが始まって40フレーム目までは yAnim0 ～ yAnim1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim0 * (40 - deadAnimeTime) / 40 + yAnim1 * (deadAnimeTime - 0) / 40;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (deadAnimeTime &lt; 60) // やられアニメが始まって60フレーム目までは yAnim1 ～ yAnim2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim1 * (60 - deadAnimeTime) / 20 + yAnim2 * (deadAnimeTime - 40) / 20;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim2; // アニメ終了 到着 y位置をセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deadAnimeTime = 0; // 次にやられたときのアニメのため0リセットしておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 再開位置からゲーム再開(各数値もリセット)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = xStart, y = yStart, vx = 0, vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false, isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int deadAnimeStep = deadAnimeTime / 3; // 3で割って[チップのパラパラの]アニメの速度は弱める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int chipAnime = deadAnimeStep % 3; // % 3で余りを求めれば余りはチップのパラパラ番号は0～2の間に収まる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, yDeadAnim, 1.0f, 10.0f * deadAnimeStep / 360.0f * 2 * DX_PI, playerChips[chipAnime], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++deadAnimeTime; // アニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;&nbsp;</em>if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;&nbsp;</em>&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;&nbsp;</em>else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;&nbsp;</em>&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;&nbsp;</em>else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;&nbsp;</em>&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;&nbsp;</em>else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;&nbsp;</em>&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      <em>&nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2; // DrawRotaGraphF関数は画像の真ん中が起点なので1/2ずらした位置計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 地形マップを[ 行のfor文×列のfor文 ]の2重ループで描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0, ySize = mapData.size(); cellY &lt; ySize; ++cellY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0, xSize = mapData[cellY].size(); cellX &lt; xSize; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[cellY][cellX]; // [行][列] の位置のcsvの地形番号(チップ番号)を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id < 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップチップを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x - camera_x + rotaShiftX, chip_y - camera_y + rotaShiftY, 1.0f, 0.0f, mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ]用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawString(chip_x - camera_x, chip_y - camera_y, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たり判定の四隅を赤枠で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawBox(getLeft(x) - camera_x, getTop(y) - camera_y, getRight(x) - camera_x, getBottom(y) - camera_y, GetColor(255, 0, 0), FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] キャラ原点(x,y)を緑丸で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawCircle(x - camera_x, y - camera_y, 2, GetColor(0, 255, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たった際の行き過ぎの めりこみ座標(debug_x,debug_y) を青線で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_x != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(debug_x - camera_x, debug_x_yTop - camera_y, debug_x - camera_x, debug_x_yBottom - camera_y, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_y != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(debug_y_xLeft - camera_x, debug_y - camera_y, debug_y_xRight - camera_x, debug_y - camera_y, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    いかがでしょう、トゲトゲにあたったらキャラがアニメして、スタート地点に戻るようになりましたか？<br>
    <br>
    今回のポイントは位置を直線的に移動させるアニメの式です。<br>
    yAnim0, yAnim1, yAnim2 など 3つのyの位置があったとすると<br>
    <br>
    float yDeadAnim; // やられた際にはyの位置をアニメさせる<br>
    // 直線的な比例アニメの式(t=時刻)  位置1×(終時刻 - t) / アニメの長さ  +  位置2×(t - 始時刻) / アニメの長さ<br>
    if (deadAnimeTime < 40) // やられアニメが始まって40フレーム目までは yAnim0 ～ yAnim1<br>
    &nbsp;&nbsp;yDeadAnim = <em>yAnim0 * (40 - deadAnimeTime) / 40 + yAnim1 * (deadAnimeTime - 0) / 40;</em><br>
    else if (deadAnimeTime < 60) // やられアニメが始まって60フレーム目までは yAnim1 ～ yAnim2<br>
    &nbsp;&nbsp;yDeadAnim = <em>yAnim1 * (60 - deadAnimeTime) / 20 + yAnim2 * (deadAnimeTime - 40) / 20;</em><br><br>
    <br>
    <br>
    式をさらに単純化すると、tが時刻0.0～1.0まで変わるとすると<br>
    &nbsp;&nbsp;<b>y = y0 × (1.0 - t) + y1 × t</b><br>
    この形の式にt=0.0をいれたときはy = y0 × (1.0 - 0.0) + y1 × 0.0 = y0(開始位置)<br>
    この形の式にt=0.5をいれたときはy = y0 × (1.0 - 0.5) + y1 × 0.5 = 0.5×y0 + 0.5×y1(中間位置)<br>
    この形の式にt=1.0をいれたときはy = y0 × (1.0 - 1.0) + y1 × 1.0 = y1(到着位置)<br>
    <br>
    つまり<b>t = 0.0～1.0 に変わると y が y0 から y1 までアニメーションする式が出来上がり</b>ます。<br>
    そう、簡単に言うと実は<b>y0 に 0～1 を、y1 に 1～0 を「0と1が入れ替わるように つじつま を合わせているだけの式」</b>です。<br>
    このアニメ式を x にもペアで使えば自由に直線的にある地点からある地点まで画像をアニメで動かせるようになります。<br>
    <br>
    <br>
    <b>[練習問題]</b><br>
    キャラのやられたときの<b>「残念な気持ちになる効果音」</b>を探してSEフォルダに保存して、<b>isDead = true; にしている瞬間に連動して</b>効果音も鳴らしてみましょう。<br>
    <br>
    <br>
    <br>
    <br>
<br>
    <h1><a id="mozTocId0015" class="mozTocH1"></a>ブロックを下から叩いたらy位置をアニメさせてバウンスするプログラム</h1>
<br>
    <br>
    <br>
    <p>さてつぎは【ブロックに<b>どの方向からめりこんだか</b>を得られるようにして<b>叩かれたブロックのマス目番号XYをキーに高速辞書でアニメ時間を管理</b>して叩かれたブロックをバウンスするサンプル】でブロックに動きをつけましょう。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      #include &lt;vector&gt;&nbsp;// csvを2次元vector配列に格納<br>
      #include &lt;string&gt;&nbsp;// 文字列std::stringに必要<br>
      #include &lt;fstream&gt;&nbsp;// ファイル読み出しstd::ifstreamに必要<br>
      #include &lt;sstream&gt;&nbsp;// 文字列ストリームに必要 ss &gt;&gt; num;で文字列から数字に変換できる<br>
      #include &lt;unordered_map&gt;&nbsp;// std::unordered_map 高速辞書配列に必要(チップ番号から壁などを表すビットへ変換する辞書)<br>
      <em>#include &lt;utility&gt;&nbsp;// std::pair(データのペア型)を使うのに必要<br>
      // [ペアを高速辞書のキーにするためハッシュ関数が必要] https://qiita.com/hamamu/items/4d081751b69aa3bb3557<br>
      template&lt;class TypeT&gt; size_t HashCombine(const size_t seed, const TypeT&amp; value)<br>
      {<br>
      &nbsp;&nbsp;return seed ^ (std::hash&lt;TypeT&gt;()(value) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2));<br>
      }<br>
      <br>
      // pair型に()をつけたときに呼び出される処理をoperator()で定義してreturnでハッシュ関数を返す<br>
      template&lt;class TypeT, class TypeS&gt;<br>
      struct std::hash&lt;std::pair&lt;TypeT, TypeS&gt;&gt;<br>
      {<br>
      &nbsp;&nbsp;size_t operator() (const std::pair&lt;TypeT, TypeS&gt;&amp; keyval) const noexcept<br>
      &nbsp;&nbsp;{ &nbsp; // returnでハッシュ関数を返すことで高速辞書のキーとして認め許されるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return HashCombine(std::hash&lt;TypeT&gt;()(keyval.first), keyval.second);<br>
      &nbsp;&nbsp;}<br>
      };</em><br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4<br>
      &nbsp;&nbsp;int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;int mapChips[64]; // マップのチップのグリッドの分割数に応じて8×8 = 64など配列で確保<br>
      &nbsp;&nbsp;LoadDivGraph("Map/mapchip.png", 64, 8, 8, CellSize, CellSize, mapChips); // マップのチップのサイズは32×32(=CellSize)<br>
      &nbsp;&nbsp;assert(mapChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; mapData;// タイルマップデータ<br>
      &nbsp;&nbsp;std::ifstream ifs_csv_file("Map/stage.csv"); // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int Width = 0, Height = 0; // マップデータの横(Width) 縦(Height)のマスの数<br>
      &nbsp;&nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp;std::string line; // 1行単位ごとにcsvファイルから文字列をstd::getlineで読み込んで受け取る<br>
      &nbsp;&nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; valuelist; // 1行ぶんの数字リスト配列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::istringstream linestream( line ); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::string comma_part; // カンマで分割された文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int widthCount = 0; // カンマで区切られた行の数字の数(各行の幅)をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (std::getline(linestream, comma_part, { ',' })) // 1行をgetlineでカンマで区切って列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istringstream ss( comma_part ); // カンマで区切られた文字をssを通して&gt;&gt;で数字に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行の数字の数がMAX記録を更新するかチェック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (widthCount &gt; MaxWidth)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxWidth = widthCount; // 暫定Maxの列の幅を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行ぶんの数字の配列をとりまとめてmapDataに1行ずつ追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (valuelist.size() != 0) // 配列に数字が1つでもあるなら.size() != 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData.emplace_back(valuelist); // mapDataに1行ずつ数字配列valuelistを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;++Height; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;Width = MaxWidth; // マップの幅Widthは一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp;// ↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp;assert(Width &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;assert(Height &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float xStart = 200, yStart = Screen::Height - 100; // キャラの初期スタート(ミス後の再開位置)<br>
      &nbsp;&nbsp;float x = xStart, y = yStart; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum <em>class </em>Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;bool isDead = false; // キャラがやられたかどうか<br>
      &nbsp;&nbsp;int deadAnimeTime = 0; // やられたときのアニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int hitOffsetLeft = 2; // 当たり判定の左端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetRight = 2; // 当たり判定の右端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetTop = 1; // 当たり判定の上端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetBottom = 0; // 当たり判定の下端のオフセット<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 当たり判定のはしっこを計算するための一時関数<br>
      &nbsp;&nbsp;auto getLeft  = [&amp;hitOffsetLeft](float worldX) { return worldX + hitOffsetLeft; };<br>
      &nbsp;&nbsp;auto getTop   = [&amp;hitOffsetTop](float worldY) { return worldY + hitOffsetTop; };<br>
      &nbsp;&nbsp;auto getRight  = [&amp;hitOffsetRight, &amp;imgSizeX](float worldX) { return worldX + imgSizeX - hitOffsetRight; };<br>
      &nbsp;&nbsp;auto getBottom = [&amp;hitOffsetBottom, &imgSizeY](float worldY) { return worldY + imgSizeY - hitOffsetBottom; };<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;enum <em>class </em>BlockBit // ブロックの特性を32桁のビットで表現<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None = 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Wall &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Damage = 0b0000'0000'0000'0000'0000'0000'0000'0010,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>Bounce = 0b0000'0000'0000'0000'0000'0000'0000'0100, // 叩くと弾むブロック</em><br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, unsigned int&gt; blockBits = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{-1,<em>(int)</em>BlockBit::None},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 0,<em>(int)</em>BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 1,<em>(int)</em>BlockBit::Damage},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 2,<em>(int)</em>BlockBit::Wall<em> | (int)BlockBit::Bounce</em>},<em> // 壁 | はずむ (|ビット論理和)</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 3,<em>(int)</em>BlockBit::Wall<em> | (int)BlockBit::Bounce</em>},<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// ブロックをバウンドさせるための 高速辞書&lt;ペア&lt;cellX,cellY&gt;, intアニメ時間&gt;<br>
      &nbsp;&nbsp;std::unordered_map&lt;std::pair&lt;int, int&gt;, int&gt; blockAnime;</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 指定された座標(worldX,worldY)の地形が 壁 や ダメージブロックかなどをチェックする一時関数<br>
      &nbsp;&nbsp;auto checkID = [&amp;blockBits, &amp;CellSize](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain, float worldX, float worldY<em>,<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int terrainID = -1; // 指定された座標の地形のID<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (worldX &lt; 0 || worldY &lt; 0) return false; // 負の座標が指定された場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = (int)(worldX / CellSize), mapY = (int)(worldY / CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 二次元配列の範囲内か判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapY &lt; terrain.size() &amp;&amp; mapX &lt; terrain[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terrainID = terrain[mapY][mapX]; // 二次元配列から地形IDを取り出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>bool isCheckBit = (((int)checkBit) &amp; blockBits[terrainID]) != 0; // ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isCheckBit &amp;&amp; pMapX != nullptr &amp;&amp; pMapY != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pMapX = mapX, *pMapY = mapY; // ブロックのcsvのセル番号をポインタに記録(nullptrの場合は記録しない)</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <em>isCheckBit</em>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>enum class HitPart // 当たった箇所を表すビット<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None &nbsp; &nbsp;= 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Left &nbsp; &nbsp;= 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Right &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0010,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Top &nbsp; &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0100,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Bottom &nbsp;= 0b0000'0000'0000'0000'0000'0000'0000'1000,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;XMiddle = 0b0000'0000'0000'0000'0000'0000'0001'0000,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;YMiddle = 0b0000'0000'0000'0000'0000'0000'0010'0000,<br>
      &nbsp;&nbsp;};</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [x方向左右]地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheckX = [&amp;checkID](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom<em>,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yTop<em>, pMapX, pMapY</em>))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <em>(int)HitPart::Left | (int)HitPart::Top</em>; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yMiddle<em>, pMapX, pMapY</em>))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <em>(int)HitPart::Left | (int)HitPart::YMiddle</em>; // 左中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yBottom<em>, pMapX, pMapY</em>))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <em>(int)HitPart::Left | (int)HitPart::Bottom</em>; // 左下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 右端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yTop<em>, pMapX, pMapY</em>))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <em>(int)HitPart::Right | (int)HitPart::Top</em>; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yMiddle<em>, pMapX, pMapY</em>))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <em>(int)HitPart::Right | (int)HitPart::YMiddle</em>; // 右中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yBottom<em>, pMapX, pMapY</em>))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <em>(int)HitPart::Right | (int)HitPart::Bottom</em>; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <em>(int)HitPart::None</em>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [y方向上下]地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheckY = [&amp;checkID](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom<em>,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yTop<em>, pMapX, pMapY</em>))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <em>(int)HitPart::Left | (int)HitPart::Top</em>; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xMiddle, yTop<em>, pMapX, pMapY</em>))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <em>(int)HitPart::XMiddle | (int)HitPart::Top</em>; // 中上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yTop<em>, pMapX, pMapY</em>))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <em>(int)HitPart::Right | (int)HitPart::Top</em>; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yBottom<em>, pMapX, pMapY</em>))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <em>(int)HitPart::Left | (int)HitPart::Bottom</em>;  // 左下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xMiddle, yBottom<em>, pMapX, pMapY</em>))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <em>(int)HitPart::XMiddle | (int)HitPart::Bottom</em>; // 中下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yBottom<em>, pMapX, pMapY</em>))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <em>(int)HitPart::Right | (int)HitPart::Bottom</em>; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <em>(int)HitPart::None</em>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheck = [&amp;hitcheckX, &amp;hitcheckY](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom<em>,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr</em>)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return hitcheckX(checkBit,terrain,xLeft,xMiddle,xRight,yTop,yMiddle,yBottom<em>,pMapX,pMapY</em>)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| hitcheckY(checkBit,terrain,xLeft,xMiddle,xRight,yTop,yMiddle,yBottom<em>,pMapX,pMapY</em>);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Width * CellSize - Screen::Width &lt;= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;float camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float debug_x = -1, debug_y = -1; // [デバッグ] めり込みすぎのラインを記録しておく変数<br>
      &nbsp;&nbsp;float debug_x_yTop = -1, debug_x_yBottom = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の上下端も記録<br>
      &nbsp;&nbsp;float debug_y_xLeft = -1, debug_y_xRight = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の左右端も記録<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは移動を停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは当たり判定も停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(hitcheck(BlockBit::Damage, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // やられたフラグをtrueに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yMiddle) || // 左中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) )  // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xLeft; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// std::fmodで小数点の余りを計算 めり込みすぎの余り = std::fmod(xLeft, CellSize)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallRight = xLeft + CellSize - (float)std::fmod(xLeft, CellSize); // 壁の右端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallRight - hitOffsetLeft; // 左端を壁の右端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓右端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) || // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yMiddle) || // 右中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xRight; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallLeft = xRight - (float)std::fmod(xRight, CellSize); // 壁の左端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallLeft + hitOffsetRight - imgSizeX; // 右端を壁の左端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは移動を停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは当たり判定も停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (hitcheck(BlockBit::Damage, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // やられたフラグをtrueに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>int mapX = 0, mapY = 0; // ぶつかったらそのブロックのCSVのセルの行mapYと列mapXを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Bounce, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;int,int&gt; mapXY = std::make_pair(mapX, mapY); // ぶつかったブロックのセルの行mapYと列mapXのペア<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) == 0) // 辞書にキーがあるかcountで数えて未登録==0のとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime[mapXY] = 0; // ブロックのアニメ時間を辞書に登録(時間が辞書にあるものだけアニメが走る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yTop) || // 中上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) )  // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yTop; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallBottom = yTop + CellSize - (float)std::fmod(yTop, CellSize); // 壁の下側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallBottom - hitOffsetTop; // 頭を壁の下端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) || // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yBottom) || // 中下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yBottom; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallTop = yBottom - (float)std::fmod(yBottom, CellSize); // 壁の上側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallTop + hitOffsetBottom - imgSizeX; // 足元を壁の上端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 床に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ブロックに当たってないからfalseにして落下するように<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Width * CellSize - Screen::Width <= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isDead) // やられたときの描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiss = y - camera_y + imgSizeY / 2; // ミスったy起点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim0 = yMiss; // アニメy位置0 始まりのy位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim1 = yMiss - 10; // アニメy位置1 アニメの途中少し上方向に 10 浮く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim2 = Screen::Height + 32; // アニメy位置2 最終y位置 画面の高さ+32で画面外へ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yDeadAnim; // やられた際にはyの位置をアニメさせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 直線的な比例アニメの式(t=時刻)  位置1×(終時刻 - t) / アニメの長さ  +  位置2×(t - 始時刻) / アニメの長さ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (deadAnimeTime &lt; 40) // やられアニメが始まって40フレーム目までは yAnim0 ～ yAnim1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim0 * (40 - deadAnimeTime) / 40 + yAnim1 * (deadAnimeTime - 0) / 40;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (deadAnimeTime &lt; 60) // やられアニメが始まって60フレーム目までは yAnim1 ～ yAnim2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim1 * (60 - deadAnimeTime) / 20 + yAnim2 * (deadAnimeTime - 40) / 20;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim2; // アニメ終了 到着 y位置をセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deadAnimeTime = 0; // 次にやられたときのアニメのため0リセットしておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 再開位置からゲーム再開(各数値もリセット)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = xStart, y = yStart, vx = 0, vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false, isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int deadAnimeStep = deadAnimeTime / 3; // 3で割って[チップのパラパラの]アニメの速度は弱める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int chipAnime = deadAnimeStep % 3; // % 3で余りを求めれば余りはチップのパラパラ番号は0～2の間に収まる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, yDeadAnim, 1.0f, 10.0f * deadAnimeStep / 360.0f * 2 * DX_PI, playerChips[chipAnime], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++deadAnimeTime; // アニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2; // DrawRotaGraphF関数は画像の真ん中が起点なので1/2ずらした位置計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 地形マップを[ 行のfor文×列のfor文 ]の2重ループで描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0, ySize = mapData.size(); cellY &lt; ySize; ++cellY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0, xSize = mapData[cellY].size(); cellX &lt; xSize; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[cellY][cellX]; // [行][列] の位置のcsvの地形番号(チップ番号)を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id &lt; 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップチップを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>auto mapXY = std::make_pair(cellX, cellY);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) == 0)</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;&nbsp;</em>DrawRotaGraphF(chip_x - camera_x + rotaShiftX, chip_y - camera_y + rotaShiftY, 1.0f, 0.0f, mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>else if ((int)BlockBit::Bounce &amp; blockBits[id])<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yBase = chip_y - camera_y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim0 = yBase - 10, yAnim1 = yBase; // yAnim0 から yAnim1の位置までアニメする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int blockTime = blockAnime[mapXY];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim = yAnim0 * (15 - blockTime) / 15 + yAnim1 * blockTime / 15;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x - camera_x + rotaShiftX, yAnim + rotaShiftY, 1.0f, 0.0f, mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++blockAnime[mapXY]; // アニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockTime > 15) // アニメ終了時間を15フレーム目とするとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime.erase(mapXY); // 辞書からアニメをerase関数で取り除く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ]用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawString(chip_x - camera_x, chip_y - camera_y, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たり判定の四隅を赤枠で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawBox(getLeft(x) - camera_x, getTop(y) - camera_y, getRight(x) - camera_x, getBottom(y) - camera_y, GetColor(255, 0, 0), FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] キャラ原点(x,y)を緑丸で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawCircle(x - camera_x, y - camera_y, 2, GetColor(0, 255, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たった際の行き過ぎの めりこみ座標(debug_x,debug_y) を青線で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_x != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(debug_x - camera_x, debug_x_yTop - camera_y, debug_x - camera_x, debug_x_yBottom - camera_y, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_y != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(debug_y_xLeft - camera_x, debug_y - camera_y, debug_y_xRight - camera_x, debug_y - camera_y, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
    <br>
    <br>
    <br>
    いかがでしょう、下からブロックを叩いたらブロックが上に少しバウンスするようになりましたか？<br>
    <br>
    <br>
    注意点として、enumでは<b> { } の外でも名前をかぶらせることができない</b>ので、<br>
    その使いづらさを解消するために、<b>C++ではenumのかわりにenum class</b>があります。<br>
    例.&nbsp;&nbsp;enum ●● { Normal, Fire, Water.. }; と<b>一回Normalという名前を定義したあと、enum ▲▲ { Normal };</b>とすると<b>Normalがかぶってエラーになってしまいます</b>。<br>
    C++ではenum classを使ったほうが無難そうですね。<br>
    (ただし、(int)型にキャストで変換しながら使う)<br>
    <br>
    <br>
    もう1点のポイントはstd::unordered_map <b>高速辞書配列の辞書のキーとできるのは<br>
    int,float,char,short,long,std::stringなどデフォルトのよく使う型のみ</b>なので、<br>
    今回は<b>xとyの2つの数字のペアをキーとして使うため</b>に、<br>
    辞書にデータを突っ込む際にどの辞書のページ( = 辞書内配列の箱)に突っ込むかを決めている<b>ハッシュ関数を別途定義</b>しなければならないです。<br>
    <br>
    ハッシュ関数や暗号化という言葉を聞いたことがありますか？<br>
    <a href="https://ja.wikipedia.org/wiki/%E6%9A%97%E5%8F%B7%E5%AD%A6%E7%9A%84%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E9%96%A2%E6%95%B0">https://ja.wikipedia.org/wiki/暗号学的ハッシュ関数</a><br>
    暗号も ハッシュ関数も <b>共通の性質</b>として、<br>
    ある値(たとえばパスワード)に対して、<br>
    ある<b>計算式をかませると、1対1の対になる計算結果がでる性質</b>が必要です。<br>
    (暗号化するときに<b>2つ以上答えが出ちゃう数式だと使えない</b>ですものね)<br>
    1対1の計算結果なら色んな式がありえます。<br>
    (ある数字のパスワードが来たら2倍した数字で暗号化するとか..のバレバレ数式でも1対1の対にはなるわけで..)<br>
    どうせ暗号化するなら<b>できる限り解析されにくい数式がないか数学的に考えるのが暗号学</b>なわけですね。<br>
    そして暗号化するときに暗号化したものの桁数が<b>何桁におさまるかも重要</b>な式の決め方の観点です。<br>
    暗号化した際の桁数が多くなりすぎたり、桁数が不安定だと、暗号化されたデータをやり取りする際に不安定ですよね。<br>
    実際に現代社会で使われているSHA-256(NSA米国家安全保障局の考案した暗号学的ハッシュ関数)も<b>256ビット(32バイト)の値(=ハッシュ値)を出力</b>します<br>
    <br>
    さて、なんか全然辞書と暗号がつながらないじゃんと思われたでしょうが、<br>
    辞書のデータをどのページに書き込むか決めるときにstd::mapのように<b>キーが順番にならんでいるなら「あ」ならこのページに書き込むと確定</b>できますが、<br>
    <b>キーを順番に並べない高速辞書std::unordered_mapの場合</b>は<b>ハッシュ関数で出てきた値でデータを入れる箱の位置を決めて放り込む</b>イメージです。<br>
    (「あみだくじで決めるようなノリ」で辞書のどのページにデータを放り込むか決めるイメージで<b>あみだくじの代わりにハッシュ関数でピシッとデータを入れる箱の位置を決める感じ</b>)<br>
    雑に例えると、例えばたくさんロッカーがあってカバンを適当にハッシュ関数で決めたロッカーに投げ込めば、<br>
    いちいち順番が決まった<b>ロッカー番号を順に確かめながらカバンをしまう手間暇より高速にほぼ1発</b>で投げ込んでしまえますよね。<br>
    (ただ、<b>適当に投げ込んだ先に、すでにカバンが入っていた場合には再ハッシュ</b>などの工夫が必要になるぶんちょっと遅くなるので、<b>めったにかぶらないくらいの十分な格納ロッカーの数(量)も必要</b>です。<br>
    ロッカーがかぶりにくいような<b>うまく結果がばらける あみだ≒ハッシュルール数式 を使うこと(質)と十分なロッカーの数(量)</b>の観点で高速辞書格納が実現されてます)<br>
    <br>
    今回のコードではxとyのペアを高速辞書のキーにするために適度に結果がばらけると研究され信じられていそうな式<br>
    seed ^ (std::hash&lt;TypeT&gt;()(value) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2));<br>
    をHashCombine()関数として定義して使用しています。(16進数 0x9e3779b9やシフトなど難しい式ですが、使う側は意味を考える必要まではないです)<br>
    <br>
    そしてそのHashCombine関数を高速辞書std::unordered_map内部であみだ用途で使用させるためにoperator()呼び出しもセットで準備しています。<br>
    ( <b>std::pair&lt;int,int&gt; a;</b> に <b>a()など()をつけたとき</b>に呼び出される<b>operator()の定義</b> )<br>
    ( <b>std::unordered_map&lt;std::pair&lt;int,int&gt,int&gt; b;</b> で <b>b[a] = 4;など辞書にデータを登録する際に暗黙でa()が呼び出されデータがあみだ的に格納される</b> )<br>
    ハッシュのシード値やreturnされるハッシュ値は<b>int型ではなくsize_t型で受け</b>ています(<a href="https://jp-seemore.com/iot/23616/">size_tならば</a>32bitマシンなら=4バイト、64bitマシンなら=8バイトにビルドする環境で合わせてくれて安心)<br>
    <p class="source">(以上略)...<br>
      #include &lt;unordered_map&gt;&nbsp;// std::unordered_map 高速辞書配列に必要(チップ番号から壁などを表すビットへ変換する辞書)<br>
      <em>#include &lt;utility&gt;&nbsp;// std::pair(データのペア型)を使うのに必要<br>
      // [ペアを高速辞書のキーにするためハッシュ関数が必要] https://qiita.com/hamamu/items/4d081751b69aa3bb3557<br>
      template&lt;class TypeT&gt; size_t HashCombine(const size_t seed, const TypeT&amp; value)<br>
      {<br>
      &nbsp;&nbsp;return seed ^ (std::hash&lt;TypeT&gt;()(value) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2));<br>
      }<br>
      <br>
      // pair型に()をつけたときに呼び出される処理をoperator()で定義してreturnでハッシュ関数を返す<br>
      template&lt;class TypeT, class TypeS&gt;<br>
      struct std::hash&lt;std::pair&lt;TypeT, TypeS&gt;&gt;<br>
      {<br>
      &nbsp;&nbsp;size_t operator() (const std::pair&lt;TypeT, TypeS&gt;&amp; keyval) const noexcept<br>
      &nbsp;&nbsp;{ &nbsp; // ()をつけたときにreturnでハッシュ関数を返すようにすることで高速辞書のキーとして使えるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return HashCombine(std::hash&lt;TypeT&gt;()(keyval.first), keyval.second);<br>
      &nbsp;&nbsp;};<br>
      }</em><br>
    (以下略)...<br>
    </p>
      <br>
      以上のoperator()の定義があれば<br>
      std::pair&lt;int,int&gt; mapXY = std::make_pair(mapX, mapY); <br>
      のように XとYのペアmapXY を 高速辞書型blockAnime のキー にして<em>blockAnime[mapXY] = 0;</em> のように気軽に代入でデータを入れ込むことができるようになります。<br>
      <p class="source">(以上略)...<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>int mapX = 0, mapY = 0; // ぶつかったらそのブロックのCSVのセルの行mapYと列mapXを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Bounce, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;int,int&gt; mapXY = std::make_pair(mapX, mapY); // ぶつかったブロックのセルの行mapYと列mapXのペア<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) == 0) // 辞書にキーがあるかcountで数えて未登録==0のとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime[mapXY] = 0; // ブロックのアニメ時間を辞書に登録(時間が辞書にあるものだけアニメが走る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
    (以下略)...<br>
    </p>
      <br>
      辞書型のよいところは、<br>
      int data[] = { -1, -1, 2, -1, -1, -1, ....}; のようにデータを不必要な-1で埋めるようなことをせずとも、<br>
      変化があった箇所だけを 辞書[キー] = 2; のように登録できるので、<b>配列型と違って無駄なデータのデフォルト埋めが必要ない使い方ができること</b>です。<br>
      ブロックのうちアニメーションさせたいのは<b>「今」や「ついさっき」叩いた、一部のブロックだけでよい</b>ですものね。<br>
      たとえば、タイルのデータが 縦 × 横 で1万 × 1万 = 1億マスあったとしましょう。<br>
      2次元配列だと <b>たった1つのマス が 2 に 変化したことを表現するのに 9万9千999個 の無駄な デフォルトの-1 が必要</b>になりますよね。<br>
      辞書型で <b>変化のあったマスだけ の「XとYのペア」をキーにして 辞書[キー] = 2; を登録するなら 9万もの -1 は必要なくなります</b>。<br>
      <b>辞書型を使いこなせるだけで「プログラミングの機動力や柔軟性のアイデア」が格段に向上</b>します。<br>
      なぜなら、何かと何かを辞書型なら結び付けられるので、<br>
      宝箱の位置 → 中身のアイテム、宝箱の位置 → すでに開けたかどうか、などアイデア次第で何にだって応用できてしまいます。<br>
      使い方での注意点は if( 辞書.count(キー) == 0 ) の辞書に キーが未登録かどうかを毎度きちんと判定しないと<br>
      何も入っていない 辞書[キー] にアクセスした瞬間に「デフォルトで 勝手に0 が入っちゃう大問題」があります。<br>
      (x,y) = (10,5)のマス目に宝箱がないのに <br>
      if( 辞書[(10,5)] ) などの判定式で使うだけで、<b>宝箱がないマスなのに 辞書[(10,5)] = 0が勝手に入って 開いた宝箱が表示されちゃう</b>バグが起こりえます。<br>
      だから必ず予防策として if( 辞書.count(キー) == 0 ) や if( 辞書.count(キー) &gt; 0 ) などの判定とセットで使うと覚えましょう。<a href="https://minus9d.hatenablog.com/entry/20120607/1339073711">if(辞書.find(キー) != 辞書.end())でもよいが</a><br>
      <br>
      プログラマは ただ動くコードを書く のを目的に作業しているのではなく<br>
      <b>「イメージ通りのデータの構造を実現するためにコードを利用する」</b>ことができてきたときに、デジタル空間の創造主に近づけます。<br>
      プログラミングとは<b>「データの構造と流れをコードで積み上げる作業」</b>です。<br>
      マインクラフトでブロックを積み上げる代わりに、<br>
      いろんな構造をもった[変数]や[配列]を積み上げて、+や-などの演算子やif、for文でデータをつなぎ合わせているイメージです。<br>
      &nbsp;&nbsp;辞書[キー] = 2; <br>
      たった1行ですが「配列型と辞書型の違い」の知識があれば、9万データが数個のデータに減らせる魔法がたった1行に凝縮されていることが理解できます。<br>
      <b>std::から始まる色んなデータの構造や関数をきちんと勉強しておくことで、#include &lt; ●● &gt; してきてうまく組み合わせて応用できるようになる</b>わけです。<br>
      <br>
      <br>
      <br>
<br>
    <h1><a id="mozTocId0016" class="mozTocH1"></a>ブロックidを辞書で変化させて叩いたらidが3 → 2 → -1 に変化してブロックを壊せるプログラム</h1>
<br>
      <br>
      <br>
      <p>さてつぎは【ブロックidの<b>変化を辞書blockChangeで管理</b>して叩いたらidが3 → 2 → -1 に変化してブロックを壊せるサンプル】でブロックを壊せるようにしてみましょう。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      #include &lt;vector&gt;&nbsp;// csvを2次元vector配列に格納<br>
      #include &lt;string&gt;&nbsp;// 文字列std::stringに必要<br>
      #include &lt;fstream&gt;&nbsp;// ファイル読み出しstd::ifstreamに必要<br>
      #include &lt;sstream&gt;&nbsp;// 文字列ストリームに必要 ss &gt;&gt; num;で文字列から数字に変換できる<br>
      #include &lt;unordered_map&gt;&nbsp;// std::unordered_map 高速辞書配列に必要(チップ番号から壁などを表すビットへ変換する辞書)<br>
      #include &lt;utility&gt;&nbsp;// std::pair(データのペア型)を使うのに必要<br>
      // [ペアを高速辞書のキーにするためハッシュ関数が必要] https://qiita.com/hamamu/items/4d081751b69aa3bb3557<br>
      template&lt;class TypeT&gt; size_t HashCombine(const size_t seed, const TypeT&amp; value)<br>
      {<br>
      &nbsp;&nbsp;return seed ^ (std::hash&lt;TypeT&gt;()(value) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2));<br>
      }<br>
      <br>
      // pair型に()をつけたときに呼び出される処理をoperator()で定義してreturnでハッシュ関数を返す<br>
      template&lt;class TypeT, class TypeS&gt;<br>
      struct std::hash&lt;std::pair&lt;TypeT, TypeS&gt;&gt;<br>
      {<br>
      &nbsp;&nbsp;size_t operator() (const std::pair&lt;TypeT, TypeS&gt;&amp; keyval) const noexcept<br>
      &nbsp;&nbsp;{ &nbsp; // returnでハッシュ関数を返すことで高速辞書のキーとして認め許されるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return HashCombine(std::hash&lt;TypeT&gt;()(keyval.first), keyval.second);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4<br>
      &nbsp;&nbsp;int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;int mapChips[64]; // マップのチップのグリッドの分割数に応じて8×8 = 64など配列で確保<br>
      &nbsp;&nbsp;LoadDivGraph("Map/mapchip.png", 64, 8, 8, CellSize, CellSize, mapChips); // マップのチップのサイズは32×32(=CellSize)<br>
      &nbsp;&nbsp;assert(mapChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; mapData;// タイルマップデータ<br>
      &nbsp;&nbsp;std::ifstream ifs_csv_file("Map/stage.csv"); // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int Width = 0, Height = 0; // マップデータの横(Width) 縦(Height)のマスの数<br>
      &nbsp;&nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp;std::string line; // 1行単位ごとにcsvファイルから文字列をstd::getlineで読み込んで受け取る<br>
      &nbsp;&nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; valuelist; // 1行ぶんの数字リスト配列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::istringstream linestream( line ); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::string comma_part; // カンマで分割された文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int widthCount = 0; // カンマで区切られた行の数字の数(各行の幅)をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (std::getline(linestream, comma_part, { ',' })) // 1行をgetlineでカンマで区切って列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istringstream ss( comma_part ); // カンマで区切られた文字をssを通して&gt;&gt;で数字に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行の数字の数がMAX記録を更新するかチェック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (widthCount &gt; MaxWidth)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxWidth = widthCount; // 暫定Maxの列の幅を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行ぶんの数字の配列をとりまとめてmapDataに1行ずつ追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (valuelist.size() != 0) // 配列に数字が1つでもあるなら.size() != 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData.emplace_back(valuelist); // mapDataに1行ずつ数字配列valuelistを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;++Height; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;Width = MaxWidth; // マップの幅Widthは一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp;// ↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp;assert(Width &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;assert(Height &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float xStart = 200, yStart = Screen::Height - 100; // キャラの初期スタート(ミス後の再開位置)<br>
      &nbsp;&nbsp;float x = xStart, y = yStart; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum class Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;bool isDead = false; // キャラがやられたかどうか<br>
      &nbsp;&nbsp;int deadAnimeTime = 0; // やられたときのアニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int hitOffsetLeft = 2; // 当たり判定の左端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetRight = 2; // 当たり判定の右端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetTop = 1; // 当たり判定の上端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetBottom = 0; // 当たり判定の下端のオフセット<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 当たり判定のはしっこを計算するための一時関数<br>
      &nbsp;&nbsp;auto getLeft  = [&amp;hitOffsetLeft](float worldX) { return worldX + hitOffsetLeft; };<br>
      &nbsp;&nbsp;auto getTop   = [&amp;hitOffsetTop](float worldY) { return worldY + hitOffsetTop; };<br>
      &nbsp;&nbsp;auto getRight  = [&amp;hitOffsetRight, &amp;imgSizeX](float worldX) { return worldX + imgSizeX - hitOffsetRight; };<br>
      &nbsp;&nbsp;auto getBottom = [&amp;hitOffsetBottom, &imgSizeY](float worldY) { return worldY + imgSizeY - hitOffsetBottom; };<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;enum class BlockBit // ブロックの特性を32桁のビットで表現<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None = 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Wall &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Damage = 0b0000'0000'0000'0000'0000'0000'0000'0010,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Bounce = 0b0000'0000'0000'0000'0000'0000'0000'0100, // 叩くと弾むブロック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>Change = 0b0000'0000'0000'0000'0000'0000'0000'1000, // 叩くとブロックの種類が変わる</em><br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, unsigned int&gt; blockBits = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{-1,(int)BlockBit::None},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 0,(int)BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 1,(int)BlockBit::Damage},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 2,(int)BlockBit::Wall | (int)BlockBit::Bounce<em> | (int)BlockBit::Change</em>}, // 壁 | はずむ<em> | ブロック変化</em> (|ビット論理和)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 3,(int)BlockBit::Wall | (int)BlockBit::Bounce<em> | (int)BlockBit::Change</em>},<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ブロックをバウンドさせるための 高速辞書&lt;ペア&lt;cellX,cellY&gt;, intアニメ時間&gt;<br>
      &nbsp;&nbsp;std::unordered_map&lt;std::pair&lt;int, int&gt;, int&gt; blockAnime;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>std::unordered_map&lt;int, int&gt; blockChange = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{  2,  3 }, // 叩くと 2 → 3 にかわる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{  3, -1 }, // 叩くと 3 → -1 にかわる<br>
      &nbsp;&nbsp;};</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 指定された座標(worldX,worldY)の地形が 壁 や ダメージブロックかなどをチェックする一時関数<br>
      &nbsp;&nbsp;auto checkID = [&amp;blockBits, &amp;CellSize](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain, float worldX, float worldY,<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int terrainID = -1; // 指定された座標の地形のID<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (worldX &lt; 0 || worldY &lt; 0) return false; // 負の座標が指定された場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = (int)(worldX / CellSize), mapY = (int)(worldY / CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 二次元配列の範囲内か判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapY &lt; terrain.size() &amp;&amp; mapX &lt; terrain[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terrainID = terrain[mapY][mapX]; // 二次元配列から地形IDを取り出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool isCheckBit = (((int)checkBit) &amp; blockBits[terrainID]) != 0; // ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isCheckBit &amp;&amp; pMapX != nullptr &amp;&amp; pMapY != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pMapX = mapX, *pMapY = mapY; // ブロックのcsvのセル番号をポインタに記録(nullptrの場合は記録しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return isCheckBit;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;enum class HitPart // 当たった箇所を表すビット<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None &nbsp; &nbsp;= 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Left &nbsp; &nbsp;= 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Right &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0010,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Top &nbsp; &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0100,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Bottom &nbsp;= 0b0000'0000'0000'0000'0000'0000'0000'1000,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;XMiddle = 0b0000'0000'0000'0000'0000'0000'0001'0000,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;YMiddle = 0b0000'0000'0000'0000'0000'0000'0010'0000,<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [x方向左右]地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheckX = [&amp;checkID](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Top; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yMiddle, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::YMiddle; // 左中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Bottom; // 左下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 右端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Top; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yMiddle, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::YMiddle; // 右中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Bottom; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [y方向上下]地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheckY = [&amp;checkID](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Top; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xMiddle, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::XMiddle | (int)HitPart::Top; // 中上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Top; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Bottom; // 左下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xMiddle, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::XMiddle | (int)HitPart::Bottom; // 中下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Bottom; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheck = [&amp;hitcheckX, &amp;hitcheckY](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return hitcheckX(checkBit,terrain,xLeft,xMiddle,xRight,yTop,yMiddle,yBottom,pMapX,pMapY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| hitcheckY(checkBit,terrain,xLeft,xMiddle,xRight,yTop,yMiddle,yBottom,pMapX,pMapY);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Width * CellSize - Screen::Width &lt;= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;float camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float debug_x = -1, debug_y = -1; // [デバッグ] めり込みすぎのラインを記録しておく変数<br>
      &nbsp;&nbsp;float debug_x_yTop = -1, debug_x_yBottom = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の上下端も記録<br>
      &nbsp;&nbsp;float debug_y_xLeft = -1, debug_y_xRight = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の左右端も記録<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは移動を停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは当たり判定も停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(hitcheck(BlockBit::Damage, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // やられたフラグをtrueに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yMiddle) || // 左中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) )  // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xLeft; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// std::fmodで小数点の余りを計算 めり込みすぎの余り = std::fmod(xLeft, CellSize)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallRight = xLeft + CellSize - (float)std::fmod(xLeft, CellSize); // 壁の右端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallRight - hitOffsetLeft; // 左端を壁の右端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓右端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) || // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yMiddle) || // 右中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xRight; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallLeft = xRight - (float)std::fmod(xRight, CellSize); // 壁の左端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallLeft + hitOffsetRight - imgSizeX; // 右端を壁の左端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは移動を停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは当たり判定も停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (hitcheck(BlockBit::Damage, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // やられたフラグをtrueに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = 0, mapY = 0; // ぶつかったらそのブロックのCSVのセルの行mapYと列mapXを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Bounce, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;int,int&gt; mapXY = std::make_pair(mapX, mapY); // ぶつかったブロックのセルの行mapYと列mapXのペア<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) == 0) // 辞書にキーがあるかcountで数えて未登録==0のとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime[mapXY] = 0; // ブロックのアニメ時間を辞書に登録(時間が辞書にあるものだけアニメが走る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>bool isBlockChanging = false; // ブロック変化フラグ(idはあとから変化させないとWallの押し戻しの跳ね返りvy = 0がなくなる)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Change, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isBlockChanging = true; // ここではフラグをtrueにするだけ(めり込み押し戻しvy=0するまえにid=-1にすると壊した瞬間にすり抜けちゃう)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yTop) || // 中上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) )  // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yTop; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallBottom = yTop + CellSize - (float)std::fmod(yTop, CellSize); // 壁の下側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallBottom - hitOffsetTop; // 頭を壁の下端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) || // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yBottom) || // 中下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yBottom; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallTop = yBottom - (float)std::fmod(yBottom, CellSize); // 壁の上側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallTop + hitOffsetBottom - imgSizeX; // 足元を壁の上端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 床に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ブロックに当たってないからfalseにして落下するように<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>if (isBlockChanging) // ブロック変化フラグ==true(すでに↑めりこみ判定でvy=0で勢いを止め反射が効くからid=-1にしてもすりぬけずにすむ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[mapY][mapX]; // 行mapY 列mapXの地形idを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockChange.count(id) &gt; 0) // blockChangeの辞書に登録のあるidのときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;int, int&gt; mapXY = std::make_pair(mapX, mapY); // ぶつかったブロックのセルの行mapYと列mapXのペア<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(blockBits[blockChange[id]] &amp; (int)BlockBit::Bounce)) // 変化先ブロックがバウンスするならアニメ時間をeraseせずに辞書に残す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime.erase(mapXY); // ブロックの種類変える前にアニメをリセットしておかないと辞書に残り続ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData[mapY][mapX] = blockChange[id]; // idを入れ替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Width * CellSize - Screen::Width <= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isDead) // やられたときの描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiss = y - camera_y + imgSizeY / 2; // ミスったy起点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim0 = yMiss; // アニメy位置0 始まりのy位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim1 = yMiss - 10; // アニメy位置1 アニメの途中少し上方向に 10 浮く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim2 = Screen::Height + 32; // アニメy位置2 最終y位置 画面の高さ+32で画面外へ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yDeadAnim; // やられた際にはyの位置をアニメさせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 直線的な比例アニメの式(t=時刻)  位置1×(終時刻 - t) / アニメの長さ  +  位置2×(t - 始時刻) / アニメの長さ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (deadAnimeTime &lt; 40) // やられアニメが始まって40フレーム目までは yAnim0 ～ yAnim1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim0 * (40 - deadAnimeTime) / 40 + yAnim1 * (deadAnimeTime - 0) / 40;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (deadAnimeTime &lt; 60) // やられアニメが始まって60フレーム目までは yAnim1 ～ yAnim2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim1 * (60 - deadAnimeTime) / 20 + yAnim2 * (deadAnimeTime - 40) / 20;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim2; // アニメ終了 到着 y位置をセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deadAnimeTime = 0; // 次にやられたときのアニメのため0リセットしておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 再開位置からゲーム再開(各数値もリセット)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = xStart, y = yStart, vx = 0, vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false, isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int deadAnimeStep = deadAnimeTime / 3; // 3で割って[チップのパラパラの]アニメの速度は弱める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int chipAnime = deadAnimeStep % 3; // % 3で余りを求めれば余りはチップのパラパラ番号は0～2の間に収まる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, yDeadAnim, 1.0f, 10.0f * deadAnimeStep / 360.0f * 2 * DX_PI, playerChips[chipAnime], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++deadAnimeTime; // アニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2; // DrawRotaGraphF関数は画像の真ん中が起点なので1/2ずらした位置計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 地形マップを[ 行のfor文×列のfor文 ]の2重ループで描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0, ySize = mapData.size(); cellY &lt; ySize; ++cellY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0, xSize = mapData[cellY].size(); cellX &lt; xSize; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[cellY][cellX]; // [行][列] の位置のcsvの地形番号(チップ番号)を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id &lt; 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップチップを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto mapXY = std::make_pair(cellX, cellY);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x - camera_x + rotaShiftX, chip_y - camera_y + rotaShiftY, 1.0f, 0.0f, mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ((int)BlockBit::Bounce &amp; blockBits[id])<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yBase = chip_y - camera_y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim0 = yBase - 10, yAnim1 = yBase; // yAnim0 から yAnim1の位置までアニメする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int blockTime = blockAnime[mapXY];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim = yAnim0 * (15 - blockTime) / 15 + yAnim1 * blockTime / 15;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x - camera_x + rotaShiftX, yAnim + rotaShiftY, 1.0f, 0.0f, mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++blockAnime[mapXY]; // アニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockTime > 15) // アニメ終了時間を15フレーム目とするとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime.erase(mapXY); // 辞書からアニメをerase関数で取り除く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ]用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawString(chip_x - camera_x, chip_y - camera_y, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たり判定の四隅を赤枠で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawBox(getLeft(x) - camera_x, getTop(y) - camera_y, getRight(x) - camera_x, getBottom(y) - camera_y, GetColor(255, 0, 0), FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] キャラ原点(x,y)を緑丸で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawCircle(x - camera_x, y - camera_y, 2, GetColor(0, 255, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たった際の行き過ぎの めりこみ座標(debug_x,debug_y) を青線で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_x != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(debug_x - camera_x, debug_x_yTop - camera_y, debug_x - camera_x, debug_x_yBottom - camera_y, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_y != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(debug_y_xLeft - camera_x, debug_y - camera_y, debug_y_xRight - camera_x, debug_y - camera_y, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>    
      <br>
      <br>
      いかがでしょう、ブロックを下から叩くとブロックのidが変化して、ブロックが壊せるようになりましたか？<br>
      オリジナルのタイルを自分で描いて、blockChange辞書に登録して、壊せるブロックを自作で増やしてみてくださいね。<br>
      <br>
      <br>
      <br>
      <br>
<br>
    <h1><a id="mozTocId0017" class="mozTocH1"></a>for文で複数ブロックidを辞書で変化させてON OFFブロックを叩いたらidが12⇔13、14⇔15にスイッチできるプログラム</h1>
<br>
      <br>
      <br>
      <p>さてつぎは【for文で複数のブロックidを<b>辞書blockChange</b>と<b>その変化させる対象をblockSwitchで管理</b>してON OFFブロックを叩いたらidが12⇔13、14⇔15にスイッチできるサンプル】でブロックをスイッチできるようにしてみましょう。</p>
    <p><code>main.cpp</code>を編集します：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <br>
      #include &lt;vector&gt;&nbsp;// csvを2次元vector配列に格納<br>
      #include &lt;string&gt;&nbsp;// 文字列std::stringに必要<br>
      #include &lt;fstream&gt;&nbsp;// ファイル読み出しstd::ifstreamに必要<br>
      #include &lt;sstream&gt;&nbsp;// 文字列ストリームに必要 ss &gt;&gt; num;で文字列から数字に変換できる<br>
      #include &lt;unordered_map&gt;&nbsp;// std::unordered_map 高速辞書配列に必要(チップ番号から壁などを表すビットへ変換する辞書)<br>
      #include &lt;utility&gt;&nbsp;// std::pair(データのペア型)を使うのに必要<br>
      // [ペアを高速辞書のキーにするためハッシュ関数が必要] https://qiita.com/hamamu/items/4d081751b69aa3bb3557<br>
      template&lt;class TypeT&gt; size_t HashCombine(const size_t seed, const TypeT&amp; value)<br>
      {<br>
      &nbsp;&nbsp;return seed ^ (std::hash&lt;TypeT&gt;()(value) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2));<br>
      }<br>
      <br>
      // pair型に()をつけたときに呼び出される処理をoperator()で定義してreturnでハッシュ関数を返す<br>
      template&lt;class TypeT, class TypeS&gt;<br>
      struct std::hash&lt;std::pair&lt;TypeT, TypeS&gt;&gt;<br>
      {<br>
      &nbsp;&nbsp;size_t operator() (const std::pair&lt;TypeT, TypeS&gt;&amp; keyval) const noexcept<br>
      &nbsp;&nbsp;{ &nbsp; // returnでハッシュ関数を返すことで高速辞書のキーとして認め許されるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return HashCombine(std::hash&lt;TypeT&gt;()(keyval.first), keyval.second);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4<br>
      &nbsp;&nbsp;int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;int mapChips[64]; // マップのチップのグリッドの分割数に応じて8×8 = 64など配列で確保<br>
      &nbsp;&nbsp;LoadDivGraph("Map/mapchip.png", 64, 8, 8, CellSize, CellSize, mapChips); // マップのチップのサイズは32×32(=CellSize)<br>
      &nbsp;&nbsp;assert(mapChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; mapData;// タイルマップデータ<br>
      &nbsp;&nbsp;std::ifstream ifs_csv_file("Map/stage.csv"); // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int Width = 0, Height = 0; // マップデータの横(Width) 縦(Height)のマスの数<br>
      &nbsp;&nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp;std::string line; // 1行単位ごとにcsvファイルから文字列をstd::getlineで読み込んで受け取る<br>
      &nbsp;&nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; valuelist; // 1行ぶんの数字リスト配列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::istringstream linestream( line ); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::string comma_part; // カンマで分割された文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int widthCount = 0; // カンマで区切られた行の数字の数(各行の幅)をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (std::getline(linestream, comma_part, { ',' })) // 1行をgetlineでカンマで区切って列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istringstream ss( comma_part ); // カンマで区切られた文字をssを通して&gt;&gt;で数字に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行の数字の数がMAX記録を更新するかチェック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (widthCount &gt; MaxWidth)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxWidth = widthCount; // 暫定Maxの列の幅を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行ぶんの数字の配列をとりまとめてmapDataに1行ずつ追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (valuelist.size() != 0) // 配列に数字が1つでもあるなら.size() != 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData.emplace_back(valuelist); // mapDataに1行ずつ数字配列valuelistを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;++Height; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;Width = MaxWidth; // マップの幅Widthは一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp;// ↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp;assert(Width &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;assert(Height &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float xStart = 200, yStart = Screen::Height - 100; // キャラの初期スタート(ミス後の再開位置)<br>
      &nbsp;&nbsp;float x = xStart, y = yStart; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum class Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;bool isDead = false; // キャラがやられたかどうか<br>
      &nbsp;&nbsp;int deadAnimeTime = 0; // やられたときのアニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>bool isSwitchOn = false; // ステージ全体のスイッチのオン、オフ状態(オンのときはオンを押せないようにする)<br>
      &nbsp;&nbsp;int id_On = 10, id_Off = 11; // オンのときにオンを押したりオフのときにオフを押せないように判定する</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int hitOffsetLeft = 2; // 当たり判定の左端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetRight = 2; // 当たり判定の右端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetTop = 1; // 当たり判定の上端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetBottom = 0; // 当たり判定の下端のオフセット<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 当たり判定のはしっこを計算するための一時関数<br>
      &nbsp;&nbsp;auto getLeft  = [&amp;hitOffsetLeft](float worldX) { return worldX + hitOffsetLeft; };<br>
      &nbsp;&nbsp;auto getTop   = [&amp;hitOffsetTop](float worldY) { return worldY + hitOffsetTop; };<br>
      &nbsp;&nbsp;auto getRight  = [&amp;hitOffsetRight, &amp;imgSizeX](float worldX) { return worldX + imgSizeX - hitOffsetRight; };<br>
      &nbsp;&nbsp;auto getBottom = [&amp;hitOffsetBottom, &imgSizeY](float worldY) { return worldY + imgSizeY - hitOffsetBottom; };<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;enum class BlockBit // ブロックの特性を32桁のビットで表現<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None = 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Wall &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Damage = 0b0000'0000'0000'0000'0000'0000'0000'0010,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Bounce = 0b0000'0000'0000'0000'0000'0000'0000'0100, // 叩くと弾むブロック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Change = 0b0000'0000'0000'0000'0000'0000'0000'1000, // 叩くとブロックの種類が変わる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>Switch = 0b0000'0000'0000'0000'0000'0000'0001'0000, // スイッチを叩くと赤ブロックや青ブロックの無効⇔有効が切替</em><br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, unsigned int&gt; blockBits = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{-1,(int)BlockBit::None},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 0,(int)BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 1,(int)BlockBit::Damage},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 2,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Change}, // 壁 | はずむ | ブロック変化 (|ビット論理和)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 3,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Change},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>{10,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Switch}, // 赤Onスイッチ</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>{11,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Switch}, // 青Offスイッチ</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>{12,(int)BlockBit::Wall}, // On に連動するブロック</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>{14,(int)BlockBit::Wall}, // Offに連動するブロック</em><br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ブロックをバウンドさせるための 高速辞書&lt;ペア&lt;cellX,cellY&gt;, intアニメ時間&gt;<br>
      &nbsp;&nbsp;std::unordered_map&lt;std::pair&lt;int, int&gt;, int&gt; blockAnime;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, int&gt; blockChange = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{  2,  3 }, // 叩くと 2 → 3 にかわる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{  3, -1 }, // 叩くと 3 → -1 にかわる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>{ 12, 13 }, // 11(OFF) を押すと 12→13</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>{ 13, 12 }, // 10(ON)  を押すと 13→12</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>{ 14, 15 }, // 10(ON)  を押すと 14→15</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>{ 15, 14 }, // 11(OFF) を押すと 15→14</em><br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; blockSwitch = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 10, {12,13,14,15} }, // 叩くと12,13,14,15がblockChangeの設定内容に応じて変化する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 11, {12,13,14,15} },<br>
      &nbsp;&nbsp;};</em><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 指定された座標(worldX,worldY)の地形が 壁 や ダメージブロックかなどをチェックする一時関数<br>
      &nbsp;&nbsp;auto checkID = [&amp;blockBits, &amp;CellSize](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain, float worldX, float worldY,<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int terrainID = -1; // 指定された座標の地形のID<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (worldX &lt; 0 || worldY &lt; 0) return false; // 負の座標が指定された場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = (int)(worldX / CellSize), mapY = (int)(worldY / CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 二次元配列の範囲内か判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapY &lt; terrain.size() &amp;&amp; mapX &lt; terrain[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terrainID = terrain[mapY][mapX]; // 二次元配列から地形IDを取り出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool isCheckBit = (((int)checkBit) &amp; blockBits[terrainID]) != 0; // ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isCheckBit &amp;&amp; pMapX != nullptr &amp;&amp; pMapY != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pMapX = mapX, *pMapY = mapY; // ブロックのcsvのセル番号をポインタに記録(nullptrの場合は記録しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return isCheckBit;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;enum class HitPart // 当たった箇所を表すビット<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None &nbsp; &nbsp;= 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Left &nbsp; &nbsp;= 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Right &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0010,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Top &nbsp; &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0100,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Bottom &nbsp;= 0b0000'0000'0000'0000'0000'0000'0000'1000,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;XMiddle = 0b0000'0000'0000'0000'0000'0000'0001'0000,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;YMiddle = 0b0000'0000'0000'0000'0000'0000'0010'0000,<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [x方向左右]地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheckX = [&amp;checkID](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Top; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yMiddle, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::YMiddle; // 左中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Bottom; // 左下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 右端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Top; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yMiddle, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::YMiddle; // 右中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Bottom; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [y方向上下]地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheckY = [&amp;checkID](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Top; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xMiddle, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::XMiddle | (int)HitPart::Top; // 中上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Top; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Bottom; // 左下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xMiddle, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::XMiddle | (int)HitPart::Bottom; // 中下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Bottom; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheck = [&amp;hitcheckX, &amp;hitcheckY](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return hitcheckX(checkBit,terrain,xLeft,xMiddle,xRight,yTop,yMiddle,yBottom,pMapX,pMapY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| hitcheckY(checkBit,terrain,xLeft,xMiddle,xRight,yTop,yMiddle,yBottom,pMapX,pMapY);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Width * CellSize - Screen::Width &lt;= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;float camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float debug_x = -1, debug_y = -1; // [デバッグ] めり込みすぎのラインを記録しておく変数<br>
      &nbsp;&nbsp;float debug_x_yTop = -1, debug_x_yBottom = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の上下端も記録<br>
      &nbsp;&nbsp;float debug_y_xLeft = -1, debug_y_xRight = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の左右端も記録<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは移動を停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは当たり判定も停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(hitcheck(BlockBit::Damage, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // やられたフラグをtrueに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yMiddle) || // 左中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) )  // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xLeft; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// std::fmodで小数点の余りを計算 めり込みすぎの余り = std::fmod(xLeft, CellSize)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallRight = xLeft + CellSize - (float)std::fmod(xLeft, CellSize); // 壁の右端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallRight - hitOffsetLeft; // 左端を壁の右端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓右端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) || // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yMiddle) || // 右中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xRight; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallLeft = xRight - (float)std::fmod(xRight, CellSize); // 壁の左端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallLeft + hitOffsetRight - imgSizeX; // 右端を壁の左端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは移動を停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは当たり判定も停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (hitcheck(BlockBit::Damage, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // やられたフラグをtrueに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = 0, mapY = 0; // ぶつかったらそのブロックのCSVのセルの行mapYと列mapXを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Bounce, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;int,int&gt; mapXY = std::make_pair(mapX, mapY); // ぶつかったブロックのセルの行mapYと列mapXのペア<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) == 0) // 辞書にキーがあるかcountで数えて未登録==0のとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime[mapXY] = 0; // ブロックのアニメ時間を辞書に登録(時間が辞書にあるものだけアニメが走る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>if ((int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Switch, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[mapY][mapX]; // 行mapY 列mapXの地形idを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((isSwitchOn &amp;&amp; id == id_Off || !isSwitchOn &amp;&amp; id == id_On) &amp;&amp; blockSwitch.count(id) &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isSwitchOn = !isSwitchOn; // trueとfalseを!で反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0; cellY &lt; Height; ++cellY) // 行をすべて調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0; cellX &lt; Width; ++cellX) // 列をすべて調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (auto switchID : blockSwitch[id]) // スイッチに反応するブロックのIDすべてを調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapData[cellY][cellX] == switchID)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData[cellY][cellX] = blockChange[switchID]; // 変化先のIDへ書き換える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; // 次の列のループへ移る(3重for文の一番内側のループをbreakして1つ外のループへ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool isBlockChanging = false; // ブロック変化フラグ(idはあとから変化させないとWallの押し戻しの跳ね返りvy = 0がなくなる)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Change, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isBlockChanging = true; // ここではフラグをtrueにするだけ(めり込み押し戻しvy=0するまえにid=-1にすると壊した瞬間にすり抜けちゃう)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yTop) || // 中上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) )  // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yTop; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallBottom = yTop + CellSize - (float)std::fmod(yTop, CellSize); // 壁の下側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallBottom - hitOffsetTop; // 頭を壁の下端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) || // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yBottom) || // 中下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yBottom; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallTop = yBottom - (float)std::fmod(yBottom, CellSize); // 壁の上側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallTop + hitOffsetBottom - imgSizeX; // 足元を壁の上端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 床に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ブロックに当たってないからfalseにして落下するように<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isBlockChanging) // ブロック変化フラグ==true(すでに↑めりこみ判定でvy=0で勢いを止め反射が効くからid=-1にしてもすりぬけずにすむ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[mapY][mapX]; // 行mapY 列mapXの地形idを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockChange.count(id) &gt; 0) // blockChangeの辞書に登録のあるidのときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;int, int&gt; mapXY = std::make_pair(mapX, mapY); // ぶつかったブロックのセルの行mapYと列mapXのペア<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(blockBits[blockChange[id]] &amp; (int)BlockBit::Bounce)) // 変化先ブロックがバウンスするならアニメ時間をeraseせずに辞書に残す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime.erase(mapXY); // ブロックの種類変える前にアニメをリセットしておかないと辞書に残り続ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData[mapY][mapX] = blockChange[id]; // idを入れ替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Width * CellSize - Screen::Width <= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isDead) // やられたときの描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiss = y - camera_y + imgSizeY / 2; // ミスったy起点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim0 = yMiss; // アニメy位置0 始まりのy位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim1 = yMiss - 10; // アニメy位置1 アニメの途中少し上方向に 10 浮く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim2 = Screen::Height + 32; // アニメy位置2 最終y位置 画面の高さ+32で画面外へ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yDeadAnim; // やられた際にはyの位置をアニメさせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 直線的な比例アニメの式(t=時刻)  位置1×(終時刻 - t) / アニメの長さ  +  位置2×(t - 始時刻) / アニメの長さ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (deadAnimeTime &lt; 40) // やられアニメが始まって40フレーム目までは yAnim0 ～ yAnim1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim0 * (40 - deadAnimeTime) / 40 + yAnim1 * (deadAnimeTime - 0) / 40;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (deadAnimeTime &lt; 60) // やられアニメが始まって60フレーム目までは yAnim1 ～ yAnim2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim1 * (60 - deadAnimeTime) / 20 + yAnim2 * (deadAnimeTime - 40) / 20;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim2; // アニメ終了 到着 y位置をセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deadAnimeTime = 0; // 次にやられたときのアニメのため0リセットしておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 再開位置からゲーム再開(各数値もリセット)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = xStart, y = yStart, vx = 0, vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false, isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int deadAnimeStep = deadAnimeTime / 3; // 3で割って[チップのパラパラの]アニメの速度は弱める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int chipAnime = deadAnimeStep % 3; // % 3で余りを求めれば余りはチップのパラパラ番号は0～2の間に収まる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, yDeadAnim, 1.0f, 10.0f * deadAnimeStep / 360.0f * 2 * DX_PI, playerChips[chipAnime], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++deadAnimeTime; // アニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 0.0f, playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 0.0f, playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2; // DrawRotaGraphF関数は画像の真ん中が起点なので1/2ずらした位置計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 地形マップを[ 行のfor文×列のfor文 ]の2重ループで描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0, ySize = mapData.size(); cellY &lt; ySize; ++cellY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0, xSize = mapData[cellY].size(); cellX &lt; xSize; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[cellY][cellX]; // [行][列] の位置のcsvの地形番号(チップ番号)を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id &lt; 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップチップを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto mapXY = std::make_pair(cellX, cellY);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x - camera_x + rotaShiftX, chip_y - camera_y + rotaShiftY, 1.0f, 0.0f, mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ((int)BlockBit::Bounce &amp; blockBits[id])<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yBase = chip_y - camera_y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim0 = yBase - 10, yAnim1 = yBase; // yAnim0 から yAnim1の位置までアニメする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int blockTime = blockAnime[mapXY];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim = yAnim0 * (15 - blockTime) / 15 + yAnim1 * blockTime / 15;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x - camera_x + rotaShiftX, yAnim + rotaShiftY, 1.0f, 0.0f, mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++blockAnime[mapXY]; // アニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockTime > 15) // アニメ終了時間を15フレーム目とするとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime.erase(mapXY); // 辞書からアニメをerase関数で取り除く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ]用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawString(chip_x - camera_x, chip_y - camera_y, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たり判定の四隅を赤枠で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawBox(getLeft(x) - camera_x, getTop(y) - camera_y, getRight(x) - camera_x, getBottom(y) - camera_y, GetColor(255, 0, 0), FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] キャラ原点(x,y)を緑丸で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawCircle(x - camera_x, y - camera_y, 2, GetColor(0, 255, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たった際の行き過ぎの めりこみ座標(debug_x,debug_y) を青線で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_x != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(debug_x - camera_x, debug_x_yTop - camera_y, debug_x - camera_x, debug_x_yBottom - camera_y, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_y != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(debug_y_xLeft - camera_x, debug_y - camera_y, debug_y_xRight - camera_x, debug_y - camera_y, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>    
      <br>
      <br>
      いかがでしょう、ON OFF スイッチを押したら赤⇔赤点線、青⇔青点線ブロックに変化するようになりましたか？<br>
      スイッチのギミックがあるだけで、ゲームのパズル要素が一気に強くなるはずです。<br>
      これである程度は面白くできなかったら「自分のゲーム制作のセンスが足りていないかも」ということになりますね(汗)。<br>
      <br>
      <b>[課題] 自作スイッチで自分のステージにパズル性を持たせて面白くしてください。</b><br>
      <br>
      <br>
      <br>
      <br>
<br>
    <h1><a id="mozTocId0018" class="mozTocH1"></a>Imageのロードをclass分けして画像のロード処理をファイル分けするプログラム</h1>
<br>
      <p><code>DivImage.h</code>を新規作成して【DivImage型】分割された画像を読込みその分割のグリッドもパラメータとして保持できるようにしましょう。</p>
      ※シューティングのDivImageと違ってnew int[AllNum]の動的配列をint* HandleArrayで受ける形ではなくstd::vector&lt;int&gt; HandleArrayを使った。<br>
    <p class="source">#ifndef DIVIMAGE_H_<br>
      #define DIVIMAGE_H_<br>
      <br>
      #include &lt;assert.h&gt; // 画像の2のべき乗チェックに使う<br>
      #include &lt;vector&gt; // 可変長配列std::vectorを使う<br>
      <br>
      // 分割画像を読込むためのデータ構造(画像数や画像ハンドル配列、3Dに使う場合の2のべき乗チェック機能をもつ)<br>
      class DivImage<br>
      {&nbsp;&nbsp;// 2Dの分割画像や3Dに分割Div画像を使うと画像全体が使われてしまうのを回避するための情報<br>
      public:<br>
      &nbsp;&nbsp;int XNum = 0; // X方向分割画像数<br>
      &nbsp;&nbsp;int YNum = 0; // Y方向分割画像数<br>
      &nbsp;&nbsp;int XSize = 0; // 画像 横 幅XSize(ピクセルドット数)<br>
      &nbsp;&nbsp;int YSize = 0; // 画像 縦 高さYSize(ピクセルドット数)<br>
      &nbsp;&nbsp;int AllNum = 0; // トータルの分割画像数<br>
      &nbsp;&nbsp;bool is3DTexture = false; // 3Dテクスチャ分割画像かtrueだと2のべき乗チェックが入る<br>
      &nbsp;&nbsp;std::vector&lt;int&gt; HandleArray; // DXのLoadDivGraphでロードした画像ハンドル番号の配列<br>
      <br>
      // 初期化 : X方向分割画像数 XNum, Y方向分割画像数 YNum, 画像 横 幅XSizeピクセル, 画像 縦 高さYSizeピクセル<br>
      &nbsp;&nbsp;DivImage(int XNum, int YNum, int XSize, int YSize, bool is3DTexture=false)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;: XNum{ XNum }, YNum{ YNum }, XSize{ XSize }, YSize{ YSize }, is3DTexture{ is3DTexture }<br>
      &nbsp;&nbsp;{ &nbsp;// 初期化コンストラクタ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;AllNum = XNum * YNum; // トータルの分割画像数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt;(AllNum, -1).swap(this-&gt;HandleArray); // 配列をAllNumぶん確保し-1で初期化<br>
      #ifdef _DEBUG // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(is3DTexture==true) ImagePowCheck((*this)); // *(this)でthisポインタの示す変数内容を表す<br>
      #endif<br>
      &nbsp;&nbsp;};<br>
      <br>
      &nbsp;&nbsp;~DivImage() {}; // デストラクタでメモリを解放<br>
      <br>
      &nbsp;&nbsp;//【勉強 []添え字演算子を独自に定義】https://programming.pc-note.net/cpp/operator.html<br>
      &nbsp;&nbsp;// 内部のHandleArrayへ今までの様にImage::explosion[5]とかで簡単アクセスできるように【あいだに噛ます】<br>
      &nbsp;&nbsp;int const&amp; operator [](int index) const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(index&lt;0 || AllNum&lt;=index) assert("画像データのアクセス番号がおかしい！" == "");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return HandleArray[index];<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;int&amp; operator [](int index)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(index&lt;0 || AllNum&lt;=index) assert("画像データのアクセス番号がおかしい！" == "");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return HandleArray[index];<br>
      &nbsp;&nbsp;}<br>
      <br>
      #ifdef _DEBUG // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;bool is_pow2(unsigned int x) // 2のべき乗か計算<br>
      &nbsp;&nbsp;{ // https://programming-place.net/ppp/contents/c/rev_res/math012.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return (x != 0) &amp;&amp; (x &amp; (x - 1)) == 0;<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;void ImagePowCheck(DivImage&amp; divImage)<br>
      &nbsp;&nbsp;{ // ★3Dに使う画像は2のべき乗でなければ受け付けないようにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// https://yttm-work.jp/gmpg/gmpg_0031.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// https://yappy-t.hatenadiary.org/entry/20100110/1263138881<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (divImage.XSize &gt; 0 &amp;&amp; divImage.YSize &gt; 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; is_pow2(divImage.XSize) &amp;&amp; is_pow2(divImage.YSize)) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else assert("3Dに使うなら2のべき乗の画像サイズにしなきゃ" == "");<br>
      &nbsp;&nbsp;}<br>
      #endif<br>
      <br>
      private: // コピーと代入をプライベートにして禁止する<br>
      &nbsp;&nbsp;&nbsp; // コピーコンストラクタの禁止privateオーバーロード<br>
      &nbsp;&nbsp;&nbsp; DivImage(const DivImage&amp; divImage) {};<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 代入演算子の禁止privateオーバーロード<br>
      &nbsp;&nbsp;&nbsp; void operator=(const DivImage&amp; divImage) {};<br>
      };<br>
      <br>
      #endif</p>
    <p><code>Image.hを新規作成して</code>【DivImage型】でキャラの分割された画像と普通の単一画像を読込んでみましょう。</p>
    <p class="source">#ifndef IMAGE_H_<br>
      #define IMAGE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "DivImage.h" // 分割画像の読込みに使う<br>
      <br>
      class Image<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Image() {}; // 初期化コンストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;~Image() {}; // 破棄する処理デストラクタ:定義と{}空の処理<br>
      &nbsp;&nbsp;static void Load();<br>
      &nbsp;&nbsp;static int LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage);<br>
      <br>
      &nbsp;&nbsp;static int playerImage; //プレイヤ画像のハンドラ(読込画像番号)<br>
      &nbsp;&nbsp;static DivImage playerChips; // [分割画像]プレイヤパラパラ画像<br>
      &nbsp;&nbsp;static DivImage mapChips; // [分割画像]マップチップ画像<br>
      <br>
      private:<br>
      <br>
      };<br>
      #endif<br>
    </p>
    <br>
    <p>次に対となるcppファイルも作成します。<br>
      <code>Image.cppを新規作成して</code>内容を次のようにします：</p>
    <p class="source">#include "Image.h"<br>
      <br>
      int Image::playerImage{-1}; // Load終わっても-1(初期値)のままだと画像ロードが失敗してますね<br>
      // ★分割画像は初期化のときに{X方向画像数, Y方向画像数, 画像横幅XSize,画像縦幅YSize}を指定<br>
      DivImage Image::playerChips{ 3, 4, 32, 32 }; // 画像分割サイズ32×32の横3つ×縦4つの分割画像<br>
      DivImage Image::mapChips{ 8, 8, 32, 32 }; // マップのグリッドの分割数に応じて8×8 = 64など確保<br>
      <br>
      void Image::Load()<br>
      {<br>
      &nbsp;&nbsp;playerImage = LoadGraph("Image/Player.png");<br>
      &nbsp;&nbsp;assert(playerImage != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる<br>
      <br>
      &nbsp;&nbsp;Image::LoadDivGraph("Image/pikkoron.png", playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;for (int i = 0; i &lt; playerChips.AllNum; ++i)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (playerChips[i] == -1) assert("分割画像読込失敗" == ""); // 画像読込失敗<br>
      <br>
      &nbsp;&nbsp;Image::LoadDivGraph("Map/mapchip.png", mapChips); // マップのチップの分割画像のロード<br>
      &nbsp;&nbsp;for (int i = 0; i &lt; mapChips.AllNum; ++i)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (mapChips[i] == -1) assert("分割画像読込失敗" == ""); // 画像読込失敗<br>
      }<br>
      <br>
      // DXライブラリのLoadDivGraphを同一関数名で使いやすくラッピング<br>
      // ★関数に参照渡しを行う<br>
      // 関数の引数に参照渡しを行うことでdivImageの中身を書き換えることができる(値渡しでは書換不可)<br>
      // https://qiita.com/agate-pris/items/05948b7d33f3e88b8967<br>
      // https://qiita.com/RuthTaro/items/f35c3a26779c0ca1a41a<br>
        int Image::LoadDivGraph(const TCHAR* FileName, DivImage&amp; divImage)<br>
        {<br>
        &nbsp;&nbsp;return DxLib::LoadDivGraph(FileName, divImage.XNum * divImage.YNum, divImage.XNum, divImage.YNum,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;divImage.XSize, divImage.YSize, divImage.HandleArray.data()); //<b>.data()でvector内部配列の先頭ポインタを渡す</b><br>
        };<br>
    </p>
    <p><code>main.cpp</code>を編集して画像のロードの処理をImageクラスを使ってするようにします：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      <em>#include "Image.h"</em><br>
      <br>
      #include &lt;vector&gt;&nbsp;// csvを2次元vector配列に格納<br>
      #include &lt;string&gt;&nbsp;// 文字列std::stringに必要<br>
      #include &lt;fstream&gt;&nbsp;// ファイル読み出しstd::ifstreamに必要<br>
      #include &lt;sstream&gt;&nbsp;// 文字列ストリームに必要 ss &gt;&gt; num;で文字列から数字に変換できる<br>
      #include &lt;unordered_map&gt;&nbsp;// std::unordered_map 高速辞書配列に必要(チップ番号から壁などを表すビットへ変換する辞書)<br>
      #include &lt;utility&gt;&nbsp;// std::pair(データのペア型)を使うのに必要<br>
      // [ペアを高速辞書のキーにするためハッシュ関数が必要] https://qiita.com/hamamu/items/4d081751b69aa3bb3557<br>
      template&lt;class TypeT&gt; size_t HashCombine(const size_t seed, const TypeT&amp; value)<br>
      {<br>
      &nbsp;&nbsp;return seed ^ (std::hash&lt;TypeT&gt;()(value) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2));<br>
      }<br>
      <br>
      // pair型に()をつけたときに呼び出される処理をoperator()で定義してreturnでハッシュ関数を返す<br>
      template&lt;class TypeT, class TypeS&gt;<br>
      struct std::hash&lt;std::pair&lt;TypeT, TypeS&gt;&gt;<br>
      {<br>
      &nbsp;&nbsp;size_t operator() (const std::pair&lt;TypeT, TypeS&gt;&amp; keyval) const noexcept<br>
      &nbsp;&nbsp;{ &nbsp; // returnでハッシュ関数を返すことで高速辞書のキーとして認め許されるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return HashCombine(std::hash&lt;TypeT&gt;()(keyval.first), keyval.second);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;<em>Image::Load(); // 画像ファイルを事前読み込み</em><br>
      &nbsp;&nbsp;<u>int playerChips[12]; // キャラのチップのグリッドの分割数に応じて3×4 = 12のぶんだけ配列を事前に確保<br>
      &nbsp;&nbsp;LoadDivGraph("Image/pikkoron.png", 12, 3, 4, 32, 32, playerChips); // キャラのチップのサイズは32×32<br>
      &nbsp;&nbsp;assert(playerChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</u><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4<br>
      &nbsp;&nbsp;int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;<u>int mapChips[64]; // マップのチップのグリッドの分割数に応じて8×8 = 64など配列で確保<br>
      &nbsp;&nbsp;LoadDivGraph("Map/mapchip.png", 64, 8, 8, CellSize, CellSize, mapChips); // マップのチップのサイズは32×32(=CellSize)<br>
      &nbsp;&nbsp;assert(mapChips[0] != -1); // 画像読込失敗、ファイル名かフォルダ名が間違ってる</u><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; mapData;// タイルマップデータ<br>
      &nbsp;&nbsp;std::ifstream ifs_csv_file("Map/stage.csv"); // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int Width = 0, Height = 0; // マップデータの横(Width) 縦(Height)のマスの数<br>
      &nbsp;&nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp;std::string line; // 1行単位ごとにcsvファイルから文字列をstd::getlineで読み込んで受け取る<br>
      &nbsp;&nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; valuelist; // 1行ぶんの数字リスト配列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::istringstream linestream( line ); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::string comma_part; // カンマで分割された文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int widthCount = 0; // カンマで区切られた行の数字の数(各行の幅)をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (std::getline(linestream, comma_part, { ',' })) // 1行をgetlineでカンマで区切って列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istringstream ss( comma_part ); // カンマで区切られた文字をssを通して&gt;&gt;で数字に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行の数字の数がMAX記録を更新するかチェック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (widthCount &gt; MaxWidth)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxWidth = widthCount; // 暫定Maxの列の幅を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行ぶんの数字の配列をとりまとめてmapDataに1行ずつ追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (valuelist.size() != 0) // 配列に数字が1つでもあるなら.size() != 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData.emplace_back(valuelist); // mapDataに1行ずつ数字配列valuelistを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;++Height; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;Width = MaxWidth; // マップの幅Widthは一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp;// ↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp;assert(Width &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;assert(Height &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float xStart = 200, yStart = Screen::Height - 100; // キャラの初期スタート(ミス後の再開位置)<br>
      &nbsp;&nbsp;float x = xStart, y = yStart; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum class Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;bool isDead = false; // キャラがやられたかどうか<br>
      &nbsp;&nbsp;int deadAnimeTime = 0; // やられたときのアニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;bool isSwitchOn = false; // ステージ全体のスイッチのオン、オフ状態(オンのときはオンを押せないようにする)<br>
      &nbsp;&nbsp;int id_On = 10, id_Off = 11; // オンのときにオンを押したりオフのときにオフを押せないように判定する<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(<em>Image::</em>playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int hitOffsetLeft = 2; // 当たり判定の左端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetRight = 2; // 当たり判定の右端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetTop = 1; // 当たり判定の上端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetBottom = 0; // 当たり判定の下端のオフセット<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 当たり判定のはしっこを計算するための一時関数<br>
      &nbsp;&nbsp;auto getLeft  = [&amp;hitOffsetLeft](float worldX) { return worldX + hitOffsetLeft; };<br>
      &nbsp;&nbsp;auto getTop   = [&amp;hitOffsetTop](float worldY) { return worldY + hitOffsetTop; };<br>
      &nbsp;&nbsp;auto getRight  = [&amp;hitOffsetRight, &amp;imgSizeX](float worldX) { return worldX + imgSizeX - hitOffsetRight; };<br>
      &nbsp;&nbsp;auto getBottom = [&amp;hitOffsetBottom, &imgSizeY](float worldY) { return worldY + imgSizeY - hitOffsetBottom; };<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;enum class BlockBit // ブロックの特性を32桁のビットで表現<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None = 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Wall &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Damage = 0b0000'0000'0000'0000'0000'0000'0000'0010,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Bounce = 0b0000'0000'0000'0000'0000'0000'0000'0100, // 叩くと弾むブロック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Change = 0b0000'0000'0000'0000'0000'0000'0000'1000, // 叩くとブロックの種類が変わる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Switch = 0b0000'0000'0000'0000'0000'0000'0001'0000, // スイッチを叩くと赤ブロックや青ブロックの無効⇔有効が切替<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, unsigned int&gt; blockBits = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{-1,(int)BlockBit::None},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 0,(int)BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 1,(int)BlockBit::Damage},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 2,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Change}, // 壁 | はずむ | ブロック変化 (|ビット論理和)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 3,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Change},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{10,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Switch}, // 赤Onスイッチ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{11,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Switch}, // 青Offスイッチ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{12,(int)BlockBit::Wall}, // On に連動するブロック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{14,(int)BlockBit::Wall}, // Offに連動するブロック<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ブロックをバウンドさせるための 高速辞書&lt;ペア&lt;cellX,cellY&gt;, intアニメ時間&gt;<br>
      &nbsp;&nbsp;std::unordered_map&lt;std::pair&lt;int, int&gt;, int&gt; blockAnime;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, int&gt; blockChange = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{  2,  3 }, // 叩くと 2 → 3 にかわる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{  3, -1 }, // 叩くと 3 → -1 にかわる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 12, 13 }, // 11(OFF) を押すと 12→13<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 13, 12 }, // 10(ON)  を押すと 13→12<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 14, 15 }, // 10(ON)  を押すと 14→15<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 15, 14 }, // 11(OFF) を押すと 15→14<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; blockSwitch = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 10, {12,13,14,15} }, // 叩くと12,13,14,15がblockChangeの設定内容に応じて変化する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 11, {12,13,14,15} },<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 指定された座標(worldX,worldY)の地形が 壁 や ダメージブロックかなどをチェックする一時関数<br>
      &nbsp;&nbsp;auto checkID = [&amp;blockBits, &amp;CellSize](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain, float worldX, float worldY,<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int terrainID = -1; // 指定された座標の地形のID<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (worldX &lt; 0 || worldY &lt; 0) return false; // 負の座標が指定された場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = (int)(worldX / CellSize), mapY = (int)(worldY / CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 二次元配列の範囲内か判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapY &lt; terrain.size() &amp;&amp; mapX &lt; terrain[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terrainID = terrain[mapY][mapX]; // 二次元配列から地形IDを取り出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool isCheckBit = (((int)checkBit) &amp; blockBits[terrainID]) != 0; // ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isCheckBit &amp;&amp; pMapX != nullptr &amp;&amp; pMapY != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pMapX = mapX, *pMapY = mapY; // ブロックのcsvのセル番号をポインタに記録(nullptrの場合は記録しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return isCheckBit;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;enum class HitPart // 当たった箇所を表すビット<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None &nbsp; &nbsp;= 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Left &nbsp; &nbsp;= 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Right &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0010,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Top &nbsp; &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0100,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Bottom &nbsp;= 0b0000'0000'0000'0000'0000'0000'0000'1000,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;XMiddle = 0b0000'0000'0000'0000'0000'0000'0001'0000,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;YMiddle = 0b0000'0000'0000'0000'0000'0000'0010'0000,<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [x方向左右]地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheckX = [&amp;checkID](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Top; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yMiddle, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::YMiddle; // 左中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Bottom; // 左下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 右端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Top; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yMiddle, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::YMiddle; // 右中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Bottom; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [y方向上下]地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheckY = [&amp;checkID](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Top; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xMiddle, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::XMiddle | (int)HitPart::Top; // 中上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Top; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Bottom; // 左下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xMiddle, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::XMiddle | (int)HitPart::Bottom; // 中下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Bottom; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheck = [&amp;hitcheckX, &amp;hitcheckY](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return hitcheckX(checkBit,terrain,xLeft,xMiddle,xRight,yTop,yMiddle,yBottom,pMapX,pMapY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| hitcheckY(checkBit,terrain,xLeft,xMiddle,xRight,yTop,yMiddle,yBottom,pMapX,pMapY);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Width * CellSize - Screen::Width &lt;= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;float camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float debug_x = -1, debug_y = -1; // [デバッグ] めり込みすぎのラインを記録しておく変数<br>
      &nbsp;&nbsp;float debug_x_yTop = -1, debug_x_yBottom = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の上下端も記録<br>
      &nbsp;&nbsp;float debug_y_xLeft = -1, debug_y_xRight = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の左右端も記録<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは移動を停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは当たり判定も停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(hitcheck(BlockBit::Damage, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // やられたフラグをtrueに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yMiddle) || // 左中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) )  // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xLeft; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// std::fmodで小数点の余りを計算 めり込みすぎの余り = std::fmod(xLeft, CellSize)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallRight = xLeft + CellSize - (float)std::fmod(xLeft, CellSize); // 壁の右端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallRight - hitOffsetLeft; // 左端を壁の右端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓右端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) || // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yMiddle) || // 右中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xRight; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallLeft = xRight - (float)std::fmod(xRight, CellSize); // 壁の左端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallLeft + hitOffsetRight - imgSizeX; // 右端を壁の左端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは移動を停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは当たり判定も停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (hitcheck(BlockBit::Damage, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // やられたフラグをtrueに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = 0, mapY = 0; // ぶつかったらそのブロックのCSVのセルの行mapYと列mapXを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Bounce, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;int,int&gt; mapXY = std::make_pair(mapX, mapY); // ぶつかったブロックのセルの行mapYと列mapXのペア<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) == 0) // 辞書にキーがあるかcountで数えて未登録==0のとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime[mapXY] = 0; // ブロックのアニメ時間を辞書に登録(時間が辞書にあるものだけアニメが走る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Switch, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[mapY][mapX]; // 行mapY 列mapXの地形idを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((isSwitchOn &amp;&amp; id == id_Off || !isSwitchOn &amp;&amp; id == id_On) &amp;&amp; blockSwitch.count(id) &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isSwitchOn = !isSwitchOn; // trueとfalseを!で反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0; cellY &lt; Height; ++cellY) // 行をすべて調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0; cellX &lt; Width; ++cellX) // 列をすべて調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (auto switchID : blockSwitch[id]) // スイッチに反応するブロックのIDすべてを調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapData[cellY][cellX] == switchID)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData[cellY][cellX] = blockChange[switchID]; // 変化先のIDへ書き換える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; // 次の列のループへ移る(3重for文の一番内側のループをbreakして1つ外のループへ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool isBlockChanging = false; // ブロック変化フラグ(idはあとから変化させないとWallの押し戻しの跳ね返りvy = 0がなくなる)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Change, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isBlockChanging = true; // ここではフラグをtrueにするだけ(めり込み押し戻しvy=0するまえにid=-1にすると壊した瞬間にすり抜けちゃう)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yTop) || // 中上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) )  // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yTop; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallBottom = yTop + CellSize - (float)std::fmod(yTop, CellSize); // 壁の下側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallBottom - hitOffsetTop; // 頭を壁の下端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) || // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yBottom) || // 中下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yBottom; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallTop = yBottom - (float)std::fmod(yBottom, CellSize); // 壁の上側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallTop + hitOffsetBottom - imgSizeX; // 足元を壁の上端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 床に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ブロックに当たってないからfalseにして落下するように<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isBlockChanging) // ブロック変化フラグ==true(すでに↑めりこみ判定でvy=0で勢いを止め反射が効くからid=-1にしてもすりぬけずにすむ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[mapY][mapX]; // 行mapY 列mapXの地形idを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockChange.count(id) &gt; 0) // blockChangeの辞書に登録のあるidのときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;int, int&gt; mapXY = std::make_pair(mapX, mapY); // ぶつかったブロックのセルの行mapYと列mapXのペア<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(blockBits[blockChange[id]] &amp; (int)BlockBit::Bounce)) // 変化先ブロックがバウンスするならアニメ時間をeraseせずに辞書に残す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime.erase(mapXY); // ブロックの種類変える前にアニメをリセットしておかないと辞書に残り続ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData[mapY][mapX] = blockChange[id]; // idを入れ替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Width * CellSize - Screen::Width <= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isDead) // やられたときの描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiss = y - camera_y + imgSizeY / 2; // ミスったy起点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim0 = yMiss; // アニメy位置0 始まりのy位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim1 = yMiss - 10; // アニメy位置1 アニメの途中少し上方向に 10 浮く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim2 = Screen::Height + 32; // アニメy位置2 最終y位置 画面の高さ+32で画面外へ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yDeadAnim; // やられた際にはyの位置をアニメさせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 直線的な比例アニメの式(t=時刻)  位置1×(終時刻 - t) / アニメの長さ  +  位置2×(t - 始時刻) / アニメの長さ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (deadAnimeTime &lt; 40) // やられアニメが始まって40フレーム目までは yAnim0 ～ yAnim1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim0 * (40 - deadAnimeTime) / 40 + yAnim1 * (deadAnimeTime - 0) / 40;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (deadAnimeTime &lt; 60) // やられアニメが始まって60フレーム目までは yAnim1 ～ yAnim2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim1 * (60 - deadAnimeTime) / 20 + yAnim2 * (deadAnimeTime - 40) / 20;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim2; // アニメ終了 到着 y位置をセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deadAnimeTime = 0; // 次にやられたときのアニメのため0リセットしておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 再開位置からゲーム再開(各数値もリセット)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = xStart, y = yStart, vx = 0, vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false, isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int deadAnimeStep = deadAnimeTime / 3; // 3で割って[チップのパラパラの]アニメの速度は弱める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int chipAnime = deadAnimeStep % 3; // % 3で余りを求めれば余りはチップのパラパラ番号は0～2の間に収まる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, yDeadAnim, 1.0f, 10.0f * deadAnimeStep / 360.0f * 2 * DX_PI, <em>Image::</em>playerChips[chipAnime], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++deadAnimeTime; // アニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, <em>Image::</em>playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, <em>Image::</em>playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 0.0f, <em>Image::</em>playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 0.0f, <em>Image::</em>playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2; // DrawRotaGraphF関数は画像の真ん中が起点なので1/2ずらした位置計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 地形マップを[ 行のfor文×列のfor文 ]の2重ループで描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0, ySize = mapData.size(); cellY &lt; ySize; ++cellY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0, xSize = mapData[cellY].size(); cellX &lt; xSize; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[cellY][cellX]; // [行][列] の位置のcsvの地形番号(チップ番号)を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id &lt; 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップチップを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto mapXY = std::make_pair(cellX, cellY);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x - camera_x + rotaShiftX, chip_y - camera_y + rotaShiftY, 1.0f, 0.0f, <em>Image::</em>mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ((int)BlockBit::Bounce &amp; blockBits[id])<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yBase = chip_y - camera_y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim0 = yBase - 10, yAnim1 = yBase; // yAnim0 から yAnim1の位置までアニメする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int blockTime = blockAnime[mapXY];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim = yAnim0 * (15 - blockTime) / 15 + yAnim1 * blockTime / 15;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x - camera_x + rotaShiftX, yAnim + rotaShiftY, 1.0f, 0.0f, <em>Image::</em>mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++blockAnime[mapXY]; // アニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockTime > 15) // アニメ終了時間を15フレーム目とするとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime.erase(mapXY); // 辞書からアニメをerase関数で取り除く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ]用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawString(chip_x - camera_x, chip_y - camera_y, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たり判定の四隅を赤枠で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawBox(getLeft(x) - camera_x, getTop(y) - camera_y, getRight(x) - camera_x, getBottom(y) - camera_y, GetColor(255, 0, 0), FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] キャラ原点(x,y)を緑丸で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawCircle(x - camera_x, y - camera_y, 2, GetColor(0, 255, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たった際の行き過ぎの めりこみ座標(debug_x,debug_y) を青線で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_x != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(debug_x - camera_x, debug_x_yTop - camera_y, debug_x - camera_x, debug_x_yBottom - camera_y, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_y != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(debug_y_xLeft - camera_x, debug_y - camera_y, debug_y_xRight - camera_x, debug_y - camera_y, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
      <br>
      <br>
      いかがでしょう、動作は変わりませんが、きちんとImageクラスを通して画像ロード処理をできるようになりましたか？<br>
      <br>
      <br>
      <br>
<br>
    <h1><a id="mozTocId0019" class="mozTocH1"></a>Soundのロードをclass分けして音声のロード処理をファイル分けするプログラム</h1>
<br>
    <p>まずはSoundクラスを作ってみましょう。基本はImage.hと似ています。</p>
    <p><code>Sound.hを新規作成</code>します。</p>
    <p class="source">#ifndef SOUND_H_<br>
      #define SOUND_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include &lt;assert.h&gt; // 音声読み込みの読込み失敗表示用<br>
      #include &lt;string&gt;<br>
      <br>
      class Sound<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;Sound() {}; // 初期化コンストラクタの定義<br>
      &nbsp;&nbsp; &nbsp;~Sound() {}; // 破棄処理デストラクタの定義<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;static void Load();<br>
      &nbsp;&nbsp; &nbsp;// メモリから音声を再生<br>
      &nbsp;&nbsp; &nbsp;static void Play(int handle, int PlayType = DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;// メモリ再生音源管理番号<br>
      &nbsp;&nbsp; &nbsp;static int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp; &nbsp;<br>
      private:<br>
      <br>
      };<br>
      #endif</p>
    <p><code>Sound.cppも新規作成</code>します。</p>
    <p class="source">#include "Sound.h"<br>
      <br>
      // メモリ再生音源管理番号<br>
      int Sound::jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      <br>
      <br>
      void Sound::Load()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;&nbsp; jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;&nbsp; jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;&nbsp; jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;&nbsp; assert(jumpSE[0] != -1); // 読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; assert(jumpSE[1] != -1); // 読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; assert(jumpSE[2] != -1); // 読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; assert(jumpSE[3] != -1); // 読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;&nbsp; <br>
      }<br>
      <br>
      // メモリ上の音声を再生する。<br>
      void Sound::Play(int handle, int PlayType)<br>
      {&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // メモリ上から音声再生<br>
      &nbsp;&nbsp;&nbsp; PlaySoundMem(handle, PlayType);<br>
      }<br>
      <br>
    </p>
    <p><code>main.cpp</code>を編集して音声のロードの処理をSoundクラスを使ってするようにします：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      <em>#include "Sound.h"</em><br>
      <br>
      #include &lt;vector&gt;&nbsp;// csvを2次元vector配列に格納<br>
      #include &lt;string&gt;&nbsp;// 文字列std::stringに必要<br>
      #include &lt;fstream&gt;&nbsp;// ファイル読み出しstd::ifstreamに必要<br>
      #include &lt;sstream&gt;&nbsp;// 文字列ストリームに必要 ss &gt;&gt; num;で文字列から数字に変換できる<br>
      #include &lt;unordered_map&gt;&nbsp;// std::unordered_map 高速辞書配列に必要(チップ番号から壁などを表すビットへ変換する辞書)<br>
      #include &lt;utility&gt;&nbsp;// std::pair(データのペア型)を使うのに必要<br>
      // [ペアを高速辞書のキーにするためハッシュ関数が必要] https://qiita.com/hamamu/items/4d081751b69aa3bb3557<br>
      template&lt;class TypeT&gt; size_t HashCombine(const size_t seed, const TypeT&amp; value)<br>
      {<br>
      &nbsp;&nbsp;return seed ^ (std::hash&lt;TypeT&gt;()(value) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2));<br>
      }<br>
      <br>
      // pair型に()をつけたときに呼び出される処理をoperator()で定義してreturnでハッシュ関数を返す<br>
      template&lt;class TypeT, class TypeS&gt;<br>
      struct std::hash&lt;std::pair&lt;TypeT, TypeS&gt;&gt;<br>
      {<br>
      &nbsp;&nbsp;size_t operator() (const std::pair&lt;TypeT, TypeS&gt;&amp; keyval) const noexcept<br>
      &nbsp;&nbsp;{ &nbsp; // returnでハッシュ関数を返すことで高速辞書のキーとして認め許されるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return HashCombine(std::hash&lt;TypeT&gt;()(keyval.first), keyval.second);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;Image::Load(); // 画像ファイルを事前読み込み<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<u>// 効果音ファイルを事前にメモリに読み込む https://dxlib.xsrv.jp/function/dxfunc_sound.html#R8N4</u><br>
      &nbsp;&nbsp;<em>Sound::Load(); // 音声ファイルを事前読み込み</em><br>
      &nbsp;&nbsp;<u>int jumpSE[4]; // 4種類のジャンプ音を読み込む<br>
      &nbsp;&nbsp;jumpSE[0] = LoadSoundMem("SE/Jump0.wav");<br>
      &nbsp;&nbsp;jumpSE[1] = LoadSoundMem("SE/Jump1.wav");<br>
      &nbsp;&nbsp;jumpSE[2] = LoadSoundMem("SE/Jump2.wav");<br>
      &nbsp;&nbsp;jumpSE[3] = LoadSoundMem("SE/Jump3.wav");<br>
      &nbsp;&nbsp;assert(jumpSE[0] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[1] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[2] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる<br>
      &nbsp;&nbsp;assert(jumpSE[3] != -1); // SE読込失敗、ファイル名かフォルダ名が間違ってる</u><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; mapData;// タイルマップデータ<br>
      &nbsp;&nbsp;std::ifstream ifs_csv_file("Map/stage.csv"); // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int Width = 0, Height = 0; // マップデータの横(Width) 縦(Height)のマスの数<br>
      &nbsp;&nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp;std::string line; // 1行単位ごとにcsvファイルから文字列をstd::getlineで読み込んで受け取る<br>
      &nbsp;&nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; valuelist; // 1行ぶんの数字リスト配列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::istringstream linestream( line ); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::string comma_part; // カンマで分割された文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int widthCount = 0; // カンマで区切られた行の数字の数(各行の幅)をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (std::getline(linestream, comma_part, { ',' })) // 1行をgetlineでカンマで区切って列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istringstream ss( comma_part ); // カンマで区切られた文字をssを通して&gt;&gt;で数字に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行の数字の数がMAX記録を更新するかチェック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (widthCount &gt; MaxWidth)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxWidth = widthCount; // 暫定Maxの列の幅を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行ぶんの数字の配列をとりまとめてmapDataに1行ずつ追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (valuelist.size() != 0) // 配列に数字が1つでもあるなら.size() != 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData.emplace_back(valuelist); // mapDataに1行ずつ数字配列valuelistを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;++Height; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;Width = MaxWidth; // マップの幅Widthは一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp;// ↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp;assert(Width &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;assert(Height &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float xStart = 200, yStart = Screen::Height - 100; // キャラの初期スタート(ミス後の再開位置)<br>
      &nbsp;&nbsp;float x = xStart, y = yStart; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum class Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;bool isDead = false; // キャラがやられたかどうか<br>
      &nbsp;&nbsp;int deadAnimeTime = 0; // やられたときのアニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;bool isSwitchOn = false; // ステージ全体のスイッチのオン、オフ状態(オンのときはオンを押せないようにする)<br>
      &nbsp;&nbsp;int id_On = 10, id_Off = 11; // オンのときにオンを押したりオフのときにオフを押せないように判定する<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(Image::playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int hitOffsetLeft = 2; // 当たり判定の左端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetRight = 2; // 当たり判定の右端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetTop = 1; // 当たり判定の上端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetBottom = 0; // 当たり判定の下端のオフセット<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 当たり判定のはしっこを計算するための一時関数<br>
      &nbsp;&nbsp;auto getLeft  = [&amp;hitOffsetLeft](float worldX) { return worldX + hitOffsetLeft; };<br>
      &nbsp;&nbsp;auto getTop   = [&amp;hitOffsetTop](float worldY) { return worldY + hitOffsetTop; };<br>
      &nbsp;&nbsp;auto getRight  = [&amp;hitOffsetRight, &amp;imgSizeX](float worldX) { return worldX + imgSizeX - hitOffsetRight; };<br>
      &nbsp;&nbsp;auto getBottom = [&amp;hitOffsetBottom, &imgSizeY](float worldY) { return worldY + imgSizeY - hitOffsetBottom; };<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;enum class BlockBit // ブロックの特性を32桁のビットで表現<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None = 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Wall &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Damage = 0b0000'0000'0000'0000'0000'0000'0000'0010,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Bounce = 0b0000'0000'0000'0000'0000'0000'0000'0100, // 叩くと弾むブロック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Change = 0b0000'0000'0000'0000'0000'0000'0000'1000, // 叩くとブロックの種類が変わる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Switch = 0b0000'0000'0000'0000'0000'0000'0001'0000, // スイッチを叩くと赤ブロックや青ブロックの無効⇔有効が切替<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, unsigned int&gt; blockBits = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{-1,(int)BlockBit::None},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 0,(int)BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 1,(int)BlockBit::Damage},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 2,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Change}, // 壁 | はずむ | ブロック変化 (|ビット論理和)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 3,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Change},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{10,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Switch}, // 赤Onスイッチ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{11,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Switch}, // 青Offスイッチ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{12,(int)BlockBit::Wall}, // On に連動するブロック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{14,(int)BlockBit::Wall}, // Offに連動するブロック<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ブロックをバウンドさせるための 高速辞書&lt;ペア&lt;cellX,cellY&gt;, intアニメ時間&gt;<br>
      &nbsp;&nbsp;std::unordered_map&lt;std::pair&lt;int, int&gt;, int&gt; blockAnime;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, int&gt; blockChange = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{  2,  3 }, // 叩くと 2 → 3 にかわる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{  3, -1 }, // 叩くと 3 → -1 にかわる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 12, 13 }, // 11(OFF) を押すと 12→13<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 13, 12 }, // 10(ON)  を押すと 13→12<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 14, 15 }, // 10(ON)  を押すと 14→15<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 15, 14 }, // 11(OFF) を押すと 15→14<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; blockSwitch = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 10, {12,13,14,15} }, // 叩くと12,13,14,15がblockChangeの設定内容に応じて変化する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 11, {12,13,14,15} },<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 指定された座標(worldX,worldY)の地形が 壁 や ダメージブロックかなどをチェックする一時関数<br>
      &nbsp;&nbsp;auto checkID = [&amp;blockBits, &amp;CellSize](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain, float worldX, float worldY,<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int terrainID = -1; // 指定された座標の地形のID<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (worldX &lt; 0 || worldY &lt; 0) return false; // 負の座標が指定された場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = (int)(worldX / CellSize), mapY = (int)(worldY / CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 二次元配列の範囲内か判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapY &lt; terrain.size() &amp;&amp; mapX &lt; terrain[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terrainID = terrain[mapY][mapX]; // 二次元配列から地形IDを取り出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool isCheckBit = (((int)checkBit) &amp; blockBits[terrainID]) != 0; // ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isCheckBit &amp;&amp; pMapX != nullptr &amp;&amp; pMapY != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pMapX = mapX, *pMapY = mapY; // ブロックのcsvのセル番号をポインタに記録(nullptrの場合は記録しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return isCheckBit;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;enum class HitPart // 当たった箇所を表すビット<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None &nbsp; &nbsp;= 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Left &nbsp; &nbsp;= 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Right &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0010,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Top &nbsp; &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0100,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Bottom &nbsp;= 0b0000'0000'0000'0000'0000'0000'0000'1000,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;XMiddle = 0b0000'0000'0000'0000'0000'0000'0001'0000,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;YMiddle = 0b0000'0000'0000'0000'0000'0000'0010'0000,<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [x方向左右]地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheckX = [&amp;checkID](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Top; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yMiddle, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::YMiddle; // 左中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Bottom; // 左下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 右端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Top; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yMiddle, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::YMiddle; // 右中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Bottom; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [y方向上下]地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheckY = [&amp;checkID](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Top; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xMiddle, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::XMiddle | (int)HitPart::Top; // 中上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Top; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Bottom; // 左下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xMiddle, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::XMiddle | (int)HitPart::Bottom; // 中下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Bottom; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheck = [&amp;hitcheckX, &amp;hitcheckY](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return hitcheckX(checkBit,terrain,xLeft,xMiddle,xRight,yTop,yMiddle,yBottom,pMapX,pMapY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| hitcheckY(checkBit,terrain,xLeft,xMiddle,xRight,yTop,yMiddle,yBottom,pMapX,pMapY);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Width * CellSize - Screen::Width &lt;= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;float camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float debug_x = -1, debug_y = -1; // [デバッグ] めり込みすぎのラインを記録しておく変数<br>
      &nbsp;&nbsp;float debug_x_yTop = -1, debug_x_yBottom = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の上下端も記録<br>
      &nbsp;&nbsp;float debug_y_xLeft = -1, debug_y_xRight = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の左右端も記録<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(<em>Sound::</em>jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(<em>Sound::</em>jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは移動を停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは当たり判定も停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(hitcheck(BlockBit::Damage, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // やられたフラグをtrueに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yMiddle) || // 左中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) )  // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xLeft; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// std::fmodで小数点の余りを計算 めり込みすぎの余り = std::fmod(xLeft, CellSize)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallRight = xLeft + CellSize - (float)std::fmod(xLeft, CellSize); // 壁の右端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallRight - hitOffsetLeft; // 左端を壁の右端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓右端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) || // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yMiddle) || // 右中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xRight; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallLeft = xRight - (float)std::fmod(xRight, CellSize); // 壁の左端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallLeft + hitOffsetRight - imgSizeX; // 右端を壁の左端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは移動を停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは当たり判定も停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (hitcheck(BlockBit::Damage, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // やられたフラグをtrueに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = 0, mapY = 0; // ぶつかったらそのブロックのCSVのセルの行mapYと列mapXを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Bounce, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;int,int&gt; mapXY = std::make_pair(mapX, mapY); // ぶつかったブロックのセルの行mapYと列mapXのペア<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) == 0) // 辞書にキーがあるかcountで数えて未登録==0のとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime[mapXY] = 0; // ブロックのアニメ時間を辞書に登録(時間が辞書にあるものだけアニメが走る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Switch, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[mapY][mapX]; // 行mapY 列mapXの地形idを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((isSwitchOn &amp;&amp; id == id_Off || !isSwitchOn &amp;&amp; id == id_On) &amp;&amp; blockSwitch.count(id) &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isSwitchOn = !isSwitchOn; // trueとfalseを!で反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0; cellY &lt; Height; ++cellY) // 行をすべて調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0; cellX &lt; Width; ++cellX) // 列をすべて調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (auto switchID : blockSwitch[id]) // スイッチに反応するブロックのIDすべてを調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapData[cellY][cellX] == switchID)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData[cellY][cellX] = blockChange[switchID]; // 変化先のIDへ書き換える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; // 次の列のループへ移る(3重for文の一番内側のループをbreakして1つ外のループへ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool isBlockChanging = false; // ブロック変化フラグ(idはあとから変化させないとWallの押し戻しの跳ね返りvy = 0がなくなる)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Change, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isBlockChanging = true; // ここではフラグをtrueにするだけ(めり込み押し戻しvy=0するまえにid=-1にすると壊した瞬間にすり抜けちゃう)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yTop) || // 中上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) )  // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yTop; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallBottom = yTop + CellSize - (float)std::fmod(yTop, CellSize); // 壁の下側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallBottom - hitOffsetTop; // 頭を壁の下端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) || // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yBottom) || // 中下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yBottom; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallTop = yBottom - (float)std::fmod(yBottom, CellSize); // 壁の上側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallTop + hitOffsetBottom - imgSizeX; // 足元を壁の上端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 床に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ブロックに当たってないからfalseにして落下するように<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isBlockChanging) // ブロック変化フラグ==true(すでに↑めりこみ判定でvy=0で勢いを止め反射が効くからid=-1にしてもすりぬけずにすむ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[mapY][mapX]; // 行mapY 列mapXの地形idを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockChange.count(id) &gt; 0) // blockChangeの辞書に登録のあるidのときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;int, int&gt; mapXY = std::make_pair(mapX, mapY); // ぶつかったブロックのセルの行mapYと列mapXのペア<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(blockBits[blockChange[id]] &amp; (int)BlockBit::Bounce)) // 変化先ブロックがバウンスするならアニメ時間をeraseせずに辞書に残す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime.erase(mapXY); // ブロックの種類変える前にアニメをリセットしておかないと辞書に残り続ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData[mapY][mapX] = blockChange[id]; // idを入れ替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Width * CellSize - Screen::Width <= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isDead) // やられたときの描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiss = y - camera_y + imgSizeY / 2; // ミスったy起点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim0 = yMiss; // アニメy位置0 始まりのy位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim1 = yMiss - 10; // アニメy位置1 アニメの途中少し上方向に 10 浮く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim2 = Screen::Height + 32; // アニメy位置2 最終y位置 画面の高さ+32で画面外へ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yDeadAnim; // やられた際にはyの位置をアニメさせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 直線的な比例アニメの式(t=時刻)  位置1×(終時刻 - t) / アニメの長さ  +  位置2×(t - 始時刻) / アニメの長さ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (deadAnimeTime &lt; 40) // やられアニメが始まって40フレーム目までは yAnim0 ～ yAnim1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim0 * (40 - deadAnimeTime) / 40 + yAnim1 * (deadAnimeTime - 0) / 40;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (deadAnimeTime &lt; 60) // やられアニメが始まって60フレーム目までは yAnim1 ～ yAnim2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim1 * (60 - deadAnimeTime) / 20 + yAnim2 * (deadAnimeTime - 40) / 20;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim2; // アニメ終了 到着 y位置をセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deadAnimeTime = 0; // 次にやられたときのアニメのため0リセットしておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 再開位置からゲーム再開(各数値もリセット)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = xStart, y = yStart, vx = 0, vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false, isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int deadAnimeStep = deadAnimeTime / 3; // 3で割って[チップのパラパラの]アニメの速度は弱める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int chipAnime = deadAnimeStep % 3; // % 3で余りを求めれば余りはチップのパラパラ番号は0～2の間に収まる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, yDeadAnim, 1.0f, 10.0f * deadAnimeStep / 360.0f * 2 * DX_PI, Image::playerChips[chipAnime], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++deadAnimeTime; // アニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, Image::playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, Image::playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 0.0f, Image::playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(x - camera_x + imgSizeX / 2, y - camera_y + imgSizeY / 2, 1.0f, 0.0f, Image::playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2; // DrawRotaGraphF関数は画像の真ん中が起点なので1/2ずらした位置計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 地形マップを[ 行のfor文×列のfor文 ]の2重ループで描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0, ySize = mapData.size(); cellY &lt; ySize; ++cellY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0, xSize = mapData[cellY].size(); cellX &lt; xSize; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[cellY][cellX]; // [行][列] の位置のcsvの地形番号(チップ番号)を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id &lt; 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップチップを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto mapXY = std::make_pair(cellX, cellY);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x - camera_x + rotaShiftX, chip_y - camera_y + rotaShiftY, 1.0f, 0.0f, Image::mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ((int)BlockBit::Bounce &amp; blockBits[id])<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yBase = chip_y - camera_y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim0 = yBase - 10, yAnim1 = yBase; // yAnim0 から yAnim1の位置までアニメする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int blockTime = blockAnime[mapXY];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim = yAnim0 * (15 - blockTime) / 15 + yAnim1 * blockTime / 15;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawRotaGraphF(chip_x - camera_x + rotaShiftX, yAnim + rotaShiftY, 1.0f, 0.0f, Image::mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++blockAnime[mapXY]; // アニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockTime > 15) // アニメ終了時間を15フレーム目とするとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime.erase(mapXY); // 辞書からアニメをerase関数で取り除く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ]用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawString(chip_x - camera_x, chip_y - camera_y, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たり判定の四隅を赤枠で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawBox(getLeft(x) - camera_x, getTop(y) - camera_y, getRight(x) - camera_x, getBottom(y) - camera_y, GetColor(255, 0, 0), FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] キャラ原点(x,y)を緑丸で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;DrawCircle(x - camera_x, y - camera_y, 2, GetColor(0, 255, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たった際の行き過ぎの めりこみ座標(debug_x,debug_y) を青線で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_x != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(debug_x - camera_x, debug_x_yTop - camera_y, debug_x - camera_x, debug_x_yBottom - camera_y, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_y != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DrawLine(debug_y_xLeft - camera_x, debug_y - camera_y, debug_y_xRight - camera_x, debug_y - camera_y, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
      <br>
      <br>
      いかがでしょう、動作は変わりませんが、きちんと<b>Soundクラスを通して</b>音声ロード処理をできるようになりましたか？<br>
      <br>
      <br>
      <br>
<br>
    <h1><a id="mozTocId0020" class="mozTocH1"></a>Cameraの描画ずらし処理をclass分けしてファイル分けしてさらにズーム機能を付加するプログラム</h1>
<br>
      <br>
      <p>まずはカメラのxとy座標をまとめて扱うためにVector2クラスを準備しましょう。</p>
    <p><code>Vector2.hを新規作成</code>します。</p>
    <p class="source">#ifndef VECTOR2_H_<br>
      #define VECTOR2_H_<br>
      <br>
      #include &lt;array&gt; // 有限個数配列。生配列[]より便利な機能がある(.size()関数とかが使える)<br>
      #include &lt;cmath&gt;<br>
      #include &lt;limits&gt; // 無限大∞をstd::numeric_limits&lt;float&gt;::infinity()のように使う<br>
      <br>
      //【注意】std::vectorとは全く違う。数学で習う【ベクトル】です。ごっちゃにしないで。<br>
      <br>
      //★【UnityのVector演算コード】https://github.com/Unity-Technologies/UnityCsReference/blob/02d565cf3dd0f6b15069ba976064c75dc2705b08/Runtime/Export/Math/Vector3.cs<br>
      //★【UnityのMath演算コード】https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Math/Mathf.cs<br>
      <br>
      // 2変数x,yを持つ構造体。2つの数字をまとめて扱うならXY座標以外にも使える。x,y別々に足したり引いたり定義したり面倒でしょう。<br>
      struct Vector2<br>
      {<br>
      &nbsp;&nbsp;union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      &nbsp;&nbsp; &nbsp;struct { // [参考ビットサイズ] https://marycore.jp/prog/c-lang/data-type-ranges-and-bit-byte-sizes/<br>
      &nbsp;&nbsp; &nbsp;float x;<br>
      &nbsp;&nbsp; &nbsp;float y;<br>
      &nbsp;&nbsp;}; //[匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp;std::array&lt;float, 2&gt; xy; // float xy[2];と同じ意味 float 2個ぶんのデータサイズでx,y 2個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp;}; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y分けて記述するの面倒なとき配列xy[2]をfor文i=0～2で回せる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Vector2() = default; // デフォルト初期化コンストラクタ<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 初期化コンストラクタ<br>
      &nbsp;&nbsp;Vector2(float x, float y = 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;this-&gt;xy = { x,y };// たった1行で書ける<br>
      &nbsp;&nbsp; &nbsp;//this-&gt;x = x;<br>
      &nbsp;&nbsp; &nbsp;//this-&gt;y = y; 2行が上のxyの様にたった1行で書けるようになる<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
      &nbsp;&nbsp;static const Vector2 zero;// = { 0.f,  0.f };<br>
      &nbsp;&nbsp;static const Vector2 one; // = { 1.f,  1.f };<br>
      &nbsp;&nbsp;static const Vector2 up;  // = { 0.f,  1.f };<br>
      &nbsp;&nbsp;static const Vector2 down;// = { 0.f, -1.f };<br>
      &nbsp;&nbsp;static const Vector2 left; // = { -1.f, 0.f };<br>
      &nbsp;&nbsp;static const Vector2 right;// = { 1.f, 0.f };<br>
      &nbsp;&nbsp;//[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
      &nbsp;&nbsp;static const Vector2 negativeInfinity;// = { -std::numeric_limits&lt;float&gt;::infinity(), .. };<br>
      &nbsp;&nbsp;//[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
      &nbsp;&nbsp;static const Vector2 positiveInfinity;// = { std::numeric_limits&lt;float&gt;::infinity(), .. };<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 2つのベクトルの内積<br>
      &nbsp;&nbsp;static float dot(const Vector2&amp; leftVec, const Vector2&amp; rightVec)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;return leftVec.x * rightVec.x + leftVec.y * rightVec.y; //普通にx同士,y同士掛けるだけ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 2つのベクトルの外積<br>
      &nbsp;&nbsp;static float cross(const Vector2&amp; leftVec, const Vector2&amp; rightVec)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;return leftVec.x * rightVec.y - leftVec.y * rightVec.x;// 外積のたすき掛け<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [static版]ベクトルの長さの2乗(0から点(x,y)までの距離)(平方根しないぶん計算速い)<br>
      &nbsp;&nbsp;static float _sqrMagnitude(const Vector2&amp; _vec)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;return _vec.x * _vec.x + _vec.y * _vec.y; // x*x + y*y<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [static版]ベクトルの長さ(0から点(x,y)までの距離)<br>
      &nbsp;&nbsp;static float _magnitude(const Vector2&amp; _vec)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;return std::sqrt(_sqrMagnitude(_vec)); // √x*x + y*y<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// destArrayにデータを保管しておく<br>
      &nbsp;&nbsp;Vector2&amp; copyToArray(std::array&lt;float, 2&gt;&amp; destArray)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;destArray = this-&gt;xy;//配列としてコピー<br>
      &nbsp;&nbsp; &nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// sourceArray配列からVector3データを生成<br>
      &nbsp;&nbsp;Vector2 fromArray(std::array&lt;float, 2&gt;&amp; sourceArray)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;return Vector2{ sourceArray[0], sourceArray[1] }; //配列から初期化<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ベクトルの長さの2乗(0から点(x,y)までの距離)(平方根しないぶん計算速い)<br>
      &nbsp;&nbsp;float sqrMagnitude()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;return x * x + y * y; // x*x + y*y<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ベクトルの長さ(0から点(x,y)までの距離)<br>
      &nbsp;&nbsp;float magnitude()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;return std::sqrt(x * x + y * y); // √(x*x + y*y)<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 正規化したベクトルを返す<br>
      &nbsp;&nbsp;Vector2 normalized()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;float mag = magnitude();<br>
      &nbsp;&nbsp; &nbsp;if (mag &lt; 0.00001f) // ほぼ0ベクトルか？<br>
      &nbsp;&nbsp; &nbsp; &nbsp;return *this;<br>
      &nbsp;&nbsp; &nbsp;else<br>
      &nbsp;&nbsp; &nbsp; &nbsp;return Vector2{ x / mag, y / mag }; // x / |x|, y / |y|<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//-----　演算子オーバーロード　-----<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 逆ベクトル<br>
      &nbsp;&nbsp;Vector2 operator -()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;return Vector2{ -this-&gt;x, -this-&gt;y };<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// Vector同士の足し算 x,y個別に足し合わせる<br>
      &nbsp;&nbsp;Vector2 operator + (const Vector2 add_v2) const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;Vector2 v2; //★*thisじゃダメな理由 a = vec1 + vec2のとき vec1の数値が書き変わったらあかんから<br>
      &nbsp;&nbsp; &nbsp;v2.x = this-&gt;x + add_v2.x; //[コレはダメ] this-&gt;x = this-&gt;x + add_v3.x;<br>
      &nbsp;&nbsp; &nbsp;v2.y = this-&gt;y + add_v2.y;<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;return v2;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// Vector同士の引き算 x,y個別に引き合わせる<br>
      &nbsp;&nbsp;Vector2 operator - (const Vector2 minus_v2) const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;Vector2 v2;<br>
      &nbsp;&nbsp; &nbsp;v2.x = this-&gt;x - minus_v2.x;<br>
      &nbsp;&nbsp; &nbsp;v2.y = this-&gt;y - minus_v2.y;<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;return v2;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// Vector同士の割り算 x,y個別に割り合わせる(0.fでは割れないようにしてある)<br>
      &nbsp;&nbsp;Vector2 operator / (float divide_num) const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;if (divide_num == 0.0f)<br>
      &nbsp;&nbsp; &nbsp; &nbsp;return *this; // Vector2 v2;と定義せずreturnしたほうが無駄な定義処理がかからないぶん速い<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;Vector2 v2;<br>
      &nbsp;&nbsp; &nbsp;v2.x = this-&gt;x / divide_num;<br>
      &nbsp;&nbsp; &nbsp;v2.y = this-&gt;y / divide_num;<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;return v2;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Vector2&amp; operator += (const Vector2 add_v2)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;this-&gt;x += add_v2.x;<br>
      &nbsp;&nbsp; &nbsp;this-&gt;y += add_v2.y;<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;return *this; //*thisを返すことで v1 + v2 + v3みたく数珠繋ぎできる<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Vector2&amp; operator -= (const Vector2 minus_v2)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;this-&gt;x -= minus_v2.x;<br>
      &nbsp;&nbsp; &nbsp;this-&gt;y -= minus_v2.y;<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 代入演算子 x,yを全部 change_numに変える<br>
      &nbsp;&nbsp;Vector2&amp; operator = (float change_num)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;this-&gt;x = change_num;<br>
      &nbsp;&nbsp; &nbsp;this-&gt;y = change_num;<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp; &nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 一致演算子 x,yが全部一致するか 一つでも違えばfalse<br>
      &nbsp;&nbsp;bool operator == (const Vector2&amp; v2_other)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;if (this-&gt;x != v2_other.x) return false;<br>
      &nbsp;&nbsp; &nbsp;if (this-&gt;y != v2_other.y) return false;<br>
      &nbsp;&nbsp; &nbsp;return true;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 不一致演算子 x,yが全部不一致か 一つでも同じならfalse<br>
      &nbsp;&nbsp;bool operator != (const Vector2&amp; v2_other)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;if (this-&gt;x == v2_other.x) return false;<br>
      &nbsp;&nbsp; &nbsp;if (this-&gt;y == v2_other.y) return false;<br>
      &nbsp;&nbsp; &nbsp;return true;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;//---- 以下 DXライブラリ向けにVector3とDX版Vectorの変換方法を用意  ---------------<br>
      &nbsp;&nbsp;<br>
      // DXlibを#includeしていればDX_LIB_Hも定義済みなので下記関数も定義される VECTORはDXライブラリ版のVector3<br>
      #ifdef DX_LIB_H<br>
      &nbsp;&nbsp;// Vector3からDxLibのVECTORへの変換<br>
      &nbsp;&nbsp;VECTOR Vec2ToVec()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;VECTOR Result;<br>
      &nbsp;&nbsp; &nbsp;Result.x = this-&gt;x;<br>
      &nbsp;&nbsp; &nbsp;Result.y = this-&gt;y;<br>
      &nbsp;&nbsp; &nbsp;Result.z = 0.f;<br>
      &nbsp;&nbsp; &nbsp;return Result;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 左辺値がDXのVECTOR型のときの=代入対応<br>
      &nbsp;&nbsp;inline operator VECTOR() const<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;VECTOR Result;<br>
      &nbsp;&nbsp; &nbsp;Result.x = this-&gt;x;<br>
      &nbsp;&nbsp; &nbsp;Result.y = this-&gt;y;<br>
      &nbsp;&nbsp; &nbsp;Result.z = 0.f;<br>
      &nbsp;&nbsp; &nbsp;return Result;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 右辺値がDXのVECTOR型のときの=代入対応<br>
      &nbsp;&nbsp;Vector2 operator=(const VECTOR&amp; other)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;this-&gt;x = other.x;<br>
      &nbsp;&nbsp; &nbsp;this-&gt;y = other.y;<br>
      &nbsp;&nbsp; &nbsp;return *this;<br>
      &nbsp;&nbsp;}<br>
      #endif<br>
      &nbsp;&nbsp;<br>
      };<br>
      <br>
      // [inlineを利用することで.cppではなく.hにstatic関数を定義] https://theolizer.com/cpp-school1/cpp-school1-28/<br>
      //↓スカラー倍や割り算については他のようにメンバ関数とすると右側からしか掛け算できなくなるので以下のようにメンバ外で関数化する<br>
      <br>
      // Vectorとスカラの掛け算(スカラー×ベクトル) x,y個別に掛け合わせる<br>
      inline Vector2 operator * (float left, const Vector2&amp; right)<br>
      {<br>
      &nbsp;&nbsp;Vector2 v2;<br>
      &nbsp;&nbsp;v2.x = left * right.x;<br>
      &nbsp;&nbsp;v2.y = left * right.y;<br>
      &nbsp;&nbsp;return v2;<br>
      }<br>
      <br>
      // (右側から)Vectorとスカラの掛け算(ベクトル×スカラー) x,y個別に掛け合わせる<br>
      inline Vector2 operator * (const Vector2&amp; left, float right)<br>
      {<br>
      &nbsp;&nbsp;Vector2 v2;<br>
      &nbsp;&nbsp;v2.x = left.x * right;<br>
      &nbsp;&nbsp;v2.y = left.y * right;<br>
      &nbsp;&nbsp;return v2;<br>
      }<br>
      <br>
      // (左側から)Vectorとスカラの割り算(スカラー/ベクトル) x,y個別に割る<br>
      inline Vector2 operator / (float lhs, const Vector2&amp; rhs)<br>
      {<br>
      &nbsp;&nbsp;Vector2 v2;<br>
      &nbsp;&nbsp;v2.x = (rhs.x == 0.0f) ? lhs / rhs.x<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : (rhs.x &gt; 0) ? std::numeric_limits&lt;float&gt;::infinity() : -std::numeric_limits&lt;float&gt;::infinity();<br>
      &nbsp;&nbsp;v2.y = (rhs.y == 0.0f) ? lhs / rhs.y<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : (rhs.y &gt; 0) ? std::numeric_limits&lt;float&gt;::infinity() : -std::numeric_limits&lt;float&gt;::infinity();<br>
      &nbsp;&nbsp;return v2;<br>
      }<br>
      <br>
      // (右側から)Vectorとスカラの割り算(ベクトル/スカラー) x,y個別に割る<br>
      inline Vector2 operator / (const Vector2&amp; lhs, float rhs)<br>
      {<br>
      &nbsp;&nbsp;Vector2 v2;<br>
      &nbsp;&nbsp;if (rhs == 0.0f)<br>
      &nbsp;&nbsp;{	// 0で割ったら∞になる<br>
      &nbsp;&nbsp; &nbsp;v2.x = (lhs.x &gt; 0) ? std::numeric_limits&lt;float&gt;::infinity() : -std::numeric_limits&lt;float&gt;::infinity();<br>
      &nbsp;&nbsp; &nbsp;v2.y = (lhs.y &gt; 0) ? std::numeric_limits&lt;float&gt;::infinity() : -std::numeric_limits&lt;float&gt;::infinity();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;else<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;v2.x = lhs.x / rhs;<br>
      &nbsp;&nbsp; &nbsp;v2.y = lhs.y / rhs;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;return v2;<br>
      }<br>
      <br>
      #endif</p>
      <p><code>Vector2.cppも新規作成</code>します。</p>
    <p class="source">#include "Vector2.h"<br>
      <br>
      // Unityのstatic変数を参考に https://docs.unity3d.com/ja/current/ScriptReference/Vector3.html<br>
      Vector2 const Vector2::zero = Vector2(0.f, 0.f);<br>
      Vector2 const Vector2::one = Vector2(1.f, 1.f);<br>
      Vector2 const Vector2::up = Vector2(0.f, 1.f);<br>
      Vector2 const Vector2::down = Vector2(0.f, -1.f);<br>
      Vector2 const Vector2::left = Vector2(-1.f, 0.f);<br>
      Vector2 const Vector2::right = Vector2(1.f, 0.f);<br>
      //[負の値の最小値] https://stackoverflow.com/questions/20016600/negative-infinity<br>
      Vector2 const Vector2::negativeInfinity = Vector2(-std::numeric_limits&lt;float&gt;::infinity(), -std::numeric_limits&lt;float&gt;::infinity());<br>
      //[極大値]https://cpprefjp.github.io/reference/limits/numeric_limits/lowest.html<br>
      Vector2 const Vector2::positiveInfinity = Vector2(std::numeric_limits&lt;float&gt;::infinity(), std::numeric_limits&lt;float&gt;::infinity());<br>
      <br>
    </p>
    上記Vector2クラスを使って次はカメラのクラスをつくります。<br>
    <p>つぎにCameraクラスを作ってみましょう。</p>
    <p><code>Camera.hを新規作成</code>します。</p>
    <p class="source">#ifndef CAMERA_H_<br>
      #define CAMERA_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "Vector2.h"<br>
      <br>
      #include &lt;unordered_map&gt; // 高速辞書配列(複数のカメラを管理するために使う)<br>
      #include &lt;memory&gt; // 回し読みポインタstd::shared_ptrを使う<br>
      #include &lt;string&gt;<br>
      <br>
      // [カメラ]画面のスクロール量を管理して描くときにそのスクロールぶんずらして描くクラス<br>
      class Camera<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Vector2 pos{ 0, 0 }; // カメラの位置 画面左上のワールド座標を表す<br>
      &nbsp;&nbsp;Vector2 leftTop{ 0, 0 }; // 描くときのの起点位置<br>
      &nbsp;&nbsp;float zoomRatio = 1.0f; // 拡大率(2.0fにするとカメラのDraw系関数を通したものを2.0f倍で描く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::string tag{ "" }; // カメラを管理するタグ(プレイヤカメラ1など名前をつけてタグ検索できるように)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [static変数] Camera::list["プレイヤ1"]などカメラ辞書配列にタグをつけてリンクを保持<br>
      &nbsp;&nbsp;static std::unordered_map&lt;std::string, std::shared_ptr&lt;Camera&gt;&gt; list;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [static関数]カメラを管理する辞書をクリア<br>
      &nbsp;&nbsp;static void clear() { std::unordered_map&lt;std::string, std::shared_ptr&lt;Camera&gt;&gt;().swap(list); }<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [static関数]カメラを辞書から1つ消す(tagと辞書のタグが一致するものを辞書から消す、共有ポインタなのでカメラの実態も道連れにメモリから消える)<br>
      &nbsp;&nbsp;static void erase(std::string&amp; tag) { list.erase(tag); }<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 初期化コンストラクタ<br>
      &nbsp;&nbsp;Camera(const std::string&amp tag, Vector2 pos, float zoomRatio = 1.0f)<br>
      &nbsp;&nbsp; &nbsp;: pos{ pos }, zoomRatio{ zoomRatio }, tag{ tag } {}<br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;virtual ~Camera() {} // 破棄デストラクタ<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [関数]指定されたワールド座標が画面の中心に来るように、カメラの位置を変更する<br>
      &nbsp;&nbsp;void LookAt(Vector2 pos) { LookAt(pos.x,pos.y); }<br>
      &nbsp;&nbsp;// [関数]指定されたワールド座標が画面の中心に来るように、カメラの位置を変更する<br>
      &nbsp;&nbsp;void LookAt(float targetX, float targetY = Screen::Height / 2);<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [関数]画像を描画(回転と個別ズームも可能)<br>
      &nbsp;&nbsp;inline int DrawRotaGraphF(float worldX, float worldY, double ExRate, double Angle, int GrHandle, int TransFlag = TRUE)<br>
      &nbsp;&nbsp;{ &nbsp; // カメラのx,yぶんだけマイナスして描く起点をずらして描くことでスクロールさせる(ズームにあわせ左上leftTopのx,yぶんもずらす)<br>
      &nbsp;&nbsp; &nbsp;if (zoomRatio == 1.0f)<br>
      &nbsp;&nbsp; &nbsp; &nbsp;return DxLib::DrawRotaGraphF(worldX - pos.x, worldY - pos.y, ExRate, Angle, GrHandle, TRUE);<br>
      &nbsp;&nbsp; &nbsp;else<br>
      &nbsp;&nbsp; &nbsp;return DxLib::DrawRotaGraphF((worldX - pos.x) * zoomRatio + leftTop.x, (worldY - pos.y) * zoomRatio + leftTop.y,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ExRate * zoomRatio, Angle, GrHandle, TRUE);<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [関数]文字列を描画<br>
      &nbsp;&nbsp;inline int DrawString(float worldX, float worldY, const TCHAR* String, unsigned int Color, unsigned int EdgeColor DEFAULTPARAM(= 0))<br>
      &nbsp;&nbsp;{ &nbsp; // カメラのx,yぶんだけマイナスして描く起点をずらして描くことでスクロールさせる(ズームにあわせ左上leftTopのx,yぶんもずらす)<br>
      &nbsp;&nbsp; &nbsp;if (zoomRatio == 1.0f)<br>
      &nbsp;&nbsp; &nbsp; &nbsp;return DxLib::DrawString((int)(worldX - pos.x), (int)(worldY - pos.y), String, Color);<br>
      &nbsp;&nbsp; &nbsp;else<br>
      &nbsp;&nbsp; &nbsp; &nbsp;return DxLib::DrawExtendString((int)(worldX - pos.x) * zoomRatio + leftTop.x, (int)(worldY - pos.y) * zoomRatio + leftTop.y,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;zoomRatio, zoomRatio, String, Color, EdgeColor);<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [関数]四角形をカメラの(pox.x,pos.y)ぶんずらして描画する<br>
      &nbsp;&nbsp;inline int DrawBox(float xLeft, float yTop, float xRight, float yBottom, unsigned int Color, int FillFlag)<br>
      &nbsp;&nbsp;{ &nbsp; // カメラの(pox.x,pos.y)ぶんずらして描画(ズームにあわせ左上leftTopのx,yぶんもずらす)<br>
      &nbsp;&nbsp; &nbsp;if (zoomRatio == 1.0f)<br>
      &nbsp;&nbsp; &nbsp; &nbsp;return DxLib::DrawBox((int)(xLeft - pos.x + 0.5f), (int)(yTop - pos.y + 0.5f),<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(int)(xRight - pos.x + 0.5f), (int)(yBottom - pos.y + 0.5f), Color, FillFlag);<br>
      &nbsp;&nbsp; &nbsp;else<br>
      &nbsp;&nbsp; &nbsp; &nbsp;return DxLib::DrawBox((int)(xLeft - pos.x + 0.5f) * zoomRatio + leftTop.x, (int)(yTop - pos.y + 0.5f) * zoomRatio + leftTop.y,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(int)(xRight - pos.x + 0.5f) * zoomRatio + leftTop.x, (int)(yBottom - pos.y + 0.5f) * zoomRatio + leftTop.y, Color, FillFlag);<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [関数]円形をカメラの(pox.x,pos.y)ぶんずらして描画する<br>
      &nbsp;&nbsp;inline int DrawCircle(int x, int y, int r, unsigned int Color, int FillFlag DEFAULTPARAM(= TRUE), int LineThickness DEFAULTPARAM(= 1))<br>
      &nbsp;&nbsp;{ &nbsp; // カメラの(pox.x,pos.y)ぶんずらして描画(ズームにあわせ左上leftTopのx,yぶんもずらす)<br>
      &nbsp;&nbsp; &nbsp;if (zoomRatio == 1.0f)<br>
      &nbsp;&nbsp; &nbsp; &nbsp;return DxLib::DrawCircle(x - pos.x, y - pos.y, r, Color, FillFlag, LineThickness);<br>
      &nbsp;&nbsp; &nbsp;else<br>
      &nbsp;&nbsp; &nbsp; &nbsp;return DxLib::DrawCircle((x - pos.x) * zoomRatio + leftTop.x, (y - pos.y) * zoomRatio + leftTop.y,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;r * zoomRatio, Color, FillFlag, LineThickness);<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [関数]直線をカメラの(pox.x,pos.y)ぶんずらして描画する<br>
      &nbsp;&nbsp;inline int DrawLine(int xStart, int yStart, int xEnd, int yEnd, unsigned int Color, int Thickness DEFAULTPARAM(= 1))<br>
      &nbsp;&nbsp;{ &nbsp; // カメラの(pox.x,pos.y)ぶんずらして描画(ズームにあわせ左上leftTopのx,yぶんもずらす)<br>
      &nbsp;&nbsp; &nbsp;if (zoomRatio == 1.0f)<br>
      &nbsp;&nbsp; &nbsp; &nbsp;return DxLib::DrawLine(xStart - pos.x, yStart - pos.y, xEnd - pos.x, yEnd - pos.y, Color, Thickness);<br>
      &nbsp;&nbsp; &nbsp;else<br>
      &nbsp;&nbsp; &nbsp; &nbsp;return DxLib::DrawLine((xStart - pos.x) * zoomRatio + leftTop.x, (yStart - pos.y) * zoomRatio + leftTop.y,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (xEnd - pos.x) * zoomRatio + leftTop.x, (yEnd - pos.y) * zoomRatio + leftTop.y, Color, Thickness);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      #endif</p>
    <p><code>Camera.cppも新規作成</code>して<b>[static変数]を.cppファイルに クラスの{}の外側に 定義 (int型以外のstatic変数では必須)</b>します。</p>
    <p class="source">#include "Camera.h"<br>
      <br>
      std::unordered_map&lt;std::string, std::shared_ptr&lt;Camera&gt;&gt; Camera::list; // カメラの辞書&lt;タグ,カメラの共有ポインタ&gt;<br>
      <br>
      void Camera::LookAt(float targetX, float targetY)<br>
      {&nbsp; // 描画起点をずらす量がここに計算される<br>
      &nbsp;&nbsp;float halfWidth = (float)Screen::Width / 2.0f;<br>
      &nbsp;&nbsp;float halfHeight = (float)Screen::Height / 2.0f;<br>
      &nbsp;&nbsp;pos.x = targetX - halfWidth; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;pos.y = targetY - halfHeight; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;if (zoomRatio != 1.0f)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp; &nbsp;leftTop.x = halfWidth - halfWidth * zoomRatio;<br>
      &nbsp;&nbsp; &nbsp;leftTop.y = halfHeight - halfHeight * zoomRatio;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;if (pos.x &lt;= 0) pos.x = 0; // マップの端ではカメラスクロール止める<br>
      &nbsp;&nbsp;if (pos.y &lt;= 0) pos.y = 0; // マップの端ではカメラスクロール止める<br>
      }<br>
      <br>
    </p>
    <p><code>main.cpp</code>を編集してカメラで描く起点をずらす処理(とズーム処理)をCameraクラスを使ってするようにします：</p>
    <p class="source">#include "DxLib.h"<br>
      #include &lt;assert.h&gt;&nbsp;// 画像読み込みの読込み失敗表示用<br>
      #include "Screen.h"<br>
      #include "Input.h"<br>
      #include "Image.h"<br>
      #include "Sound.h"<br>
      <em>#include "Camera.h"</em><br>
      <br>
      #include &lt;vector&gt;&nbsp;// csvを2次元vector配列に格納<br>
      #include &lt;string&gt;&nbsp;// 文字列std::stringに必要<br>
      #include &lt;fstream&gt;&nbsp;// ファイル読み出しstd::ifstreamに必要<br>
      #include &lt;sstream&gt;&nbsp;// 文字列ストリームに必要 ss &gt;&gt; num;で文字列から数字に変換できる<br>
      #include &lt;unordered_map&gt;&nbsp;// std::unordered_map 高速辞書配列に必要(チップ番号から壁などを表すビットへ変換する辞書)<br>
      #include &lt;utility&gt;&nbsp;// std::pair(データのペア型)を使うのに必要<br>
      // [ペアを高速辞書のキーにするためハッシュ関数が必要] https://qiita.com/hamamu/items/4d081751b69aa3bb3557<br>
      template&lt;class TypeT&gt; size_t HashCombine(const size_t seed, const TypeT&amp; value)<br>
      {<br>
      &nbsp;&nbsp;return seed ^ (std::hash&lt;TypeT&gt;()(value) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2));<br>
      }<br>
      <br>
      // pair型に()をつけたときに呼び出される処理をoperator()で定義してreturnでハッシュ関数を返す<br>
      template&lt;class TypeT, class TypeS&gt;<br>
      struct std::hash&lt;std::pair&lt;TypeT, TypeS&gt;&gt;<br>
      {<br>
      &nbsp;&nbsp;size_t operator() (const std::pair&lt;TypeT, TypeS&gt;&amp; keyval) const noexcept<br>
      &nbsp;&nbsp;{ &nbsp; // returnでハッシュ関数を返すことで高速辞書のキーとして認め許されるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return HashCombine(std::hash&lt;TypeT&gt;()(keyval.first), keyval.second);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;// 画面モードの設定<br>
      &nbsp;&nbsp;SetGraphMode(Screen::Width, Screen::Height, 32 ) ; // 画面サイズをScreenクラスに合わせて設定してカラービット数32ビットで起動<br>
      &nbsp;&nbsp;SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズをScreenクラスに合わせて設定(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;SetMainWindowText("ゲームのウィンドウ名を変えるときはここ");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;//↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;// ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ゲームのwhileループを開始する前の初期化処理<br>
      &nbsp;&nbsp;Image::Load(); // 画像ファイルを事前読み込み<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Sound::Load(); // 音声ファイルを事前読み込み<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::vector&lt;std::vector&lt;int&gt;&gt; mapData;// タイルマップデータ<br>
      &nbsp;&nbsp;std::ifstream ifs_csv_file("Map/stage.csv"); // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int Width = 0, Height = 0; // マップデータの横(Width) 縦(Height)のマスの数<br>
      &nbsp;&nbsp;int MaxWidth = 0; // 1行の数字の最大個数<br>
      &nbsp;&nbsp;std::string line; // 1行単位ごとにcsvファイルから文字列をstd::getlineで読み込んで受け取る<br>
      &nbsp;&nbsp;while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; valuelist; // 1行ぶんの数字リスト配列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::istringstream linestream( line ); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;std::string comma_part; // カンマで分割された文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int widthCount = 0; // カンマで区切られた行の数字の数(各行の幅)をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (std::getline(linestream, comma_part, { ',' })) // 1行をgetlineでカンマで区切って列を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istringstream ss( comma_part ); // カンマで区切られた文字をssを通して&gt;&gt;で数字に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss &gt;&gt; num; // 文字列ストリーム&gt;&gt;で数字へ変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valuelist.emplace_back(num); // 数字をこの行のリスト(valuelist)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++widthCount; //この行のカンマで区切られた数字の数をカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行の数字の数がMAX記録を更新するかチェック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (widthCount &gt; MaxWidth)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxWidth = widthCount; // 暫定Maxの列の幅を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 1行ぶんの数字の配列をとりまとめてmapDataに1行ずつ追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (valuelist.size() != 0) // 配列に数字が1つでもあるなら.size() != 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData.emplace_back(valuelist); // mapDataに1行ずつ数字配列valuelistを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;++Height; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;Width = MaxWidth; // マップの幅Widthは一番数字の個数の多かった行に合わせる<br>
      &nbsp;&nbsp;// ↓読込んだCSVの幅と高さをチェック<br>
      &nbsp;&nbsp;assert(Width &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;assert(Height &gt; 0 &amp;&amp; "マップ読込み失敗ファイル名間違い、もしくはMapフォルダにファイルがないのでは?" != "");<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float xStart = 200, yStart = Screen::Height - 100; // キャラの初期スタート(ミス後の再開位置)<br>
      &nbsp;&nbsp;float x = xStart, y = yStart; // 初期位置<br>
      &nbsp;&nbsp;float yJumpStart = 0; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float vx = 0, vy = 0; // プレイヤの速度<br>
      &nbsp;&nbsp;enum class Direction { Left, Right }; // enumでキャラの向いてる方向をDirection型として2種類(LeftとRight)定義<br>
      &nbsp;&nbsp;Direction direction = Direction::Right; // キャラの向いてる方向<br>
      &nbsp;&nbsp;int animeTime = 0; // アニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;bool isDead = false; // キャラがやられたかどうか<br>
      &nbsp;&nbsp;int deadAnimeTime = 0; // やられたときのアニメ時間<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;bool isSwitchOn = false; // ステージ全体のスイッチのオン、オフ状態(オンのときはオンを押せないようにする)<br>
      &nbsp;&nbsp;int id_On = 10, id_Off = 11; // オンのときにオンを押したりオフのときにオフを押せないように判定する<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int vx_idx = 0; // 横方向の加速の段階<br>
      &nbsp;&nbsp;float vxSpeedMax = 15; // X左右方向の限界速度<br>
      &nbsp;&nbsp;float vyJumpSpeed[] = { 14, 15, 16, 4 }, vyDownSpeedMax[] = { 16, 16, 16, 8 }; // ダッシュ段階に応じた複数のジャンプの上昇と降下スピードのリミット<br>
      &nbsp;&nbsp;float vyForce = 0;<br>
      &nbsp;&nbsp;float vyForceJump[] = { 0.5f,0.4f,0.3f,0.1f }, vyGravity[] = { 0.8f,0.8f,0.8f,0.8f }; // ダッシュ段階に応じた複数のパラメータを持つように<br>
      &nbsp;&nbsp;bool isGround = true; // 着地しているか<br>
      &nbsp;&nbsp;bool isFlying = false; // 飛行モード<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int imgSizeX, imgSizeY; // 画像の縦横サイズ<br>
      &nbsp;&nbsp;GetGraphSize(Image::playerChips[0], &amp;imgSizeX, &amp;imgSizeY); // GetGraphSize関数で画像の縦横を得られる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;int hitOffsetLeft = 2; // 当たり判定の左端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetRight = 2; // 当たり判定の右端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetTop = 1; // 当たり判定の上端のオフセット<br>
      &nbsp;&nbsp;int hitOffsetBottom = 0; // 当たり判定の下端のオフセット<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 当たり判定のはしっこを計算するための一時関数<br>
      &nbsp;&nbsp;auto getLeft  = [&amp;hitOffsetLeft](float worldX) { return worldX + hitOffsetLeft; };<br>
      &nbsp;&nbsp;auto getTop   = [&amp;hitOffsetTop](float worldY) { return worldY + hitOffsetTop; };<br>
      &nbsp;&nbsp;auto getRight  = [&amp;hitOffsetRight, &amp;imgSizeX](float worldX) { return worldX + imgSizeX - hitOffsetRight; };<br>
      &nbsp;&nbsp;auto getBottom = [&amp;hitOffsetBottom, &imgSizeY](float worldY) { return worldY + imgSizeY - hitOffsetBottom; };<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;enum class BlockBit // ブロックの特性を32桁のビットで表現<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None = 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Wall &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Damage = 0b0000'0000'0000'0000'0000'0000'0000'0010,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Bounce = 0b0000'0000'0000'0000'0000'0000'0000'0100, // 叩くと弾むブロック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Change = 0b0000'0000'0000'0000'0000'0000'0000'1000, // 叩くとブロックの種類が変わる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Switch = 0b0000'0000'0000'0000'0000'0000'0001'0000, // スイッチを叩くと赤ブロックや青ブロックの無効⇔有効が切替<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, unsigned int&gt; blockBits = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{-1,(int)BlockBit::None},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 0,(int)BlockBit::Wall},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 1,(int)BlockBit::Damage},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 2,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Change}, // 壁 | はずむ | ブロック変化 (|ビット論理和)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 3,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Change},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{10,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Switch}, // 赤Onスイッチ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{11,(int)BlockBit::Wall | (int)BlockBit::Bounce | (int)BlockBit::Switch}, // 青Offスイッチ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{12,(int)BlockBit::Wall}, // On に連動するブロック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{14,(int)BlockBit::Wall}, // Offに連動するブロック<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ブロックをバウンドさせるための 高速辞書&lt;ペア&lt;cellX,cellY&gt;, intアニメ時間&gt;<br>
      &nbsp;&nbsp;std::unordered_map&lt;std::pair&lt;int, int&gt;, int&gt; blockAnime;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, int&gt; blockChange = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{  2,  3 }, // 叩くと 2 → 3 にかわる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{  3, -1 }, // 叩くと 3 → -1 にかわる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 12, 13 }, // 11(OFF) を押すと 12→13<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 13, 12 }, // 10(ON)  を押すと 13→12<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 14, 15 }, // 10(ON)  を押すと 14→15<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 15, 14 }, // 11(OFF) を押すと 15→14<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; blockSwitch = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 10, {12,13,14,15} }, // 叩くと12,13,14,15がblockChangeの設定内容に応じて変化する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{ 11, {12,13,14,15} },<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 指定された座標(worldX,worldY)の地形が 壁 や ダメージブロックかなどをチェックする一時関数<br>
      &nbsp;&nbsp;auto checkID = [&amp;blockBits, &amp;CellSize](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain, float worldX, float worldY,<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int terrainID = -1; // 指定された座標の地形のID<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (worldX &lt; 0 || worldY &lt; 0) return false; // 負の座標が指定された場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = (int)(worldX / CellSize), mapY = (int)(worldY / CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 二次元配列の範囲内か判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapY &lt; terrain.size() &amp;&amp; mapX &lt; terrain[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terrainID = terrain[mapY][mapX]; // 二次元配列から地形IDを取り出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool isCheckBit = (((int)checkBit) &amp; blockBits[terrainID]) != 0; // ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isCheckBit &amp;&amp; pMapX != nullptr &amp;&amp; pMapY != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pMapX = mapX, *pMapY = mapY; // ブロックのcsvのセル番号をポインタに記録(nullptrの場合は記録しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return isCheckBit;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;enum class HitPart // 当たった箇所を表すビット<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;None &nbsp; &nbsp;= 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Left &nbsp; &nbsp;= 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Right &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0010,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Top &nbsp; &nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0100,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Bottom &nbsp;= 0b0000'0000'0000'0000'0000'0000'0000'1000,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;XMiddle = 0b0000'0000'0000'0000'0000'0000'0001'0000,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;YMiddle = 0b0000'0000'0000'0000'0000'0000'0010'0000,<br>
      &nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [x方向左右]地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheckX = [&amp;checkID](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Top; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yMiddle, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::YMiddle; // 左中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Bottom; // 左下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 右端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Top; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yMiddle, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::YMiddle; // 右中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Bottom; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [y方向上下]地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheckY = [&amp;checkID](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Top; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xMiddle, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::XMiddle | (int)HitPart::Top; // 中上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Top; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xLeft, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Left | (int)HitPart::Bottom; // 左下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xMiddle, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::XMiddle | (int)HitPart::Bottom; // 中下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(checkBit, terrain, xRight, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::Right | (int)HitPart::Bottom; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;auto hitcheck = [&amp;hitcheckX, &amp;hitcheckY](BlockBit checkBit, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; terrain,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return hitcheckX(checkBit,terrain,xLeft,xMiddle,xRight,yTop,yMiddle,yBottom,pMapX,pMapY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| hitcheckY(checkBit,terrain,xLeft,xMiddle,xRight,yTop,yMiddle,yBottom,pMapX,pMapY);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<em>// カメラをmake_sharedで共有生成して Camera::list 辞書配列 に"プレイヤ0"というタグをつけて保持<br>
      &nbsp;&nbsp;Camera::list["プレイヤ0"] = std::make_shared&lt;Camera&gt;("プレイヤ0", Vector2(x,y), 1.0f); // ズーム率初期値1.0f<br>
      &nbsp;&nbsp;auto pCamera = Camera::list["プレイヤ0"]; // タイルをスクロールして描くカメラへの共有リンクを得る</em><br>
      &nbsp;&nbsp;pCamera->LookAt(x, y); // プレイヤのキャラ(x,y)位置を中心に追跡スクロール<br>
      &nbsp;&nbsp;int zoomAnimCount = 0; // ジャンプした時のズームアウトアニメのカウンタ</em><br>
      &nbsp;&nbsp;<u>float camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Width * CellSize - Screen::Width &lt;= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;float camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ</u><br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;float debug_x = -1, debug_y = -1; // [デバッグ] めり込みすぎのラインを記録しておく変数<br>
      &nbsp;&nbsp;float debug_x_yTop = -1, debug_x_yBottom = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の上下端も記録<br>
      &nbsp;&nbsp;float debug_y_xLeft = -1, debug_y_xRight = -1; // [デバッグ] カメラが動くのでめり込んだ瞬間の左右端も記録<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;Input::Init(); // Inputクラスの初期化<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;ScreenFlip();<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;while (ProcessMessage() == 0)<br>
      &nbsp;&nbsp;{&nbsp;&nbsp;// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Input::Update(); // Inputの更新(これを毎ターンやらないとキーの状態が変わらず反応しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_LEFT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Left;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt; 0) vx = 0; // 急ブレーキ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &gt;= -vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += -0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButton(PAD_INPUT_RIGHT))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = Direction::Right;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt; 0) vx *= 0.9; // すべりながら減衰ブレーキ表現(vxは9/10ずつ減少する)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx &lt;= vxSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx += 0.35f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 飛行モード中にZキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; Input::GetButtonDown(PAD_INPUT_A))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 3; // [3]番には飛行中のパラメータが入ってる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // 押すたび少し羽ばたく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(Sound::jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Input::GetButtonDown(PAD_INPUT_A)) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0; // 加速の段階をリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float vx_abs = (vx &lt; 0) ? -vx : vx; // absはvxの絶対値(マイナスなら-をつけてプラスに直す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 6) ++vx_idx; // 一定値を超えるごとに加速段階を+1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) ++vx_idx; // 最大0～2段階まで +1ずつされる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (vx_abs &gt; 9) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = true; // 飛行モードにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 加速段階に応じて違うジャンプ音を鳴らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlaySoundMem(Sound::jumpSE[vx_idx], DX_PLAYTYPE_BACK);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = -vyJumpSpeed[vx_idx]; // ジャンプ方向はY上方向(マイナス方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyForceJump[vx_idx]; // 上昇フェーズ中の下方向へ引っ張られる力(この行がないと際限なくジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yJumpStart = y; // ジャンプ開始する瞬間のy位置を保管する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (vy &gt;= 0) // 下落開始(vy &lt; 0のときはまだジャンプ上昇の勢いありvy==0を境に勢いは逆方向に)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Input::GetButtonUp(PAD_INPUT_A)) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (yJumpStart - y &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vyForce = vyGravity[vx_idx]; // ジャンプ上昇中(vy &lt; 0のとき)にボタンを離したら早めに重力をかけ始める(小ジャンプ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは移動を停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += vx; // 速度のぶん現在の位置から移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは当たり判定も停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(hitcheck(BlockBit::Damage, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // やられたフラグをtrueに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 左端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yMiddle) || // 左中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) )  // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xLeft; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// std::fmodで小数点の余りを計算 めり込みすぎの余り = std::fmod(xLeft, CellSize)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallRight = xLeft + CellSize - (float)std::fmod(xLeft, CellSize); // 壁の右端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallRight - hitOffsetLeft; // 左端を壁の右端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓右端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) || // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yMiddle) || // 右中が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x = xRight; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_x_yTop = y - Screen::Height / 2, debug_x_yBottom = y + Screen::Height / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallLeft = xRight - (float)std::fmod(xRight, CellSize); // 壁の左端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = wallLeft + hitOffsetRight - imgSizeX; // 右端を壁の左端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは移動を停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!isDead) // やられたときは当たり判定も停止<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当たり判定の四隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xLeft = getLeft(x) + 0.01f, xRight = getRight(x) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yTop = getTop(y) + 0.01f, yBottom = getBottom(y) - 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float xMiddle = xLeft + (getRight(x) - getLeft(x)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiddle = yTop + (getBottom(y) - getTop(y)) / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (hitcheck(BlockBit::Damage, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = true; // やられたフラグをtrueに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int mapX = 0, mapY = 0; // ぶつかったらそのブロックのCSVのセルの行mapYと列mapXを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Bounce, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;int,int&gt; mapXY = std::make_pair(mapX, mapY); // ぶつかったブロックのセルの行mapYと列mapXのペア<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) == 0) // 辞書にキーがあるかcountで数えて未登録==0のとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime[mapXY] = 0; // ブロックのアニメ時間を辞書に登録(時間が辞書にあるものだけアニメが走る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Switch, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[mapY][mapX]; // 行mapY 列mapXの地形idを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((isSwitchOn &amp;&amp; id == id_Off || !isSwitchOn &amp;&amp; id == id_On) &amp;&amp; blockSwitch.count(id) &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isSwitchOn = !isSwitchOn; // trueとfalseを!で反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0; cellY &lt; Height; ++cellY) // 行をすべて調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0; cellX &lt; Width; ++cellX) // 列をすべて調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (auto switchID : blockSwitch[id]) // スイッチに反応するブロックのIDすべてを調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapData[cellY][cellX] == switchID)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData[cellY][cellX] = blockChange[switchID]; // 変化先のIDへ書き換える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; // 次の列のループへ移る(3重for文の一番内側のループをbreakして1つ外のループへ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool isBlockChanging = false; // ブロック変化フラグ(idはあとから変化させないとWallの押し戻しの跳ね返りvy = 0がなくなる)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (int)HitPart::Top<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&amp; hitcheck(BlockBit::Change, mapData, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, &amp;mapX, &amp;mapY))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isBlockChanging = true; // ここではフラグをtrueにするだけ(めり込み押し戻しvy=0するまえにid=-1にすると壊した瞬間にすり抜けちゃう)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 頭の部分が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkID(BlockBit::Wall, mapData, xLeft, yTop) || // 左上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yTop) || // 中上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yTop) )  // 右上が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yTop; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallBottom = yTop + CellSize - (float)std::fmod(yTop, CellSize); // 壁の下側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallBottom - hitOffsetTop; // 頭を壁の下端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 壁に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // ↓足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xLeft, yBottom) || // 左下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xMiddle, yBottom) || // 中下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;checkID(BlockBit::Wall, mapData, xRight, yBottom) )  // 右下が壁か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y = yBottom; // [デバック] めり込んだラインを記録しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_y_xLeft = x - Screen::Width / 2, debug_y_xRight = x + Screen::Width / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float wallTop = yBottom - (float)std::fmod(yBottom, CellSize); // 壁の上側の境界<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = wallTop + hitOffsetBottom - imgSizeX; // 足元を壁の上端に沿わす(めり込んだぶんを押し戻す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = 0; // 床に当たったら速度をストップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false; // ブロックに当たってないからfalseにして落下するように<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isBlockChanging) // ブロック変化フラグ==true(すでに↑めりこみ判定でvy=0で勢いを止め反射が効くからid=-1にしてもすりぬけずにすむ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[mapY][mapX]; // 行mapY 列mapXの地形idを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockChange.count(id) &gt; 0) // blockChangeの辞書に登録のあるidのときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;int, int&gt; mapXY = std::make_pair(mapX, mapY); // ぶつかったブロックのセルの行mapYと列mapXのペア<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(blockBits[blockChange[id]] &amp; (int)BlockBit::Bounce)) // 変化先ブロックがバウンスするならアニメ時間をeraseせずに辞書に残す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime.erase(mapXY); // ブロックの種類変える前にアニメをリセットしておかないと辞書に残り続ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapData[mapY][mapX] = blockChange[id]; // idを入れ替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vx *= 0.97f; // 減速率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;vy += vyForce; // 勢い(力・フォースを加算)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vy &gt;= vyDownSpeedMax[vx_idx]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vy = vyDownSpeedMax[vx_idx];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>if (vy &gt;= 0.0f && zoomAnimCount &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;--zoomAnimCount;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (zoomAnimCount &lt; 60) // 上方向の加速中は最大60までカウントしてズームアウト(広域を映す)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;++zoomAnimCount;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 最大(1-0.25)=0.75倍ズームアウト<br>
      &nbsp;&nbsp;&nbsp;&nbsp;pCamera-&gt;zoomRatio = (zoomAnimCount &lt; 2) ? 1.0f : 1.0f - 0.25f * zoomAnimCount / 60.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;pCamera->LookAt(x, y); // プレイヤのキャラ(x,y)位置を中心に追跡スクロール</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<u>camera_x = x - Screen::Width / 2; // 指定されたx座標が画面の中心に来るようにScreenの幅 / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_x &lt;= 0) camera_x = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Width * CellSize - Screen::Width <= camera_x) camera_x = Width * CellSize - Screen::Width; // ステージのはしっこ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;camera_y = y - Screen::Height / 2; // 指定されたy座標が画面の中心に来るようにScreenの高さ / 2を引く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (camera_y &lt;= 0) camera_y = 0; // ステージのはしっこではカメラの追随を止める(csvファイルのマイナスエリアを描かないように)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else if (Height * CellSize - Screen::Height &lt;= camera_y) camera_y = Height * CellSize - Screen::Height; // ステージのはしっこ</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// ダッシュ段階に応じてキャラクタのアニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float vx_dash = (vx &lt; 0) ? -vx : vx; // 絶対値でプラスだけにする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 0.5f) animeTime += 1; // 時間 +1 ( 合計 1 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 6) animeTime += 1;  // 時間 +1 (計 1+1=2 ) 1フレームごとに2アニメ時間が進む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (vx_dash &gt; 9) animeTime += 2; // 最終段階ではアニメ時間をさらに +2 (計 1+1+2=4 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int animeStep = animeTime / 10; // 10を5に変えたらアニメ速度が上がる(10ごとに1コマアニメが進む)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animeStep &gt;= 3) // アニメのステップ数が0,1,2の3段階までなら3を超えたら0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeTime = 0; // 0へ戻り再びアニメ時間を再ループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animeStep = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (isDead) // やられたときの描画処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yMiss = y <u>- camera_y </u>+ imgSizeY / 2; // ミスったy起点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim0 = yMiss; // アニメy位置0 始まりのy位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim1 = yMiss - 10; // アニメy位置1 アニメの途中少し上方向に 10 浮く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim2 = Screen::Height + 32; // アニメy位置2 最終y位置 画面の高さ+32で画面外へ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yDeadAnim; // やられた際にはyの位置をアニメさせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 直線的な比例アニメの式(t=時刻)  位置1×(終時刻 - t) / アニメの長さ  +  位置2×(t - 始時刻) / アニメの長さ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (deadAnimeTime &lt; 40) // やられアニメが始まって40フレーム目までは yAnim0 ～ yAnim1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim0 * (40 - deadAnimeTime) / 40 + yAnim1 * (deadAnimeTime - 0) / 40;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (deadAnimeTime &lt; 60) // やられアニメが始まって60フレーム目までは yAnim1 ～ yAnim2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim1 * (60 - deadAnimeTime) / 20 + yAnim2 * (deadAnimeTime - 40) / 20;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yDeadAnim = yAnim2; // アニメ終了 到着 y位置をセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deadAnimeTime = 0; // 次にやられたときのアニメのため0リセットしておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 再開位置からゲーム再開(各数値もリセット)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isDead = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = xStart, y = yStart, vx = 0, vy = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isGround = false, isFlying = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vx_idx = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int deadAnimeStep = deadAnimeTime / 3; // 3で割って[チップのパラパラの]アニメの速度は弱める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int chipAnime = deadAnimeStep % 3; // % 3で余りを求めれば余りはチップのパラパラ番号は0～2の間に収まる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>pCamera-&gt;</em>DrawRotaGraphF(x <u>- camera_x </u>+ imgSizeX / 2, yDeadAnim, 1.0f, 10.0f * deadAnimeStep / 360.0f * 2 * DX_PI, Image::playerChips[chipAnime], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++deadAnimeTime; // アニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isFlying &amp;&amp; direction == Direction::Left) // 飛ぶと-60度傾けて表示 キャラチップは[4]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>pCamera-&gt;</em>DrawRotaGraphF(x <u>- camera_x </u>+ imgSizeX / 2, y <u>- camera_y </u>+ imgSizeY / 2, 1.0f,-60.0f / 360.0f * 2 * DX_PI, Image::playerChips[4], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (isFlying &amp;&amp; direction == Direction::Right) // 60度回転させて表示 キャラチップは[7]で固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>pCamera-&gt;</em>DrawRotaGraphF(x <u>- camera_x </u>+ imgSizeX / 2, y <u>- camera_y </u>+ imgSizeY / 2, 1.0f, 60.0f / 360.0f * 2 * DX_PI, Image::playerChips[7], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Left) // キャラのチップの[5][4][3]を[5 - animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>pCamera-&gt;</em>DrawRotaGraphF(x <u>- camera_x </u>+ imgSizeX / 2, y <u>- camera_y </u>+ imgSizeY / 2, 1.0f, 0.0f, Image::playerChips[5 - animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (direction == Direction::Right) // キャラのチップの[6][7][8]を[6 + animeStep]で使う(animeStep=0,1,2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>pCamera-&gt;</em>DrawRotaGraphF(x <u>- camera_x </u>+ imgSizeX / 2, y <u>- camera_y </u>+ imgSizeY / 2, 1.0f, 0.0f, Image::playerChips[6 + animeStep], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2; // DrawRotaGraphF関数は画像の真ん中が起点なので1/2ずらした位置計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 地形マップを[ 行のfor文×列のfor文 ]の2重ループで描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellY = 0, ySize = mapData.size(); cellY &lt; ySize; ++cellY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0, xSize = mapData[cellY].size(); cellX &lt; xSize; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = mapData[cellY][cellX]; // [行][列] の位置のcsvの地形番号(チップ番号)を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id &lt; 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップチップを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto mapXY = std::make_pair(cellX, cellY);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockAnime.count(mapXY) == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>pCamera-&gt;</em>DrawRotaGraphF(chip_x <u>- camera_x </u>+ rotaShiftX, chip_y <u>- camera_y </u>+ rotaShiftY, 1.0f, 0.0f, Image::mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ((int)BlockBit::Bounce &amp; blockBits[id])<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yBase = chip_y<u> - camera_y</u>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim0 = yBase - 10, yAnim1 = yBase; // yAnim0 から yAnim1の位置までアニメする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int blockTime = blockAnime[mapXY];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float yAnim = yAnim0 * (15 - blockTime) / 15 + yAnim1 * blockTime / 15;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>pCamera-&gt;</em>DrawRotaGraphF(chip_x <u>- camera_x </u>+ rotaShiftX, yAnim + rotaShiftY, 1.0f, 0.0f, Image::mapChips[id], TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++blockAnime[mapXY]; // アニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (blockTime > 15) // アニメ終了時間を15フレーム目とするとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockAnime.erase(mapXY); // 辞書からアニメをerase関数で取り除く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ]用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>pCamera-&gt;</em>DrawString(chip_x<u> - camera_x</u>, chip_y<u> - camera_y</u>, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たり判定の四隅を赤枠で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>pCamera-&gt;</em>DrawBox(getLeft(x)<u> - camera_x</u>, getTop(y)<u> - camera_y</u>, getRight(x)<u> - camera_x</u>, getBottom(y)<u> - camera_y</u>, GetColor(255, 0, 0), FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] キャラ原点(x,y)を緑丸で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<em>pCamera-&gt;</em>DrawCircle(x<u> - camera_x</u>, y<u> - camera_y</u>, 2, GetColor(0, 255, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// [デバッグ] 当たった際の行き過ぎの めりこみ座標(debug_x,debug_y) を青線で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_x != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<em>pCamera-&gt;</em>DrawLine(debug_x<u> - camera_x</u>, debug_x_yTop<u> - camera_y</u>, debug_x<u> - camera_x</u>, debug_x_yBottom<u> - camera_y</u>, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (debug_y != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<em>pCamera-&gt;</em>DrawLine(debug_y_xLeft<u> - camera_x</u>, debug_y<u> - camera_y</u>, debug_y_xRight<u> - camera_x</u>, debug_y<u> - camera_y</u>, GetColor(0, 0, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 速度などをデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if(vy != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfDx("y:%.1f vy:%.2f idx:%d\n", y, vy, vx_idx);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;}
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// キー入力待ちをする<br>
      &nbsp;&nbsp;WaitKey();<br>
      &nbsp;&nbsp;// ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;DxLib_End();<br>
      &nbsp;&nbsp;// ソフトの終了<br>
      &nbsp;&nbsp;return 0;<br>
      }</p>
      <br>
      <br>
      いかがでしょう、Cameraクラスを通してゲームを正しく描けましたか？ジャンプするときズームアウトするようになりましたか？<br>
      ズームインやズームアウトは<b>目立たず地味ですが、これがなければスマブラのぶっとび演出が表現できません</b>よね。<br>
      数式もうまく工夫しないと急なズームアウトも不自然ですし、カメラワークは難しいです。<br>
      (カメラの<b>存在をユーザーが意識しなくて地味であればあるほど</b>、それは<b>自然なカメラワークということ</b>になりますから)<br>
      <br>
      キャラの<b>移動の速度があがればあがるほど</b>、ズームアウトして<b>移動先をみせなければ、フィールドの先に何があるのかをユーザーが予見できない</b>ようになります。<br>
      空を飛ぶのであれば空とフィールドの広さをズームアウトで表現できれば、操作自体は変わらずともユーザーに広い視野で自由な移動感覚を演出できます。<br>
      ゲームに限らずとも「スケール感覚とは相対的なもの」です。<br>
      ドラゴンボールでフリーザが惑星を破壊する何年も前に、すでに「アラレちゃんは<a href="https://dic.pixiv.net/a/%E5%9C%B0%E7%90%83%E5%89%B2%E3%82%8A">地球を割っていました</a>」<br>
      <br>
      つまり「<b>カメラをどこに置くか</b>」「<b>大きいものと小さいものをどのように相対的に対比</b>させるか」などの観点で<b>アイデアを出してはじめて「スケールを表現手段」にできる</b>のです。<br>
      <be>
      さらにもう1点、Google Mapのピンチイン、ピンチアウトはユーザーが気軽にスケールを直感的に変えられるという意味で発明的なUIだと感じませんか。<br>
      ユーザーの「操作をどう直感的にズームなどのスケールと連動させるか」という観点も非常にセンスが問われます。<br>
      逆にいうなら、FPSやホラーなど潜む系のゲームではあえてユーザーの視野を狭くしたり広くしたり「視野の観点がない」レベルデザインは単調さの要因となりえます。<br>
      <br>
      ひとつひとつの<b>「自分の中のあたりまえを批判的に整理」</b>することでしか<b>「自分にしかできないこだわり」にたどりつくこと</b>はできません。<br>
      じゃないと、プロの作ったあたりまえの気持ちいいゲーム性の上で転がされるただの消費者ユーザーの域を出ず、既存のゲーム超えるきっかけがつかめないことになりかねません。<br>
      <br>
      ズームアウトひとつとっても「全然あたりまえじゃない」んです。<br>
      プレイヤーや他の制作者を<b>出し抜くためには「目の前のあたりまえの表現をこそ疑問を持ちうたぐってかかり」<br>
      「あたりまえ → 新しい観点の発掘」か「あたりまえ → モチーフの置換」など思考を巡らせ「計画可能な手数で」新しさの尻尾を自分自身の表現利益のために掴み取らねば</b>なりません<br>
      <br>
      <br>
<br>
    <h1><a id="mozTocId0021" class="mozTocH1"></a>地形をBlock(アニメ機能付き)とTile(データ読込とブロック描画)という概念に切り分けたプログラム</h1>
<br>
      <br>
      <br>
      まずは地形という概念について哲学してみましょう。<br>
      この2Dゲーム世界の地形の構成要素はブロックです。マインクラフトならボクセルです。<br>
      そしてブロックがタイル状に並ぶことによって、マリオのような地形が形作られています。<br>
      そういう意味では、マインクラフトをはじめて見たとき「3Dボクセル版マリオだな」と感じました。<br>
      <br>
      初代マリオの面白さは1つ1つのブロックのバリエーションにあり「子供でもステージを自作したい」と刺激されるような「レゴブロック感」にあると初見で感じました。<br>
      3D版マリオよりもマインクラフトのほうが、初代2Dマリオをはじめて見た時の「自分でも作ってみたい(作れそう)」という気持ちが刺激されるような気がします。<br>
      <br>
      シンプルな構成要素は子供でも組み合わせをイメージできるような発展性があるということではないでしょうか。<br>
      <br>
      <br>
      さて、BlockブロックとTileタイルの概念に戻ります。<br>
      地形を単純におおざっぱにステージと呼んでしまうことは楽ですが、つきつめて考えて単一物(ブロック)と複合物(タイル)という概念を哲学して分別して考えられることが大事です。<br>
      ゲーム世界の最小構成要素(原子のようなもの)からじっくり考え抜いてイメージすることこそが、オリジナルのゲームやプログラムを自力でくみ上げるための第1歩となります。<br>
      (最終的にはその構成要素同士が連動したり、配置されたりして絡み合うことで「ゲーム性」が生まれるわけですから)<br>
      <a href="https://www.4gamer.net/games/999/G999905/20230326005/">世界の定義そのものが新しいゲーム性を生み出す設定アイデア</a>だってありうるのです。<br>
      <br>
      <br>
      <br>
      さてまずはブロックの位置のバウンスアニメのデータを扱うためにキーフレーム(アニメの時間と位置とオプションで画像ハンドルを持つ構造体)を定義します。<br>
      <br>
    <p><code>KeyFrame.hを新規作成</code>してブロックのアニメの<b>時間と位置と画像ハンドル番号(チップのパラパラアニメ)</b>を持つ構造体を作成します。</p>
    <p class="source">#ifndef KEYFRAME_H_<br>
      #define KEYFRAME_H_<br>
      <br>
      #include "Vector2.h"<br>
      <br>
      struct KeyFrame // アニメの時間と位置(とオプションで画像ハンドル)を持つ構造体<br>
      {<br>
      &nbsp;&nbsp;Vector2 pos{ 0,0 }; // ある時間での位置<br>
      &nbsp;&nbsp;int time = 0; // 時刻(経過フレーム数)<br>
      &nbsp;&nbsp;int handle = -1; // 画像ハンドル(途中で画像を変えるなら)<br>
      &nbsp;&nbsp;int tNext = -1; // このキーフレームのあとtime=tNextの時刻に(0にすればループに使える)<br>
      &nbsp;&nbsp;bool isStop = false; // キーフレームの時間経過をストップするか<br>
      &nbsp;&nbsp;KeyFrame&amp; SetStop(bool isStop) { this-&gt;isStop = isStop; return *this; }<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;KeyFrame(int time, Vector2 pos, int handle = -1, int tNext = -1, bool isStop = false)<br>
      &nbsp;&nbsp; &nbsp; &nbsp;: time{ time }, pos{ pos }, handle{ handle }, tNext{ tNext }, isStop{ isStop } {}<br>
      &nbsp;&nbsp;virtual ~KeyFrame() {}<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>Block.hを新規作成</code>してタイルマップの1つ1つのブロックの行と列番号やアニメや描画する機能を管理するクラスを作成します。</p>
    <p class="source">#ifndef BLOCK_H_<br>
      #define BLOCK_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Vector2.h"<br>
      #include "KeyFrame.h"<br>
      <br>
      #include &lt;vector&gt; // アニメのキーフレームを2次元vector配列に格納<br>
      #include &lt;string&gt; // 文字列std::stringを使う<br>
      <br>
      #include &lt;unordered_map&gt; // 高速辞書配列std::unordered_mapを使う<br>
      #include &lt;utility&gt; // std::pair(データのペア型)を使うのに必要<br>
      // [ペアを高速辞書のキーにするためハッシュ関数が必要] https://qiita.com/hamamu/items/4d081751b69aa3bb3557<br>
      template&lt;class TypeT&gt; size_t HashCombine(const size_t seed, const TypeT&amp; value)<br>
      {<br>
      &nbsp;&nbsp;return seed ^ (std::hash&lt;TypeT&gt;()(value) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2));<br>
      }<br>
      <br>
      // pair型に()をつけたときに呼び出される処理をoperator()で定義してreturnでハッシュ関数を返す<br>
      template&lt;class TypeT, class TypeS&gt; struct std::hash&lt;std::pair&lt;TypeT, TypeS&gt;&gt;<br>
      {<br>
      &nbsp;&nbsp;size_t operator() (const std::pair&lt;TypeT, TypeS&gt;&amp; keyval) const noexcept<br>
      &nbsp;&nbsp;{ &nbsp; // returnでハッシュ関数を返すことで高速辞書のキーとして認め許されるようになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return HashCombine(std::hash&lt;TypeT&gt;()(keyval.first), keyval.second);<br>
      &nbsp;&nbsp;}<br>
      };<br>
      <br>
      class Camera; // 循環回避の前方宣言(ポインタ使用のみなら.hで#inludeせずともエラー出なくなる)<br>
      <br>
      class Block // 1つ1つのブロック(タイルマップのチップ)を表すクラス<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;int cellX = -1, cellY = -1; // マス目番号(csvの列と行の番号)<br>
      &nbsp;&nbsp;Vector2 pos{ 0,0 }; // ブロックのワールド座標位置<br>
      &nbsp;&nbsp;int* pID = nullptr; // マップチップ画像のIDへのリンク<br>
      &nbsp;&nbsp;int* pHandle = nullptr; // 描くチップの画像ハンドル番号へのリンク<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 初期化コンストラクタ<br>
      &nbsp;&nbsp;Block(int cellX, int cellY, int cellSize = 32, int* pHandle = nullptr, int* pID = nullptr)<br>
      &nbsp;&nbsp; &nbsp; &nbsp;: cellX{ cellX }, cellY{ cellY }, CellSize{ cellSize }, pHandle{ pHandle }, pID{ pID }<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;pos.y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;pos.x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;virtual ~Block() {} // 破棄デストラクタ<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;virtual void Update(); // 更新処理<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;virtual void Draw(Camera* pCamera); // 描画処理<br>
      };<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;<br>
      <br>
      <br>
      class AnimBlock : public Block // ベースとなるBlock型を継承してアニメするブロックを定義する<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;Vector2 animPos{ 0,0 }; // アニメで(pos.x + animPos.x, pos.y + animPos.y)にずらして描く<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ブロックをバウンドなどアニメさせるためマス目セルXY番号→アニメ時間の 高速辞書&lt;ペア&lt;cellX,cellY&gt;, intアニメ時間&gt;<br>
      &nbsp;&nbsp;static std::unordered_map&lt;std::pair&lt;int, int&gt;, int&gt; cellTime;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::vector&lt;KeyFrame&gt; anim; // 一連のアニメの時間と位置を持つキーレームの配列<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 初期化コンストラクタ<br>
      &nbsp;&nbsp;AnimBlock(std::vector&lt;KeyFrame&gt;&amp; anim, int cellX, int cellY, int cellSize = 32, int* pHandle = nullptr, int* pID = nullptr)<br>
      &nbsp;&nbsp; &nbsp; &nbsp;: anim{ anim }, Block(cellX, cellY, cellSize, pHandle, pID) {}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;virtual void Update() override; // 更新処理<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;virtual void Draw(Camera* pCamera) override; // 描画処理<br>
      };<br>
      #endif<br>
    </p>
    <p><code>Block.cppを新規作成</code>してBlock.hの処理やCamera.hを#includeしてカメラぶんずらしてブロックを描いたりアニメする処理を作成します。</p>
    <p class="source">#include "Block.h"<br>
      <br>
      #include "Camera.h" // CameraでもBlockやTileを#includeする可能性を考えて循環回避(.cppで#include)<br>
      <br>
      std::unordered_map&lt;std::pair&lt;int, int&gt;, int&gt; AnimBlock::cellTime;<br>
      <br>
      // 更新処理<br>
      void Block::Update()<br>
      {<br>
      &nbsp;&nbsp;pos.y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;pos.x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      }<br>
      <br>
      // 描画処理<br>
      void Block::Draw(Camera* pCamera)<br>
      {<br>
      &nbsp;&nbsp;if (pCamera == nullptr) return; // カメラのリンク切れなら描けない<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ポインタからidを読みだす<br>
      &nbsp;&nbsp;int id = (pID != nullptr) ? *pID : -1;<br>
      &nbsp;&nbsp;int handle = (pHandle != nullptr) ? *pHandle : -1;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// マップチップを描く<br>
      &nbsp;&nbsp;float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2;<br>
      &nbsp;&nbsp;pCamera->DrawRotaGraphF(pos.x + rotaShiftX, pos.y + rotaShiftY, 1.0f, 0.0f, handle, TRUE);<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// デバッグ用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;if (id != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;pCamera->DrawString(pos.x, pos.y, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      }<br>
      <br>
      // 更新処理<br>
      void AnimBlock::Update()<br>
      {<br>
      &nbsp;&nbsp;pos.y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;pos.x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;auto mapXY = std::make_pair(cellX, cellY);<br>
      &nbsp;&nbsp;size_t animSize = anim.size(); // anim配列の数(.size()関数を毎度呼ぶだけでも少し計算のムダ:1度目に変数に保持)<br>
      &nbsp;&nbsp;if (animSize == 0) // アニメがない場合は(0,0)の固定位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;animPos = Vector2{ 0,0 };<br>
      &nbsp;&nbsp;else if (cellTime.count(mapXY) &gt; 0 && animSize &gt; 1)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int blockTime = cellTime[mapXY];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;size_t i = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (size_t j = 1; j &lt; animSize; ++j)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (anim[j-1].time &lt;= blockTime &amp;&amp; blockTime &lt;= anim[j].time)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = j - 1; // 時刻に対応するキーフレーム番号区間を見つけた<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Vector2 startPos{ anim[i].pos.x, anim[i].pos.y };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float nowTime = blockTime - anim[i].time;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (animSize &lt; 2) // キーフレームが1つ以下なら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animPos = startPos; // アニメせずスタート位置のまま固定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector2 endPos{ anim[i + 1].pos.x, anim[i + 1].pos.y };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//数値例.float yAnim0 = yBase - 10, yAnim1 = yBase; // yAnim0 から yAnim1の位置までアニメする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float time = anim[i + 1].time - anim[i].time;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//数値例.float yAnim = yAnim0 * (15 - blockTime) / 15 + yAnim1 * blockTime / 15;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animPos = startPos * ((time - nowTime) / time) + endPos * (nowTime / time);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// 画像をパラパラ画像アニメするならキーフレームの画像ハンドル番号へリンクする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;pHandle = &amp;anim[i].handle; // iが変わってhandle番号が変われば画像が変わりパラパラアニメする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (anim[i].isStop != true)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++cellTime[mapXY]; // アニメ時間を進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int iEnd = animSize - 1; // 最後の配列番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (cellTime[mapXY] &gt; anim[iEnd].time) // アニメ終了時間をこえたとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;if (anim[iEnd].tNext &gt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;cellTime[mapXY] = anim[iEnd].tNext; // アニメ時刻をtNextに飛ばして辞書時刻を書き換え<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;cellTime.erase(mapXY); // 辞書からアニメをerase関数で取り除く<br>
      &nbsp;&nbsp;}<br>
      }<br>
      <br>
      // 描画処理<br>
      void AnimBlock::Draw(Camera* pCamera)<br>
      {<br>
      &nbsp;&nbsp;if (pCamera == nullptr) return;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ポインタからidを読みだす<br>
      &nbsp;&nbsp;int id = (pID != nullptr) ? *pID : -1;<br>
      &nbsp;&nbsp;int handle = (pHandle != nullptr) ? *pHandle : -1;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// マップチップを描く<br>
      &nbsp;&nbsp;float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2;<br>
      &nbsp;&nbsp;pCamera-&gt;DrawRotaGraphF(pos.x + animPos.x + rotaShiftX, pos.y + animPos.y + rotaShiftY, 1.0f, 0.0f, handle, TRUE);<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// デバッグ用にcsvのidの数字を描く<br>
      &nbsp;&nbsp;if (id != -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;pCamera-&gt;DrawString(pos.x, pos.y, std::to_string(id).c_str(), GetColor(255, 255, 255));<br>
      }<br>
    </p>
    <p><code>Tile.hを新規作成</code>してCSVからマップの1つ1つのブロックidを読み出して(x,y)に対応するマス目(cellX,cellY)のidに応じてブロックをまとめて描くクラスを作成します。</p>
    <p class="source">#ifndef TILE_H_<br>
      #define TILE_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "DataCsv.h"<br>
      #include "Block.h"<br>
      <br>
      #include &lt;assert.h&gt; // 読込み失敗表示用<br>
      #include &lt;vector&gt; // csvを2次元vector配列に格納<br>
      #include &lt;string&gt; // 文字列std::stringを使う<br>
      #include &lt;unordered_map&gt; // 高速辞書配列std::unordered_mapを使う<br>
      <br>
      class Camera; // 循環回避の前方宣言(ポインタ使用のみなら.hで#inludeせずともエラー出なくなる)<br>
      <br>
      class Tile // タイルマップのデータクラス<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;int CellSize = 32; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;std::unordered_map&lt;int, int&gt; blockBits; // ブロックのビット辞書<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;DataCsv Data;// csvデータ<br>
      &nbsp;&nbsp;int&amp; Width = Data.Width; // マップデータの横のマス数への&amp;参照<br>
      &nbsp;&nbsp;int&amp; Height = Data.Height; // マップデータの縦のマス数への&amp;参照<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// ★スムーズに[][]でアクセスできるように[]演算子を独自定義する<br>
      &nbsp;&nbsp;std::vector&lt;int&gt;&amp; operator[](std::size_t index) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return Data[index]; // 書き込み<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::vector&lt;int&gt; operator[](std::size_t index) const { // constは添え字[]読み取りの処理を定義<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return Data[index]; // 読み取り<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;std::size_t size()<br>
      &nbsp;&nbsp;{ &nbsp; // size()関数の名前をvectorと被らせることで使う側は2次元vectorのままのコードで使える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return Data.size();<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 初期化コンストラクタ<br>
      &nbsp;&nbsp;Tile(std::string filePath = "", int cellSize = 32) : CellSize { cellSize }<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Load(filePath); // csvファイルをロード<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 破棄デストラクタ<br>
      &nbsp;&nbsp;virtual ~Tile()<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Data.clear(); // csvデータをメモリからクリアする<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// csvファイルの読み込み<br>
      &nbsp;&nbsp;void Load(std::string&amp; filePath)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Data.Load(filePath);<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 指定された座標(worldX,worldY)の地形が 壁 や ダメージブロックかなどをチェックする一時関数<br>
      &nbsp;&nbsp;bool checkID(BlockBit checkBit, float worldX, float worldY,<br>
      &nbsp;&nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr, int* pTerrainID = nullptr);<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [X方向左右]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      &nbsp;&nbsp;int hitcheckX(BlockBit checkBit,<br>
      &nbsp;&nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr);<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// [Y方向上下]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      &nbsp;&nbsp;int hitcheckY(BlockBit checkBit,<br>
      &nbsp;&nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr);<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      &nbsp;&nbsp;int hitcheck(BlockBit checkBit,<br>
      &nbsp;&nbsp; &nbsp; &nbsp;float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp; &nbsp; &nbsp;int* pMapX = nullptr, int* pMapY = nullptr);<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 描画処理<br>
      &nbsp;&nbsp;void Draw(Camera* pCamera);<br>
      };<br>
      #endif<br>
    </p>
    <p><code>Tile.cppを新規作成</code>してタイルマップの1つ1つのブロックの行と列番号やアニメや描画する機能を管理するクラスを作成します。</p>
    <p class="source">#include "Tile.h"<br>
      <br>
      #include "Image.h"<br>
      #include "Camera.h" // CameraでもBlockやTileを#includeする可能性を考えて循環回避(.cppで#include)<br>
      <br>
      // 指定された座標(worldX,worldY)の地形が 壁 や ダメージブロックかなどをチェックする関数<br>
      bool Tile::checkID(BlockBit checkBit, float worldX, float worldY,<br>
      &nbsp; &nbsp; int* pMapX, int* pMapY, int* pTerrainID)<br>
      {<br>
      &nbsp;&nbsp;int terrainID; // 指定された座標の地形のID<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;if (worldX &lt; 0 || worldY &lt; 0) return false; // 負の座標(データ配列外)が指定された場合<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// マップ座標系(二次元配列の行と列)に変換する<br>
      &nbsp;&nbsp;int mapX = (int)(worldX / CellSize), mapY = (int)(worldY / CellSize);<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;// 二次元配列の範囲内か判定<br>
      &nbsp;&nbsp;if (mapY &lt; Data.size() &amp;&amp; mapX &lt; Data[mapY].size())<br>
      &nbsp;&nbsp; &nbsp;terrainID = Data[mapY][mapX]; // 二次元配列から地形IDを取り出す<br>
      &nbsp;&nbsp;else<br>
      &nbsp;&nbsp; &nbsp;terrainID = -1; // 配列の外のデータは-1扱いにする<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;if (pTerrainID != nullptr)<br>
      &nbsp;&nbsp; &nbsp;*pTerrainID = terrainID;<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;bool isCheckBit = (((int)checkBit) &amp; blockBits[terrainID]) != 0; // ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      &nbsp;&nbsp;if (isCheckBit &amp;&amp; pMapX != nullptr &amp;&amp; pMapY != nullptr)<br>
      &nbsp;&nbsp; &nbsp;*pMapX = mapX, * pMapY = mapY; // ブロックのcsvのセル番号をポインタに記録(nullptrの場合は記録しない)<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;return isCheckBit;<br>
      }<br>
      <br>
      // [X方向左右]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      int Tile::hitcheckX(BlockBit checkBit,<br>
      &nbsp; &nbsp; float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp; &nbsp; int* pMapX, int* pMapY)<br>
      {<br>
      &nbsp;&nbsp;// 左端がめりこんでいるか？<br>
      &nbsp;&nbsp;if (checkID(checkBit, xLeft, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp; &nbsp;return (int)HitPart::Left | (int)HitPart::Top; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;if (checkID(checkBit, xLeft, yMiddle, pMapX, pMapY))<br>
      &nbsp;&nbsp; &nbsp;return (int)HitPart::Left | (int)HitPart::YMiddle; // 左中がめりこんでいる<br>
      &nbsp;&nbsp;if (checkID(checkBit, xLeft, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp; &nbsp;return (int)HitPart::Left | (int)HitPart::Bottom; // 左下がめりこんでいる<br>
      &nbsp;&nbsp;// 右端がめりこんでいるか？<br>
      &nbsp;&nbsp;if (checkID(checkBit, xRight, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp; &nbsp;return (int)HitPart::Right | (int)HitPart::Top; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;if (checkID(checkBit, xRight, yMiddle, pMapX, pMapY))<br>
      &nbsp;&nbsp; &nbsp;return (int)HitPart::Right | (int)HitPart::YMiddle; // 右中がめりこんでいる<br>
      &nbsp;&nbsp;if (checkID(checkBit, xRight, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp; &nbsp;return (int)HitPart::Right | (int)HitPart::Bottom; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;return (int)HitPart::None;<br>
      }<br>
      <br>
      // [Y方向上下]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      int Tile::hitcheckY(BlockBit checkBit,<br>
      &nbsp; &nbsp; float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp; &nbsp; int* pMapX, int* pMapY)<br>
      {<br>
      &nbsp;&nbsp;// 頭の部分がめりこんでいるか？<br>
      &nbsp;&nbsp;if (checkID(checkBit, xLeft, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp; &nbsp;return (int)HitPart::Left | (int)HitPart::Top; // 左上がめりこんでいる<br>
      &nbsp;&nbsp;if (checkID(checkBit, xMiddle, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp; &nbsp;return (int)HitPart::XMiddle | (int)HitPart::Top; // 中上がめりこんでいる<br>
      &nbsp;&nbsp;if (checkID(checkBit, xRight, yTop, pMapX, pMapY))<br>
      &nbsp;&nbsp; &nbsp;return (int)HitPart::Right | (int)HitPart::Top; // 右上がめりこんでいる<br>
      &nbsp;&nbsp;// 足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;if (checkID(checkBit, xLeft, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp; &nbsp;return (int)HitPart::Left | (int)HitPart::Bottom; // 左下がめりこんでいる<br>
      &nbsp;&nbsp;if (checkID(checkBit, xMiddle, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp; &nbsp;return (int)HitPart::XMiddle | (int)HitPart::Bottom; // 中下がめりこんでいる<br>
      &nbsp;&nbsp;if (checkID(checkBit, xRight, yBottom, pMapX, pMapY))<br>
      &nbsp;&nbsp; &nbsp;return (int)HitPart::Right | (int)HitPart::Bottom; // 右下がめりこんでいる<br>
      &nbsp;&nbsp;<br>
      &nbsp;&nbsp;return (int)HitPart::None;<br>
      }<br>
      <br>
      // 地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      int Tile::hitcheck(BlockBit checkBit,<br>
      &nbsp; &nbsp; float xLeft, float xMiddle, float xRight, float yTop, float yMiddle, float yBottom,<br>
      &nbsp; &nbsp; int* pMapX, int* pMapY)<br>
      {<br>
      &nbsp;&nbsp;return hitcheckX(checkBit, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, pMapX, pMapY)<br>
      &nbsp;&nbsp; &nbsp; &nbsp; | hitcheckY(checkBit, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, pMapX, pMapY);<br>
      }<br>
      <br>
      // 描画処理<br>
      void Block::Draw(Camera* pCamera)<br>
      {<br>
      &nbsp;&nbsp;float rotaShiftX = CellSize / 2, rotaShiftY = CellSize / 2;<br>
      &nbsp;&nbsp;for (int cellY = 0; cellY &lt; Height; ++cellY)<br>
      &nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;float chip_y = (float)(cellY * CellSize); // マス目Y(行)番号×マス目サイズで y座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (int cellX = 0; cellX &lt; Width; ++cellX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float chip_x = (float)(cellX * CellSize); // マス目X(列)番号×マス目サイズで x座標に戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int id = -1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (cellY &lt; Data.size() &amp;&amp; cellX &lt; Data[cellY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id = Data[cellY][cellX]; // [行][列]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id &lt; 0) continue; // -1のときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// マップチップを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto mapXY = std::make_pair(cellX, cellY);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (AnimBlock::cellTime.count(mapXY) == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Block block{ cellX, cellY, CellSize, &amp;Image::mapChips[id], &amp;id };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block.Update();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block.Draw(pCamera); // カメラのリンクを渡してブロックを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ((int)BlockBit::Bounce & blockBits[id])<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //[アニメ]とりあえずローカル変数定義するが、コマ数(データ量)が増えたらループ負荷の少ない所に移動が無難か<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector<KeyFrame> anim = { {0, Vector2(0,-10), Image::mapChips[id]},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {15, Vector2(0,0),  Image::mapChips[id]} };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AnimBlock block{ anim, cellX, cellY, CellSize};<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block.Update(); // アニメ位置を更新してから<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block.Draw(pCamera); // カメラのリンクを渡してブロックを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;}<br>
      }<br>
    </p>
      <br>
      <br>
  </body>
</html>
