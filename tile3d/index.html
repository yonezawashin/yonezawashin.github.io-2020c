<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>[C++]3Dタイル描画エンジン</title>
    <link rel="stylesheet" href="../style.css">
    <style>
      
    </style>
  </head>
  <body>
    <p class="title">[C++]3Dタイル描画エンジン1</p>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId0001">試しにボックス型のタイルをポリゴンを表示してみる</a></li>
      <li><a href="#mozTocId0002">複数カメラと複数スクリーンで複数プレイヤ視点で3D空間を描けるようにする</a></li>
      <li><a href="#mozTocId0003">文字タグ判定の代わりに使えるハッシュ(32bit)でカメラにhash32タグをつけて管理する</a></li>
      <li><a href="#mozTocId0004">ワールドを定義して、複数プレイヤと複数カメラをワールドに保持する</a></li>
      <li><a href="#mozTocId0005">シーンを定義して、ゲームシーンの中に複数ワールドを保持する</a></li>
      <li><a href="#mozTocId0006">MyTimerクラスでchronoから得た時刻でゲームの描画のFPSを管理する</a></li>
      <li><a href="#mozTocId0007">共通のベース基底となるGameObjectを定義して、プレイヤなどはそれを継承する形を設計する</a></li>
      <li><a href="#mozTocId0008">Componentクラスを継承して、プレイヤなどに付け離し再利用可能なコンポーネント指向の機能を設計する</a></li>
      <li><a href="#mozTocId0009">何もない空間をグリッド分割して隣接していない空間に所属するものとの当たり判定をスルーして高速化する</a></li>
    </ol>
    <br>
    <a id="mozTocId0001" class="mozTocH1">
      <h1>試しにボックス型のタイルをポリゴンを表示してみる</h1>
    </a> (DXの<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId0002">プロジェクトはシューティングの別記事を参考</a>に作っておいてください。<br>
    <p><code>Resource.h と Resource.cppは次の記事を参考に作っておきます→</code><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/polygon3d/index.html#mozTocId0011">画像や音声や3Dのファイルを読み込んで辞書で管理するクラス</a><br>
    </p>
    <p><code>Mapフォルダ</code>を作成して、地形画像ファイル<code>mapchip.png</code>は<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/practice.html#mozTocId0010">2Dアクションゲームの別記事を参考</a>にMap/mapchip.pngで保管されている前提で進めます)</p>
    <p><code>main.cppを新規作成</code>して、分割テクスチャ画像でタイルを正しく表示できるかテストします。</p>
    <p class="source"> #include "DxLib.h"<br>
      <br>
      #include "<b>Resource.h</b>"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(960, 540, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(960, 540);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // タイルマップを読み込む <b>縦8マス、横8マス、縦32ピクセル、横32ピクセル</b><br>
      &nbsp;&nbsp;&nbsp; std::string mapChipPath{ "<b>Map/mapchip.png</b>" };<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath,8,8,32,32)-&gt;Load(); // <b>メソッドチェーン</b> -&gt; でMakeShared読込後にLoadもする<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2Dタイル描画処理(位置x, y, 拡大率, 回転, 画像ID, TRUEなら透過有効)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawRotaGraphF(100, 200, 1.0f, 0, Resource::files[mapChipPath]-&gt;m_handles[<b>2</b>], TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    <p><code>MyDraw.hを新規作成</code>して、3Dで分割テクスチャ画像を描画する関数を準備します。</p>
    <p class="source"> #ifndef MYDRAW_H_<br>
      #define MYDRAW_H_<br>
      <br>
      #include &lt;assert.h&gt; // 画像読込み失敗表示用<br>
      #include &lt;cmath&gt; // std::absを使う<br>
      #include &lt;vector&gt;<br>
      <br>
      #include "DxLib.h"<br>
      #include "Resource.h"<br>
      <br>
      // 3Dのタイルを描くための自作描画系処理のクラス<br>
      class MyDraw<br>
      {<br>
      public:<br>
      <br>
      &nbsp;&nbsp;&nbsp; enum class Plane<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // XYZ平面の指定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 1,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ★デフォルトではDXライブラリ2D座標系に合わせて右手系 &amp; Yの矢印を画面下方向に設定<br>
      &nbsp;&nbsp;&nbsp; //static bool isLeftHanded;<br>
      &nbsp;&nbsp;&nbsp; static VECTOR XYZ_ARROW;<br>
      &nbsp;&nbsp;&nbsp; static bool IsReverseX_Texture;<br>
      &nbsp;&nbsp;&nbsp; static bool IsReverseY_Texture;<br>
      &nbsp;&nbsp;&nbsp; static bool IsReverseZ_Texture;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ★【Y矢印の方向と右手・左手系】の設定に合わせたVECTORを取得<br>
      &nbsp;&nbsp;&nbsp; // このVGetを通せば座標系を統一できる<br>
      &nbsp;&nbsp;&nbsp; // 入力される座標x,y,zは左上を(x,y,z) = (0,0,0)としてZの奥方向をプラス<br>
      &nbsp;&nbsp;&nbsp; // Yをマイナス下方向としたDXライブラリの画面座標系を想定<br>
      &nbsp;&nbsp;&nbsp; static VECTOR VGet(float x, float y, float z)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // DXライブラリの3D描画座標系に変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (XYZ_ARROW.x == 1 &amp;&amp; XYZ_ARROW.y == 1 &amp;&amp; XYZ_ARROW.z == 1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // DX デフォルト2D描画座標系<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DxLib::VGet(x, y, z);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (XYZ_ARROW.x == 1 &amp;&amp; XYZ_ARROW.y == -1 &amp;&amp; XYZ_ARROW.z == 1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // DX 3D描画座標系<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DxLib::VGet(x, -y, z);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR Result;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (XYZ_ARROW.x == 1) Result.x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else Result.x = -x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (XYZ_ARROW.y == 1) Result.y = y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else Result.y = -y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (XYZ_ARROW.z == 1) Result.z = z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else Result.z = -z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Result;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline static VECTOR_D VecAngle(Plane plane, double Angle)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D AngleVec = DxLib::VGetD(0.0F, 0.0F, 0.0F);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面に合わせて回転軸を選択<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (plane == Plane::X) AngleVec.x = Angle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (plane == Plane::Y) AngleVec.y = Angle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (plane == Plane::Z) AngleVec.z = Angle;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return AngleVec;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 回転行列からXYZ軸周りの角度(単位:ラジアン)に戻す<br>
      &nbsp;&nbsp;&nbsp; inline static VECTOR_D GetAngle(MATRIX_D rotMat)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double threshold = 0.001;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D radAngle; // XYZ軸周りの角度(単位:ラジアン)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[参考:opencvは左手系なので行列位置は斜め鏡映し逆] https://qiita.com/q_tarou/items/46e5045068742dfb2fa6<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (std::abs(rotMat.m[1][2] - 1.0) &lt; threshold) { // rotMat[1][2] = sin(x) = 1の時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.x = DX_PI / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.y = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.z = std::atan2(rotMat.m[0][1], rotMat.m[0][0]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (std::abs(rotMat.m[1][2] + 1.0) &lt; threshold) { // rotMat[1][2] = sin(x) = -1の時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.x = -DX_PI / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.y = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.z = std::atan2(rotMat.m[0][1], rotMat.m[0][0]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.x = std::asin(rotMat.m[1][2]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.y = std::atan2(-rotMat.m[0][2], rotMat.m[2][2]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.z = std::atan2(-rotMat.m[1][0], rotMat.m[1][1]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return radAngle;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // UnityにならってfarClipPlane(z方向のどこまで遠いものを描くか)<br>
      &nbsp;&nbsp;&nbsp; // https://qiita.com/shoridevel/items/5c4a249ff09244645c93<br>
      &nbsp;&nbsp;&nbsp; //static int farClipPlane;// = 1000;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラの視点、注視点、アップベクトルを設定する( アップベクトルはＹ軸方向から導き出す )<br>
      &nbsp;&nbsp;&nbsp; static int SetCameraPositionAndTarget_UpVecY(VECTOR Position, VECTOR Target)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手・左手系とY軸矢印の方向に従い座標を変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR Position_COVERT_XYZ = VGet(Position.x, Position.y, Position.z);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR Target_COVERT_XYZ = VGet(Target.x, Target.y, Target.z);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DxLib::SetCameraPositionAndTarget_UpVecY(Position_COVERT_XYZ, Target_COVERT_XYZ);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 画像のビルボード描画(常に面がカメラ向き)( 座標指定が float 版 )<br>
      &nbsp;&nbsp;&nbsp; static int DrawDivBillboardGraphF3D(Plane plane, float xf, float yf, float zf, double ExRate, VECTOR_D Angle, Texture&amp; divTexture, int id, int TransFlag = TRUE, int ReverseXFlag = FALSE, int ReverseYFlag = FALSE, int ReverseZFlag = FALSE)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyDraw::DrawDivRotaGraphF3D(plane, xf, yf, zf, ExRate, Angle, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag, true); // ビルボード描画フラグをtrueに<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 画像の回転描画( 座標指定が float 版 )<br>
      &nbsp;&nbsp;&nbsp; static int DrawDivRotaGraphF(float xf, float yf, double ExRate, double Angle, Texture&amp; divTexture, int id, int TransFlag, int ReverseXFlag = FALSE, int ReverseYFlag = FALSE, int ReverseZFlag = FALSE)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // Zの値を0.0Fとして<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyDraw::DrawDivRotaGraphF3D(Plane::Z, xf, yf, 0.0F, ExRate, Angle, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 画像の回転描画( 座標指定が float 版 )【注意！】現状Angle回転機能は未対応<br>
      &nbsp;&nbsp;&nbsp; static int DrawDivRotaGraphF3D(Plane plane, float xf, float yf, float zf, double ExRate, double Angle, Texture&amp; divTexture, int id, int TransFlag = TRUE, int ReverseXFlag = FALSE, int ReverseYFlag = FALSE, int ReverseZFlag = FALSE)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D AngleVec = VecAngle(plane, Angle);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 角度だけ↓VECTOR化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyDraw::DrawDivRotaGraphF3D(plane, xf, yf, zf, ExRate, AngleVec, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp; // ↓すぐ下のAngleベクタ版関数に引き継ぐ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 画像の回転描画( 座標指定が float 版 )【注意！】現状Angle回転機能は未対応<br>
      &nbsp;&nbsp;&nbsp; static int <b>DrawDivRotaGraphF3D</b>(Plane plane, float xf, float yf, float zf, double ExRate, VECTOR_D Angle, Texture&amp; <b>divTexture</b>, int <b>id</b>, int TransFlag = TRUE, int ReverseXFlag = FALSE, int ReverseYFlag = FALSE, int ReverseZFlag = FALSE, bool isBillboard = false)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 遠すぎるものは描かないで即return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (zf &gt; farClipPlane) return -1;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手・左手系とY軸矢印の方向に従い座標を変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR COVERT_XYZ = MyDraw::VGet(xf, yf, zf);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float Xf = COVERT_XYZ.x, Yf = COVERT_XYZ.y, Zf = COVERT_XYZ.z;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (id &lt; 0 &amp;&amp; divTexture.m_handles.size() &lt;= id) { assert("div画像id指定範囲外" == ""); return -1; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imageWidth = divTexture.m_XSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imageHeight = divTexture.m_YSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float u_X0 = 0.0F, v_Y0 = 0.0F; //点Vertex[0]のuとvの値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float u_X3 = 1.0F, v_Y3 = 1.0F; //点Vertex[3]のuとvの値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (divTexture.m_XNum &gt; 1 || divTexture.m_YNum &gt; 1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // div分割画像の分割位置確定のため横uと縦vの値を計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int divX = id % divTexture.m_XNum;//分割X列番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int divY = id / divTexture.m_XNum;//分割Y行番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u_X0 = (float)divX / (float)(divTexture.m_XNum);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v_Y0 = (float)divY / (float)(divTexture.m_YNum);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u_X3 = (float)(divX + 1) / (float)(divTexture.m_XNum);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v_Y3 = (float)(divY + 1) / (float)(divTexture.m_YNum);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 【拡大縮小率ExRate】をかけて画像サイズを再計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imageWidth = (int)(imageWidth * ExRate);&nbsp; // 拡大縮小した画像の幅<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imageHeight = (int)(imageHeight * ExRate);// 拡大縮小した画像の高さ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float halfWidth = (float)(imageWidth / 2);//画像幅の1/2(先に計算し使いまわして処理削減)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float halfHeight = (float)(imageHeight / 2);//画像高さの1/2(先に計算し使いまわして処理削減)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //【テクスチャ反転処理】幅halfWidthと高さhalfHeightをマイナスにすることで反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★ReverseXFlagとIsReverseX_Texture両方反転は【反転の反転で=反転しない!】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 【反転の反転で=反転しない!】は★XOR【排他的論理和 ^ 演算子】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [排他的論理和 ^ 演算子]http://www7b.biglobe.ne.jp/~robe/cpphtml/html01/cpp01047.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((IsReverseX_Texture ^ (ReverseXFlag == TRUE))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (plane == Plane::Y || plane == Plane::Z))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // マイナス幅でテクスチャ反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; halfWidth = -halfWidth;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((IsReverseY_Texture ^ (ReverseYFlag == TRUE))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (plane == Plane::X || plane == Plane::Z))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // マイナス幅でテクスチャ反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; halfHeight = -halfHeight;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (IsReverseZ_Texture ^ (ReverseZFlag == TRUE))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // マイナス幅でテクスチャ反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (plane == Plane::X) halfWidth = -halfWidth;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (plane == Plane::Y) halfHeight = -halfHeight;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [頂点VERTEXは四角形は6個必要] https://dixq.net/rp/57.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★CGの【最小単位は三角形】2Dはドットの集合で描くが【CGは三角形の集合で描く】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>VERTEX3D</b> Vertex[6]; // ポリゴン２枚なので、頂点は６個(三角3点×2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // VERTEX3DSHADER Vertex[6]; // シェーダの頂点を使う場合<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★頂点情報のセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // Plane=X なら X平面に(Y,Z) = (yf,zf)中心に描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Plane=Y なら Y平面に(X,Z) = (xf,zf)中心に描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Plane=Z なら Z平面に(X,Y) = (xf,yf)中心に描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 回転は以下リンク参照<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=past&amp;no=2749<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX TransformMatrix;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 回転( x, y, z軸回転の順に回転した後、座標移動行列により平行移動)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★★MMultは行列の乗算【乗算した順にx軸回転→y軸回転→z軸回転→平行移動】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★【複数軸回転は頭が混乱するのでクォータニオンをつかうやり方もある】<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isBillboard)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D billboardAngle = (isBillboard) ? GetAngle(DxLib::GetCameraBillboardMatrixD()) : DxLib::VGetD(0, 0, 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Angle.x += billboardAngle.x; Angle.y += billboardAngle.y; Angle.z += billboardAngle.z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MGetRotX((float)Angle.x);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotY((float)Angle.y));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotZ((float)Angle.z));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★【座標移動行列により移動】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetTranslate(VGet(Xf, Yf, Zf)));<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (plane == Plane::X)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //座標固定平面→→→→→→→→→↓X平面指定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[0].pos = VTransform(VGet(0.0F, +halfHeight, -halfWidth), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[1].pos = VTransform(VGet(0.0F, +halfHeight, +halfWidth), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[2].pos = VTransform(VGet(0.0F, -halfHeight, -halfWidth), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[3].pos = VTransform(VGet(0.0F, -halfHeight, +halfWidth), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (plane == Plane::Y)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //座標固定平面→→→→→→→→→→→→→→→→↓Y平面指定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[0].pos = VTransform(VGet(-halfWidth, 0.0F, +halfHeight), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[1].pos = VTransform(VGet(+halfWidth, 0.0F, +halfHeight), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[2].pos = VTransform(VGet(-halfWidth, 0.0F, -halfHeight), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[3].pos = VTransform(VGet(+halfWidth, 0.0F, -halfHeight), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // if (plane == Plane::Z)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //座標固定平面→→→→→→→→→→→→→→→→→→→→→→↓Z平面指定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[0].pos = VTransform(VGet(-halfWidth, +halfHeight, 0.0F), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[1].pos = VTransform(VGet(+halfWidth, +halfHeight, 0.0F), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[2].pos = VTransform(VGet(-halfWidth, -halfHeight, 0.0F), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[3].pos = VTransform(VGet(+halfWidth, -halfHeight, 0.0F), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[4].pos = Vertex[2].pos; // 点2と点4は同じ位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[5].pos = Vertex[1].pos; // 点1と点5は同じ位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //↑点0 点1&amp;5 点4&amp;2 点3 の4点の四角形を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★div分割画像を考慮に入れて【UV展開】切り出し位置を0.0～1.0で指定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[0].u = u_X0; Vertex[0].v = v_Y0; Vertex[0].su = u_X0; Vertex[0].sv = v_Y0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[1].u = u_X3; Vertex[1].v = v_Y0; Vertex[1].su = u_X3; Vertex[1].sv = v_Y0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[2].u = u_X0; Vertex[2].v = v_Y3; Vertex[2].su = u_X0; Vertex[2].sv = v_Y3;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[3].u = u_X3; Vertex[3].v = v_Y3; Vertex[3].su = u_X3; Vertex[3].sv = v_Y3;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[4].u = u_X0; Vertex[4].v = v_Y3; Vertex[4].su = u_X0; Vertex[4].sv = v_Y3;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[5].u = u_X3; Vertex[5].v = v_Y0; Vertex[5].su = u_X3; Vertex[5].sv = v_Y0;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 輝度(拡散光:Diffuseの明るさ)は全地点100% a(拡散光:Diffuseのアルファ不透明度) も最大値(255=不透明 0=透明)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[0].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[1].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[2].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[3].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[4].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[5].dif = GetColorU8(255, 255, 255, 255);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 鏡面反射光(スペキュラ)は全地点30<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[0].spc = GetColorU8(0, 0, 0, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[1].spc = GetColorU8(0, 0, 0, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[2].spc = GetColorU8(0, 0, 0, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[3].spc = GetColorU8(0, 0, 0, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[4].spc = GetColorU8(0, 0, 0, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[5].spc = GetColorU8(0, 0, 0, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 法線を設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[0].norm = VGet(0.0f, 0.0f, -1.0f); // Vertex[0].binorm = // シェーダーを利用するとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[1].norm = VGet(0.0f, 0.0f, -1.0f); // Vertex[1].binorm = <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[2].norm = VGet(0.0f, 0.0f, -1.0f); // Vertex[2].binorm = <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[3].norm = VGet(0.0f, 0.0f, -1.0f); // Vertex[3].binorm = <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[4].norm = VGet(0.0f, 0.0f, -1.0f); // Vertex[4].binorm = <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[5].norm = VGet(0.0f, 0.0f, -1.0f); // Vertex[5].binorm = <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 0 1 2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 5 4 3<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //↑上の順の点で点0 点1&amp;5 点4&amp;2 点3 の4点の四角形を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //DxLib::DrawSphere3D(VGet(Xf, Yf, Zf),1, 4, GetColor(255, 255, 255),GetColor(255, 255, 255),FALSE); // テストとして四角形の中心に目印の球体を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ポリゴンを２枚描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::<b>DrawPolygon3D</b>(Vertex, 2, <b>divTexture[id]</b>, TransFlag);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (divTexture[id] != -1) //[シェーダーを利用する場合] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4204<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; DxLib::SetUseTextureToShader(0, divTexture[id]); // 使用するテクスチャを０番にセット<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // シェーダーを利用して描く場合はこちら https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4204<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //DxLib::DrawPolygon3DToShader(Vertex, 2); // シェーダーにも対応できるようにToShader系関数を通して描く<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // 画像ボックスの回転描画( 座標指定が float 版 )<br>
      &nbsp;&nbsp;&nbsp; static void <b>DrawDivBoxF3D</b>(float xf, float yf, float zf, double ExRate, Texture&amp; divTexture, int id, int TransFlag = TRUE, int ReverseXFlag = FALSE, int ReverseYFlag = FALSE, int ReverseZFlag = FALSE)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imageWidth = (int)((double)divTexture.m_XSize * ExRate);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imageHeight = (int)((double)divTexture.m_YSize * ExRate);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D Angle = VGetD(0,0,0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //サイコロの6面を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(Plane::Y, xf, yf - imageHeight / 2, zf, ExRate, Angle, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(Plane::Y, xf, yf + imageHeight / 2, zf, ExRate, Angle, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // X方向の裏側は左右反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(Plane::X, xf - imageWidth / 2, yf, zf, ExRate, Angle, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, !ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(Plane::X, xf + imageWidth / 2, yf, zf, ExRate, Angle, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(Plane::Z, xf, yf, zf - imageHeight / 2, ExRate, Angle, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Z方向の裏側は左右反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(Plane::Z, xf, yf, zf + imageHeight / 2, ExRate, Angle, divTexture, id, TransFlag, !ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 床の回転描画( 座標指定が float 版 )<br>
      &nbsp;&nbsp;&nbsp; static int DrawDivRotaFloorF3D(Plane plane, float xf, float yf, float zf, double ExRate, double Angle, Texture&amp; divTexture, int id, int TransFlag = TRUE, int ReverseXFlag = FALSE, int ReverseYFlag = FALSE, int ReverseZFlag = FALSE)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D AngleVec = VecAngle(plane, Angle);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imageHeight = (int)((double)divTexture.m_YSize * ExRate);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 角度だけ↓VECTOR化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyDraw::DrawDivRotaGraphF3D(plane, xf, yf - imageHeight / 2, zf, ExRate, AngleVec, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 四角形（枠線のみ）を描画する<br>
      &nbsp;&nbsp;&nbsp; static int DrawLineBox(VECTOR startPos, VECTOR endPos, unsigned int color)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawCube3D(startPos, endPos, color, color, FALSE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>main.cpp</code>にプログラムを追加し、MyDrawクラスを通して、ポリゴンでサイコロ状のボックスを描いてみましょう。</p>
    <p class="source"> #include "DxLib.h"<br>
      <br>
      #include "Resource.h"<br>
      <em>#include "MyDraw.h"</em><br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(960, 540, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(960, 540);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // タイルマップを読み込む 縦8マス、横8マス、縦32ピクセル、横32ピクセル<br>
      &nbsp;&nbsp;&nbsp; std::string mapChipPath{ "Map/mapchip.png" };<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath,8,8,32,32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込語にLoadもする<br>
      <em></em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 光の明暗計算を無効に<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>// 2Dタイル描画処理(位置x, y, 拡大率, 回転, 画像ID, TRUEなら透過有効)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawRotaGraphF(100, 200, 1.0f, 0, Resource::files[mapChipPath]-&gt;m_handles[2], TRUE);</u><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0,&nbsp; *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    いかがでしょう？謎のバラバラの変な図形がでちゃいましたか？<br>
    よく眺めてみましょう。お互いがお互いを塗りつぶしあっている感じですね。<br>
    これは、<b>カメラからの距離に応じて塗りつぶすかどうかを決める「Zバッファ」</b>が効いてない状態です。<br>
    Zバッファが効いていない状態では、3Dの図形を描いた順に塗りつぶされます。<br>
    <br>
    <p><code>main.cpp</code>のプログラムを変更し、Zバッファを有効にして描いてみましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Resource.h"<br>
      #include "MyDraw.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(960, 540, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(960, 540);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // タイルマップを読み込む 縦8マス、横8マス、縦32ピクセル、横32ピクセル<br>
      &nbsp;&nbsp;&nbsp; std::string mapChipPath{ "Map/mapchip.png" };<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath,8,8,32,32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込語にLoadもする<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// Ｚバッファを有効にする [Zの深度]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }<br>
    </p>
    <br>
    いかがですか？カメラからの距離に応じてタイルがサイコロ状に描画されましたか?<br>
    <br>
    Zバッファが有効ならば、<b>カメラから見た奥行き(=Z)と、すでにZバッファに塗られているドットの奥行きを比較して、手前のものが上に塗られていきます</b>。<br>
    逆にいうなら、岩の裏に隠れてカメラから見えないアイテムを、アイテムを描く際にZバッファを一時的に有効にしたり、無効にさせたりして、チカチカさせれば、<br>
    岩に隠れているアイテムを一番上に塗りつぶして、目立たせるような演出もできなくはないわけです(岩とかマップすべてがアイテムより先に描かれていればだが)<br>
    <br>
    <br>
    <br>
    <br>
    <a id="mozTocId0002" class="mozTocH1">
      <h1>複数カメラと複数スクリーンで複数プレイヤ視点で3D空間を描けるようにする</h1>
    </a>
    <p><code>Input.hとInput.cppを別記事から作成しておきます→</code><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId50020">Inputクラスを拡張してマウス、キーボード対応させる</a></p>
    <p><code>Vector3.hとVector3.cppを別記事から作成しておきます→</code><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/polygon3d/index.html#mozTocId0013">Vector3に色々な関数を用意して3D空間の当たり判定をする</a></p>
    <br>
    さて、複数のプレイヤで遊べるゲームを作るためには、カメラが複数あって、スクリーンに複数の視点が描ける機能が必要ですよね。<br>
    そう、実は、カメラが複数あるということはそれを描く先であるスクリーンも複数だったり、切り替える場合はスクリーン1枚だったりと、<br>
    カメラとそれを描くスクリーンは関連づいたり切り替わったり「リンクしあう関係に」なるのですね。<br>
    そして、GPUでの3Dの描画過程でも3D上のローカル位置→ワールド位置→カメラからのビュー行列変換→スクリーン射影変換→クリッピング...と、<br>
    <b>カメラの行列変換処理(3D)とスクリーン位置(2D)は、実は行列計算をはさんで表裏一体</b>の近い関係なのです。<br>
    <br>
    では、カメラとスクリーンの数だけ、変換行列がDXライブラリの内部に沢山あるのでしょうか？<br>
    実はそうではなくて、カメラのための変換行列は内部で1つだけ、で運用されています。<br>
    え、そうすると複数カメラ視点はどうやるの？と疑問と不安が出てきそうですが、<br>
    描く処理(=<b>Drawコール</b>)の直前に、その都度、カメラのための変換行列の設定値を変える処理を呼びだして、<br>
    カメラの行列のセッティングを変えたい→3Dを描きたい(=Drawコール)→カメラ行列設定を変えたい→.. 以下繰り返し<br>
    のような「コマンドをセットでまとめてGPUに送り付ける」という方式で、<br>
    画面スクリーン(画面に映らないスクリーンにも描ける)にGPUは処理の結果の数値(色など)を格納している、というわけで、<br>
    実はGPU側からすれば「カメラのセッティングを変えろ！」も「描け！(Drawコール)」もコマンドの1種として、<br>
    沢山の届いた一連のコマンドを「コマンドの順番に沿って たんたん と実行」してるにすぎないわけです。<br>
    <br>
    では、複数のカメラの視点を描くにはどうするかというと、<br>
    ①「描く先のスクリーンを変えろ！」→「カメラの位置などの設定を変えろ！」→...→「現在の行列設定でポリゴンを描け」...<br>
    ②「描く先のスクリーンを変えろ！」→「カメラの位置などの設定を変えろ！」→...→「現在の行列設定でポリゴンを描け」...<br>
    上記の一連のコマンドを、複数あるカメラの数①、②..ぶん繰り返せば、スクリーン①②..には違う視点の映像が描かれていくわけです。<br>
    <br>
    上記の世界観をイメージできると、<a href="https://docs.unity3d.com/ja/2021.3/Manual/optimizing-draw-calls.html">ドローコールに関する話題</a>もなんとなくイメージできるようになります。<br>
    そう、ほんとは、DxLib::DrawPolygonIndexed3DToShaderなどを呼ぶ回数を減らすために<br>
    「点のVertexをサイコロの面全部まとめて詰め込めば一気に6面(12ポリゴンぶん)」12コールのかわりに1回だけDrawコールを呼ぶ工夫など、<br>
    GPUの処理の負荷を下げる努力なども実はできて、アピールポイントにすることもできたりするわけです。<br>
    (点をまとめることはできるが、その点に張るテクスチャ指定は1枚=GPUの設計的に←だからUnityの木[同じ共通テクスチャの]が沢山ある森なんかは1回のドローコールにできるかも)<br>
    とりあえずは、基礎を勉強するために、最も愚直な形で1ポリゴンずつ3Dを描く形から始めているわけです。<br>
    一番愚直なスタンダードで愚かな基礎の経験から始めてこそ、それを工夫して変化させた「発展の発想ができる地力につながるわけなので」<br>
    逆に言うなら「便利に慣れすぎて原型に出会えない損失」のほうが危険な「ドローコールってなんですか状態(遊戯王っすか)」に陥るので。<br>
    (同じようなゲームを繰り替えし作るループでは地力は上がらない、次のゲームを作るためにどんな新たな知識を必要とし出会えたか？)<br>
    DXライブラリのDrawPolygonIndexed3DToShaderという関数を知っていることには、世間的には何の意味もないナンセンスだけども、<br>
    ポリゴンを描く「ドローコール」がGPUにどのように届くかの世界観を持っていることは、Unityにも他のゲームエンジンにも共通する意味のあること。<br>
    逆に言うならば、Unityの便利な関数を使いこなして同じようなゲームを作る作業ループも実はナンセンスを浪費してないか？を一旦振り返る必要がある。<br>
    <br>
    MyDraw.hというファイルの名前をつけてあるのも、マイダイアリー(私の日記)みたいなニュアンスで、<br>
    あくまで個人の見解のプログラムというニュアンスで名付けてあります。個人の見解でおのおのが進化させる余地があるということです。<br>
    <br>
    さて、では本題であるところの複数視点の描画に挑戦していきましょう。<br>
    <br>
    <p><code>Screen.hを新規作成</code>して、デフォルトの画面全体の縦横のサイズと<b>違うサイズの別スクリーンがStar()～End()関数で指定</b>されたときにも、<br>
      視野(FOV=<a href="https://www.youtube.com/watch?v=iqAvAFvlLy0">Field Of View</a>:フィールドのビュー)すなわちスクリーンに描かれる3Dの範囲を StartFov()～EndFov()関数でDraw系関数を囲うことで、<br>
      一時的にカメラの射影変換行列(プロジェクション行列)の幅w 高さhの行列のパラメータを変更した状態で、GPUに描かせることができるようにしましょう。</p>
    <p class="source">#ifndef _SCREEN_H<br>
      #define _SCREEN_H<br>
      <br>
      #include "DxLib.h"<br>
      <br>
      #include "Input.h"<br>
      <br>
      #include &lt;assert.h&gt; // アサート警告表示用<br>
      <br>
      // 画面解像度<br>
      class Screen<br>
      {<br>
      public: //publicはC＃と違いpublic:以下にまとめて書かれるスタイル<br>
      &nbsp;&nbsp;&nbsp; static constexpr int Width = 1280; // 幅(Nintendoスイッチの縦横サイズ[いわゆるHD画質16:9]を採用)<br>
      &nbsp;&nbsp;&nbsp; static constexpr int Height = 720; // 高さ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // X,Yがウィンドウの中にあるか<br>
      &nbsp;&nbsp;&nbsp; static bool IsInsideWindow(int screenX = Input::MouseX, int screenY = Input::MouseY) { return (0 &lt;= screenX &amp;&amp; screenX &lt; Width) &amp;&amp; (0 &lt;= screenY &amp;&amp; screenY &lt; Height); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; static int SubWidth, tmpSubWidth; // 現在指定中のサブのスクリーンの幅:SubWidth と 指定前のスクリーンの幅:tmpSubWidth<br>
      &nbsp;&nbsp;&nbsp; static int SubHeight, tmpSubHeight; // 現在指定中のサブのスクリーンの高さ:SubHeight と 指定前のスクリーンの高さ:tmpSubHeight<br>
      &nbsp;&nbsp;&nbsp; static int DrawHandle; // Start()～End()で指定中のハンドル番号<br>
      &nbsp;&nbsp;&nbsp; static int tmpDrawHandle; // Endまでのあいだ一旦変更前のhandleを退避<br>
      &nbsp;&nbsp;&nbsp; static int tmpResetSetting; // SetDrawScreen切り替え前に 設定を一旦tmpに退避<br>
      &nbsp;&nbsp;&nbsp; static MATRIX_D tmpViewportMatrix; // StartFov前に もとのビューポート行列を一旦退避<br>
      &nbsp;&nbsp;&nbsp; static MATRIX_D tmpProjectionMatrix; // StartFov前に もとの射影変換行列を一旦退避<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 射影変換行列とビューポート行列をスクリーンの大きさに合わせて再設定<br>
      &nbsp;&nbsp;&nbsp; static void StartFov(int handle, double fovAngle = 0)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // [描画の縦横領域が変わっても画角維持] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4639<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpViewportMatrix = DxLib::GetCameraViewportMatrixD(); // もとのビューポート行列を一旦退避<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpProjectionMatrix = DxLib::GetCameraProjectionMatrixD(); // もとの射影変換行列を一旦退避<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int handleWidth, handleHeight; // <b>描画するスクリーンのサイズ</b>を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetGraphSize(handle, <b>&amp;handleWidth, &amp;handleHeight</b>);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 射影行列を再設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX_D ProjectionMatrix;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double fovRad = (fovAngle == 0) ? DxLib::GetCameraFovD() : DX_PI * fovAngle / 180.0; // スクリーンに描くカメラの画角の設定 0のときは既存のFOVの設定を適用<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto dotAspect = DxLib::GetCameraDotAspectD(); // スクリーンに描くカメラのドットアスペクト比率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::<b>CreatePerspectiveFovMatrixD</b>(&amp;ProjectionMatrix, fovRad, DxLib::GetCameraNear(), DxLib::GetCameraFar(), (double)<b>handleHeight / handleWidth * dotAspect</b>);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToProjectionD(&amp;ProjectionMatrix); // 射影変換行列をスクリーン幅や高さやFOVの設定に合わせて一時的に再設定<br>
      #if 0 // [参考]デフォルトの射影変換行列のDXライブラリの内部計算<br>
      #define FOV&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (60.0 * DX_PI / 180.0)<br>
      #define NEARZ&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (0.0)<br>
      #define FARZ&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (1000.0)<br>
      #define TAN_FOV_HALF&nbsp;&nbsp;&nbsp; (0.52359877559829887307710723054658) // /*(0.57735026918962573)*/ tan( FOV * 0.5 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (略)...<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>w</b> = GSYS.DrawSetting.DrawSizeX;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>h</b> = GSYS.DrawSetting.DrawSizeY;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D = (double)((h / 2) / TAN_FOV_HALF);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (略)...<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreatePerspectiveFovMatrixD(&amp;mat, FOV, D * 0.1, D + FARZ, -1.0f); // デフォルトの射影変換行列 呼び出し<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (略)...<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↓ デフォルトの射影変換行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX_D mat; // ProjectionMatrix 射影行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double Sin = std::sin(fov / 2), Cos = std::cos(fov / 2); // tan(θ / 2) = Sin / Cos&nbsp;&nbsp; θ = fovのとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (-0.0001 &lt; Sin &amp;&amp; Sin &lt; 0.0001) return -1;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aspect = (double)MathScreenSizeY / (double)MathScreenSizeX;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double <b>w = aspect * (Cos / Sin); // = 高/幅 / tan( θ / 2 )</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double <b>h = 1.0 * (Cos / Sin); // = 1 / tan( θ / 2 )</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat-&gt;m[0][0] = <b>w</b>;&nbsp;&nbsp; mat-&gt;m[0][1] = 0;&nbsp;&nbsp; mat-&gt;m[0][2] = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat-&gt;m[0][3] = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat-&gt;m[1][0] = 0;&nbsp;&nbsp; mat-&gt;m[1][1] = <b>h</b>;&nbsp;&nbsp; mat-&gt;m[1][2] = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat-&gt;m[1][3] = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat-&gt;m[2][0] = 0;&nbsp;&nbsp; mat-&gt;m[2][1] = 0;&nbsp;&nbsp; mat-&gt;m[2][2] = zFar / (zFar - zNear);&nbsp; mat-&gt;m[2][3] = 1.0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat-&gt;m[3][0] = 0;&nbsp;&nbsp; mat-&gt;m[3][1] = 0;&nbsp;&nbsp; mat-&gt;m[3][2] = -zNear * zFar / (zFar - zNear);&nbsp; mat-&gt;m[3][3] = 0.0;<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビューポート行列の再設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[<b>スクリーン上の3Dの消失点をスクリーンのサイズの1/2の真ん中の位置に設定</b>] https://dxlib.xsrv.jp/function/dxfunc_3d_camera.html#R12N12<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetCameraScreenCenter((float)handleWidth / 2.0f, (float)handleHeight / 2.0f);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 射影変換行列とビューポート行列をStartFovする前に戻す<br>
      &nbsp;&nbsp;&nbsp; static void EndFov()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToProjectionD(&amp;tmpViewportMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToViewportD(&amp;tmpProjectionMatrix);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ★このStartとEndのあいだの描画処理は別スクリーンに描かれるようになる is3Dに<br>
      &nbsp;&nbsp;&nbsp; static int Start(int handle = DX_SCREEN_BACK, bool is3D = false, double fovAngle = 0)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // スクリーンのハンドルが 0以下 なら普通のスクリーンに描画する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (handle &lt; 0) handle = DX_SCREEN_BACK;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::tmpResetSetting = DxLib::GetUseSetDrawScreenSettingReset(); // 設定を一旦tmpに退避<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseSetDrawScreenSettingReset(FALSE); // SetDrawScreen切り替え時に設定をリセットしない(FALSE)(これをやらないとカメラ視点などがリセットされるから)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::tmpDrawHandle = DxLib::GetDrawScreen(); // Endまでのあいだ一旦変更前のhandleを退避<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetGraphSize(tmpDrawHandle, &amp;tmpSubWidth, &amp;tmpSubHeight); // 現在のスクリーンのサイズを一旦退避<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 描く先を別途用意した別スクリーン(指定されたhandle)に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (DxLib::<b>SetDrawScreen(handle)</b> == -1) DxLib::SetDrawScreen(handle = DX_SCREEN_BACK); // -1 失敗したら普通のDX_SCREEN_BACKのほうに描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::DrawHandle = handle; // 現在選択中のスクリーンのハンドル番号を handleに 変更<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 描画するスクリーンのサイズを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (DxLib::GetGraphSize(handle, &amp;Screen::SubWidth, &amp;Screen::SubHeight) == -1) return handle; // -1 失敗したらreturn<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is3D) // 3Dのときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::<b>StartFov(handle, fovAngle); // 射影変換行列とビューポート行列をスクリーンの大きさに合わせて再設定</b><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return handle;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ★このStartとEndのあいだの描画処理は別スクリーンに描かれるようになる<br>
      &nbsp;&nbsp;&nbsp; static void End(bool is3D = false)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ゲームを描く先をもとのデフォルトに戻しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawScreen(tmpDrawHandle = (tmpDrawHandle &lt; 0) ? DX_SCREEN_BACK : tmpDrawHandle);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::DrawHandle = tmpDrawHandle; // 現在選択中のスクリーンのハンドル番号を handleに 変更<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int beforeSubWidth = Screen::SubWidth, beforeSubHeight = Screen::SubHeight; // Start()で変更した幅と高さを 一時退避<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (DxLib::GetGraphSize(tmpDrawHandle, &amp;Screen::SubWidth, &amp;Screen::SubHeight) == -1) return; // -1 失敗したらreturn<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is3D) // 3Dのときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::<b>EndFov(); // 射影変換行列とビューポート行列をStartFovする前に戻す</b><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseSetDrawScreenSettingReset((tmpResetSetting == -1) ? TRUE : tmpResetSetting); // 設定をStart()前の元に戻す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 指定した screenHandle のキャンバスをきれいにまっさらにクリアする<br>
      &nbsp;&nbsp;&nbsp; static void ClearDrawScreen(int screenHandle)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::Start(screenHandle);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen(); // screenHandle のキャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::End();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };// C＃と違ってクラスの定義も;セミコロンで終わる<br>
      <br>
      <br>
      <br>
      #endif</p>
    <br>
    <p><code>Screen.cppを新規作成</code>して、Start()～End()やStartFov()～EndFov()の間にはさんでDrawコールするあいだ、<br>
      Start()で一時的にパラメータを変更する前のカメラの行列のパラメータを一旦保管するtmp～系変数をstatic定義します。<br>
    </p>
    <p class="source">#include "Screen.h"<br>
      <br>
      <br>
      int Screen::SubWidth{ 0 }, Screen::tmpSubWidth{ 0 }; // 現在指定中のサブのスクリーンの幅:SubWidth と 指定前のスクリーンの幅:tmpSubWidth<br>
      int Screen::SubHeight{ 0 }, Screen::tmpSubHeight{ 0 }; // 現在指定中のサブのスクリーンの高さ:SubHeight と 指定前のスクリーンの高さ:tmpSubHeight<br>
      <br>
      int Screen::DrawHandle{ DxLib::GetDrawScreen() }; // Start()～End()で指定中のハンドル番号<br>
      int Screen::tmpDrawHandle{ -1 }; // Endまでのあいだ一旦変更前のhandleを退避<br>
      int Screen::tmpResetSetting{ -1 }; // SetDrawScreen切り替え前に 設定を一旦tmpに退避<br>
      MATRIX_D Screen::tmpViewportMatrix; // StartFov前に もとのビューポート行列を一旦退避<br>
      MATRIX_D Screen::tmpProjectionMatrix; // StartFov前に もとの射影変換行列を一旦退避<br>
      <br>
    </p>
    Start()で一旦もとからのパラメータをtmp～の変数に退避しておいて、End()でそれを元のパラメータ設定に戻すという方式です。<br>
    <br>
    さて、スクリーンのStart()関数にFOV視野の角度を渡さなければならぬということは、<br>
    当然、カメラ側から現在のFOV視野の角度のセッティングなどをDXライブラリ内部のカメラのビュー行列から得るための関数も必要です。<br>
    さらに、複数カメラがあるということは、カメラの位置も複数持てるように、カメラの初期化コンストラクタやカメラの位置の変数を準備する必要があります。<br>
    <p><code>Camera.hを新規作成</code>して、GetCameraSetting関数などで現在のFov視野角などの情報を得たり、個別にカメラをコンストラクタで初期化できるようにしましょう。</p>
    <p class="source">#ifndef CAMERA_H_<br>
      #define CAMERA_H_<br>
      <br>
      #include &lt;functional&gt; // カメラのDraw関数に「引数として関数=ラムダ式」を渡してカメラのDraw関数の外側の呼び出し元から描画したい処理を渡すことができるようにする<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "MyDraw.h"<br>
      #include "Vector3.h"<br>
      <br>
      <br>
      class Camera<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // カメラの位置(ワールド座標)<br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 pos; // カメラの位置(ワールド座標)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // unionしてx,y,zでもアクセスできるように<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; struct Rotate { double V, H, T; }; // カメラの回転角度定義 DXライブラリの内部行列ではfloatじゃなくてdouble型で保持されているので倍精度のdouble型にした<br>
      &nbsp;&nbsp;&nbsp; Rotate rot{ 0.0, 0.0, 0.0 }; // カメラの3軸の回転角度<br>
      &nbsp;&nbsp;&nbsp; double <b>fovAngle</b> = 0; // カメラをスクリーンに描くときの視野角(0～179度) 0のときはDxLib::GetCameraFovD()で得られる値が適用される<br>
      <br>
      &nbsp;&nbsp;&nbsp; float cameraLookAtHeight{ 0.0f }; // LookAtする対象を見下ろす高さ<br>
      <br>
      &nbsp;&nbsp;&nbsp; int <b>screenHandle</b> = DX_SCREEN_BACK; //<b>カメラを描くスクリーンのハンドル番号</b><br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Camera(Vector3 worldPos) : pos{ worldPos } {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; // デストラクタ<br>
      &nbsp;&nbsp;&nbsp; ~Camera() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラを通して描くスクリーンのハンドル番号を設定する<br>
      &nbsp;&nbsp;&nbsp; void <b>SetScreenHandle</b>(int handle) { <b>screenHandle</b> = handle; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラの位置をセットしなおす<br>
      &nbsp;&nbsp;&nbsp; void SetPosition(Vector3 worldPos)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ワールド座標系として保存<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;pos = worldPos;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 指定されたワールド座標が画面の中心に来るように、カメラの位置を変更する<br>
      &nbsp;&nbsp;&nbsp; void LookAt(Vector3 targetXYZ)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // カメラの位置と向きを設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //MyDraw::SetCameraPositionAndTarget_UpVecY(pos, targetXYZ + Vector3(0, cameraLookAtHeight,0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 注視点はターゲットの座標から cameraLookAtHeight 分だけ高い位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndTarget_UpVecY(this-&gt;pos, targetXYZ + Vector3(0, this-&gt;cameraLookAtHeight, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;rot.H = DxLib::GetCameraAngleHRotateD(); // カメラの水平方向の向きを取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;rot.V = DxLib::GetCameraAngleVRotateD();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;rot.T = DxLib::GetCameraAngleTRotateD();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 現在のDX内部のカメラのビュー行列などに入っているカメラの設定パラメータを得る<br>
      &nbsp;&nbsp;&nbsp; static void <b>GetCameraSettings</b>(VECTOR_D* pPosition, double* pRotV = nullptr, double* pRotH = nullptr, double* pRotT = nullptr,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double* <b>pFov</b> = nullptr, double* pNear = nullptr, double* pFar = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pPosition != nullptr) *pPosition = DxLib::GetCameraPositionD(); // カメラ位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pRotV != nullptr) *pRotV = DxLib::GetCameraAngleVRotateD(); // カメラの角度V<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pRotH != nullptr) *pRotH = DxLib::GetCameraAngleHRotateD(); // カメラの角度H<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pRotT != nullptr) *pRotT = DxLib::GetCameraAngleTRotateD(); // カメラの角度T<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pFov != nullptr) *pFov = DxLib::<b>GetCameraFovD</b>(); // カメラの視野角<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pNear != nullptr) *pNear = DxLib::GetCameraNearD(); // カメラ一番近くの描き始めるレンジ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pFar != nullptr) *pFar = DxLib::GetCameraFarD(); // カメラ一番遠くの描くレンジ<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラの視野角に変更があったら変えて射影変換行列を再計算する (現在と同じfovの数値の場合は再計算をしないで負荷を回避)<br>
      &nbsp;&nbsp;&nbsp; static inline void SetupCamera_PerspectiveD(double fov) { if (DxLib::GetCameraFovD() != fov) DxLib::SetupCamera_PerspectiveD(fov); }<br>
      &nbsp;&nbsp;&nbsp; // カメラの視野角に変更があったら変えて射影変換行列を再計算する (現在と同じfovの数値の場合は再計算をしないで負荷を回避)<br>
      &nbsp;&nbsp;&nbsp; static inline void SetCameraNearFarD(double Near, double Far) { if (DxLib::GetCameraNearD() != Near &amp;&amp; DxLib::GetCameraFarD() != Far) DxLib::SetCameraNearFarD(Near, Far); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラの設定を変える<br>
      &nbsp;&nbsp;&nbsp; static void SetCameraSettings(VECTOR_D* pPosition, double* pRotV, double* pRotH, double* pRotT,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double* pFov = nullptr, double* pNear = nullptr, double* pFar = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pPosition != nullptr &amp;&amp; pRotV != nullptr &amp;&amp; pRotH != nullptr &amp;&amp; pRotT != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngleD(*pPosition, *pRotV, *pRotH, *pRotT);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pFov != nullptr) Camera::<b>SetupCamera_PerspectiveD(*pFov)</b>; // カメラの視野角に変化があったら射影変換行列を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pNear != nullptr &amp;&amp; pFar != nullptr) Camera::SetCameraNearFarD(*pNear, *pFar); // カメラ一番近くから遠くまで描くレンジ<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // このワールドに存在するカメラすべてに対して funcで描きたい処理を渡して 全カメラのスクリーンに対して描画処理を走らせる<br>
      &nbsp;&nbsp;&nbsp; inline void Draw(<b>std::function&lt;void()&gt; drawFunc</b>) noexcept<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D beforeCamPos; // 設定変更前のカメラのパラメータを一旦、保管<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double beforeVRot, beforeHRot, beforeTRot, beforeNear, beforeFar, beforeFov;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Camera::<b>GetCameraSettings</b>(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;<b>beforeFov</b>, &amp;beforeNear, &amp;beforeFar);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::<b>SetCameraPositionAndAngle</b>(this-&gt;pos, this-&gt;rot.V, this-&gt;rot.H, this-&gt;rot.T); // カメラの位置、回転を設定<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Screen::Start</b>(this-&gt;<b>screenHandle</b>, true, this-&gt;<b>fovAngle</b>); // <b>カメラに関連付けられたscreenHandleのスクリーンを描画先にする</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>drawFunc(); // 渡された描画処理を実行</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Screen::End</b>(true); // 描画先を元に戻す<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <b>カメラの設定をもとに戻しておく</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Camera::SetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;<b>beforeFov</b>, &amp;beforeNear, &amp;beforeFar);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    個々のカメラには、上記↑のDraw関数を準備して、その引数に std::function型のdrawfunc 経由で描きたい処理(=関数)を渡せるようにしてあります。<br>
    トリッキーに聞こえるかもしれませんが、関数の引数( )内に関数を渡すのです。<br>
    Draw関数に関数を渡せれば、Draw関数を呼び出す外側から色んなDraw系の処理を使う側が自由に渡せます。<br>
    std::function型のラムダ式ならばそれができます。プログラミングの自由度がめちゃめちゃ上がります。<br>
    <br>
    <br>
    では、実際にそのDraw関数にラムダ式[&amp;]{ ～ }で描画処理を渡してみましょう。<br>
    <p><code>main.cppを変更</code>して、複数カメラ視点、複数カメラで3Dを描いてみましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      <em>#include "Screen.h"<br>
        #include "Camera.h"</em><br>
      #include "Resource.h"<br>
      #include "MyDraw.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(<em>Screen::Width, Screen::Height</em>, 32); // 画面サイズ <em>Width×Height</em>のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(<em>Screen::Width, Screen::Height</em>);// ウィンドウサイズ <em>Width×Height</em>(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // タイルマップを読み込む 縦8マス、横8マス、縦32ピクセル、横32ピクセル<br>
      &nbsp;&nbsp;&nbsp; std::string mapChipPath{ "Map/mapchip.png" };<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath,8,8,32,32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      <br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <em>// SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する<br>
        &nbsp;&nbsp;&nbsp; // ( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを2つ生成 画面の全体の縦方向サイズの Height / 2 にして、上下分割で配置できるようにする<br>
        &nbsp;&nbsp;&nbsp; int screenHandle0 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
        &nbsp;&nbsp;&nbsp; int screenHandle1 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; // カメラを2つ生成して、2つのカメラ視点を2つのスクリーンにそれぞれ関連付ける<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;std::shared_ptr&lt;Camera&gt;&gt; cameras; // 複数のカメラへのポインタを格納する配列<br>
        &nbsp;&nbsp;&nbsp; cameras.emplace_back(std::make_shared&lt;Camera&gt;(Vector3{ 20,40,-50 })); // カメラ0<br>
        &nbsp;&nbsp;&nbsp; cameras.emplace_back(std::make_shared&lt;Camera&gt;(Vector3{ 80,30,-50 })); // カメラ1<br>
        <br>
        &nbsp;&nbsp;&nbsp; cameras[0]-&gt;screenHandle = screenHandle0; // カメラ0 と スクリーン0 を関連付ける<br>
        &nbsp;&nbsp;&nbsp; cameras[1]-&gt;screenHandle = screenHandle1; // カメラ1 と スクリーン1 を関連付ける</em><br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Screen::ClearDrawScreen(screenHandle0); // 一旦スクリーン0のキャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle1); // 一旦スクリーン1のキャンバスをきれいにまっさらに</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファを有効にする [Zの深度]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 複数のカメラを 範囲 for文 で回す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; camera : cameras)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ラムダ式[&amp;](){ ～ }で{}の外側の変数すべてを &amp; キャプチャで&amp;参照として「Draw関数の内側へ引き連れて」処理できる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw関数() の 外側にある変数 mapChipPath も[&amp;]効果で { } の内側で問題なくアクセスできている↓</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 0);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 70, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 4);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// スクリーン0の内容を画面に描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, 0, screenHandle0, FALSE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, 0, Screen::Width, Screen::Height / 2, GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーン1の内容を画面に描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, Screen::Height / 2, screenHandle1, FALSE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, Screen::Height / 2, Screen::Width, Screen::Height, GetColor(0, 255, 0));</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }<br>
    </p>
    いかがでしょう？複数のカメラ視点からの3Dのビューが、上下複数のスクリーンに描画されたでしょうか？<br>
    (見やすいようにタイルのブロックの数も3つに増やしておきました。)<br>
    ラムダ式は便利なのですが、あまり初心者向けのC++の本には出てきたのを見たことがありません。<br>
    私もC++とは関係ない別言語のJavascript経由で、<a href="https://dqn.sakusakutto.jp/2009/01/javascript_1.html">関数の中に関数を渡せると便利</a>だというニーズに気づきました。<br>
    今回のラムダ式はJavascriptでいうところの、<a href="https://dqn.sakusakutto.jp/2009/01/javascript_2.html">無名関数として3Dブロックを描く処理</a>をdrawfuncとしてDraw関数の引数に渡した形という雰囲気でしょうか。<br>
    ある言語においては基本的な文法が、別の言語では初心者向けではない、みたいな扱いになっていたりするのは機会の損失ですよね。<br>
    大事なのは「文法を実際に使いたくなるシチュエーションに出会えるかどうか」です。<br>
    その意味で今回のDrawへの 無名ラムダ式渡し はぴったりの実例だと思います。<br>
    ラムダ式がなかったら...色んな種類のDraw処理を書き分けるのが...どうするよ...難しくなります。<br>
    <br>
    「それでは今回の文法ニーズを振り返っておきましょう。」<br>
    Start() ～ End() で囲い込むスタイルの書き方のニーズがある。→<a href="https://qiita.com/Ushio/items/446d78c881334919e156">imguiのBegin()～End()囲いの雰囲気</a><br>
    関数の中に関数を渡すにはラムダ式が便利。(C++の入門書にはあまり出てこないので学校で勉強してても卒業まで出会えないことも多い)<br>
    <br>
    今回はDraw関数にdrawfuncとして、描きたい処理を渡すことで、<br>
    <p class="source">void Draw関数 (&nbsp;&nbsp;&nbsp; drawfunc &nbsp;&nbsp;&nbsp;)<br>
      {<br>
      &nbsp;&nbsp;Start() ←カメラやスクリーンの設定を変える(もとの設定を一旦保管しておく)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;drawfunc() ←描きたい処理をはさみこんだ真ん中で実行する<br>
      <br>
      &nbsp;&nbsp;End() ←カメラやスクリーンの設定を元に戻す<br>
      }<br>
    </p>
    以上の処理を割と簡単に書くことができました。<br>
    ん、カメラもDrawStart() ～ DrawEnd() みたいに囲うスタイルにもできるんじゃないかって？<br>
    確かに、できますね。<br>
    要はセッティングの変数をDXライブラリ内部やCameraクラスやScreenクラスが蓄えることができれば、<br>
    Start() ～ End() 方式で設計することもできますね。<br>
    では、ラムダ式が真に威力を発揮するのはどういうときでしょうか？<br>
    たとえばStart() End()でさばけないような、データが複雑な木構造のときに、木の枝をたどって、<br>
    目的のデータにたどりついたら drawfunc を実行するとしたらどうでしょう？<br>
    沢山の関節があるCGデータやフォルダの中にフォルダがあるような木の構造をたどって、<br>
    CGの指だったらある処理を走らせたいとか、<br>
    フォルダをたどった先にあるデータが写真形式だったら写真アイコンを描く、<br>
    とか複雑な構造の場合はラムダ式を渡す形が向いているかもしれません。<br>
    <br>
    <br>
    <br>
    <a id="mozTocId0003" class="mozTocH1">
      <h1>文字タグ判定の代わりに使えるハッシュ(32bit)でカメラにhash32タグをつけて管理する</h1>
    </a> まず、最初にハッシュという言葉は色んな意味で使われている(ハッシュドビーフも)ので区別しなければいけない<br>
    英語圏で＃はハッシュと読まれる。だからハッシュタグのハッシュは＃の意味だ。<br>
    それとは<b>全く異なる</b> <b>情報科学の言葉</b>としても「<a href="https://ja.wikipedia.org/wiki/%E6%9A%97%E5%8F%B7%E5%AD%A6%E7%9A%84%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E9%96%A2%E6%95%B0">暗号学的ハッシュ関数</a>」のようなハッシュという言葉がある。<br>
    今回のハッシュはこちらの情報科学のハッシュ関数に近い概念だ。<br>
    例えば、パスワードは入力された文字の羅列をそのままネットで送信すると、個人情報が「もれ放題」になる。<br>
    なので<b>パスワードの文字の羅列を数字などの羅列に変換するパスワード変換の関数を通して</b>から、ネット経由でサーバーに送られる。<br>
    その変換に「法則性がなければ、ないほど」解読が難しい変換の関数として評価される。<br>
    ただし、忘れてはいけないのは、ある文字の羅列に対して、<br>
    変換した後にできる数字などの羅列が他のパスワードを入力した場合にできるものと同じ(かぶる)だと、<br>
    別の間違ったパスワードでログインできちゃうことになりうる。<br>
    なので、ある文字の羅列に対して、変換後にできる数字などの羅列は「<b>ほぼかぶらない(42億分の1とか)</b>」必要がある。<br>
    <b>ハッシュ関数は、この「変換前のパターンに対して、変換後のパターンが※ほぼかぶらない」性質を持つ色んな数式的関数</b>のことを言う。<br>
    <b>逆にいうと「めっちゃかぶる手抜きのハッシュ関数」の計算ルールも考え出すこともできる</b>。<br>
    例えば、ある数字のパスワードを、あるキーとなる数字で割った余りを変換後のパスワードとするとすると<br>
    <b>パスワードの数字が10だったとする。パスワードをキー:8で割るというハッシュ関数を考える</b>とすると<br>
    <b>パスワード:10 が 変換後:2</b> になる。<br>
    そうすると<b>9ではログインできないが10や18なら余りが2になってログインできるハッシュ関数</b>ができあがる。<br>
    やばいじゃん！と思うかもしれないが<b>ハッシュ関数のルールとはそれが8分の1の確率なのか、42億分の1の確率なのかの違いに過ぎない</b>。<br>
    ハッシュの一致判定とは、<b>ある入力を一定のかぶりにくいルールで変換して、その変換後の出力どうしが一致するか判定すること</b>だ。<br>
    そして、もう一つ着目してほしい点がある。<br>
    8で割ると10が2になって、<b>2桁の10 が 1桁の2 の数字になって数字の桁数が減っている！</b><br>
    これは890とか3桁の数字にも当てはまる。<br>
    そう、<b>どんな入力も一定の桁数内に収めてしまう性質をもったハッシュ関数がありうる</b>のだ。<br>
    今回、<b>導入するhash32はどんな文字の羅列でも32桁の0と1の2進数に収めてしまう性質</b>をもったハッシュ関数が採用されている。<br>
    "Zako0"などの判別タグを、文字列のままデータとしてキープしておくと長い文字列のタグでデータはかさばるし、 <br>
    それよりは、<b>用途が「タグが一致するか」だけなら、文字列のままではなく、hash32型の32桁の0と1のビットとして保管</b>しておいて、<b><br>
      32桁の0,1の数字どうしを判別</b>したほうが、<br>
    <b>メモリの消費量</b>(=32bitで一定)的にも、<b>一致判定の速度的</b>にも(文字列どうしの比較はめちゃ遅いので)効率的になる。<br>
    <br>
    <p><code>MyHash.hを新規作成</code>して、文字列をハッシュのルールに基づいて32桁の0と1に変換してhash32型のタグどうしで一致判定できるようにしましょう。</p>
    <p class="source">#ifndef MYHASH_H_<br>
      #define MYHASH_H_<br>
      <br>
      #include &lt;string&gt;<br>
      #include &lt;stdint.h&gt; // uint32_t 型 32ビットの unsined 数値型に変換する<br>
      <br>
      #define CRC32_TABLE_SIZE (256) // CRC32テーブルの要素数<br>
      <br>
      // 言語 C++ C# など や ビルドするコンパイラ VisualStudioやgccなどに関係なく同じハッシュを計算値できる<br>
      // [参考] https://norizn.hatenablog.com/entry/2020/10/18/145628<br>
      <br>
      // <b>生成済みのCRC32テーブル</b> このテーブルをベースとして使用してハッシュ値を計算する<br>
      static constexpr uint32_t s_crc32_table[CRC32_TABLE_SIZE] =<br>
      {<br>
      &nbsp;&nbsp;&nbsp; 0x00000000, 0x04C11DB7, 0x09823B6E, 0x0D4326D9,<br>
      &nbsp;&nbsp;&nbsp; 0x130476DC, 0x17C56B6B, 0x1A864DB2, 0x1E475005,<br>
      &nbsp;&nbsp;&nbsp; 0x2608EDB8, 0x22C9F00F, 0x2F8AD6D6, 0x2B4BCB61,<br>
      &nbsp;&nbsp;&nbsp; 0x350C9B64, 0x31CD86D3, 0x3C8EA00A, 0x384FBDBD,<br>
      &nbsp;&nbsp;&nbsp; 0x4C11DB70, 0x48D0C6C7, 0x4593E01E, 0x4152FDA9,<br>
      &nbsp;&nbsp;&nbsp; 0x5F15ADAC, 0x5BD4B01B, 0x569796C2, 0x52568B75,<br>
      &nbsp;&nbsp;&nbsp; 0x6A1936C8, 0x6ED82B7F, 0x639B0DA6, 0x675A1011,<br>
      &nbsp;&nbsp;&nbsp; 0x791D4014, 0x7DDC5DA3, 0x709F7B7A, 0x745E66CD,<br>
      &nbsp;&nbsp;&nbsp; 0x9823B6E0, 0x9CE2AB57, 0x91A18D8E, 0x95609039,<br>
      &nbsp;&nbsp;&nbsp; 0x8B27C03C, 0x8FE6DD8B, 0x82A5FB52, 0x8664E6E5,<br>
      &nbsp;&nbsp;&nbsp; 0xBE2B5B58, 0xBAEA46EF, 0xB7A96036, 0xB3687D81,<br>
      &nbsp;&nbsp;&nbsp; 0xAD2F2D84, 0xA9EE3033, 0xA4AD16EA, 0xA06C0B5D,<br>
      &nbsp;&nbsp;&nbsp; 0xD4326D90, 0xD0F37027, 0xDDB056FE, 0xD9714B49,<br>
      &nbsp;&nbsp;&nbsp; 0xC7361B4C, 0xC3F706FB, 0xCEB42022, 0xCA753D95,<br>
      &nbsp;&nbsp;&nbsp; 0xF23A8028, 0xF6FB9D9F, 0xFBB8BB46, 0xFF79A6F1,<br>
      &nbsp;&nbsp;&nbsp; 0xE13EF6F4, 0xE5FFEB43, 0xE8BCCD9A, 0xEC7DD02D,<br>
      <br>
      &nbsp;&nbsp;&nbsp; 0x34867077, 0x30476DC0, 0x3D044B19, 0x39C556AE,<br>
      &nbsp;&nbsp;&nbsp; 0x278206AB, 0x23431B1C, 0x2E003DC5, 0x2AC12072,<br>
      &nbsp;&nbsp;&nbsp; 0x128E9DCF, 0x164F8078, 0x1B0CA6A1, 0x1FCDBB16,<br>
      &nbsp;&nbsp;&nbsp; 0x018AEB13, 0x054BF6A4, 0x0808D07D, 0x0CC9CDCA,<br>
      &nbsp;&nbsp;&nbsp; 0x7897AB07, 0x7C56B6B0, 0x71159069, 0x75D48DDE,<br>
      &nbsp;&nbsp;&nbsp; 0x6B93DDDB, 0x6F52C06C, 0x6211E6B5, 0x66D0FB02,<br>
      &nbsp;&nbsp;&nbsp; 0x5E9F46BF, 0x5A5E5B08, 0x571D7DD1, 0x53DC6066,<br>
      &nbsp;&nbsp;&nbsp; 0x4D9B3063, 0x495A2DD4, 0x44190B0D, 0x40D816BA,<br>
      &nbsp;&nbsp;&nbsp; 0xACA5C697, 0xA864DB20, 0xA527FDF9, 0xA1E6E04E,<br>
      &nbsp;&nbsp;&nbsp; 0xBFA1B04B, 0xBB60ADFC, 0xB6238B25, 0xB2E29692,<br>
      &nbsp;&nbsp;&nbsp; 0x8AAD2B2F, 0x8E6C3698, 0x832F1041, 0x87EE0DF6,<br>
      &nbsp;&nbsp;&nbsp; 0x99A95DF3, 0x9D684044, 0x902B669D, 0x94EA7B2A,<br>
      &nbsp;&nbsp;&nbsp; 0xE0B41DE7, 0xE4750050, 0xE9362689, 0xEDF73B3E,<br>
      &nbsp;&nbsp;&nbsp; 0xF3B06B3B, 0xF771768C, 0xFA325055, 0xFEF34DE2,<br>
      &nbsp;&nbsp;&nbsp; 0xC6BCF05F, 0xC27DEDE8, 0xCF3ECB31, 0xCBFFD686,<br>
      &nbsp;&nbsp;&nbsp; 0xD5B88683, 0xD1799B34, 0xDC3ABDED, 0xD8FBA05A,<br>
      <br>
      &nbsp;&nbsp;&nbsp; 0x690CE0EE, 0x6DCDFD59, 0x608EDB80, 0x644FC637,<br>
      &nbsp;&nbsp;&nbsp; 0x7A089632, 0x7EC98B85, 0x738AAD5C, 0x774BB0EB,<br>
      &nbsp;&nbsp;&nbsp; 0x4F040D56, 0x4BC510E1, 0x46863638, 0x42472B8F,<br>
      &nbsp;&nbsp;&nbsp; 0x5C007B8A, 0x58C1663D, 0x558240E4, 0x51435D53,<br>
      &nbsp;&nbsp;&nbsp; 0x251D3B9E, 0x21DC2629, 0x2C9F00F0, 0x285E1D47,<br>
      &nbsp;&nbsp;&nbsp; 0x36194D42, 0x32D850F5, 0x3F9B762C, 0x3B5A6B9B,<br>
      &nbsp;&nbsp;&nbsp; 0x0315D626, 0x07D4CB91, 0x0A97ED48, 0x0E56F0FF,<br>
      &nbsp;&nbsp;&nbsp; 0x1011A0FA, 0x14D0BD4D, 0x19939B94, 0x1D528623,<br>
      &nbsp;&nbsp;&nbsp; 0xF12F560E, 0xF5EE4BB9, 0xF8AD6D60, 0xFC6C70D7,<br>
      &nbsp;&nbsp;&nbsp; 0xE22B20D2, 0xE6EA3D65, 0xEBA91BBC, 0xEF68060B,<br>
      &nbsp;&nbsp;&nbsp; 0xD727BBB6, 0xD3E6A601, 0xDEA580D8, 0xDA649D6F,<br>
      &nbsp;&nbsp;&nbsp; 0xC423CD6A, 0xC0E2D0DD, 0xCDA1F604, 0xC960EBB3,<br>
      &nbsp;&nbsp;&nbsp; 0xBD3E8D7E, 0xB9FF90C9, 0xB4BCB610, 0xB07DABA7,<br>
      &nbsp;&nbsp;&nbsp; 0xAE3AFBA2, 0xAAFBE615, 0xA7B8C0CC, 0xA379DD7B,<br>
      &nbsp;&nbsp;&nbsp; 0x9B3660C6, 0x9FF77D71, 0x92B45BA8, 0x9675461F,<br>
      &nbsp;&nbsp;&nbsp; 0x8832161A, 0x8CF30BAD, 0x81B02D74, 0x857130C3,<br>
      <br>
      &nbsp;&nbsp;&nbsp; 0x5D8A9099, 0x594B8D2E, 0x5408ABF7, 0x50C9B640,<br>
      &nbsp;&nbsp;&nbsp; 0x4E8EE645, 0x4A4FFBF2, 0x470CDD2B, 0x43CDC09C,<br>
      &nbsp;&nbsp;&nbsp; 0x7B827D21, 0x7F436096, 0x7200464F, 0x76C15BF8,<br>
      &nbsp;&nbsp;&nbsp; 0x68860BFD, 0x6C47164A, 0x61043093, 0x65C52D24,<br>
      &nbsp;&nbsp;&nbsp; 0x119B4BE9, 0x155A565E, 0x18197087, 0x1CD86D30,<br>
      &nbsp;&nbsp;&nbsp; 0x029F3D35, 0x065E2082, 0x0B1D065B, 0x0FDC1BEC,<br>
      &nbsp;&nbsp;&nbsp; 0x3793A651, 0x3352BBE6, 0x3E119D3F, 0x3AD08088,<br>
      &nbsp;&nbsp;&nbsp; 0x2497D08D, 0x2056CD3A, 0x2D15EBE3, 0x29D4F654,<br>
      &nbsp;&nbsp;&nbsp; 0xC5A92679, 0xC1683BCE, 0xCC2B1D17, 0xC8EA00A0,<br>
      &nbsp;&nbsp;&nbsp; 0xD6AD50A5, 0xD26C4D12, 0xDF2F6BCB, 0xDBEE767C,<br>
      &nbsp;&nbsp;&nbsp; 0xE3A1CBC1, 0xE760D676, 0xEA23F0AF, 0xEEE2ED18,<br>
      &nbsp;&nbsp;&nbsp; 0xF0A5BD1D, 0xF464A0AA, 0xF9278673, 0xFDE69BC4,<br>
      &nbsp;&nbsp;&nbsp; 0x89B8FD09, 0x8D79E0BE, 0x803AC667, 0x84FBDBD0,<br>
      &nbsp;&nbsp;&nbsp; 0x9ABC8BD5, 0x9E7D9662, 0x933EB0BB, 0x97FFAD0C,<br>
      &nbsp;&nbsp;&nbsp; 0xAFB010B1, 0xAB710D06, 0xA6322BDF, 0xA2F33668,<br>
      &nbsp;&nbsp;&nbsp; 0xBCB4666D, 0xB8757BDA, 0xB5365D03, 0xB1F740B4,<br>
      };<br>
      <br>
      // 言語 C++ C# など や ビルドするコンパイラ VisualStudioやgccなどに関係なく変換後が同じになるハッシュ値を計算する<br>
      class hash32<br>
      <b>#ifdef _DEBUG</b> // [デバッグビルド時だけ _DEBUG が定義] デバッグのときだけ std::string を継承して文字列と同じ扱いにできる(メモリ量は無駄なのでReleaseビルドのときは継承させない)<br>
      &nbsp;&nbsp;&nbsp; : protected std::string // [std::stringはデストラクタがvirtualではないのでprotected:継承] https://mahou-ptr.hatenablog.com/entry/2017/12/05/163120<br>
      <b>#endif</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [std::stringを継承するときの注意点] https://qiita.com/samakusa/items/d6f0bf48a3f1e72edae1<br>
      {<br>
      public:<br>
      <b>#ifndef _DEBUG</b> // Releaseビルドのときは コンストラクタに constexpr をつけて、ビルド中のうちに文字列からハッシュ値へ事前計算を走らせる<br>
      &nbsp;&nbsp;&nbsp; <b>constexpr</b><br>
      <b>#endif</b><br>
      &nbsp;&nbsp;&nbsp; inline hash32(const char* str) : m_hash{ hashcode(str, std::string(str).length()) }<br>
      <b>#ifdef _DEBUG</b> // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; ,std::string(str) // Releaseビルドのときはstd::stringは継承されないのでメモリ量は32ビットになり、コンパクトになる<br>
      <b>#endif</b><br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ちょっと読みにくいけど ここがコンストラクタになってる<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <b>#ifndef _DEBUG</b> // Releaseビルドのときは コンストラクタに constexpr をつけて、ビルド中のうちに文字列からハッシュ値へ事前計算を走らせる<br>
      &nbsp;&nbsp;&nbsp; constexpr<br>
      <b>#endif</b><br>
      &nbsp;&nbsp;&nbsp; inline hash32(const std::string &amp; str) : m_hash{ hashcode(str.c_str(), str.length()) }<br>
      <b>#ifdef _DEBUG</b> // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; ,std::string(str) // Releaseビルドのときはstd::stringは継承されないのでメモリ量は32ビットになり、コンパクトになる<br>
      <b>#endif</b><br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ちょっと読みにくいけど ここがコンストラクタになってる<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <b>#ifdef _DEBUG</b> // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;&nbsp; ~hash32() { std::string().swap(*this); } // デバッグのときだけ念のため継承しているstd::stringを空のstd::string()とswapしておく(stringにはvirtualデストラクタがない)<br>
      <b>#endif</b><br>
      <br>
      &nbsp;&nbsp;&nbsp; // <b>文字列からハッシュ値を計算して返す</b><br>
      &nbsp;&nbsp;&nbsp; static <b>constexpr</b> uint32_t <b>hashcode</b>(const char* str, const size_t length)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // CRC32 Hashの特徴: 計算が簡単で速い 広く利用されている　ハッシュの衝突が発生する確率が低い(1/43億) ハードウェアでの実装が容易<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t hash = 0xffffffff; //[CRC32] https://norizn.hatenablog.com/entry/2020/10/18/145628<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0; i &lt; length; ++i) //[CRC32] https://qiita.com/He3-toolbox/items/3c40ca4b744bad2c0e04<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hash = (hash &lt;&lt; 8) ^ s_crc32_table[((hash &gt;&gt; 24) ^ str[i]) &amp; 0xff];<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hash;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 一致演算子 hash32型 どうしを比較する std::unordered_mapなどのキーにするときにも比較は必須<br>
      &nbsp;&nbsp;&nbsp; constexpr inline bool operator == (const hash32 &amp; other) const { return this-&gt;m_hash == other.m_hash; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 不一致演算子 hash32型 どうしを比較する std::unordered_mapなどのキーにするときにも比較は必須<br>
      &nbsp;&nbsp;&nbsp; constexpr inline bool operator != (const hash32 &amp; other) const { return this-&gt;m_hash != other.m_hash; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 一致演算子 m_hashの値が一致するか判定<br>
      &nbsp;&nbsp;&nbsp; constexpr inline bool operator == (const char* str) const { return m_hash == hashcode(str, std::string(str).length()); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 不一致演算子<br>
      &nbsp;&nbsp;&nbsp; <b>constexpr</b> inline bool operator != (const char* str) const { return m_hash != hashcode(str, std::string(str).length()); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 一致演算子 m_hashの値が一致するか判定<br>
      &nbsp;&nbsp;&nbsp; <b>constexpr</b> inline bool operator == (const std::string &amp; str) const { return m_hash == hashcode(str.c_str(), str.length()); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 一致演算子 m_hashの値が一致するか判定<br>
      &nbsp;&nbsp;&nbsp; <b>constexpr</b> inline bool operator != (const std::string &amp; str) const { return m_hash != hashcode(str.c_str(), str.length()); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ハッシュ値を取得<br>
      &nbsp;&nbsp;&nbsp; <b>constexpr</b> inline operator uint32_t() const { return m_hash; }<br>
      <br>
      private:<br>
      &nbsp;&nbsp;&nbsp; // 文字列から変換した ハッシュ値<br>
      &nbsp;&nbsp;&nbsp; uint32_t m_hash{ 0 }; // 同じ文字列からは必ず同じハッシュ値に計算変換されるので、文字列を比較せずにすむ(文字列の比較は計算が重たいので回避できる)<br>
      };<br>
      <br>
      // <b>std::unordered_map で 自作クラスをキーにできるようにするには operator() と == 一致演算子が必須</b>&nbsp; https://qiita.com/izmktr/items/8e0fd1b6e37de59a9bd0<br>
      namespace std {<br>
      &nbsp;&nbsp;&nbsp; template&lt;&gt;<br>
      &nbsp;&nbsp;&nbsp; class hash&lt;<b>hash32</b>&gt; {<br>
      &nbsp;&nbsp;&nbsp; public: //[<b>std::unordered_mapのキー が uint32_t型のとき</b>の 速度やメモリ使用量比較] https://tech.preferred.jp/ja/blog/sparse-vector/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t operator () (const hash32&amp; hash) const { return std::hash&lt;uint32_t&gt;()(hash); }<br>
      &nbsp;&nbsp;&nbsp; };<br>
      }<br>
      <br>
      // "Zako0"_hash32 などのように 文字列 "～" の後ろに_hash32 をつけるとhash32型 -&gt; uint32_tに変換される オペレータ""_hash32 を定義<br>
      <b>constexpr</b> uint32_t operator""_hash32(const char* str, std::size_t length) // [参考] https://cpprefjp.github.io/lang/cpp11/user_defined_literals.html<br>
      {<br>
      &nbsp;&nbsp;&nbsp; return hash32::hashcode(str, length); // hash32型のハッシュルールで32ビットのuint型に変換して返す<br>
      }<br>
      <br>
      #endif<br>
    </p>
    <br>
    さて、いろいろ難しいコードがでてきたが、最初のほうに出てきたのは<a href="https://ja.wikipedia.org/wiki/%E5%B7%A1%E5%9B%9E%E5%86%97%E9%95%B7%E6%A4%9C%E6%9F%BB">CRC-32 で32桁への変換をするため</a> のテーブルである。<br>
    詳細はwikiをみてもらえば、数学者であれば完全理解できると思うので、そのへんの解説は↑wikiに譲るとしよう。<br>
    <br>
    今回作成したのはhash32クラスである。<br>
    このクラスには<b>「仕掛け」</b>がしてある。<br>
    デバッグ用ビルド ではデバック用に class hash32 : protected std::string の:継承の形でstd::string型を継承して文字タグを残しておき、<br>
    本番リリース用ビルドでは、<b>#ifndef _DEBUG マクロ の効果</b>で↑ 文字タグを継承せず、完全に純粋な32桁の0と1の32bitぶんのデータしか持たず、<br>
    リリース時には文字列タグのムダなメモリ使用を打ち消す工夫が「仕掛け」てある。<br>
    <br>
    さらに、<b>第2の「仕掛け」</b>として、<br>
    == 一致判定 や != 不一致判定の 演算子オペレータoperator の先頭に<br>
    <b>constexpr</b> を付けてある。<br>
    <a href="https://qiita.com/saltheads/items/dd65935878a0901fe9e7">constexprとは何か</a>というと、<br>
    [再生ビルド]ボタンを押して、<b>コンパイルをしている最中に計算できる数値はビルド中に事前計算しておいてくれる</b>ものだ。<br>
    例えば、if (tag == "Zako0") という判別するプログラムがあったとする。<br>
    tag が ただのstd::string型であれば、ゲームの実行中に tag が"Zako0" と一致するかの遅くてムダな計算が走る。<br>
    constexpr をつけたhash32の == オペレータならば<b>[再生ビルド]ボタンを押してビルドをしている最中に"Zako0"が32桁のビットとして事前に計算されうる</b>ので<br>
    ゲームを起動して遊んでいる最中には、ムダな文字列のハッシュへの変換処理も、文字列どうしの比較一致判定処理も まったくいらなくなる。<br>
    <br>
    hash32クラスの導入も簡単だ。<br>
    <b>std::string tag; // 文字列タグ<br>
      ↓<br>
      hash32 tag; // hash32タグ</b> <br>
    たった<b>これだけの変更で、もとの if (tag == "Zako0") の判定の部分は変えなくても高速な32桁の数値どうしの一致判定に変わる</b>。<br>
    <b>必要なのは「hash32とは何なのか」を理解して「自分の言葉で説明できること」</b>のみ。<br>
    (当然「自分の言葉で説明できない」場合は「ハッシュ判定のありがたみ」はわからないわけなのでその人にとっては使う意味もない)<br>
    <br>
    さて、<b>第3の「仕掛け」</b>も理解しておこう。<br>
    今回導入したハッシュ関数の数式の変換ルールは<br>
    <b>「C#やC++などの言語やVisualStudioやgccやclangなどのビルドするコンパイラ」が違っても同じハッシュ値になる</b><br>
    という性質をもっている。<br>
    C++にもデフォルトの std::hash でハッシュ値を計算する機能がある。<br>
    じゃあ、なぜデフォルトを使わないか？<br>
    <b>今回導入したハッシュ関数[CRC32]ならば、ウィンドウズ上でセーブしたデータもスマホのiPhone上でセーブしたデータもハッシュ値に一貫性</b>がある。<br>
    つまり、スマホでセーブしたデータをウィンドウズ上で続きをあそぶときにも、<br>
    "Zako0"のhash32タグが010100001010...32桁のビット値としてスマホでセーブされていれば、<br>
    ウィンドウズでゲームを再開して、セーブされた010100001010...32桁のタグの数値は、ちゃんと"Zako0"として一致判定できるということだ。<br>
    <b>CRC32というルールで変換された、というルールさえ一致していれば、きちんと環境が違っても変換結果は一致</b>する。<br>
    デフォルトの std::hash を使った場合はどうなるか？<br>
    std::hash はVisualStudio(ウインドウズ)やclang(スマホiPhone)のビルドする環境によって、違うハッシュルールでビルドされる可能性がある。(環境依存)<br>
    ゆえに、デフォルトのstd::hashでは変換後の数値をセーブして引き継ぎたいときにはまったくあてにならない。<br>
    <b>どうせハッシュを使うなら「CRC32というルールで保存するぞ」と明確に変換ルールを決めて運用するほうが、機動力や互換性が高くなる</b>。<br>
    <br>
    ゆえに、hash32は保存データを伴うプログラムを作る上での「基本インフラ」として組み込むニーズがある。<br>
    MyRandomクラスの乱数生成のメルセンヌツイスタと同じような「基本の情報科学的インフラ」として、持っておいて損はない。<br>
    では、実際にこのMyHash.hを使って、カメラにhash32でタグを振ってみよう。<br>
    <br>
    <p><code>main.cppを変更</code>して、hash32でカメラをstd::vectorではなくstd::unordered_mapの辞書にhash32タグを振って管理してみましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Screen.h"<br>
      #include "Camera.h"<br>
      <em>#include "MyHash.h"</em><br>
      #include "Resource.h"<br>
      #include "MyDraw.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ Width×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ Width×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // タイルマップを読み込む 縦8マス、横8マス、縦32ピクセル、横32ピクセル<br>
      &nbsp;&nbsp;&nbsp; std::string mapChipPath{ "Map/mapchip.png" };<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath,8,8,32,32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      <br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp; // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する<br>
      &nbsp;&nbsp;&nbsp; // ( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを2つ生成 画面の全体の縦方向サイズの Height / 2 にして、上下分割で配置できるようにする<br>
      &nbsp;&nbsp;&nbsp; int screenHandle0 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      &nbsp;&nbsp;&nbsp; int screenHandle1 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラを2つ生成して、2つのカメラ視点を2つのスクリーンにそれぞれ関連付ける<br>
      &nbsp;&nbsp;&nbsp; <em>std::unordered_map&lt;hash32, </em>std::shared_ptr&lt;Camera&gt;&gt; cameras; // 複数のカメラへのポインタを格納する<em>タグを振った辞書</em>配列<br>
      &nbsp;&nbsp;&nbsp; cameras.emplace<em>("カメラ0", </em>std::make_shared&lt;Camera&gt;(Vector3{ 20,40,-50 })); // カメラ0<br>
      &nbsp;&nbsp;&nbsp; cameras.emplace<em>("カメラ1", </em>std::make_shared&lt;Camera&gt;(Vector3{ 80,30,-50 })); // カメラ1<br>
      <br>
      &nbsp;&nbsp;&nbsp; cameras["カメラ0"]-&gt;screenHandle = screenHandle0; // カメラ0 と スクリーン0 を関連付ける<br>
      &nbsp;&nbsp;&nbsp; cameras["カメラ1"]-&gt;screenHandle = screenHandle1; // カメラ1 と スクリーン1 を関連付ける<br>
      &nbsp;&nbsp; &nbsp;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle0); // 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle1); // 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファを有効にする [Zの深度]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 複数のカメラを 範囲 for文 で回す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; camera : cameras)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ラムダ式[&amp;](){ ～ }で{}の外側の変数すべてを &amp; キャプチャで&amp;参照として「Draw関数の内側へ引き連れて」処理できる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera.second-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw関数() の 外側にある変数 mapChipPath も[&amp;]効果で { } の内側で問題なくアクセスできている↓<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 70, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 4);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if (camera.first == "カメラ0") <b>//←"カメラ0"はビルド時に事前にハッシュ値が計算され、文字列ではない数値とおきかわっている</b><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらがカメラ0", GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (camera.first == "カメラ1")<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらはカメラ1", GetColor(0, 255, 0));</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーン0の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, 0, screenHandle0, FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, 0, Screen::Width, Screen::Height / 2, GetColor(255, 0, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーン1の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, Screen::Height / 2, screenHandle1, FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, Screen::Height / 2, Screen::Width, Screen::Height, GetColor(0, 255, 0));<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    いかがでしょう？ちゃんと上の画面に赤色の文字で「こちらがカメラ0」、下の画面に緑色の文字で「こららはカメラ1、現場からお伝えします」と出てきましたでしょうか？<br>
    <br>
    一応お伝えしておきますが、CRC32についてはwebで検索すればでてきますが、<br>
    hash32クラスはこの記事で作成したクラスなので当然、web検索してもでてきません。<br>
    std::stringを継承してあたかも文字列のように扱える設計も特にweb検索してもでてくるはずがないです。<br>
    つまり、使うユーザー側が 記事の内容や意図を理解 して、使わない限りは「<b>文字列タグで一致判定しているのとほぼ変わらない</b>」ということです。<br>
    <b>std::のライブラリだって「使う側が特性を理解して使わない限りはプログラムの動作や速度をカスタマイズできない」のと同じ</b>です。<br>
    AIやChatGPTだってそうです。便利な時代になっても、<b>どのみち求められているのは「使う側の基礎知識 = 地力」</b>なのです。<br>
    <br>
    数学すべてを理解する必要はないが「<a href="https://www.1101.com/nintendo/pikmin3/2013-07-19.html">物事の本質や道理を把握するちから</a>」は大事なのです。<br>
    プログラムや数学の専門家じゃない任天堂の宮本先生でも「原理と機能を把握するちから = 地力」は持っている。<br>
    ゲームが計算機をベースにしている以上、その原理や源流を脳みそからシャットアウトする人には、新しいものを生み出す機会を損失するリスクが伴うということです<br>
    誰だって「原理や機能を把握する地力のあるかしこい人」と仕事するほうが実力が発揮できる現場になる、のは あたりまえでしょう。<br>
    その能力はむしろ「ゲームをプランニングするプランナ側」に必要な能力です。プログラマの能力を最大限に引き出される現場で働きたいでしょう。<br>
    ゲームの学科などではプログラミングをあきらめた人がゲームのプランナを逃げで選択し、プログラミングを続ける人を逆に使う側になったりしがちですが、<br>
    ゲームのプランニングはプログラミングやCGやデザインなど確固たるバックグラウンドに持った地力のある人が仕切るほうが対話が現場で生まれ実力が引き出されると思います。<br>
    <br>
    数学やプログラムより、むしろ大事なのは<b>「むずかしいことを自分のことばで把握して説明できること = 脳力」(ものわかりのよさ、話のわかるひと)</b>ではないでしょうか。<br>
    技術側は技術を自分のことばで説明する能力を持つ、それを活かす側はその話を理解できるよう基礎に興味を持ちきちんと時代ともに追いかける、それが理想的開発現場です。<br>
    <br>
    <br>
    <br>
    <br>
    <a id="mozTocId0004" class="mozTocH1">
      <h1>ワールドを定義して、複数プレイヤと複数カメラをワールドに保持する</h1>
    </a>
    <p><code>別記事でImageフォルダにImage/pikkoron.pngと新たに別に自作したImage/satan.pngを保存しておいてください</code><a

        href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/practice.html#mozTocId0008">→CharaMELで自作のキャラのタイル分割画像を作る</a></p>
    <br>
    Unityなどゲームエンジンには「シーン」などの概念がある。<br>
    「シーン」の下に複数のカメラや複数のゲームオブジェクトがヒエラルキーとしてぶら下がっている。<br>
    シーンを閉じるとともにぶら下がっている複数のゲームオブジェクトを巻き込んで「道ずれにシーンごとリセット」される。<br>
    シーンをまたぐためには「<a href="https://rurugamedev-blog.com/entry/2023/04/13/%E3%80%90Unity%E3%80%91SingletonMonobehaviour%E3%81%A8%E3%81%AF%EF%BC%9F%E7%9B%AE%E7%9A%84%E3%82%84%E4%BD%BF%E3%81%84%E6%96%B9%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E8%A7%A3%E8%AA%AC">別シーンをロードしても消えないDontDestoroyOnLoadを前提としたSingletonMonoBehaviorなど</a>」がパターンとして使われる。<br>
    ゆえに、プレイヤが扉に入って、別ワールドに移動するような場合「シーン切り替え=ワールド移動」のようにイメージされていると思う。<br>
    じゃあ、例えばプレイヤ①がワールド①にいて、プレイヤ②がワールド①からワールド②に扉で移動するとしたケースでは、<br>
    ワールド①とワールド② を シーン①とシーン② のように設計しているとすると、シーン②をLoadするときにシーン①が消えてしまうではないか。<br>
    (ワールド①をDontDestoroyOnLoadにしたときには、シーン①とシーン②のステージのXYZ座標のエリアが「かぶらないように」しないと、2つのステージがごっちゃになった世界になっちゃう)<br>
    ゆえに、今回は「シーン」という概念と「ワールド」という概念を明確に区別する設計をしてみよう。<br>
    「シーン」の下に複数の「ワールド」がぶら下がるような設計をするためには、<br>
    複数のカメラやゲームオブジェクトの保持(と道連れリセット)は「ワールド」にて分担する形がいい。<br>
    <br>
    今回は先行して「ワールド」のみの設計に集中する。<br>
    設計するにあたり、<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId00073">シューティングでGameManger(シングルトン)の担った役割</a>をワールドが代わりに担うため、<br>
    色んな別クラスでWorld.hが #include "World.h" されて<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId00071">インクルードのリンクがワールドに集中して循環インクルード問題が起こる</a>ことが事前に予想される。<br>
    ゆえにワールドは「個別の Player.hやCamera.h のインクルードはしない」設計が適切になる。<br>
    #includeするかわりに「前方宣言をして Playerというクラスや Cameraというクラスがありうる」という宣言だけをしてやる。<br>
    <p class="source">class Camera; // 前方宣言だけして#include はしなければポインタ型 Camera* の定義は許される<br>
      class Player;<br>
      <br>
      class World<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Camera* camera; // 前方宣言をすればポインタは定義が許されるようになる<br>
      &nbsp;&nbsp;&nbsp; Player* player;<br>
      };<br>
    </p>
    ポインタの実体は「メモリ上の住所 = 番地番号」である。<br>
    だから64bit環境のマシンではポインタは64ビットの番地を持てるし、少し昔の32bit環境のマシンではポインタは32ビットの番地を持っているに過ぎない<br>
    ようは、void* 型のポインタも Player* 型のポインタも「実は同じ64bitの数字 = int型やshort型などと同類」に過ぎないわけです。<br>
    だから.hヘッダでPlayerのメンバの変数や関数を呼び出したりしない状況にして、ポインタだけならば、<br>
    実は #include しなくてもポインタ番号だけの定義にしてしまえば「インクルードするまでもない」のです。<br>
    Playerのメンバ変数の hp ヒットポイント などまでアクセスしたり、コンストラクタで初期化したいなら #include Playerまで必要だが、<br>
    Worldクラスの中に、Player* player; や Camera* camera; など「ポインタを羅列するだけなら前方宣言だけでいい」のである。<br>
    そして、この「ポインタならばインクルード不要」を応用することで「循環インクルード」を回避できるのである。<br>
    <br>
    ワールドクラスの定義はプレイヤやカメラなどの「ポインタをキープ」することに特化する。<br>
    ようは「住所番地の掲示板」を主とした役割として設計するのだ。<br>
    <br>
    第2の設計要件として必要なのが「キープ = 道連れ」の役割である。<br>
    ワールドを閉じたときにワールド内にカメラやプレイヤがいたら「ワールドもろとも一緒にメモリから消えてお掃除してほしい = バルス」<br>
    「キープ(道ずれ)」は共有ポインタの役目そのものである。<br>
    <a href="https://sleepygamersmemo.blogspot.com/2019/01/unity-optimizing-gc-collect.html">C#で暗に黙々とガベージコレクタがやってくれている役割</a>を共有ポインタで代行する。<br>
    <p class="source">#include &lt;memory&gt; // 共有ポインタを使う<br>
      class Camera; // 前方宣言だけして#include はしなければポインタ型 Camera* の定義は許される<br>
      class Player;<br>
      <br>
      class World<br>
      {<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Camera&gt; camera; // 前方宣言をすればポインタは定義が許されるようになる<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Player&gt; player;<br>
      };<br>
    </p>
    これで、Worldクラスが削除されるとともに、cameraやplayerが別の個所に共有リンクが張られていない状態(共有カウンタが1←ワールドのみの)ならば、<br>
    worldが最後までキープしていた共有カウンタ1が、このworldクラスが閉じられるとともに、共有カウンタが0になり、道ずれにできる。<br>
    つまり、Worldクラスは共有ポインタの最後の命綱(いのちづな)の共有カウント 1 をキープする役割を上記コードで期待できるわけです。<br>
    具体的には、以下のコード例で、プレイヤは命綱をキープして消えずにワールドを移動できます。<br>
    <p class="source">world2-&gt;player = world1-&gt;player; // <b>ワールド2でプレイヤへのリンクが張られた</b>のでplayerポインタの<b>共有カウンタが+1</b>になる<br>
      world1-&gt;player = nullptr; // <b>world1のplayerポインタがnullになる</b>のでplayerの<b>共有カウンタが-1</b>される<br>
      // 結果、playerは<b>ワールド2のぶんは最低限の共有カウンタ1は確保</b>されているので消えない(ワールド移動完了!!!!)<br>
    </p>
    このように、ようはstd::shared_ptr型のリンクがnullptrじゃないリンクされた数だけ共有ポインタのplayer内部の共有カウンタが+1され、<br>
    全リンクがnullptrにならない限り、playerは消えるのを免れられるということ。<br>
    <br>
    例えるならば、メンヘラ系VTuberがいいねが完全に0になったらやめる(引退するする詐欺)みたいな状況をイメージすると、ワールドが最後の推し 1 カウントを保持していて、<br>
    完全にどこからも気にされない状態(共有リンク切れ)ならばワールド消滅とともにさすがに消していいだろ。<br>
    という「この世界(ワールド)にいるうちは最後まで見捨てないよ設計」です。<br>
    なので、<b>デッドロック(互いにどっかのクラス同士で共有リンク張りあい状態)のときは<br>
      「永遠にメンヘラが世界消滅後もメモリに残り続けるという罠」</b>もあったりするので気を付けましょう。<br>
    <br>
    そして、もしPlayerのhpなどメンバ変数にアクセスしたかったり、<br>
    コンストラクタを呼んで初期化したいときはWorld.cppのほうで#include "Player.h"すれば、循環インクルードは回避できる構造を設計できる。<br>
    <p class="source"><b>World.h</b>の例<br>
      #include &lt;memory&gt; // 共有ポインタを使う<br>
      class Camera; // 前方宣言だけして#include はしなければポインタ型 Camera* の定義は許される<br>
      class Player;<br>
      <br>
      class World<br>
      {<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Camera&gt; camera; // 前方宣言をすればポインタは定義が許されるようになる<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Player&gt; player;<br>
      &nbsp;&nbsp;&nbsp; void MakePlayer(); //<b> .hでは初期化を直で呼ばずに、間接的に初期化するための関数だけを定義</b><br>
      };<br>
    </p>
    <p class="source"><b>World.cpp</b>の例 <br>
      #include "World.h";<br>
      <br>
      #include "Player.h"; // <b>.cppでは</b>std::make_sharedで初期化コンストラクタを呼ぶために<b>インクルードは必要</b><br>
      #include "Camera.h";<br>
      <br>
      void World::MakePlayer()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; player = std::make_shared&lt;Player&gt;(); // 初期化コンストラクタを呼ぶ<br>
      &nbsp;&nbsp;&nbsp; player-&gt;hp = 10; // インクルードしてればメンバ変数にもアクセスできる<br>
      };<br>
    </p>
    こういう風にして<b>実際の#includeを.cppに逃がせば</b>、少なくとも<b>Player.h と World.hどうしが循環インクルードすることはない構造を設計できる</b>。<br>
    まあ、普通はめんどくさがらずに「実際の処理は全部 .cpp に書くようにする」のが王道の世間一般のC++のプログラミングスタイルではある。<br>
    ただ、私はVisual Studioで「定義をここに表示」で.hヘッダの処理をワンクリックで追いかけて見たりできて便利なので<br>
    「コードを試行錯誤で書いている最中は.hで処理を書いて考えたり、必要に応じて.cppに処理を移したり、最後に丁寧に.cppに処理を移してきれいにする」<br>
    みたいな形で書き進めがちなので .h書き をおすすめしてるわけではない。<br>
    きれいな理想的なコーディングスタイルは<a href="https://github.com/raulmur/ORB_SLAM/blob/master/include/Map.h">FaceBookの元技術者の人</a>の恐ろしいほど簡潔で「読める」コードをみて真似するのがよい。最終理想形である。<br>
    上記のプロジェクトでも、中身が1行の処理のようなinline展開できそうな簡単な関数の処理は.hに書かれていたりする。<br>
    また、<a href="https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp">ヘッダオンリーなライブラリなどの文化</a>もあるので、<b>スタイルは場合や人や開発現場によりけり</b>である。<br>
    <br>
    <br>
    <br>
    <p><code>World.hを新規作成</code>して、世界で保持する(道ずれにする)要素を共有ポインタで定義しましょう。</p>
    <p class="source">#ifndef WORLD_H_<br>
      #define WORLD_H_<br>
      <br>
      #include &lt;list&gt;<br>
      #include &lt;memory&gt;<br>
      #include &lt;unordered_map&gt;<br>
      #include &lt;functional&gt; // std::functionのラムダ式 で 関数を Draw関数の引数にして、カメラすべてに対して描画処理を発動させる <br>
      <br>
      #include "MyHash.h" // ワールドのタグをhash32型で管理する<br>
      <br>
      <br>
      // [前方宣言] 宣言だけして、#includeはしてないので、ポインタだけはこのファイル内でつかえる<br>
      // #includeはしてないので、hpなどの変数には#include "～.h"しないとアクセスできないので循環インクルード防止のため.cppでインクルードしてください<br>
      class GameScene;<br>
      class Player;<br>
      class PlayerBullet;<br>
      class Enemy;<br>
      class Camera;<br>
      <br>
      // プレイヤや敵や弾などの共有ポインタを管理し、EraseRemoveIfで消して参照カウンタが0になったらそれらを消滅させるクラス(C#のガベージコレクタの代わり)<br>
      class World<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline World(GameScene* pScene, const std::string&amp; worldTag = "") : m_pScene{ pScene }, tag{ worldTag } {}<br>
      &nbsp;&nbsp;&nbsp; inline ~World() {}<br>
      protected: // public:にすると他で外部で後からタグやシーンを書き換えられると辞書での管理などの前提がおかしくなるのでprotected:する<br>
      &nbsp;&nbsp;&nbsp; hash32 tag{ "" }; // ワールド名のタグ<br>
      &nbsp;&nbsp;&nbsp; GameScene* m_pScene{ nullptr }; // ワールドを所有するシーン<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; hash32 Tag() const { return tag; }<br>
      &nbsp;&nbsp;&nbsp; GameScene* scene() { return m_pScene; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::<b>shared_ptr</b>&lt;Player&gt;&gt; players; // プレイヤのタグ辞書<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト <br>
      <br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 削除処理を共通テンプレート関数にする<br>
      &nbsp;&nbsp;&nbsp; // [共通テンプレート関数]https://programming-place.net/ppp/contents/cpp/language/009.html#function_template<br>
      &nbsp;&nbsp;&nbsp; template &lt;typename TypeT, class T_if&gt;<br>
      &nbsp;&nbsp;&nbsp; void EraseRemoveIf(std::list&lt;TypeT&gt;&amp; v, T_if if_condition)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 特定のタイプT↑&nbsp; ↑配列v&nbsp;&nbsp; ↑条件式if_condition<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; v.erase(<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::remove_if(v.begin(), v.end(), if_condition),<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; v.end() //&nbsp; ↓remove_ifの位置<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; );//例.[生][生][死][死][死]← v.end()の位置<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::<b>shared_ptr</b>&lt;Camera&gt;&gt; cameras; // このワールドに存在するカメラの辞書&lt;カメラにつけたタグ, カメラの共有ポインタ&gt;<br>
      &nbsp;&nbsp;&nbsp; // 指定されたタグのカメラへの共有ポインタを得る　カメラ辞書に存在しないタグでアクセスしたときにunordered_mapの特性で勝手に意図しないカメラができるのを防ぐ関数<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Camera&gt; camera(const std::string&amp; cameraTag) { auto itr = cameras.find(cameraTag); return (itr != end(cameras)) ? itr-&gt;second : nullptr; }<br>
      &nbsp;&nbsp;&nbsp; // このワールドに存在するカメラすべてに対して drawFuncで描きたい処理を渡して 全カメラのスクリーンに対して描画処理を走らせる<br>
      &nbsp;&nbsp;&nbsp; void Draw(std::function&lt;void()&gt; drawFunc) noexcept;<br>
      &nbsp;&nbsp;&nbsp; // カメラにタグをつけてワールドに追加 カメラにもワールドへのポインタリンクを張る<br>
      &nbsp;&nbsp;&nbsp; inline bool AddCamera(const std::string&amp; cameraTag, std::shared_ptr&lt;Camera&gt; pCamera);<br>
      &nbsp;&nbsp;&nbsp; // 指定したタグのカメラをこのワールドから削除する カメラ側の worldへのリンクのポインタも nullptr にする<br>
      &nbsp;&nbsp;&nbsp; inline bool EraseCamera(const std::string&amp; cameraTag);<br>
      &nbsp;&nbsp;&nbsp; // カメラを nowWorld から nextWorld に移動させる<br>
      &nbsp;&nbsp;&nbsp; static bool MoveCamera(const std::string&amp; cameraTag, World* nowWorld, World* nextWorld);<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>World.cppを新規作成</code>して、ポインタ以外の実体のインクルードが必要な処理を記述しましょう。</p>
    <p class="source">#include "World.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Camera.h"<br>
      #include "Screen.h"<br>
      <br>
      <br>
      // カメラにタグをつけてワールドに追加 カメラにもワールドへの生ポインタリンクを渡す<br>
      bool World::AddCamera(const std::string&amp; cameraTag, std::shared_ptr&lt;Camera&gt; pCamera)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (pCamera == nullptr) return false;<br>
      &nbsp;&nbsp;&nbsp; if (cameras.count(cameraTag) &gt; 0) return false; // すでに同じタグのカメラがワールドにあったら false<br>
      &nbsp;&nbsp;&nbsp; if (pCamera-&gt;world() != nullptr) pCamera-&gt;world()-&gt;EraseCamera(cameraTag); // すでにカメラが別ワールドに配置されていたら別ワールドから削除<br>
      &nbsp;&nbsp;&nbsp; cameras.emplace(cameraTag, pCamera); // ワールドにカメラを追加する<br>
      &nbsp;&nbsp;&nbsp; pCamera-&gt;world(this); // カメラにもワールドへのポインタリンクを張る<b>(カメラ側に渡すのは共有ポインタではない生ポインタだから共有デッドロックにはならない)</b><br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      // 指定したタグのカメラをこのワールドから削除する カメラ側の worldへのリンクのポインタも nullptr にする<br>
      bool World::EraseCamera(const std::string&amp; cameraTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; auto itr = cameras.find(cameraTag); // 指定したタグのカメラを探す<br>
      &nbsp;&nbsp;&nbsp; if (itr == end(cameras)) return false; // 指定したタグのカメラがワールドにない<br>
      &nbsp;&nbsp;&nbsp; auto pCamera = itr-&gt;second;<br>
      &nbsp;&nbsp;&nbsp; pCamera-&gt;world(nullptr); // カメラ側の worldへのリンクのポインタも nullptrに<br>
      &nbsp;&nbsp;&nbsp; cameras.erase(cameraTag); // カメラを辞書から削除<br>
      <br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      // カメラを nowWorld から nextWorld に移動させる<br>
      bool World::MoveCamera(const std::string&amp; cameraTag, World* nowWorld, World* nextWorld)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (nowWorld == nullptr) return false;<br>
      &nbsp;&nbsp;&nbsp; auto itr = nowWorld-&gt;cameras.find(cameraTag); // タグでカメラを探す<br>
      &nbsp;&nbsp;&nbsp; if (itr == end(nowWorld-&gt;cameras)) return false; // タグに関連づいたカメラがなかった<br>
      &nbsp;&nbsp;&nbsp; auto targetCamera = itr-&gt;second; // カメラの共有ポインタをキープ(次の行でeraseしてもカメラの共有カウンタは0にはならずこのリンクのおかげでカメラはメモリに残存)<br>
      &nbsp;&nbsp;&nbsp; targetCamera-&gt;world(nullptr); // カメラ側の worldへのリンクのポインタを一旦 nullptrに<br>
      &nbsp;&nbsp;&nbsp; nowWorld-&gt;cameras.erase(cameraTag); // nowWorld からは カメラを消す<br>
      &nbsp;&nbsp;&nbsp; if (nextWorld == nullptr) return false;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return nextWorld-&gt;AddCamera(cameraTag, targetCamera); // 次のワールドにカメラを追加する<br>
      }<br>
      <br>
      // このワールドに存在するカメラすべてに対して funcで描きたい処理を渡して 全カメラのスクリーンに対して描画処理を走らせる<br>
      void World::Draw(std::function&lt;void()&gt; drawFunc) noexcept<br>
      {<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : cameras)&nbsp;&nbsp;&nbsp; // このワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR_D beforeCamPos; // 設定変更前のカメラのパラメータを一旦、保管<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; double beforeVRot, beforeHRot, beforeTRot, beforeNear, beforeFar, beforeFov;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Camera::GetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;beforeFov, &amp;beforeNear, &amp;beforeFar);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //camera-&gt;screenID<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngle(camera-&gt;pos, camera-&gt;rot.V, camera-&gt;rot.H, camera-&gt;rot.T); // 各カメラの位置、回転を設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Screen::Start(camera-&gt;screenHandle, true, camera-&gt;fovAngle); // カメラに関連付けられたスクリーンIDを描画先にする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; drawFunc(); // 渡された描画処理を実行<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Screen::End(true); // 描画先を元に戻す<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラの設定をもとに戻しておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Camera::SetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;beforeFov, &amp;beforeNear, &amp;beforeFar);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    <p><code>Camera.hを変更</code>して、ワールドに所有される立場のカメラ側からも自分の今いるワールドの情報にアクセスできるために<br>
      World* 型の生ポインタを初期化と同時に渡しておけるようにしましょう。</p>
    <p class="source">#ifndef CAMERA_H_<br>
      #define CAMERA_H_<br>
      <br>
      #include &lt;functional&gt; // カメラのDraw関数に「引数として関数=ラムダ式」を渡してカメラのDraw関数の外側の呼び出し元から描画したい処理を渡すことができるようにする<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "MyDraw.h"<br>
      #include "Vector3.h"<br>
      <br>
      <br>
      class Camera<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // カメラの位置(ワールド座標)<br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 pos; // カメラの位置(ワールド座標)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // unionしてx,y,zでもアクセスできるように<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; struct Rotate { double V, H, T; }; // カメラの回転角度定義 DXライブラリの内部行列ではfloatじゃなくてdouble型で保持されているので倍精度のdouble型にした<br>
      &nbsp;&nbsp;&nbsp; Rotate rot{ 0.0, 0.0, 0.0 }; // カメラの3軸の回転角度<br>
      &nbsp;&nbsp;&nbsp; double fovAngle = 0; // カメラをスクリーンに描くときの視野角(0～179度) 0のときはDxLib::GetCameraFovD()で得られる値が適用される<br>
      <br>
      &nbsp;&nbsp;&nbsp; float cameraLookAtHeight{ 0.0f }; // LookAtする対象を見下ろす高さ<br>
      <br>
      &nbsp;&nbsp;&nbsp; int screenHandle = DX_SCREEN_BACK; //カメラを描くスクリーンのハンドル番号<br>
      <em>protected:<br>
        &nbsp;&nbsp;&nbsp; World* m_world; // カメラが存在するワールドへのポインタ<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; World* world() { return m_world; } //ワールドへのポインタを得る<br>
        &nbsp;&nbsp;&nbsp; Camera&amp; world(World* pWorld) { m_world = pWorld; return *this; } // ワールドへのポインタを再セットする</em><br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Camera(<em>World* pWorld, </em>Vector3 worldPos) : <em>m_world{ pWorld }, </em>pos { worldPos } {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; // デストラクタ<br>
      &nbsp;&nbsp;&nbsp; ~Camera() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラを通して描くスクリーンのハンドル番号を設定する<br>
      &nbsp;&nbsp;&nbsp; void SetScreenHandle(int handle) { screenHandle = handle; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラの位置をセットしなおす<br>
      &nbsp;&nbsp;&nbsp; void SetPosition(Vector3 worldPos)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ワールド座標系として保存<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;pos = worldPos;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 指定されたワールド座標が画面の中心に来るように、カメラの位置を変更する<br>
      &nbsp;&nbsp;&nbsp; void LookAt(Vector3 targetXYZ)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // カメラの位置と向きを設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //MyDraw::SetCameraPositionAndTarget_UpVecY(pos, targetXYZ + Vector3(0, cameraLookAtHeight,0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 注視点はターゲットの座標から cameraLookAtHeight 分だけ高い位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndTarget_UpVecY(this-&gt;pos, targetXYZ + Vector3(0, this-&gt;cameraLookAtHeight, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // カメラ回転後の角度を保存<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;rot.H = DxLib::GetCameraAngleHRotateD(); // カメラの水平方向の向きを取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;rot.V = DxLib::GetCameraAngleVRotateD();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;rot.T = DxLib::GetCameraAngleTRotateD();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 現在のDX内部のカメラのビュー行列などに入っているカメラの設定パラメータを得る<br>
      &nbsp;&nbsp;&nbsp; static void GetCameraSettings(VECTOR_D* pPosition, double* pRotV = nullptr, double* pRotH = nullptr, double* pRotT = nullptr,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double* pFov = nullptr, double* pNear = nullptr, double* pFar = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pPosition != nullptr) *pPosition = DxLib::GetCameraPositionD(); // カメラ位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pRotV != nullptr) *pRotV = DxLib::GetCameraAngleVRotateD(); // カメラの角度V<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pRotH != nullptr) *pRotH = DxLib::GetCameraAngleHRotateD(); // カメラの角度H<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pRotT != nullptr) *pRotT = DxLib::GetCameraAngleTRotateD(); // カメラの角度T<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pFov != nullptr) *pFov = DxLib::GetCameraFovD(); // カメラの視野角<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pNear != nullptr) *pNear = DxLib::GetCameraNearD(); // カメラ一番近くの描き始めるレンジ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pFar != nullptr) *pFar = DxLib::GetCameraFarD(); // カメラ一番遠くの描くレンジ<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラの視野角に変更があったら変えて射影変換行列を再計算する (現在と同じfovの数値の場合は再計算をしないで負荷を回避)<br>
      &nbsp;&nbsp;&nbsp; static inline void SetupCamera_PerspectiveD(double fov) { if (DxLib::GetCameraFovD() != fov) DxLib::SetupCamera_PerspectiveD(fov); }<br>
      &nbsp;&nbsp;&nbsp; // カメラの視野角に変更があったら変えて射影変換行列を再計算する (現在と同じfovの数値の場合は再計算をしないで負荷を回避)<br>
      &nbsp;&nbsp;&nbsp; static inline void SetCameraNearFarD(double Near, double Far) { if (DxLib::GetCameraNearD() != Near &amp;&amp; DxLib::GetCameraFarD() != Far) DxLib::SetCameraNearFarD(Near, Far); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラの設定を変える<br>
      &nbsp;&nbsp;&nbsp; static void SetCameraSettings(VECTOR_D* pPosition, double* pRotV, double* pRotH, double* pRotT,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double* pFov = nullptr, double* pNear = nullptr, double* pFar = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pPosition != nullptr &amp;&amp; pRotV != nullptr &amp;&amp; pRotH != nullptr &amp;&amp; pRotT != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngleD(*pPosition, *pRotV, *pRotH, *pRotT);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pFov != nullptr) Camera::SetupCamera_PerspectiveD(*pFov); // カメラの視野角に変化があったら射影変換行列を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pNear != nullptr &amp;&amp; pFar != nullptr) Camera::SetCameraNearFarD(*pNear, *pFar); // カメラ一番近くから遠くまで描くレンジ<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // このワールドに存在するカメラすべてに対して funcで描きたい処理を渡して 全カメラのスクリーンに対して描画処理を走らせる<br>
      &nbsp;&nbsp;&nbsp; inline void Draw(std::function&lt;void()&gt; drawFunc) noexcept<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D beforeCamPos; // 設定変更前のカメラのパラメータを一旦、保管<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double beforeVRot, beforeHRot, beforeTRot, beforeNear, beforeFar, beforeFov;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Camera::GetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;beforeFov, &amp;beforeNear, &amp;beforeFar);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngle(this-&gt;pos, this-&gt;rot.V, this-&gt;rot.H, this-&gt;rot.T); // カメラの位置、回転を設定<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::Start(this-&gt;screenHandle, true, this-&gt;fovAngle); // カメラに関連付けられたscreenHandleのスクリーンを描画先にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawFunc(); // 渡された描画処理を実行<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::End(true); // 描画先を元に戻す<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // カメラの設定をもとに戻しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Camera::SetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;beforeFov, &amp;beforeNear, &amp;beforeFar);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>MyMath.hを新規作成</code>して、プレイヤが歩き回るさいの計算に必要な円周率などの定数を定義しましょう。</p>
    <p class="source">#ifndef MYMATH_H_<br>
      #define MYMATH_H_<br>
      <br>
      // 数学関連クラス<br>
      class MyMath<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // [<b>static constexprを使うことでstaticな定数を.hヘッダで初期化</b>] https://onihusube.hatenablog.com/entry/2019/06/30/230431<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; static constexpr float Sqrt2 = 1.41421356237f; // ルート2<br>
      &nbsp;&nbsp;&nbsp; static constexpr float PI = 3.14159265359f; // 円周率<br>
      &nbsp;&nbsp;&nbsp; static constexpr float Deg2Rad = PI / 180.0f; // 度からラジアンに変換する定数<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Player.hを新規作成</code>して、ワールドを歩きまわるプレイヤをタイル分割画像でパラパラアニメ描画できるようにしましょう。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Resource.h"<br>
      #include "MyHash.h" // hash32型でプレイヤが現在いるワールドのタグを管理する<br>
      #include "Vector3.h"<br>
      <br>
      class World; // 前方宣言<br>
      class Camera; // 前方宣言<br>
      <br>
      class Player<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Player(World* world, Pad pad, Vector3 position)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pad{ pad }, m_world{ world }, position{ position }, velocity{ 0,0,0 }, force{0,0,0}<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Player";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~Player() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★下記3つはメモリ上で共用状態になる(position、x,y,z、xyzどの名前から数値を変えたり読出してもメモリ上は同じ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 同じデータに3種類の名前を付けたイメージ、しかもVector3の機能や配列としてのアクセスの仕方もできて便利<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // XYZ座標&nbsp; [匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 position; // XYZ座標<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp;&nbsp; };// unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vx, vy, vz; }; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 velocity; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyz;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vxForce, vyForce, vzForce; }; // XYZ方向にかかる力(Unityでいうと AddForce関数 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 force; // XYZ方向の力(物理的には加速度:1フレームごとにvelocityの増える=加速する量)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyzForce;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; hash32 tag{ "" }; // プレイヤにつけるタグ<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; World* m_world; // 配置されたワールドへのリンク<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; virtual World* world() { return m_world; }<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
      &nbsp;&nbsp;&nbsp; virtual void world(World* changeWorld) { m_world = changeWorld; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; Pad pad; // 操作するコントローラー番号<br>
      &nbsp;&nbsp;&nbsp; hash32 worldTag{ "" }; // 現在いるワールドのタグ<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeedMax = 6; // 移動速度Max値<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeed = 0;//移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; float moveAngle = 0; // X軸→方向から何度か<br>
      &nbsp;&nbsp;&nbsp; float deltaAngle = 0; // プレイヤの動く角度の変化率、ハンドルを切ったらだんだんもとに戻る<br>
      &nbsp;&nbsp;&nbsp; int animCount = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image; // プレイヤの板ポリゴンで描くタイル分割画像への共有リンク<br>
      <br>
      &nbsp;&nbsp;&nbsp; Camera* camera{ nullptr }; // プレイヤを追随するカメラ<br>
      &nbsp;&nbsp;&nbsp; void SetCamera(Camera* pCamera) { camera = pCamera; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理<br>
      &nbsp;&nbsp;&nbsp; virtual void HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw();<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>Player.cppを新規作成</code>して、ワールドを歩きまわる処理を記述にしましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      void Player::HandleInput()<br>
      {<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_LEFT) <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_A)) )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = - MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += 1; //ハンドルを左に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_RIGHT)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_D)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle -= 1; //ハンドルを右に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_UP)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_W)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = - MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += 0.6f; //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; MoveSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = MoveSpeedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(pad, PAD_INPUT_DOWN)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_S)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed -= 0.6f; //ブレーキを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.9f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = -0.9f;//ちょっとだけバックできるように<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pad == Pad::Key || pad == Pad::One) // コントローラ1またはキーボード操作のプレイヤのときだけ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGUP)) // キーボードのPageUp ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = 2.0f; // テスト用に空中の上方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGDN)) // キーボードのPageDown ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -2.0f; // テスト用に空中の下方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp; x += vx;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp; y += vy;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp; z += vz;<br>
      <br>
      &nbsp;&nbsp;&nbsp; vy += vyForce; // 勢い(力・フォースを加算<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int animIndex = animCount / 20; // キャラのパラパラアニメの画像番号(最大3)<br>
      &nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp; if (abs_vx &gt; 1.00f || abs_vz &gt; 1.00f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6; // キャラが地面のXとZ方向に少しでもスピードがあったらアニメを走らせる<br>
      &nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // プレイヤのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 9; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // カメラ向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 奥向きの画像<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *image, imgIndex + animIndex, TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    <br>
    <p><code>main.cppを変更</code>して、hash32でカメラをstd::vectorではなくstd::unordered_mapの辞書にhash32タグを振って管理してみましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Screen.h"<br>
      #include "Camera.h"<br>
      #include "MyHash.h"<br>
      #include "Resource.h"<br>
      #include "MyDraw.h"<br>
      <em>#include "Player.h"</em><br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ Width×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ Width×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // タイルマップを読み込む 縦8マス、横8マス、縦32ピクセル、横32ピクセル<br>
      &nbsp;&nbsp;&nbsp; std::string mapChipPath{ "Map/mapchip.png" };<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath,8,8,32,32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>std::string playerImgPath1{ "Image/<b>pikkoron.png</b>" };<br>
        &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath1, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; std::string playerImgPath2{ "Image/<b>satan.png</b>" };<br>
        &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath2, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp; // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する<br>
      &nbsp;&nbsp;&nbsp; // ( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを2つ生成 画面の全体の縦方向サイズの Height / 2 にして、上下分割で配置できるようにする<br>
      &nbsp;&nbsp;&nbsp; int screenHandle0 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      &nbsp;&nbsp;&nbsp; int screenHandle1 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// ワールドを生成<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;World&gt; world1 = std::make_shared&lt;World&gt;(nullptr, "ワールド1");</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラを2つ生成して、2つのカメラ視点を2つのスクリーンにそれぞれ関連付ける<br>
      &nbsp;&nbsp;&nbsp; <u>std::unordered_map&lt;hash32, std::shared_ptr&lt;Camera&gt;&gt; cameras; // 複数のカメラへのポインタを格納するタグを振った辞書配列</u><br>
      &nbsp;&nbsp;&nbsp; <em>world1-&gt;</em>cameras.emplace<em>(</em>"カメラ0", std::make_shared&lt;Camera&gt;(<em>world1.get(), </em>Vector3{ 20,40,-50 })); // カメラ0<br>
      &nbsp;&nbsp;&nbsp; <em>world1-&gt;</em>cameras.emplace<em>(</em>"カメラ1", std::make_shared&lt;Camera&gt;(<em>world1.get(), </em>Vector3{ 80,30,-50 })); // カメラ1<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>world1-&gt;</em>cameras["カメラ0"]-&gt;screenHandle = screenHandle0; // カメラ0 と スクリーン0 を関連付ける<br>
      &nbsp;&nbsp;&nbsp; <em>world1-&gt;</em>cameras["カメラ1"]-&gt;screenHandle = screenHandle1; // カメラ1 と スクリーン1 を関連付ける<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <em>world1-&gt;players.emplace("プレイヤ0", std::make_shared&lt;Player&gt;(world1.get(), Pad::Key, Vector3{ 20,30,-50 }));<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players.emplace("プレイヤ1", std::make_shared&lt;Player&gt;(world1.get(), Pad::Two, Vector3{ 80,30,0 }));<br>
        <br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ0"]-&gt;SetCamera(world1-&gt;cameras["カメラ0"].get()); // .get()で共有ポインタstd::shared_ptrから生の*ポインタへ変換<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ1"]-&gt;SetCamera(world1-&gt;cameras["カメラ1"].get());<br>
        <br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ0"]-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath1]);<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ1"]-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath2]);<br>
        <br>
        &nbsp;&nbsp;&nbsp; Input::Init(); // 入力状態を初期化</em><br>
      &nbsp;&nbsp;&nbsp; <br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle0); // 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle1); // 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Input::Update(); // 入力状態を更新</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファを有効にする [Zの深度]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// world1のプレイヤを更新する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; pair : world1-&gt;players)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer = pair.second;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer-&gt;Update();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // world1のプレイヤを描画する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; pair : world1-&gt;players)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer = pair.second;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer-&gt;Draw();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 複数のカメラを 範囲 for文 で回す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; camera : cameras)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ラムダ式[&amp;](){ ～ }で{}の外側の変数すべてを &amp; キャプチャで&amp;参照として「Draw関数の内側へ引き連れて」処理できる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera.second-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw関数() の 外側にある変数 mapChipPath も[&amp;]効果で { } の内側で問題なくアクセスできている↓<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 70, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 4);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (camera.first == "カメラ0")<b> </b>//←"カメラ0"はビルド時に事前にハッシュ値が計算され、文字列ではない数値とおきかわっている<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらがカメラ0", GetColor(255, 0, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (camera.first == "カメラ1")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらはカメラ1", GetColor(0, 255, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーン0の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, 0, screenHandle0, FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, 0, Screen::Width, Screen::Height / 2, GetColor(255, 0, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーン1の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, Screen::Height / 2, screenHandle1, FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, Screen::Height / 2, Screen::Width, Screen::Height, GetColor(0, 255, 0));<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    いかがでしょう？実行したら、キーボードの上下左右矢印キーで上画面のプレイヤ0を、WASDキーで下画面のプレイヤ1を操作することができたでしょうか？<br>
    worldを間にはさんだことで、cameraとplayerがworldのポインタを経由して互いのデータにアクセスできるため、<br>
    違うキャラのカメラと自分のキャラの位置など、トリッキーなデータどうしのアクセスもworldを通してできるようになっています。<br>
    また、違うワールドにいるときはカメラのforループでは違うワールドにあるカメラはfor文に引っかからないわけなので、<br>
    別の世界にいるキャラは当然、描かれない仕組みがワールドの配下にcamaraやplayerのポインタが管理されることによって実現できています。<br>
    <br>
    <br>
    <a id="mozTocId0005" class="mozTocH1">
      <h1>シーンを定義して、ゲームシーンの中に複数ワールドを保持する</h1>
    </a>
    <p><code>前提として乱数クラスMyRandomを別記事から作成しておきます</code>←<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId20052">乱数で散乱弾を作成する</a><br>
    </p>
    <br>
    つぎは、シーンを定義して、ワールドはGameSceneの中で複数保持できるように設計していきましょう。<br>
    <br>
    <p><code>Scene.hを新規作成</code>して、様々なシーンの基底ベースとなるクラスを定義します(UpdateやDrawなどを純粋仮想関数としてoverride必須にしておく)。<br>
    </p>
    <p class="source">#ifndef SCENE_H_<br>
      #define SCENE_H_<br>
      <br>
      #include &lt;string&gt; // シーンの判別文字列tagに使う<br>
      #include "MyHash.h" // hash32型をタグ判別に使う<br>
      <br>
      // シーンの基底クラス あいまいなabstract型タイプ(virtual ～() = 0;の純粋仮想関数を含む)<br>
      class Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; std::string tag{ "" }; // シーンの判別に使う<br>
      &nbsp;&nbsp;&nbsp; hash32 typeTag{ "" }; // シーンのタイプの判別に使う<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Scene(const std::string&amp; sceneTag = "") : tag{ sceneTag }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //仮想デストラクタ【忘れるとメモリがヤバいダメ絶対】<br>
      &nbsp;&nbsp;&nbsp; virtual ~Scene()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 特に配列とかなくても★string文字列も内部では実質配列だから！5文字分のメモリとかがすり減ってく..<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 仮想デストラクタはstringなど暗黙に内部に配列を持つ要素のデストラクタを暗黙に呼んでくれている！<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //★純粋仮想関数=0は継承したGameSceneなどの必須機能(継承したら絶対override必須縛り)<br>
      &nbsp;&nbsp;&nbsp; // 必須縛りによってSceneを継承したものは【Update,Drawが実装されてるはずの確証があるので】<br>
      &nbsp;&nbsp;&nbsp; // for文であいまいなSceneのまま【まとめてUpdate,Drawできる】のだ。<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Initialize() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 終了処理(大抵Initializeと同じくリセット処理を行うがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp;&nbsp; virtual void Finalize() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    次に、シーンを管理するマネージャーが欲しいので、シングルトンのテンプレートクラスを準備します。<br>
    <p><code>Singleton.hを新規作成</code>して、シングルトンのテンプレートクラスを定義します。<br>
    </p>
    <p class="source">#ifndef SINGLETON_H_<br>
      #define SINGLETON_H_<br>
      <br>
      // テンプレートT型シングルトンSingleton&lt;～&gt; ～になんでも指定して唯一物にできる<br>
      // ★Singleton&lt;TypeT&gt;型は【必ず唯一で複製不可】(使い方:どこからでもアクセスし変数を共有するクラス向き)<br>
      // ★ゲーム内の【どこからアクセスしても統一性が保たれる】(唯一だから)「クラス名と実体が一致」<br>
      template&lt;class TypeT&gt;<br>
      class Singleton<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // Instance()を通して【しか】T型クラスをつくれないうえに、<br>
      &nbsp;&nbsp;&nbsp; // ★作ったものは【かならず唯一で複製不可】<br>
      &nbsp;&nbsp;&nbsp; // それが【シングルトン型】！<br>
      &nbsp;&nbsp;&nbsp; // ゲーム中で唯一で複製不可にしたい【ゲームを一律管理するクラス】などに最適！<br>
      &nbsp;&nbsp;&nbsp; // https://teratail.com/questions/17416<br>
      &nbsp;&nbsp;&nbsp; // http://rudora7.blog81.fc2.com/blog-entry-393.html<br>
      &nbsp;&nbsp;&nbsp; // ②↓同じ関数の定義はプログラム全体で１つだけしか許されません。(static関数名は被らない)<br>
      &nbsp;&nbsp;&nbsp; static inline TypeT&amp; Instance()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //①↓関数の中で定義されたstatic変数は、関数の定義毎に１つ領域が確保されます。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static TypeT instance; //メモリ上にstatic変数確保(静かに常に待機するinstance)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return instance; //①=(常駐)②=(唯一) ①と②両方満たすinstanceは【メモリ上に唯一】<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; Singleton() {} // 外部でのインスタンス作成は禁止(protected:内部公開、外部禁止)<br>
      &nbsp;&nbsp;&nbsp; virtual ~Singleton() {} // 仮想デストラクタ(シングルトンを【継承するためには忘れちゃダメ】)<br>
      <br>
      private:<br>
      &nbsp;&nbsp;&nbsp; void operator=(const Singleton&amp; obj) {} // 代入演算子禁止<br>
      &nbsp;&nbsp;&nbsp; Singleton(const Singleton&amp; obj) {} // コピーコンストラクタ禁止(コピーできない【唯一】)<br>
      &nbsp;&nbsp;&nbsp; static TypeT* instance; // private:だから外部アクセスできない【GetInstance()経由しか無理】<br>
      };<br>
      <br>
      // いつもcppで書いたstatic変数初期化も★【Tテンプレートクラスだからすべて.hヘッダにまとめて書いた】<br>
      template&lt; class TypeT &gt;<br>
      TypeT* Singleton&lt; TypeT &gt;::instance = 0; //cppでの定義を.h内に書いた(static変数はclass内で初期化できないから)<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>SceneManager.hを新規作成</code>して、シングルトンを継承してどこからでもアクセスできるマネージャを定義します。<br>
    </p>
    <p class="source">#ifndef SCNENEMANAGER_H_<br>
      #define SCNENEMANAGER_H_<br>
      <br>
      #include &lt;vector&gt;<br>
      #include &lt;memory&gt;<br>
      #include &lt;string&gt;<br>
      #include &lt;assert.h&gt; // シーン読み込みの失敗表示用<br>
      <br>
      #include "MyHash.h" // hash32型でタグを管理する<br>
      #include "Singleton.h"<br>
      <br>
      class Scene; //クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      <br>
      class SceneManager : public Singleton&lt;SceneManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; friend class Singleton&lt;SceneManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Scene&gt; prevScene{ nullptr }; // 一つ前のシーン<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Scene&gt; currentScene{ nullptr }; // 現在のシーン<br>
      <br>
      &nbsp;&nbsp;&nbsp; hash32 currentSceneType{ "" }; // 現在のシーン名を保管しておく<br>
      &nbsp;&nbsp;&nbsp; std::string currentSceneTag{ "" }; // 現在のシーンのタグを保管しておく<br>
      <br>
      &nbsp;&nbsp;&nbsp; hash32 changingSceneType{ "" }; // 予約された次のシーンのクラス名(次に移動予定のシーン名を保管しておく)<br>
      &nbsp;&nbsp;&nbsp; std::string changingSceneTag{ "" }; // 予約された次のシーンのタグ(次に移動予定のシーンのタグを保管しておく)<br>
      <br>
      &nbsp;&nbsp;&nbsp; // シーン名を比較、何の変化もなければfalseでシーン移動不必要の判定<br>
      &nbsp;&nbsp;&nbsp; bool isChanging(const std::string&amp; nextSceneType, const std::string&amp; nextSceneTag = "");<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次のシーンの予約だけしてLoadScene()を引数なしで呼び出したタイミングで遷移する(ループの途中じゃないキリのいいタイミングを狙って遷移させる)<br>
      &nbsp;&nbsp;&nbsp; void NextScene(const std::string&amp; nextSceneName, const std::string&amp; nextSceneTag = "");<br>
      <br>
      &nbsp;&nbsp;&nbsp; // シーンをチェンジし遷移する(前のシーンのリセット処理もする)<br>
      &nbsp;&nbsp;&nbsp; void LoadScene(const std::string&amp; sceneName = "", const std::string&amp; nextSceneTag = "");<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; SceneManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;&nbsp; virtual ~SceneManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>SceneManager.cppを新規作成</code>して、先行してGameSceneなどをロード・切り替えする処理を先に書いておきます。<br>
    </p>
    <p class="source">#include "SceneManager.h"<br>
      <br>
      #include "Scene.h"<br>
      #include "TitleScene.h"<br>
      #include "GameScene.h"<br>
      #include "GameOverScene.h"<br>
      <br>
      bool SceneManager::isChanging(const std::string&amp; nextSceneType, const std::string&amp; nextSceneTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (currentSceneType != nextSceneType) //シーンのタイプ不一致<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // シーンのタイプが変更<br>
      &nbsp;&nbsp;&nbsp; if (currentSceneTag != nextSceneTag) //シーンのタグ不一致<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // シーンのタグが変更<br>
      <br>
      &nbsp;&nbsp;&nbsp; return false; // シーンに変更無し<br>
      }<br>
      <br>
      void SceneManager::NextScene(const std::string&amp; nextSceneType, const std::string&amp; nextSceneTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 遷移予定nextシーン名と現在のシーン名を比較、何の変化もなければfalseでシーン移動不必要の判定<br>
      &nbsp;&nbsp;&nbsp; if (isChanging(nextSceneType) == false) return; //特に変更なしでシーン移動の必要なし<br>
      <br>
      &nbsp;&nbsp;&nbsp; changingSceneType = nextSceneType; // 次に移動予定のシーン名を保管しておく<br>
      }<br>
      <br>
      void SceneManager::LoadScene(const std::string&amp; nextSceneType, const std::string&amp; nextSceneTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; hash32 loadSceneType = nextSceneType;<br>
      &nbsp;&nbsp;&nbsp; std::string loadSceneTag = nextSceneTag;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // nextSceneTypeの指定が空の場合にはNextScene()での事前のシーン変更予約があるかチェック<br>
      &nbsp;&nbsp;&nbsp; if (nextSceneType == "" &amp;&amp; changingSceneType != "")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loadSceneType = changingSceneType;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loadSceneTag = changingSceneTag;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (loadSceneType == "") return; // シーン指定がないときは終了<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 現在のシーンの終了処理<br>
      &nbsp;&nbsp;&nbsp; if (currentScene != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentScene-&gt;Finalize(); // 終了処理を呼び出す<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (loadSceneType == "TitleScene")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次のシーンの生成<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentScene = std::make_shared&lt;TitleScene&gt;(loadSceneTag);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (loadSceneType == "GameScene")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次のシーンの生成<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentScene = std::make_shared&lt;GameScene&gt;(loadSceneTag);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (loadSceneType == "GameOverScene")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次のシーンの生成<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentScene = std::make_shared&lt;GameOverScene&gt;(loadSceneTag);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert("指定されたシーンの生成処理が見つからなかった→SceneManager.cppを見直しましょう" == "");<br>
      <br>
      &nbsp;&nbsp;&nbsp; currentSceneType = loadSceneType; // 現在のシーン名の更新<br>
      &nbsp;&nbsp;&nbsp; currentSceneTag = loadSceneTag; // 現在のシーンのタグの更新<br>
      <br>
      &nbsp;&nbsp;&nbsp; changingSceneType = ""; // NextScenceのシーン予約名をリセット<br>
      &nbsp;&nbsp;&nbsp; changingSceneTag = ""; // NextScenceのシーン予約タグをリセット<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次のシーンの初期化<br>
      &nbsp;&nbsp;&nbsp; currentScene-&gt;Initialize(); // 初期化を呼び出す<br>
      }<br>
    </p>
    今回はシューティングのときと違って、初期化のときにシーンのタグを渡せるように設計しました。<br>
    たとえば、同じ"GameScene"のシーンタイプでも、どのステージを遊ぶのかなどをタグを通して渡せれば、<br>
    ステージごとにシーンタイプを増やして別定義しなくてすむようになりますし、柔軟性が増します。<br>
    <br>
    <p><code>TitleScene.hを新規作成</code>して、特に今回は処理を書きませんが実際に制作するときにはタイトル画面を実装するためのひな形だけ作っておきます。<br>
    </p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      <br>
      #include "SceneManager.h"<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; SceneManager&amp; sm = SceneManager::Instance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; TitleScene(const std::string&amp; sceneTag = "") : Scene(sceneTag)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "TitleScene";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp;&nbsp; void Finalize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(Pad::All, PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sm.LoadScene("GameScene"); //シーン遷移<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "TitleSceneです。ボタン押下でGameSceneへ。", GetColor(255, 255, 255));<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>GameOverScene.hを新規作成</code>して、特に今回は処理を書きませんが実際に制作するときにはゲームオーバー画面を実装するためのひな形だけ作っておきます。<br>
    </p>
    <p class="source">#ifndef GAMEOVERSCENE_H_<br>
      #define GAMEOVERSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      <br>
      #include "SceneManager.h"<br>
      <br>
      class GameOverScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; SceneManager&amp; sm = SceneManager::Instance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; GameOverScene(const std::string&amp; sceneTag = "") : Scene(sceneTag)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "GameOverScene";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp;&nbsp; void Finalize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(Pad::All, PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sm.LoadScene("TitleScene"); //シーン遷移<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "GameOver....ボタン押下でPlaySceneへ", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    さて、今回の本題のGameSceneを作成する前に、シーンに関するセッティングをCSVファイルから読みだせるようにすれば、<br>
    ゲームシーンに関する情報、例えば、ステージのマップのファイルの場所一覧、などをプランナがエクセルで管理でき、それをCSVに吐き出して、<br>
    そのセッティングに合わせて、ゲームのシーンの初期化と同時に、ワールドのマップ読出しに必要な情報をCSVファイルから柔軟に得ることができます。<br>
    <p><code>DaraCsv.hを新規作成</code>して、CSV形式のファイルをロードできるようにします。<br>
    </p>
    <p class="source">#ifndef DATACSV_H_<br>
      #define DATACSV_H_<br>
      <br>
      #include &lt;vector&gt;<br>
      #include &lt;string&gt;<br>
      <br>
      #include &lt;fstream&gt; // ファイル読み出しifstreamに必要<br>
      #include &lt;string&gt; //文字列に必要<br>
      #include &lt;sstream&gt; // 文字列ストリームに必要<br>
      <br>
      #include &lt;assert.h&gt; // 読込み失敗表示用<br>
      <br>
      <br>
      //★CsvValue型をint型や文字列string型や小数float型として【カメレオン】のように使える。<br>
      // 【エクセルはマス目がカメレオン】整数も小数も文字列もありうる。<br>
      // それを解消して統一して扱える便利な★CsvValue型。<br>
      class CsvValue<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; enum class Type : unsigned char<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Int,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Float,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; String,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; NUM<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; Type type = Type::String;<br>
      protected: // 内部データを書き換え禁止:書き換えられるとintと文字列とのずれが起きうる<br>
      &nbsp;&nbsp;&nbsp; // エクセルのCsvデータはマス目がint,float,stringの3種類ありうる<br>
      &nbsp;&nbsp;&nbsp; union {&nbsp; // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int intData = 0; // 整数int型データを格納<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float floatData; // 小数float型データを格納<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string stringData{ "" }; // 文字列string型データを格納<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; CsvValue() = default;<br>
      &nbsp;&nbsp;&nbsp; // 3種類のコンストラクタ<br>
      &nbsp;&nbsp;&nbsp; CsvValue(float floatData) : type{ Type::Float }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;floatData = floatData;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;stringData = std::to_string(floatData);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; CsvValue(const std::string&amp; stringData) : type{ Type::String }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;stringData = stringData;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; ~CsvValue() {}; // 仮想デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; void operator=(const int&amp; intValue) // 代入演算子<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;intData = intValue;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; void copy(const CsvValue&amp; value)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; type = value.type;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (value.type == Type::Int) { this-&gt;intData = value.intData; this-&gt;stringData = std::to_string(value.intData); }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (value.type == Type::Float) { this-&gt;floatData = value.floatData; this-&gt;stringData = std::to_string(value.floatData); }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (value.type == Type::String) { this-&gt;stringData = value.stringData; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; void operator=(const CsvValue&amp; value) { copy(value); } // 代入演算子<br>
      &nbsp;&nbsp;&nbsp; CsvValue(const CsvValue&amp; value) { copy(value); } // コピーコンストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 変換演算子によりCSVのセルをintとしてもstringとしても扱えるように<br>
      &nbsp;&nbsp;&nbsp; // https://programming-place.net/ppp/contents/cpp/language/019.html#conversion_op<br>
      &nbsp;&nbsp;&nbsp; // 3種類の読み取りオペレータ<br>
      &nbsp;&nbsp;&nbsp; operator int()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (type == Type::Float) return (int)floatData;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (type == Type::String &amp;&amp; intData == 0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; intData = intFromString(); // デフォルトで文字列として読込んだデータをintに変換<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return intData;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline operator float()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (type == Type::Int) return (float)intData;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (type == Type::String &amp;&amp; intData == 0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; floatData = floatFromString(); // デフォルトで文字列として読込んだデータをfloatに変換<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return floatData;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline operator std::string() const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return stringData;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; int intFromString() // 文字列データからint型への変換する関数<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::istringstream ss(stringData); //文字列ストリームの初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ss &gt;&gt; num; // 文字列ストリームから数字への変換<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return num;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; float floatFromString() // 文字列データからfloat型への変換する関数<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::istringstream ss(stringData); //文字列ストリームの初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ss &gt;&gt; num; // 文字列ストリームから数字への変換<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return num;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      // CSVの1行を[]オペレータでアクセスした際1行のサイズが足りない場合に自動resizeする機能を[]オペレータに実装する<br>
      struct CsvLine : public std::vector&lt;CsvValue&gt;<br>
      {<br>
      &nbsp;&nbsp;&nbsp; inline std::vector&lt;CsvValue&gt;&amp; operator[](std::size_t index) {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (index &gt;= size()) { resize(index + 1); }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return (*this)[index]; // 読み書き<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      // CSVファイルを読込み幅や高さとデータ本体を保持するデータ型<br>
      struct DataCsv<br>
      {<br>
      &nbsp;&nbsp;&nbsp; enum class CsvType<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IntMap,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CsvValue<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; CsvType type;<br>
      &nbsp;&nbsp;&nbsp; bool isInitialized = false; //[継承2重ロード対策]ベース基底でロードしたらtrueに<br>
      &nbsp;&nbsp;&nbsp; // 読込んだデータファイルの情報<br>
      &nbsp;&nbsp;&nbsp; std::string FilePath{ "" };<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;CsvLine&gt; Data;// csvデータ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ★スムーズに[][]でアクセスできるように[]演算子を独自定義する<br>
      &nbsp;&nbsp;&nbsp; // https://www.hiramine.com/programming/c_cpp/operator.html<br>
      &nbsp;&nbsp;&nbsp; inline std::vector&lt;CsvValue&gt;&amp; operator[](std::size_t index) { <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (index &gt;= Data.size())<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Data.resize(index + 1); // 範囲外アクセス時は自動リサイズ(使う人が大きな数字間違っていれるとやばいので注意)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Data[index]; // 読取り<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::size_t size()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // size()関数の名前をvectorと被らせることで使う側はvectorインvectorのままのコードで使える<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Data.size();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // 初期化コンストラクタでファイル名を指定して初期化と同時にファイル読込<br>
      &nbsp;&nbsp;&nbsp; DataCsv(std::string FilePath = "", CsvType csvType = CsvType::IntMap) : type{csvType}, FilePath { FilePath }<br>
      &nbsp;&nbsp;&nbsp; {// csvファイルの読込み★【初期化と同時なのでファイルとデータ型が一心同体で使いやすい】<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (FilePath != "")<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Load(FilePath, csvType); // ファイル読込み<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; virtual ~DataCsv()<br>
      &nbsp;&nbsp;&nbsp; {// 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; clear();// 2次元配列データのお掃除<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // データをクリアしてメモリを節約する<br>
      &nbsp;&nbsp;&nbsp; virtual void clear()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // [確実にメモリを空にするには] http://vivi.dyndns.org/tech/cpp/vector.html#shrink_to_fit<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::vector&lt;CsvLine&gt;().swap(Data); // 空のテンポラリオブジェクトでリセット<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitialized = false; //ロード済みフラグをOFF<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // csvファイルの読み込み<br>
      &nbsp;&nbsp;&nbsp; virtual void Load(std::string filePath, CsvType csvType = CsvType::IntMap)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (filePath == "" || isInitialized) return; //ファイル名がないもしくはロード済<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;FilePath = filePath; // ファイル名を保管<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;type = csvType;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Data.clear(); //データを一旦クリア<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::ifstream ifs_csv_file(filePath);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string line; //1行単位の読込み文字列<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int readWidth = 0, readHeight = 0; //読込みデータの幅と高さ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int maxWidth = 0; //今から読み込んだ時のMAXの幅<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CsvLine valuelist; // 1行の数字リスト<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::istringstream linestream(line); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string splitted; // カンマ分割文字列<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int widthCount = 0; //この行の幅をカウント<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;type == CsvType::IntMap)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (std::getline(linestream, splitted, { ',' }))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::istringstream ss; //文字列ストリームの初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ss = std::istringstream(splitted); //文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ss &gt;&gt; num; // 文字列ストリームから数字への変換<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; valuelist.push_back(CsvValue(num)); // 数字をリスト(1行リスト)に追加<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; widthCount++; //この行の幅をカウントアップ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (this-&gt;type == CsvType::CsvValue)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (std::getline(linestream, splitted, { ',' }))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (splitted.size() &gt; 1 &amp;&amp; splitted[0] == '\"')<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; splitted = splitted.substr(1, splitted.size() - 2);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; valuelist.emplace_back(splitted); // 数字を数字のリスト(1行リスト)に追加<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; widthCount++; //この行の幅をカウントアップ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (widthCount &gt; maxWidth) maxWidth = widthCount; //暫定Max幅を更新<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 1行分をvectorに追加<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (valuelist.size() != 0) Data.emplace_back(valuelist);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; readHeight++; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; readWidth = maxWidth; //MAX幅の王者を確定<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(readWidth &gt; 0); // マップ幅がおかしい<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(readHeight &gt; 0); // マップ高さがおかしい<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // コンストラクタで初期化でロードの場合とLoad関数経由で読む経路があるから<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitialized = true; // 読込み初期化済みフラグをON<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Mapフォルダの中にGameSceneSetting.csvを新規作成</code>して、下記内容のcsvのデータで、シーン1というタグでGameSceneを初期生成するとき、<br>
      ステージ1というタグのついたワールドにMap/stage1.jsonから読みだしたマップを読み出し生成する、という情報を記述し保存しておきましょう。(マップのjson読み出しはのちの章でやる予定です)<br>
    </p>
    <p class="source">"//","GameSceneでシーン名を指定するとその行以降をそのシーンで使うworldsとしてロードする",,,,<br>
      "GameScene","シーン1",,,,<br>
      "ステージ1","Map/stage1.json",,,,<br>
      <br>
    </p>
    <br>
    <br>
    <p><code>GameScene.hを新規作成</code>して、ゲームを実際にUpdateしたりDrawしたりするためのシーンを定義しましょう(ワールドの定義もシーンの中にある)。<br>
    </p>
    <p class="source">#ifndef GAMESCENE_H_<br>
      #define GAMESCENE_H_<br>
      <br>
      #include &lt;memory&gt; // 共有ポインタ std::shared_ptrを使う<br>
      #include &lt;unordered_map&gt; // ワールドにタグをつけて複数のワールドを管理 複数あれば(扉→別マップへの移動→元のマップへ戻っても敵が消えずに残せる)<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Resource.h"<br>
      #include "Screen.h"<br>
      #include "Camera.h"<br>
      #include "DataCsv.h"<br>
      <br>
      #include "SceneManager.h"<br>
      <br>
      struct GameSceneSetting // ゲームシーン情報をGameSceneSetting.csvなどから読みだす<br>
      {<br>
      &nbsp;&nbsp;&nbsp; GameSceneSetting(const std::string&amp; csvFileName = "")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (csvFileName != "") Load(csvFileName);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; ~GameSceneSetting() {}; //デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; struct WorldTag_Path<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WorldTag_Path() = default;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline WorldTag_Path(const std::string&amp; tag, const std::string&amp; mapFilePath) : tag{ tag }, mapFilePath{ mapFilePath } {}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline ~WorldTag_Path() {}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string tag{ "" }; // ワールドにつけるtag<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string mapFilePath{ "" }; // マップのファイルパス<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; struct Info : public std::unordered_map&lt;hash32, WorldTag_Path&gt; // &lt;ワールド名のタグ, ワールドのファイルパス&gt;<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Info() = default;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline Info(const std::string&amp; gameSceneTag) : gameSceneTag{ gameSceneTag } {};<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~Info() {};<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string gameSceneTag{ "" }; // シーン名のタグ<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, Info&gt; info; //[辞書]シーン名のタグ → ワールド情報<br>
      &nbsp;&nbsp;&nbsp; bool isInitialized = false; //[継承2重ロード対策]<br>
      &nbsp;&nbsp;&nbsp; std::string FilePath{ "" }; // csvのファイルパス<br>
      <br>
      &nbsp;&nbsp;&nbsp; Info&amp; operator[](const std::string&amp; gameSceneTag) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(info.count(gameSceneTag) != 0 &amp;&amp; "シーン情報が読み取れていません Map/GameSceneSettings.csv に情報があるか確認！");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return info[gameSceneTag]; // 読み書き<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; void Load(const std::string&amp; csvFileName = "")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isInitialized) return; // 2重ロード対策<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (csvFileName != "") this-&gt;FilePath = csvFileName;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;FilePath == "") return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataCsv Data; // マップ情報一覧のデータ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data.Load(csvFileName, DataCsv::CsvType::CsvValue);// CSVファイルからデータをロード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string gameSceneTag; //ゲームシーン名<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; Data.size(); ++j)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((std::string)Data[j][0] == "//") continue; // 一番左の列が//なら読み飛ばしのコメント行<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((std::string)Data[j][0] == "GameScene")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gameSceneTag = Data[j][1]; //ゲームシーン名<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info.emplace(std::piecewise_construct, std::forward_as_tuple(gameSceneTag), std::forward_as_tuple(gameSceneTag));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (gameSceneTag == "") continue; //ステージファイル名が未確定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((std::string)Data[j][0] != "")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info[gameSceneTag][(std::string)Data[j][0]] = std::move(WorldTag_Path(Data[j][0], Data[j][1])); //ワールド名 → ワールドのファイルのパスを読み取り<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      <br>
      class GameScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; static GameSceneSetting settings; // ゲームシーンの設定情報 デフォルトは{ "Map/GameSceneSetting.csv" } を読み取り<br>
      <br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; SceneManager&amp; sm = SceneManager::Instance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;World&gt;&gt; worlds; // 複数ワールドの共有ポインタ辞書<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // ワールドをタグをつけて生成する<br>
      &nbsp;&nbsp;&nbsp; void CreateWorld(const std::string&amp; worldTag) { if (worlds.count(worldTag) == 0) { worlds.emplace(worldTag, std::make_shared&lt;World&gt;(this, worldTag)); } }<br>
      &nbsp;&nbsp;&nbsp; // タグからワールドへのポインタリンクを得る<br>
      &nbsp;&nbsp;&nbsp; World* world(const std::string&amp; worldTag) { auto itr = worlds.find(worldTag); return (itr != end(worlds)) ? itr-&gt;second.get() : nullptr; }<br>
      &nbsp;&nbsp;&nbsp; // 指定したゲームシーンのタグに関連づいたファイル名に対応したワールドを初期化する<br>
      &nbsp;&nbsp;&nbsp; bool LoadWorlds(const std::string&amp; gameSceneTag);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤはタイトル画面などでも初期選択できるようにあえてworld配下の管理ではなく<br>
      &nbsp;&nbsp;&nbsp; // GameScene配下の管理でゲーム開始時から直接生成できるようにここに定義<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;Player&gt;&gt; players; // &lt;タグ,プレイヤへの共有ポインタ&gt;辞書[複数プレイヤ可能]<br>
      &nbsp;&nbsp;&nbsp; void ChangeWorld(const std::string&amp; worldTag, std::shared_ptr&lt;Player&gt; pPlayer); // プレイヤのいるワールドを移動する<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; GameScene(const std::string&amp; sceneTag = "") : Scene(sceneTag)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "GameScene";<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;tag != "") // this-&gt;tag には : Scene(sceneTag) 経由で sceneTag が設定されている<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadWorlds(this-&gt;tag); // GameSceneSetting.csv に設定したタグに対応したファイルをロード<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp;&nbsp; void Finalize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ここにプレイ終了時のリセット処理(ゲームクリアやゲームオーバーなど)<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override;<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>GameScene.cppを新規作成</code>して、ゲームをUpdateしたりDrawしたりする処理を実装しましょう。<br>
    </p>
    <p class="source">#include "GameScene.h"<br>
      <br>
      #include "Player.h"<br>
      <br>
      GameSceneSetting GameScene::settings{ "Map/GameSceneSetting.csv" }; // ゲームシーンの設定情報<br>
      <br>
      // 指定したゲームシーンのタグに関連づいたファイル名に対応したワールドを初期化する<br>
      bool GameScene::LoadWorlds(const std::string&amp; gameSceneTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (settings.info.count(gameSceneTag) == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto&amp; info = settings[gameSceneTag];<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; tag_mapPath : info)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateWorld(tag_mapPath.second.tag); // ワールドをタグをつけて生成<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      void GameScene::ChangeWorld(const std::string&amp; worldTag, std::shared_ptr&lt;Player&gt; pPlayer)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (pPlayer == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp; if (worlds.count(worldTag) == 0) return; // 存在しないタグだった<br>
      <br>
      &nbsp;&nbsp;&nbsp; pPlayer-&gt;world(worlds[worldTag].get()); // ワールドへのリンクをすげ替える<br>
      }<br>
      <br>
      <br>
      void GameScene::Initialize()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Ｚバッファを有効にする [Zの深度]<br>
      &nbsp;&nbsp;&nbsp; //[参考]https://docs.google.com/presentation/d/1Z23t1yAS7uzPDVakgW_M02p20qt9DeTs4ku4IiMDLco/edit?usp=sharing<br>
      &nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する<br>
      &nbsp;&nbsp;&nbsp; // ( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを2つ生成 画面の全体の縦方向サイズの Height / 2 にして、上下分割で配置できるようにする<br>
      &nbsp;&nbsp;&nbsp; screenHandle0 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      &nbsp;&nbsp;&nbsp; screenHandle1 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath, 8, 8, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath1, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath2, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの生成<br>
      &nbsp;&nbsp;&nbsp; if (pWorld != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pWorld-&gt;AddCamera("カメラ1", Camera::defaultCamera); // カメラ1というタグをデフォルトカメラにつけてワールドにデフォルトカメラを配置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ1", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera1 = pWorld-&gt;camera("カメラ1"); // カメラ1 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera1-&gt;SetScreenHandle(screenHandle0); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer1 = std::make_shared&lt;Player&gt;(pWorld, Pad::Key, Vector3(90 + 256, 32, 95 + 256));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ1", pPlayer1); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath1]);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;camera = pCamera1.get(); // カメラをプレイヤにリンクする<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ2", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera2 = pWorld-&gt;camera("カメラ2"); // プレイヤ2 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera2-&gt;SetScreenHandle(screenHandle1); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer2 = std::make_shared&lt;Player&gt;(pWorld, Pad::Two, Vector3(190, 32, 195));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ2", pPlayer2); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath2]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;camera = pCamera2.get(); // カメラをプレイヤにリンクする<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      <br>
      void GameScene::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle0); // 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle1); // 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; player : players)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player.second-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      }<br>
      <br>
      void GameScene::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; player : players)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player.second-&gt;Draw(); // プレイヤの描画【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // プレイヤのいるワールドのカメラのみを描けば、プレイヤのいないワールドは描かずに済む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 複数のカメラを 範囲 for文 で回す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; camera : player.second-&gt;world()-&gt;cameras)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ラムダ式[&amp;](){ ～ }で{}の外側の変数すべてを &amp; キャプチャで&amp;参照として「Draw関数の内側へ引き連れて」処理できる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera.second-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw関数() の 外側にある変数 mapChipPath も[&amp;]効果で { } の内側で問題なくアクセスできている↓<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 70, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 8);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (camera.first == "カメラ1")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらがプレイヤ1", GetColor(255, 0, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (camera.first == "カメラ2")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらはプレイヤ2", GetColor(0, 255, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーン0の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, 0, screenHandle0, FALSE);<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, 0, Screen::Width, Screen::Height / 2, GetColor(255, 0, 0));<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーン1の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, Screen::Height / 2, screenHandle1, FALSE);<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, Screen::Height / 2, Screen::Width, Screen::Height, GetColor(0, 255, 0));<br>
      <br>
      }<br>
    </p>
    さて、このまま、main.cppでシーンを直接Update、Drawしていいものか？<br>
    なぜなら、タイトルシーンやゲームオーバー、ゲーム中のシーンで共通するような処理はあるでしょうから、<br>
    シーンとmain.cppの間にもう一つGameというクラスをはさんで、共通の処理はそちらにさせるようにしましょう。<br>
    <br>
    <br>
    <p><code>Game.hを新規作成</code>して、各シーンで共通する処理をUpdateしたりDrawしたりする処理を実装しましょう。<br>
    </p>
    <p class="source">#ifndef GAME_H_<br>
      #define GAME_H_<br>
      <br>
      #include "Screen.h"<br>
      #include "SceneManager.h"<br>
      #include "Scene.h"<br>
      #include "MyRandom.h"<br>
      #include "Input.h"<br>
      <br>
      class Game<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; Game() {}; // 初期化コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; ~Game() {}; // 破棄処理デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; SceneManager&amp; sm = SceneManager::Instance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; void Init()<br>
      &nbsp;&nbsp;&nbsp; {// Init処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 各種Init中に、<b>ユーザーにお待ちいただく間、不安を和らげるためのメッセージをScreenFlipで表示</b>してからInit開始<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string loadingStr("ゲーム起動中...&nbsp; 必要なファイルをロードしています");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int strSize = DxLib::GetFontSize() * loadingStr.size();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawString(Screen::Width / 2 - strSize / 2, Screen::Height / 2, loadingStr.c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Input::Init(); // 入力機能の初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数のシードを現時点の時刻に連動して初期化<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ゲーム開始して最初のシーンに遷移<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.LoadScene("<b>GameScene</b>", "<b>シーン1</b>");<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; void Update() {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // シーンの更新処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.currentScene-&gt;Update();<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // NextScene関数で次のシーン移動予約があったらシーンを移動する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.LoadScene(); // 引数無し呼び出しの場合、事前に NextScene関数で予約がない場合はスルーされる<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; void Draw()<br>
      &nbsp;&nbsp;&nbsp; {// 描画処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // シーンの描画処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.currentScene-&gt;Draw();<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>main.cppを変更</code>して、Gameクラスを通じてシーンをInit、Update、Drawしましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      <em>#include "Game.h"</em><br>
      <br>
      #include "Screen.h"<br>
      <u>#include "Camera.h"<br>
        #include "MyHash.h"<br>
        #include "Resource.h"<br>
        #include "MyDraw.h"<br>
        #include "Player.h"</u><br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ Width×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ Width×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 初期化処理<br>
        &nbsp;&nbsp;&nbsp; Game game;<br>
        &nbsp;&nbsp;&nbsp; game.Init(); // gameのInit準備</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>// タイルマップを読み込む 縦8マス、横8マス、縦32ピクセル、横32ピクセル<br>
        &nbsp;&nbsp;&nbsp; std::string mapChipPath{ "Map/mapchip.png" };<br>
        &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath,8,8,32,32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::string playerImgPath1{ "Image/pikkoron.png" };<br>
        &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath1, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; std::string playerImgPath2{ "Image/satan.png" };<br>
        &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath2, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
        <br>
        &nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp;&nbsp; // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する<br>
        &nbsp;&nbsp;&nbsp; // ( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを2つ生成 画面の全体の縦方向サイズの Height / 2 にして、上下分割で配置できるようにする<br>
        &nbsp;&nbsp;&nbsp; int screenHandle0 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
        &nbsp;&nbsp;&nbsp; int screenHandle1 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ワールドを生成<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;World&gt; world1 = std::make_shared&lt;World&gt;(nullptr, "ワールド1");<br>
        <br>
        &nbsp;&nbsp;&nbsp; // カメラを2つ生成して、2つのカメラ視点を2つのスクリーンにそれぞれ関連付ける<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;cameras.emplace("カメラ0", std::make_shared&lt;Camera&gt;(world1.get(), Vector3{ 20,40,-50 })); // カメラ0<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;cameras.emplace("カメラ1", std::make_shared&lt;Camera&gt;(world1.get(), Vector3{ 80,30,-50 })); // カメラ1<br>
        <br>
        &nbsp;&nbsp;&nbsp; world1-&gt;cameras["カメラ0"]-&gt;screenHandle = screenHandle0; // カメラ0 と スクリーン0 を関連付ける<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;cameras["カメラ1"]-&gt;screenHandle = screenHandle1; // カメラ1 と スクリーン1 を関連付ける<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players.emplace("プレイヤ0", std::make_shared&lt;Player&gt;(world1.get(), Pad::Key, Vector3{ 20,30,-50 }));<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players.emplace("プレイヤ1", std::make_shared&lt;Player&gt;(world1.get(), Pad::Two, Vector3{ 80,30,0 }));<br>
        <br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ0"]-&gt;SetCamera(world1-&gt;cameras["カメラ0"].get()); // .get()で共有ポインタstd::shared_ptrから生の*ポインタへ変換<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ1"]-&gt;SetCamera(world1-&gt;cameras["カメラ1"].get());<br>
        <br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ0"]-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath1]);<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ1"]-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath2]);<br>
        <br>
        &nbsp;&nbsp;&nbsp; Input::Init(); // 入力状態を初期化</u><br>
      &nbsp;&nbsp;&nbsp; <br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>game.Update(); //ゲームの更新処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; game.Draw(); // パラパラ漫画の描画処理</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle0); // 一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle1); // 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // 入力状態を更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファを有効にする [Zの深度]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // world1のプレイヤを更新する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; pair : world1-&gt;players)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer = pair.second;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer-&gt;Update();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // world1のプレイヤを描画する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; pair : world1-&gt;players)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer = pair.second;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer-&gt;Draw();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 複数のカメラを 範囲 for文 で回す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; camera : cameras)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ラムダ式[&amp;](){ ～ }で{}の外側の変数すべてを &amp; キャプチャで&amp;参照として「Draw関数の内側へ引き連れて」処理できる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera.second-&gt;Draw([&amp;]()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw関数() の 外側にある変数 mapChipPath も[&amp;]効果で { } の内側で問題なくアクセスできている↓<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 0);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 70, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 4);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (camera.first == "カメラ0") //←"カメラ0"はビルド時に事前にハッシュ値が計算され、文字列ではない数値とおきかわっている<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらがカメラ0", GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (camera.first == "カメラ1")<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらはカメラ1", GetColor(0, 255, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーン0の内容を画面に描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, 0, screenHandle0, FALSE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, 0, Screen::Width, Screen::Height / 2, GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーン1の内容を画面に描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, Screen::Height / 2, screenHandle1, FALSE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, Screen::Height / 2, Screen::Width, Screen::Height, GetColor(0, 255, 0));</u><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    いかがでしょう？無事、2つのプレイヤから見える世界が映し出され、操作できましたか？<br>
    Gameクラスに任せることで、main.cppはすっきり見通しがよくなりました。<br>
    <br>
    <a id="mozTocId0006" class="mozTocH1">
      <h1>MyTimerクラスでchronoから得た時刻でゲームの描画のFPSを管理する</h1>
    </a> さて、板ポリとはいえ3Dを描画するので、描画のフレームレート[単位 FPS:Frame Per Second]を管理したいところです。<br>
    <p><code>MyTimer.hを新規作成</code>して、chrono経由で現在時刻などを計測できる機能をシングルトンとして準備しましょう。</p>
    <p class="source">#ifndef MYTIMER_H_<br>
      #define MYTIMER_H_<br>
      <br>
      <br>
      #include &lt;chrono&gt; // 精度の高い時刻を得る(C++ならWindows,Macなど色んな環境で使える)<br>
      #include &lt;thread&gt; // 処理休止sleep_forするために必要<br>
      #include &lt;string&gt; // 文字列string型に必要<br>
      #include &lt;sstream&gt; // ostringstreamに必要 標準出力(ostringstreamで文字列に標準出力を)<br>
      #include &lt;iomanip&gt; // 時間の文字列出力put_time()に必要<br>
      <br>
      #include "Singleton.h"<br>
      <br>
      // マルチプラットフォーム対応のchrono使用の時刻取り扱いクラス(C++11対応なら移植容易)<br>
      class MyTimer : public Singleton&lt;MyTimer&gt;<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;friend class Singleton&lt;MyTimer&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 最初にsystem_clockとsteady_clockの両方で現在時間を取得<br>
      &nbsp;&nbsp; &nbsp;// ★system_clockは【WindowなどOSの時刻(ユーザーが変更したら巻き戻しもありうる)】<br>
      &nbsp;&nbsp; &nbsp;// ★steady_clockは【↑OSに依存しない時刻(不可逆なので時間計測に向いている)】<br>
      &nbsp;&nbsp; &nbsp;std::chrono::system_clock::time_point systemInitTime = std::chrono::system_clock::now();<br>
      &nbsp;&nbsp; &nbsp;std::chrono::steady_clock::time_point steadyInitTime = std::chrono::steady_clock::now();<br>
      &nbsp;&nbsp; &nbsp;std::chrono::steady_clock::time_point steadyNowTime = std::chrono::steady_clock::now();<br>
      <br>
      &nbsp;&nbsp; &nbsp;std::chrono::system_clock::time_point systemTimeFromStart = UpdateSystemTimeFromStart();<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 時刻を保管する文字列【注意】UpdateSystemTimeFromStart()呼ばないうちは最新に更新されない<br>
      &nbsp;&nbsp; &nbsp;std::string timeStringSystemClock = GetTimeString("%Y年%m月%d日%H時%M分%S秒");<br>
      &nbsp;&nbsp; &nbsp;float timeScale = 1.0f;//[実験機能]main.cppで画面を描く速度と連動させてスローモーションや早送りも<br>
      &nbsp;&nbsp; &nbsp;bool isTimeScaleMode = false; //[実験機能]スローモーション、早送りモードをON OFF<br>
      <br>
      <br>
      &nbsp;&nbsp; &nbsp;// 起動時間の記録の初期化/リセット(Initし直せば再取得もできる)<br>
      &nbsp;&nbsp; &nbsp;inline void Init()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // 最初にsystem_clockとsteady_clockの両方で現在時間を取得(再取得も)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; systemInitTime = std::chrono::system_clock::now();<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; steadyInitTime = <b>std::chrono::steady_clock::now();</b><br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 現時刻をOSに左右されず求める(計算結果はsystemTimeFromStartに保管)<br>
      &nbsp;&nbsp; &nbsp;inline std::chrono::system_clock::time_point <b>UpdateSystemTimeFromStart</b>()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; steadyNowTime = <b>std::chrono::steady_clock::now(); //現時刻を得る(OSの時刻じゃない方)</b><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // <b>開始時のsteady_clock::nowとの差</b>をとって、開始時のsystem_clock::nowに足す<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // [参考] https://techblog.kayac.com/steady_clock<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; systemTimeFromStart =<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; systemInitTime + std::chrono::duration_cast&lt;std::chrono::seconds&gt;(<b>steadyNowTime - steadyInitTime</b>);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return systemTimeFromStart;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 現時刻を特定の文字列フォーマットで得る(得たものはsteadyNowTimeとtimeStringSystemClockに保管)<br>
      &nbsp;&nbsp; &nbsp;// 出力は"%c"ならフォーマットは[Mon Nov 27 10:58:32 2017]<br>
      &nbsp;&nbsp; &nbsp;// "%Y年%m月%d日%H時%M分%S秒"なら[2020年12月11日14時30分15秒](デフォルト)<br>
      &nbsp;&nbsp; &nbsp;// [フォーマット例] https://cpprefjp.github.io/reference/chrono/local_time.html<br>
      &nbsp;&nbsp; &nbsp;inline std::string&amp; GetTimeString(const char* timeStringFormat = "%Y年%m月%d日%H時%M分%S秒")<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; systemTimeFromStart = UpdateSystemTimeFromStart();//現時刻をOS時刻に左右されず得る<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // 時刻タイプ型をsystem_clockのtime_point型からtime_t型に変換する。<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::time_t timeFromStart = std::chrono::system_clock::to_time_t(systemTimeFromStart);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // ローカルタイムを得る(ローカルタイムについては以下リンク参照)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // https://programming.pc-note.net/c/time.html<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct tm localTimeFromStart;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; localtime_s(&amp;localTimeFromStart, &amp;timeFromStart);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //【ostringstream】は文字列ストリームに&lt;&lt;演算子などの方法でデータを流し込んでいく<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // https://programming-place.net/ppp/contents/cpp/library/029.html#write_to_string_stream<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::ostringstream oss;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //↓この一行で文字列ストリームに流し込み<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; oss &lt;&lt; std::put_time(&amp;localTimeFromStart, timeStringFormat) &lt;&lt; std::endl;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; timeStringSystemClock = oss.std::ostringstream::str(); //str()で文字列string化して保管<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return timeStringSystemClock; //現時刻を文字列として返す<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      <br>
      &nbsp;&nbsp; &nbsp;// Initしてから現在までの経過時間を得る(単位Tick = 100ナノ秒 = 1/10000000秒)<br>
      &nbsp;&nbsp; &nbsp;inline long GetElapsedTicks()<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 時刻を更新<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <b>UpdateSystemTimeFromStart</b>();<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // Initしてから現在までの経過時間(ナノ秒)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; auto durationFromInit = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(steadyNowTime - steadyInitTime);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // Tick数。1Tick = 100ナノ秒 = 1/10000000秒<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return (long)(durationFromInit.count() / 100);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 指定ナノ秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;inline void SleepForNanoSec(int waittime)<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 指定ナノ秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::nanoseconds(waittime));<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 指定マイクロ秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;inline void SleepForMicroSec(int waittime)<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 指定ミリ秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::microseconds(waittime));<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 指定ミリ秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;inline void SleepForMilliSec(int waittime)<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 指定ミリ秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(waittime));<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 指定 秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;inline void SleepForSec(int waittime)<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 指定 秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::seconds(waittime));<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 指定 分 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;inline void SleepForMinutes(int waittime)<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 指定 分 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::minutes(waittime));<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      protected:<br>
      &nbsp;&nbsp; &nbsp;// 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp; &nbsp;MyTimer() {};<br>
      &nbsp;&nbsp; &nbsp;//外部からのインスタンス破棄も禁止<br>
      &nbsp;&nbsp; &nbsp;virtual ~MyTimer() {};<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>main.cppを変更</code>して、MyTimerクラスでゲームの毎フレーム描画処理(GameDraw)を「スキップやウェイト待ち処理」などしてフレームレートを安定させましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Game.h"<br>
      <em>#include "MyTimer.h"</em><br>
      #include "Screen.h"<br>
      <br>
      <em>//[g_グローバル変数 と s_スタティックグローバル変数の違い] https://zenn.dev/melos/articles/1ddb67d024220f<br>
        // グローバル変数は「他のファイルからもアクセス可能な変数」になる<br>
        // staticグローバル変数は「他のファイルからはアクセスできないこのファイル限定呼び出し可能変数」になる<br>
        <br>
        // FPS 60フレームを目標にして描画に時間がかかるときに描画をスキップして1秒あたりのフレームレートを安定させる<br>
        <br>
        int g_targetFPS{ 60 }; // 目標のFPS(Frame Per Second, 1秒あたりのフレーム数)<br>
        static bool s_isEnableFrameSkip{ true }; // 高負荷時にフレームスキップするか（falseの場合は処理落ち（スロー））<br>
        double g_maxAllowSkipTime{ 0.2 }; // フレームスキップする最大間隔（秒）これ以上の間隔が空いた場合はスキップせずに処理落ちにする。<br>
        long g_intervalTicks = (long)(1.0 / g_targetFPS * 10000000); // フレーム間のTick数 1Tick = 100ナノ秒 = 1/10000000秒<br>
        int g_maxAllowSkipCount = (int)(g_targetFPS * g_maxAllowSkipTime); // フレームスキップを許す最大数<br>
        <br>
        static long s_nextFrameTicks = g_intervalTicks; // 次のフレームの目標時刻<br>
        static long s_fpsTicks{ 0 }; // FPS計測のためのTicks<br>
        static int s_skipCount{ 0 }; // 何回連続でフレームスキップしたか<br>
        static int s_fpsFrameCount{ 0 }; // FPS計測のためのフレームカウント 60回数えるごとに、要した時間からFPSを算出する<br>
        <br>
        <br>
        static float s_currentFPS; // 現在のFPS (Frame per Second)<br>
        <br>
        // ゲームを描く処理<br>
        static inline void GameDraw(Game&amp; game)<br>
        {//↑staticグローバル関数は「他のファイルからはアクセスできないこのファイル限定呼び出し可能関数」になる<br>
        &nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp; game.Draw(); // パラパラ漫画の描画処理<br>
        #ifdef DEBUG_DRAW_FPS<br>
        &nbsp;&nbsp;&nbsp; DxLib::DrawString(Screen::Width - 130, 30, (std::string("FPS:") + std::to_string(s_currentFPS)).c_str(), GetColor(255, 255, 255));<br>
        #endif<br>
        &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); // 裏で描いておいたパラパラ漫画を表面に入れ替えフリップ<br>
        &nbsp;&nbsp;&nbsp; s_skipCount = 0; // フレームスキップのカウントをリセット<br>
        }</em><br>
      <br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; <em>// [Windowsの機能]このプログラム実行の処理優先度を上げたいときに呼ぶ<br>
        &nbsp;&nbsp;&nbsp; SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; // ★垂直同期とはモニターへの描画が完了するまで処理全体を停止し、<br>
        &nbsp;&nbsp;&nbsp; // 描画処理と更新処理の間隔を双方一定となるように処理の間隔を調整すること<br>
        &nbsp;&nbsp;&nbsp; // https://qiita.com/Seiten_Minagawa/items/615312ebe5e688ffee7f<br>
        &nbsp;&nbsp;&nbsp; // 画面リフレッシュレートと目標フレームレートが等しい場合は垂直同期を有効に、等しくない場合は垂直同期を無効にする<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetWaitVSyncFlag( (DxLib::GetRefreshRate() == g_targetFPS) ? TRUE : FALSE ); //垂直同期を切るか?<br>
        &nbsp;&nbsp;&nbsp; //DxLib::SetWaitVSyncFlag(0); // 垂直同期を強制的に切りたい場合はコメントをはずす https://www.ay3s-room.com/entry/dxlib-framerate-controll</em><br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ Width×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ Width×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; <em>DxLib::SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させるか?</em><br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 独自時刻クラスの参照を得る(シングルトン型)<br>
        &nbsp;&nbsp;&nbsp; MyTimer&amp; timer = MyTimer::Instance();<br>
        &nbsp;&nbsp;&nbsp; timer.Init(); // 時刻計測開始</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; Game game;<br>
      &nbsp;&nbsp;&nbsp; game.Init(); // gameのInit準備<br>
      <em>#ifdef _DEBUG // デバッグ用にgameのinit終了までの秒数を一瞬画面に出す(初期化ロード時間計測のため)<br>
        &nbsp;&nbsp;&nbsp; long initTime = timer.GetElapsedTicks(); // デバッグ用にInitの経過時間を取得<br>
        &nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, std::to_string(initTime / 10000000.0).c_str(), GetColor(255, 255, 255));<br>
        #endif</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <em>timer.Init(); // 時刻計測開始時間リセット(game.Initにかかった時間は計測時間に含めないため)</em><br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      <em>#ifdef DEBUG_DRAW_FPS // ←#defineされていたら FPSを画面右上に描画する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // FPSの計測(FPS = 1秒あたりのパラパラ漫画枚数)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++s_fpsFrameCount; // フレーム数のカウントを +1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s_fpsFrameCount &gt;= 60) // 60フレームを超えたら<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 経過時間 1Tick = 100ナノ秒 = 1/10000000秒 (elasped=経過)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long elapsedTicks = timer.GetElapsedTicks() - s_fpsTicks;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float elapsedSec = (float)elapsedTicks / 10000000; // 単位を秒(s:Second)に変換<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_currentFPS = s_fpsFrameCount / elapsedSec;// 現在のFPS<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_fpsFrameCount = 0; // 60枚数えたら0リセット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 60枚数えたら現在のFPS(パラパラ速度)を記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_fpsTicks = timer.GetElapsedTicks();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        #endif</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; game.Update(); //ゲームの更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>game.Draw(); // パラパラ漫画の描画処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>//[実験機能]スローモーション、早送り(time.timeScaleが 2で2倍速 0.5で1/2スロー)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (timer.isTimeScaleMode &amp;&amp; timer.timeScale &gt; 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // フレームレートを再計算し早送りやスローモーション<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_targetFPS = (int)(60 * timer.timeScale); // 目標のFPS(Frame Per Second, 1秒あたりのフレーム数)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_maxAllowSkipTime = 0.2; // フレームスキップする最大間隔（秒）。これ以上の間隔が空いた場合はスキップせずに処理落ちにする。<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_intervalTicks = (long)(1.0 / g_targetFPS * 10000000); // フレーム間のTick数。1Tick = 100ナノ秒 = 1/10000000秒<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_maxAllowSkipCount = (int)(g_targetFPS * g_maxAllowSkipTime);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★垂直同期がDX設定で効いているならDXライブラリにWait処理を任せられる(フレームスキップだけ自分でやる)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (DxLib::GetWaitVSyncFlag() == TRUE &amp;&amp; timer.isTimeScaleMode == false)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ★フレームスキップとは描画処理が重い時にパラパラ漫画を1枚飛ばすか?<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s_isEnableFrameSkip)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ★余った時刻 = 次のパラパラ予定時刻 - 現在の時刻<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long waitTicks = s_nextFrameTicks - timer.GetElapsedTicks();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (waitTicks &lt; 0) // 目標時刻をオーバーしている<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★あまりにも漫画のパラパラページ数を飛ばすとキャラがワープして見えるので限度をつけてる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s_skipCount &lt; g_maxAllowSkipCount) // 連続フレームスキップ数が最大スキップ数を超えていなければ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++s_skipCount; // フレームスキップした数を +1（描画処理を飛ばした数）<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 最大スキップ数を超えてるので、フレームスキップしないで描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_nextFrameTicks = timer.GetElapsedTicks();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GameDraw(game); // ★限度越えでスロー描画処理に切替え<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 目標時刻OKなのでフレームスキップしないで描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★DXライブラリが自動で液晶の60Hzとタイミング合わせて描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GameDraw(game); // 描画処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次のパラパラ予定時刻はIntervalTicks(単位:100ナノ秒)あと<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_nextFrameTicks += g_intervalTicks;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ここのelseは何があってもフレームスキップしない設定の時に来る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GameDraw(game); // ★スロー描画処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ★垂直同期がDX設定で【効いてない】ならWait処理を自力でやる(フレームスキップも自分でやる)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↓こちらはフレームスキップ処理(waitTicks = 次のパラパラ予定時刻 - 現在の時刻)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long waitTicks = s_nextFrameTicks - timer.GetElapsedTicks(); // 余った時間（待機が必要な時間）<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s_isEnableFrameSkip &amp;&amp; waitTicks &lt; 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // あまりにも漫画のパラパラページ数を飛ばしすぎるとキャラがワープして見えるので限度をつけてる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s_skipCount &lt; g_maxAllowSkipCount)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++s_skipCount; // フレームスキップ（描画処理を飛ばす）<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // スキップ数の許容限度をオーバーしたら、FPSを落としてでもスローで無理してでも描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 次のパラパラ予定時刻を現時刻に設定するので次も絶対遅れてwaitTicks &lt; 0になる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_nextFrameTicks = timer.GetElapsedTicks();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GameDraw(game); //遅れつつもスローモーションで描いてゆく設定の時はここ(当然Updateも遅れていく)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ★自力でWait処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (waitTicks &gt; 20000) // あと2ミリ秒以上待つ必要がある<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ★自作TimeクラスのSleepで一定時間プログラム休止<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://marycore.jp/prog/objective-c/sleep-process/#sleep_for<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Sleepは指定した時間でピッタリ戻ってくるわけではないので、<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 余裕を持って、「待たなければならない時間-2ミリ秒」Sleepする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int waitMillsec = (int)(waitTicks / 10000) - 2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timer.SleepForMilliSec(waitMillsec);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 時間が来るまで何もしないループを回して待機する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (timer.GetElapsedTicks() &lt; s_nextFrameTicks)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 所定の時間になるまで空ループ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GameDraw(game); // 所定の時間になったら描画処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次のパラパラ予定時刻はIntervalTicks(単位:100ナノ秒)あと<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_nextFrameTicks += g_intervalTicks;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    いかがでしょう？フレームレートを安定させる処理をいれました。<br>
    といわれても実感があまり湧きませんね。<br>
    では、画面にFPSを表示させてみましょう。<br>
    <p><code>main.cppを変更</code>して、#define DEBUG_DRAW_FPSで FPSを画面右上に表示させるマクロを発動させましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Game.h"<br>
      #include "MyTimer.h"<br>
      #include "Screen.h"<br>
      <br>
      <br>
      <em>#define DEBUG_DRAW_FPS // ここをコメントアウトすると画面にFPSを文字で表示しない</em><br>
      <br>
      <br>
      //[g_グローバル変数 と s_スタティックグローバル変数の違い] https://zenn.dev/melos/articles/1ddb67d024220f<br>
      // グローバル変数は「他のファイルからもアクセス可能な変数」になる<br>
      // staticグローバル変数は「他のファイルからはアクセスできないこのファイル限定呼び出し可能変数」になる<br>
      <br>
      // FPS 60フレームを目標にして描画に時間がかかるときに描画をスキップして1秒あたりのフレームレートを安定させる<br>
      <br>
      int g_targetFPS{ 60 }; // 目標のFPS(Frame Per Second, 1秒あたりのフレーム数)<br>
      static bool s_isEnableFrameSkip{ true }; // 高負荷時にフレームスキップするか（falseの場合は処理落ち（スロー））<br>
      double g_maxAllowSkipTime{ 0.2 }; // フレームスキップする最大間隔（秒）これ以上の間隔が空いた場合はスキップせずに処理落ちにする。<br>
      long g_intervalTicks = (long)(1.0 / g_targetFPS * 10000000); // フレーム間のTick数 1Tick = 100ナノ秒 = 1/10000000秒<br>
      int g_maxAllowSkipCount = (int)(g_targetFPS * g_maxAllowSkipTime); // フレームスキップを許す最大数<br>
      <br>
      (中略)..........................<br>
      <br>
      // ゲームを描く処理<br>
      static inline void GameDraw(Game&amp; game)<br>
      {//↑staticグローバル関数は「他のファイルからはアクセスできないこのファイル限定呼び出し可能関数」になる<br>
      &nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp; game.Draw(); // パラパラ漫画の描画処理<br>
      #ifdef <b>DEBUG_DRAW_FPS</b><em> // game.Drawを描いたあとに上のレイヤにぬりつぶす形でFPSを文字で画面右上に表示</em><br>
      &nbsp;&nbsp;&nbsp; DxLib::<b>DrawString</b>(Screen::Width - 130, 30, (std::string("FPS:") + std::to_string(<b>s_currentFPS</b>)).c_str(), GetColor(255, 255, 255));<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたパラパラ漫画を表面に入れ替えフリップ<br>
      &nbsp;&nbsp;&nbsp; s_skipCount = 0; // フレームスキップのカウントをリセット<br>
      }<br>
      <br>
      <br>
      (以下略).....<br>
    </p>
    <br>
    いかがでしょう？game.Draw()の「あとにFPSを描画」しているので、<br>
    ゲーム本体の描画のレイヤの上を、必ず塗りつぶして画面右上に現在のFPSを表示させることができます。<br>
    今は快適なFPSで描画できていますが、今後、ゲームの描画を複雑化させたときにFPSの状況をモニタリングする必要もでてくるかもしれません。<br>
    留意しなければいけないのが、Drawはスキップしていますが、Updateはスキップしていないということです。<br>
    今後、Update文にAIの経路の探索など重い処理を入れた場合はFPSは当然落ちます。<br>
    そのため、Unityなどでは <b>Update文(毎フレーム) と FixedUpdate文(固定フレームレート毎)</b> を分けているわけですね。<br>
    とりあえずこのゲームでは初心者にもとっつきやすい「固定フレームレート」前提の仕組みで制作していきます。<br>
    つまり、このゲームにおける Update文 = FixedUpdate文 の意味に読み替えて理解しておいたほうがいいです。<br>
    <br>
    <br>
    <a id="mozTocId0007" class="mozTocH1">
      <h1>共通のベース基底となるGameObjectを定義して、プレイヤなどはそれを継承する形を設計する</h1>
    </a>
    <p><code>前提としてクラスQuaternionを別記事から作成しておきます</code>←<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/polygon3d/index.html#mozTocId0015">クオータニオンで安定して回転できるようにする</a><br>
    </p>
    <br>
    さて、次はゲームエンジンの基礎となる共通のベース基底となるGameObjectクラスを設計していきましょう。<br>
    UnityではGameObjectという名前ですし、Unreal EngineではActor(アクター)と呼ばれる概念です。<br>
    名前は好みの問題ですのでGameObjectという名前にしましょう。<br>
    さて、GameObjectの使われ方を考えておきましょう。<br>
    重大なのは、<b>シーンの配下にあり「シーンと道ずれに消えてリセットされるべき」</b>という要件です。<br>
    これは、<b>最初から共有ポインタとしてstd::make_sharedされる前提で設計すべき</b>、ということです。<br>
    そして、共有ポインタ前提で設計する際に厄介なのは GameObjectクラス内部の関数で this を使いたいときです。<br>
    <b>this も「自分自身を指すポインタ」である</b>以上、その<b>thisポインタが共有されたときにも、カウント +1 しなければ、つじつまが崩れてしまいます</b>。<br>
    <b>ただの this では共有カウンタは +1 されない</b>ので、代わりに <a href="https://cpprefjp.github.io/reference/memory/enable_shared_from_this/shared_from_this.html">shared_from_this</a> を使って<b>「共有カウントを +1 したthis」を使う必要</b>があります。<br>
    shared_from_this を使う資格は「<a href="https://cpprefjp.github.io/reference/memory/enable_shared_from_this.html">std::enable_shared_from_this</a> を継承したクラスに与えられる」ので<b>GameObjectはstd::enable_shared_from_this を継承したクラスでないといけません</b>。<br>
    そして、さらなる<b>「重大なる厄介さ」</b>が待ち構えています。<br>
    <br>
    <b>「shared_from_thisは初期化コンストラクタで呼んではならない」という制約</b>です。<br>
    <br>
    この「厄介な制約」により、<b>事実上「shared_from_thisを使いたいような処理は初期化コンストラクタではできない」</b>ことを回避せねばならなくなってしまいました。<br>
    ゆえに、<b>代わりにInit()関数とか、UnityでいうStart()やAwake()関数のようなものを初期化の代替としてコンストラクタの後追いで一緒に呼ぶ、という回避策が必要</b>になります。<br>
    逆にいうと、<b>GameObjectを継承するクラスは「使う側が自由にnew GameObject(～)やstd::make_sharedできてはいけない」設計が必要</b>となってきます。<br>
    まあ、どのみちUnityでもシーンにGameObjectを生成するときにはInstatiate()関数を経由して生成していますよね。<br>
    直接生成を封じるためには<b>「クラスの初期化コンストラクタをprotected:にして外部から直接コンストラクタ経由の初期化生成するのを封じる」対策が必要</b>です。<br>
    上記までの事情を分かっているプログラマなら初期化コンストラクタとInit()関数をセットで呼んで初期生成するでしょうが、<br>
    事情を知らないプログラマは普通に初期化コンストラクタ経由で初期生成をしようとするでしょう。それをprotected:で邪魔するのです。<br>
    代わりに<b>コンストラクタのコメントに// Create関数経由で初期生成してください とただし書きをしておけば「空気読んでくれ」</b>は伝わります。<br>
    関数の名前はMake()関数でもいいし、Create()関数でもいいですが、わりとwebに出てくる動画などではcreate()関数にしていることが多い感はありますね。<br>
    なのでcreate()関数などが共有ポインタを返すような文脈で出てきているwebの動画などは「暗に上記事情の設計」をしている雰囲気がかもし出されている、と感じるべきです。<br>
    <br>
    さてと、上記事情をGameObjectが 直接std::enable_shared_from_thisを継承する 形でも設計はできるのですが、<br>
    今後<b>「GameObjectじゃないものも上記事情をかかえる場合もありそう」</b>だと予測できますよね。<br>
    ですので、さらに「ベース基底となるObjectクラス(std::enable_shared_from_thisを継承)」を間に入れるほうがよさそうです。<br>
    GameObjectは上記のObjectクラスを継承して「間接的にstd::enable_shared_from_thisを孫として継承」する形にします。<br>
    ついでにObjectクラスにはUnityにもあるように<br>
    「通し番号インスタンスIDを初期化と同時にカウントアップして保持して == で同じインスタンスIDか判定」<br>
    「タグを振ってFindWithTagで辞書からタグでオブジェクトを検索できる機能」<br>
    なども組み入れてしまいましょう。<br>
    <br>
    <p><code>Object.hを新規作成</code>して、継承するとshared_from_this_asでき、<br>
      Create関数経由で初期化とInitをセットでできて、インスタンスIDやタグを振って検索できるベース基底クラスを準備しましょう。</p>
    <p class="source">#ifndef OBJECT_H_<br>
      #define OBJECT_H_<br>
      <br>
      #include &lt;memory&gt; // 共有ポインタを使う<br>
      #include &lt;unordered_map&gt;<br>
      #include "MyHash.h" // hash32でタグ→オブジェクトを辞書検索できるようにする<br>
      <br>
      <br>
      // <b>Objectクラスのコンストラクタでは shared_from_this を使えない</b>から<br>
      // <b>Initをoverride継承</b>して<b> Initの中で shared_from_thisを必要</b>とする<b>初期化する際に渡すパラメタ</b>を<br>
      // このベース基底クラスを継承して定義する<br>
      struct <b>InitParams</b><br>
      {<br>
      &nbsp;&nbsp;&nbsp; InitParams() = default;<br>
      <br>
      &nbsp;&nbsp;&nbsp; <b>// このクラスを継承したクラスで、初期化に必要なパラメタを渡す(初期化に必要なパラメタはそれぞれ違うので)</b><br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual ~InitParams() {}<br>
      };<br>
      <br>
      <br>
      // GameObjectなどをこの Object型を継承して新規生成することで シリアルIDを自動で振り、shared_from_this_as&lt;Player&gt;()などで 共有状態のthisを得られるようにする<br>
      class Object <b>: public std::enable_shared_from_this</b>&lt;Object&gt;<br>
      {&nbsp;&nbsp;&nbsp; // [std::shared_ptrでthisポインタをつかうためには]↑ https://www.kabuku.co.jp/developers/cpp_enable_shared_from_this<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 通し番号(シリアルID)をstaticで管理してインスタンスが生成されるたびにシリアル番号を++して返す<br>
      &nbsp;&nbsp;&nbsp; static unsigned int <b>newID</b>() { <b>static unsigned int _serialID_ = 0;</b> return _serialID_<b>++</b>; }<br>
      protected: // protected:にしてクラス外からの直接のアクセスを阻む<br>
      &nbsp;&nbsp;&nbsp; const unsigned int m_InstanceID; // オブジェクトのインスタンスID (0 ～ 約42億までの番号)<br>
      &nbsp;&nbsp;&nbsp; hash32 m_Tag{ "" }; // オブジェクトに振ったタグ デフォルトの空文字""の場合は検索可能な辞書に登録しない<br>
      <br>
      &nbsp;&nbsp;&nbsp; // <b>コンストラクタはprotected:にしてある</b>ので <b>Create関数経由で初期化</b>してください<br>
      &nbsp;&nbsp;&nbsp; Object() : m_InstanceID{ Object::<b>newID</b>() } {&nbsp; };<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; unsigned int InstanceID() { return m_InstanceID; };<br>
      &nbsp;&nbsp;&nbsp; inline hash32 Tag() const { return m_Tag; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ (辞書にタグが登録されていたら、そのタグを辞書からも消しておく)<br>
      &nbsp;&nbsp;&nbsp; virtual ~Object() { if (m_Tag != "") umTagObjects().erase(m_Tag); };<br>
      <br>
      &nbsp;&nbsp;&nbsp; //[protectedなコンストラクタでもstd::make_sharedで呼ぶテク] https://gintenlabo.hatenablog.com/entry/20131211/1386771626<br>
      &nbsp;&nbsp;&nbsp; template&lt;typename ObjectT&gt;<br>
      &nbsp;&nbsp;&nbsp; struct ProtectedCall : public ObjectT<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // <b>ダミーとなる ProtectedCallクラスが public:だからそれを経由して間接的にコンストラクタがprotected:なクラスでもmake_sharedを呼ぶ</b>テク<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class... ArgsT&gt; // std::make_sharedはprotectedな継承クラスは呼べないのでそれを回避するテクニック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; explicit ProtectedCall(ArgsT&amp;&amp;... args)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : ObjectT(std::forward&lt;ArgsT&gt;(args)...) { } //std::forwardで複数引数を完全転送で引き渡し https://proc-cpuinfo.fixstars.com/2016/03/c-html/<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // <b>コンストラクタでは shared_from_this を使えないから、Initをoverride継承</b>して Initの中で <b>shared_from_thisを必要とする初期化</b>をする<br>
      &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;<b>InitParams</b>&gt; initParams = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>// overrideして shared_from_this_as が必要な パラメータの初期化を行ってください</b><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // <b>Objectを継承した型はこの create関数を経由して新規生成</b>する<br>
      &nbsp;&nbsp;&nbsp; template &lt;typename DerivedT, typename OutTypeT = DerivedT, <b>typename ...ArgsT</b>&gt;<br>
      &nbsp;&nbsp;&nbsp; static auto <b>Create</b>(std::shared_ptr&lt;InitParams&gt; initParams, ArgsT&amp;&amp;...args)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pObject = std::static_pointer_cast&lt;OutTypeT&gt;(<b>std::make_shared</b>&lt;ProtectedCall&lt;DerivedT&gt;&gt;(std::forward&lt;ArgsT&gt;(args)...));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pObject-&gt;<b>Init(initParams)</b>; // <b>コンストラクタでは shared_from_this_as できないものをmake_sharedが終わったタイミングで一緒に初期化</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pObject;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // <b>shared_from_this() を DerivedT型にキャストして返す</b> [参考] https://qiita.com/terukazu/items/e4129105b12442e42651<br>
      &nbsp;&nbsp;&nbsp; template &lt;typename DerivedT&gt;<br>
      &nbsp;&nbsp;&nbsp; auto <b>shared_from_this_as()</b> noexcept {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::dynamic_pointer_cast&lt;DerivedT&gt;(<b>Object::shared_from_this()</b>);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // &lt;振ったタグ, オブジェクトへの弱共有リンク&gt; の辞書を関数内staticで保持して検索できるようにしてある<br>
      &nbsp;&nbsp;&nbsp; static inline std::unordered_map&lt;hash32, std::weak_ptr&lt;Object&gt;&gt;&amp; umTagObjects()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 関数内staticで タグから オブジェクトへの弱共有ポインタを保持<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static std::unordered_map&lt;hash32, std::weak_ptr&lt;Object&gt;&gt; _umTagObjects_;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _umTagObjects_;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // オブジェクトにタグを振って検索できるようにしておく (空文字 "" のタグが指定されたら辞書から消す)<br>
      &nbsp;&nbsp;&nbsp; template &lt;typename DerivedT&gt;<br>
      &nbsp;&nbsp;&nbsp; inline auto SetTag(const std::string&amp; tag)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_Tag != "" &amp;&amp; tag == "") // 空文字 "" のタグが指定されたら辞書から消す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umTagObjects().erase(m_Tag); // 既存のタグが辞書に登録されてたら辞書から消す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Tag = ""; // タグを空文字へリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return shared_from_this_as&lt;DerivedT&gt;(); // メソッドチェーンで-&gt;で連鎖アクセスできるように thisを返す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Tag = tag; // タグを設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umTagObjects().emplace(m_Tag, shared_from_this_as&lt;DerivedT&gt;()); // タグと弱共有リンクをペアで辞書に登録<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return shared_from_this_as&lt;DerivedT&gt;(); // メソッドチェーンで-&gt;で連鎖アクセスできるように thisを返す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // オブジェクトに振っておいたタグで検索する<br>
      &nbsp;&nbsp;&nbsp; template &lt;typename DerivedT&gt;<br>
      &nbsp;&nbsp;&nbsp; static std::weak_ptr&lt;DerivedT&gt; FindWithTag(const std::string&amp; tag)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto found = umTagObjects().find(tag); // 辞書からtagと一致するものを見つける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (found == end(umTagObjects())) // 結果がendのときは見つからなかった<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::weak_ptr&lt;DerivedT&gt;(); // 空の弱共有ポインタを返す(空の弱共有ポインタはlock()してもnullptrになる)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (found-&gt;second.lock() == nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 辞書には found が見つかったが lock()したら nullptr のときはすでにリンク先本体が消されているから辞書からもeraseで消す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umTagObjects().erase(tag);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::weak_ptr&lt;DerivedT&gt;(); // 空の弱ポインタを返す(lock()してもnullptrになる)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::dynamic_pointer_cast&lt;DerivedT&gt;(found); // DerivedT型(継承先の型タイプ)に変換してreturn する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 比較演算子 == ではインスタンスIDを比較する<br>
      &nbsp;&nbsp;&nbsp; inline bool operator == (const Object&amp; other) const { return this-&gt;m_InstanceID == other.m_InstanceID; }<br>
      &nbsp;&nbsp;&nbsp; // 不一致演算子 != ではインスタンスIDを比較する<br>
      &nbsp;&nbsp;&nbsp; inline bool operator != (const Object&amp; other) const { return !(*this == other); }<br>
      };<br>
      <br>
      <br>
      #endif<br>
    </p>
    <br>
    template &lt;typename DerivedT&gt;などテンプレートでかなり読みづらいとは思いますが、<br>
    ようはCreate関数の中でstd::make_sharedで初期化して、それとセットでInit関数も呼び出しているということです。<br>
    初期化コンストラクタでは例えば、World* worldやVector3 positionなど色々初期化で渡したい引数があるしクラスごとに引数の数も増えるとおもいますが、<br>
    Create関数のテンプレートの <b>typename ...ArgsT</b>←これのおかげで魔法のように<b>引数が</b>ワールドやポジション以外に<b>何個増えても</b>、<br>
    Create( world, position, ～その他いろんな引数が増えても...) のように呼び出しかたがテンプレで拡張可能になっています。<br>
    <br>
    あとはこのObjectクラスを継承すれば、GameObjectは<b>shared_from_this_as&lt;Player&gt;()</b>などで 「共有カウンタを+1できるthis」 を使える準備が整います。<br>
    <br>
    <p><code>GameObject.hを新規作成</code>して、PlayerやZakoなどの基底ベースとなるクラスを準備しましょう。</p>
    <p class="source">#ifndef GAMEOBJECT_H_<br>
      #define GAMEOBJECT_H_<br>
      <br>
      #include &lt;memory&gt; // 共有ポインタの定義のため<br>
      <br>
      #include "Vector3.h"<br>
      #include "Quaternion.h"<br>
      <br>
      #include "Object.h" // インスタンスIDや検索タグを持ち、shared_from_this_as&lt;継承先クラス名&gt;などができる<br>
      <br>
      class World; // 前方宣言<br>
      <br>
      // ゲーム上に表示される物体の基底クラス。<br>
      // プレイヤーや敵、アイテムなどはこのクラスを継承して作る。<br>
      class GameObject : public Object<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるのでCreate関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; GameObject(World* world = nullptr, Vector3 position = { 0,0,0 }, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Object(), m_world{ world }, position{ position }, rotation{ rotation }, velocity{ velocity }, force{ force }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~GameObject() {}<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★下記3つはメモリ上で共用状態になる(position、x,y,z、xyzどの名前から数値を変えたり読出してもメモリ上は同じ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 同じデータに3種類の名前を付けたイメージ、しかもVector3の機能や配列としてのアクセスの仕方もできて便利<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // XYZ座標&nbsp; [匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 position; // XYZ座標<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp;&nbsp; }; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
      <br>
      &nbsp;&nbsp;&nbsp; Quaternion rotation; // 回転クオータニオン<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vx, vy, vz; }; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 velocity; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyz;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vxForce, vyForce, vzForce; }; // XYZ方向にかかる力(Unityでいうと AddForce関数 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 force; // XYZ方向の力(物理的には加速度:1フレームごとにvelocityの増える=加速する量)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyzForce;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; World* m_world; // GameObjectが配置されたワールドへのリンク<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; virtual World* world() { return m_world; }<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
      &nbsp;&nbsp;&nbsp; virtual void world(World* changeWorld) { m_world = changeWorld; }<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; bool isDead{ false }; // 死んだ（削除対象）フラグ<br>
      &nbsp;&nbsp;&nbsp; bool isStatic{ false }; // 動かない(静的オブジェクトか?)<br>
      &nbsp;&nbsp;&nbsp; bool isGround{ false }; // 地面についているか<br>
      &nbsp;&nbsp;&nbsp; bool isFlying{ false }; // 空をとんでいるか<br>
      <br>
      &nbsp;&nbsp;&nbsp; hash32 typeTag{ "" }; // 小カテゴリ Zako0など個別のタイプ<br>
      &nbsp;&nbsp;&nbsp; hash32 baseTag{ "" }; // 大カテゴリ Enemyなど大まかなベースジャンル<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() = 0; // 純粋仮想関数 = 0 にすると【絶対 Update()関数はoverrideしなきゃいけない義務を付与できる 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() = 0; // 純粋仮想関数 = 0 にすると【絶対 Draw()関数はoverrideしなきゃいけない義務を継承先クラスに付与 】<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    とりあえずは位置positionなどは「親子構造をもたない形」で定義しました。<br>
    親子構造を持つtransformなどを考え出すと、xを一つ変えるだけでもそのxの変化を子供に伝搬させる必要が出てきたりして、<br>
    x = x + 1; したあとにいちいち UpdateChildX() などしないと子供に伝搬されず、忘れると「なぜだー状態」になり、<br>
    非常に頭が混乱して、初心者にはとっつきにくいプログラミングになってしまうので、シンプル化して他に注力するため今回は導入を見送ります。<br>
    <br>
    <p><code>Player.hを変更</code>して、GameObjectを継承しましょう。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Resource.h"<br>
      #include "GameObject.h"<br>
      <u>#include "MyHash.h" // hash32型でプレイヤが現在いるワールドのタグを管理する<br>
        #include "Vector3.h"</u><br>
      <br>
      class World; // 前方宣言<br>
      class Camera; // 前方宣言<br>
      <br>
      class Player<em> : public GameObject</em><br>
      {<br>
      <em>protected:</em><br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<em>はprotected:にしてあるので、Create関数経由で初期生成してください</em><br>
      &nbsp;&nbsp;&nbsp; Player(World* world, Pad pad, Vector3 position<em>, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 }</em>)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pad{ pad }, <em>GameObject(world, position, rotation, velocity, force)</em> <u>m_world{ world }, position{ position }, velocity{ 0,0,0 }, force{0,0,0}</u><br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;<em>typeTag</em> = "Player";<em> // タグは個別の"プレイヤ1"などに使い、タイプはtypeTagで判別する形にしてタイプのジャンルを区別</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <em>public:</em><br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~Player() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★下記3つはメモリ上で共用状態になる(position、x,y,z、xyzどの名前から数値を変えたり読出してもメモリ上は同じ)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 同じデータに3種類の名前を付けたイメージ、しかもVector3の機能や配列としてのアクセスの仕方もできて便利<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // XYZ座標&nbsp; [匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 position; // XYZ座標<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
        &nbsp;&nbsp;&nbsp; };// unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
        <br>
        &nbsp;&nbsp;&nbsp; union {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vx, vy, vz; }; // XYZ方向の速度<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 velocity; // XYZ方向の速度<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyz;<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; union {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vxForce, vyForce, vzForce; }; // XYZ方向にかかる力(Unityでいうと AddForce関数 )<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 force; // XYZ方向の力(物理的には加速度:1フレームごとにvelocityの増える=加速する量)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyzForce;<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; hash32 tag{ "" }; // プレイヤにつけるタグ<br>
        protected:<br>
        &nbsp;&nbsp;&nbsp; World* m_world; // 配置されたワールドへのリンク<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
        &nbsp;&nbsp;&nbsp; virtual World* world() { return m_world; }<br>
        &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
        &nbsp;&nbsp;&nbsp; virtual void world(World* changeWorld) { m_world = changeWorld; }</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; Pad pad; // 操作するコントローラー番号<br>
      &nbsp;&nbsp;&nbsp; hash32 worldTag{ "" }; // 現在いるワールドのタグ<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeedMax = 6; // 移動速度Max値<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeed = 0;//移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; float moveAngle = 0; // X軸→方向から何度か<br>
      &nbsp;&nbsp;&nbsp; float deltaAngle = 0; // プレイヤの動く角度の変化率、ハンドルを切ったらだんだんもとに戻る<br>
      &nbsp;&nbsp;&nbsp; int animCount = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image; // プレイヤの板ポリゴンで描くタイル分割画像への共有リンク<br>
      <br>
      &nbsp;&nbsp;&nbsp; Camera* camera{ nullptr }; // プレイヤを追随するカメラ<br>
      &nbsp;&nbsp;&nbsp; void SetCamera(Camera* pCamera) { camera = pCamera; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理<br>
      &nbsp;&nbsp;&nbsp; virtual void HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update()<em> override</em>;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw()<em> override</em>;<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>Player.cppを変更</code>して、GameObjectを継承する記述にしましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      void Player::HandleInput()<br>
      {<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_LEFT) <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_A)) )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = - MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += 1; //ハンドルを左に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_RIGHT)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_D)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle -= 1; //ハンドルを右に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_UP)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_W)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = - MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += 0.6f; //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; MoveSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = MoveSpeedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(pad, PAD_INPUT_DOWN)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_S)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed -= 0.6f; //ブレーキを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.9f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = -0.9f;//ちょっとだけバックできるように<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pad == Pad::Key || pad == Pad::One) // コントローラ1またはキーボード操作のプレイヤのときだけ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGUP)) // キーボードのPageUp ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = 2.0f; // テスト用に空中の上方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGDN)) // キーボードのPageDown ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -2.0f; // テスト用に空中の下方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>rotation.SetRotation(VGet(0, (180 - moveAngle) * MyMath::Deg2Rad, 0)); // 前向きの3Dモデルなら180度回転させて奥方向の向きに設定</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp; x += vx;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp; y += vy;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp; z += vz;<br>
      <br>
      &nbsp;&nbsp;&nbsp; vy += vyForce; // 勢い(力・フォースを加算<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; // moveAngleは2D画像のX方向右を0度とするから、-90度回すと画像を正面に捉える位置にカメラを置ける<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int animIndex = animCount / 20; // キャラのパラパラアニメの画像番号(最大3)<br>
      &nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp; if (abs_vx &gt; 1.00f || abs_vz &gt; 1.00f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6; // キャラが地面のXとZ方向に少しでもスピードがあったらアニメを走らせる<br>
      &nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // プレイヤのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 9; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // カメラ向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 奥向きの画像<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *image, imgIndex + animIndex, TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    <br>
    <p><code>GameScene.cppを変更</code>して、ObjectのCreate関数を呼び出す形でPlayerを新規生成する記述にしましょう。</p>
    <p class="source">#include "GameScene.h"<br>
      <br>
      #include "Player.h"<br>
      <br>
      (中略).................<br>
      <br>
      <br>
      void GameScene::Initialize()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; (中略).................<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの生成<br>
      &nbsp;&nbsp;&nbsp; if (pWorld != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pWorld-&gt;AddCamera("カメラ1", Camera::defaultCamera); // プレイヤ1というタグをカメラにつけてワールドにカメラを配置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ1", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera1 = pWorld-&gt;camera("カメラ1"); // カメラ1 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera1-&gt;SetScreenHandle(screenHandle0); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer1 = <em>Object::Create&lt;Player&gt;(nullptr, </em>pWorld, Pad::Key, Vector3(90 + 256, 32, 95 + 256));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ1", pPlayer1); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath1]);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;camera = pCamera1.get(); // カメラをプレイヤにリンクする<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ2", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera2 = pWorld-&gt;camera("カメラ2"); // カメラ2 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera2-&gt;SetScreenHandle(screenHandle1); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer2 = <em>Object::Create&lt;Player&gt;(nullptr, </em>pWorld, Pad::Two, Vector3(190, 32, 195));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ2", pPlayer2); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath2]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;camera = pCamera2.get(); // カメラをプレイヤにリンクする<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      <br>
      (以下、略)......<br>
    </p>
    <br>
    いかがでしょう？カメラも今後必要あらば、ObjectやGameObjectを継承させることもできなくはありません。<br>
    現状は、shared_from_this_as&lt;Player&gt;を使ってInitで初期化しなきゃいけないようなものはありません。<br>
    次は、上記のshared_from_this_asを使ったInit初期化処理が必要になるような「コンポーネントの仕組み」を導入してみましょう。<br>
    <br>
    <a id="mozTocId0008" class="mozTocH1">
      <h1>Componentクラスを継承して、プレイヤなどに付け離し再利用可能なコンポーネント指向の機能を設計する</h1>
    </a> Unityなどのゲームエンジンの便利さを担保している仕組みとして「コンポーネント」があります。<br>
    ベースとなるGameObjectに[AddComponentボタン]を押して機能を付けたり外したりできる仕組みです。<br>
    では、そもそもコンポーネントとは何なのかを考えてみる必要がありそうです。<br>
    コンポーネントはいろいろな機能を持ちますが、それらはしょせんは継承した先の追加の機能にすぎません。<br>
    ですからコンポーネントそのものとは何なのか？ということに対する1つの重要な答えは、<br>
    <br>
    <b>「そのコンポーネントの所有者(オーナー)のパラメータにアクセスでき、オーナーに付着することができる」</b><br>
    <br>
    ゲームでいうところの装備みたいなイメージでしょうか？<br>
    装備すると、装備したオーナーのHPを毎ターン回復、するとするなら、オーナーのHPのパラメータにアクセスして、書き換えられなきゃいけません。<br>
    つまり、コンポーネントは<b>初期化するときに「所有者オーナーの this ポインタを受け取り、そのthis経由でオーナーのパラメタを書き換える」</b><br>
    ことができれば、装備主にいろいろな影響を与えることができるわけです。<br>
    すなわち<b>「コンストラクタでオーナーのthisを受け取り、オーナーに所有:共有ポインタで所持され、オーナーと道連れにリセットされる」</b>という<br>
    shared_from_this_as と std::shared_ptrの組み合わせが、コンポーネントの設計の根幹であることが導かれます。<br>
    <br>
    では、下記のシンプル化したComponentの仕組みを見てみましょう。<br>
    <p class="source">Componentの例<br>
      struct Component<br>
      {<br>
      &nbsp;&nbsp; GameObject* m_owner{ nullptr }; // オーナーのパラメータへアクセスするためのポインタ<br>
      &nbsp;&nbsp; Component(GameObject* owner) : m_owner{ owner } {}<br>
      <br>
      &nbsp;&nbsp; void Update()<br>
      &nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owner-&gt;x += 1; // ポインタ経由でオーナーの位置を+1ずつずらす<br>
      &nbsp;&nbsp; }<br>
      } </p>
    そうです。コンストラクタの初期化のときに宿主である所有者オーナーのポインタ ownerさえ受け取ってリンクを取っておけば、<br>
    毎回のUpdate()ごとに宿主オーナーのパラメタの x を +1 するなり、毒で宿主のHPを減らし続けるなり、<br>
    オーナーのパラメタに影響を及ぼすことができます。<br>
    <br>
    オーナー側は下記のようになります。<br>
    <p class="source">Playerの例<br>
      struct Player<br>
      {<br>
      &nbsp;&nbsp; <b>std::shared_ptr&lt;Component&gt;</b> m_component{ nullptr }; // コンポーネントへの共有カウンタ +1をキープして消えないように所持する<br>
      &nbsp;&nbsp; Player() : m_component{ this } {}<br>
      <br>
      &nbsp;&nbsp; void Update()<br>
      &nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_component-&gt;Update(); // コンポーネントのUpdate経由でオーナーの位置を+1ずつずらす<br>
      &nbsp;&nbsp; }<br>
      } </p>
    所有者のオーナー側はコンポーネントへの共有ポインタに最低限 +1 のカウンタをキープし続けることでコンポーネントが消えないようにキープします。<br>
    そして、Playerクラス側のUpdate関数内でm_component-&gt;Update(); のように所有するコンポーネントのUpdateを経由して自分のx位置のパラメタを変化させます。<br>
    これが一番シンプルな形のコンポーネントの仕組みです。<br>
    <br>
    ただし、コンポーネント側のポインタは生ポインタの this ではなく共有ポインタのほうがよいでしょう。<br>
    一旦、生ポインタになってしまうと、例えば、コンポーネントを継承した当たり判定のコライダがあるとしましょう。<br>
    コライダ同士が衝突した際に、どれとどれがぶつかったかの衝突情報にはぶつかったGameObjectの共有ポインタが必要になります。<br>
    なぜ、生ポインタだとだめなの？と思うかもしれませんが、<br>
    衝突した情報を見ている時点ですでにそのぶつかったGameObjectが消えてしまっているとしたら、<br>
    <b>生ポインタでは、住所は空の番号(=nullptr) ではないけど、すでにその住所にあった データ本体は メモリから削除済 ということ</b>が起こりえます。<br>
    例えるなら、<b>スマホに遠い昔の知人の電話番号はまだ登録されているが、電話をかけてみると「この番号は現在使われておりません」となる状態</b>です。<br>
    この状態の生ポインタは、VisualStudioの環境ではデバッグでアクセスすると0xccccccccc.. という16進数のcで埋まった番号になっています。<br>
    この<b>すでにメモリから削除済の0xcccccc...状態になっているポインタを「ダングリングポインタ」</b>と呼びます。<br>
    <b>「ダングリング状態 = 0xcccccc....」で「ヌルポインタ状態 = 0x000000....」ですからダングリング状態は if (p == nullptr) では判定できません</b>。<br>
    ですから、ダングリング状態が予想される状況では、共有ポインタを使うことになります。<br>
    共有ポインタには std::shared_ptr だけではなく 弱共有ポインタ std::weak_ptr もあります。<br>
    <b>弱共有ポインタ std::weak_ptr は 共有ポインタstd::shared_ptr と違って、リンクを張っただけでは 共有カウンタを +1 しません</b>。<br>
    <br>
    弱共有ポインタは使うときだけ、<br>
    <b>std::shared_ptr&lt;Component&gt; pComponent = weak_pComponent.lock();</b> のように <br>
    <b>.lock() でロックすることによって、ふつうの共有ポインタ std::shared_ptr型に戻すことができます</b>。<br>
    当然、<b>戻した共有ポインタ pComponent が使われなくなれば、lock()も外れて、再び共有カウンタは -1 </b>されます。<br>
    では、もし <b>弱共有ポインタstd::weak_ptrの指す先がすでに「この番号は現在使われておりません状態」のとき</b>はどうなるのでしょうか？<br>
    この場合は<b>生ポインタと違って if (pComponent == nullptr) の判定で引っ掛けることができます</b>。<br>
    <br>
    このように<b>生ポインタではなくstd::weak_ptrの弱共有ポインタなら、使いたいときだけ.lockして共有ポインタに戻したり、ダングリング判定もできます</b>。<br>
    なので、<b>やはり大元「おおもと」のGameObjectは生ポインタの this では心もとない</b>ので shared_from_this_as で 共有ポインタ状態で初期生成できる必要があります。<br>
    <br>
    <b>大元が生ポインタ発祥であると、衝突など「大元がすでに現在使われておりません状態」のダングリング判定が必要な状況で詰んでしまう</b>ことになるのです。<br>
    <br>
    では、下記のstd::weak_ptr化したComponentの例を見てみましょう。<br>
    <p class="source">Componentの例<br>
      struct Component<br>
      {<br>
      &nbsp;&nbsp; <em>std::weak_ptr&lt;GameObject&gt;</em> m_owner{ nullptr }; // オーナーのパラメータへアクセスするためのポインタ<br>
      &nbsp;&nbsp; Component(<em>std::shared_ptr&lt;GameObject&gt;</em> owner) : m_owner{ owner } {}<br>
      <br>
      &nbsp;&nbsp; void Update()<br>
      &nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>auto pPlayer = owner.lock(); // 共有ポインタに戻す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pPlayer != nullptr) // ダングリング状態じゃないか？<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pPlayer-</em>&gt;x += 1; // ポインタ経由でオーナーの位置を+1ずつずらす<br>
      &nbsp;&nbsp; }<br>
      } </p>
    これでダングリング状態の心配もなくなりました。<br>
    なぜ m_owner は std::shared_ptrじゃなくわざわざstd::weak_ptrにする必要があるのか？って？<br>
    これは、<b>Componentが「所有される側だから」</b>です。<br>
    オーナーであるPlayerは「共有カウンタが 0」にならない限りはメモリから削除されません。<br>
    でも、もし<b>「所有しているコンポーネント内部にstd::shared_ptrのリンクがあるとずっと +1 が残ってしまう」</b>わけですね。<br>
    「プレイヤと道連れにプレイヤの所有するコンポーネントも消えてほしい」はずなのに<b>逆に「コンポーネント側の +1」の呪いにかかって成仏できない</b>わけです。<br>
    <b>コンポーネント内部の m_owner が 弱共有ポインタ std::weak_ptr ならば 共有カウンタは +1 されない</b>ので、呪われる心配はありません。<br>
    <br>
    この<b>「所有する側と所有される側が互いに std::shared_ptr のリンクを持ち続ける 呪い」はデッドロックの実例として注意が必要</b>です。<br>
    なので、一時的に使ってすぐにリンクを捨てる場合以外は、できる限りstd::weak_ptrで使うときだけ.lock()して使うほうがデッドロックの心配は減ります。<br>
    <b>使う側は「std::shared_ptrをメンバ変数などとして長期保持する際は、デッドロックしないかを気にする必要」</b>があります。<br>
    std::shared_ptrが共有だけでなく「+1のキープ」を意味することを意識した上で「むやみにクラスのメンバ変数としてstd::shared_ptr型を持たず」に<br>
    <b>どこが共有状態の「最低限の+1のキープ」のおおもとか</b>をプログラミングする人は明確に知っておかないと「メモリから成仏しない状態」に悩むことになるでしょう。<br>
    <br>
    共有ポインタの使い手はつねに「いかに道連れにしてやろうか」を考えながらプログラミングする必要があるのです。<br>
    <br>
    実はこれはC++だけじゃなくC#でも同じです。<br>
    暗黙のリンクがあちこちに張られている限り「メモリから成仏されない」=「メモリもれ」=「メモリリーク」が起こっている可能性があります。<br>
    「C#はポインタを意識しなくてすむ」=「すべてが暗黙の共有リンク状態」であるわけで、<br>
    <b>実は「普通の共有ポインタ」と「弱共有ポインタ」を自分でちゃんと区別して使い分けられるC++のほうがまだ怖くない説</b>、すらあるわけです。<br>
    <br>
    <b>「その変数のリンク先、ほんとにメモリから消えてくれてますか？」(怪談調)のことばを意識しながらプログラムしてください</b>ね。<br>
    <br>
    ではPlayerに付着できるジャンプ上昇と重力落下のコンポーネントを設計していきましょう。<br>
    設計を始める前に、まずはコンポーネント設計無しのPlayerクラスへの直打ちでのジャンプと重力落下のコードを書いてみましょう。<br>
    ジャンプのコードはこちらの記事を参考に3D対応します→<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/practice.html#mozTocId0004">キャラをZキーでジャンプさせるプログラム</a> <br>
    <p><code>Player.hを変更</code>して、ジャンプと重力落下の処理を直打ちで追加します。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Resource.h"<br>
      #include "GameObject.h"<br>
      <br>
      class World; // 前方宣言<br>
      class Camera; // 前方宣言<br>
      <br>
      class Player : public GameObject<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるので、Create関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; Player(World* world, Pad pad, Vector3 position, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pad{ pad }, GameObject(world, position, rotation, velocity, force)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "Player"; // タグは個別の"プレイヤ1"などに使い、タイプはtypeTagで判別する形にしてタイプのジャンルを区別<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~Player() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; Pad pad; // 操作するコントローラー番号<br>
      &nbsp;&nbsp;&nbsp; hash32 worldTag{ "" }; // 現在いるワールドのタグ<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeedMax = 6; // 移動速度Max値<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeed = 0;//移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; float moveAngle = 0; // X軸→方向から何度か<br>
      &nbsp;&nbsp;&nbsp; float deltaAngle = 0; // プレイヤの動く角度の変化率、ハンドルを切ったらだんだんもとに戻る<br>
      &nbsp;&nbsp;&nbsp; int animCount = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image; // プレイヤの板ポリゴンで描くタイル分割画像への共有リンク<br>
      <br>
      &nbsp;&nbsp;&nbsp; Camera* camera{ nullptr }; // プレイヤを追随するカメラ<br>
      &nbsp;&nbsp;&nbsp; void SetCamera(Camera* pCamera) { camera = pCamera; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>float yJumpStart{ 0.0f };<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyJumpSpeed{ 13, 14, 15, 4 }; // ジャンプ開始の初期速度<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyForceJump{ 0.5f, 0.4f, 0.3f, 0.1f }; // ジャンプ上昇にかかる力の初期値<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyGravity{ 0.8f,0.8f,0.8f,0.8f }; // 重力の設定値<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyDownSpeedMax{ 16, 16, 16, 8 }; // 降下スピードのリミット</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理<br>
      &nbsp;&nbsp;&nbsp; virtual void HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() override;<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>Player.cppを変更</code>して、GameObjectを継承する記述にしましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      void Player::HandleInput()<br>
      {<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_LEFT) <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_A)) )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = - MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += 1; //ハンドルを左に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_RIGHT)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_D)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle -= 1; //ハンドルを右に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_UP)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_W)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = - MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += 0.6f; //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; MoveSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = MoveSpeedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(pad, PAD_INPUT_DOWN)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_S)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed -= 0.6f; //ブレーキを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.9f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = -0.9f;//ちょっとだけバックできるように<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pad == Pad::Key || pad == Pad::One) // コントローラ1またはキーボード操作のプレイヤのときだけ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGUP)) // キーボードのPageUp ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = 2.0f; // テスト用に空中の上方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGDN)) // キーボードのPageDown ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -2.0f; // テスト用に空中の下方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>if (isGround)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pad, PAD_INPUT_A) // Zキーを押した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを押した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = vyJumpSpeed[0]; // ジャンプ方向はY上方向<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vyForce = -vyForceJump[0];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yJumpStart = y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (vy &lt;= 0) // 下落開始(vyが0未満のときはまだジャンプ中)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vyForce = -vyGravity[0]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (Input::GetButtonUp(pad, PAD_INPUT_A) // Zキーを離した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonUp(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを離した瞬間<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (y - yJumpStart &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vyForce = -vyGravity[0]; // ジャンプ上昇中(vy未満のとき)にボタンを離したら早めに重力をかけ始める<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; rotation.SetRotation(VGet(0, (180 - moveAngle) * MyMath::Deg2Rad, 0)); // 前向きの3Dモデルなら180度回転させて奥方向の向きに設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp; x += vx;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp; y += vy;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp; z += vz;<br>
      <br>
      &nbsp;&nbsp;&nbsp; vy += vyForce; // 勢い(力・フォースを加算<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>if (y &lt;= 0.0f) // 0.0fを地面として 0.0f以下になったら地面に着地したと判定する<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f; // 地面に沿わせる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -0.01f; // 下方向への速度をほぼ 0 にする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGround = true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (vy &lt;= -vyDownSpeedMax[0]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -vyDownSpeedMax[0];</em><br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; // moveAngleは2D画像のX方向右を0度とするから、-90度回すと画像を正面に捉える位置にカメラを置ける<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int animIndex = animCount / 20; // キャラのパラパラアニメの画像番号(最大3)<br>
      &nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp; if (abs_vx &gt; 1.00f || abs_vz &gt; 1.00f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6; // キャラが地面のXとZ方向に少しでもスピードがあったらアニメを走らせる<br>
      &nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // プレイヤのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 9; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // カメラ向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 奥向きの画像<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *image, imgIndex + animIndex, TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    いかかでしょう？上のカメラの"プレイヤ1"は<b>キーボードのZキー(コントローラ1はA)を押したらジャンプ</b>しましたか？<br>
    下のカメラの"プレイヤ2"は<b>キーボードのQキー(コントローラ2はA)を押したらジャンプ</b>しましたか？<br>
    いちいち追加のコントローラをPCに用意しなくてもプレイヤ2もキーボードでデバッグできるようにしました。<br>
    <br>
    まあ、これで全然OKじゃん、と思う人もいますでしょうが、コンポーネントで着脱可能にすれば「アイテムを取ったらジャンプできるようになる」<br>
    もしくは、プレイヤ以外の「敵にもジャンプや重力のコンポーネントを付着して再利用」することも可能になり、柔軟性があがるわけです。<br>
    それがわざわざ頑張って「コンポーネント化」する意義なわけですね。<br>
    <br>
    ではここからはこの「ジャンプするコンポーネント」と「重力落下するコンポーネント」を作成していきましょう。<br>
    <br>
    まずはベース基底となるComponentクラスを準備します。<br>
    <p><code>Component.hを新規作成</code>して、コンポーネントのベース基底となるクラスを作成しましょう。</p>
    <p class="source">#ifndef COMPONENT_H_<br>
      #define COMPONENT_H_<br>
      <br>
      #include &lt;unordered_map&gt; // コンポーネントの辞書配列に使う<br>
      #include &lt;typeindex&gt; // intやComponentなどの「型」をsize_t型の IDの数値 へ typeid(int)などを使って変換する<br>
      #include "MyHash.h" // MyHashクラスで 言語 C++ C# など や ビルドするコンパイラ VisualStudioやgccなどに関係なく同じハッシュを計算<br>
      #include &lt;string&gt;<br>
      #include &lt;memory&gt; // 共有ポインタを使う<br>
      <br>
      #include "Object.h" // コンポーネントもObjectクラスを継承してshared_from_thisできるようにする<br>
      <br>
      class GameObject; //前方宣言(循環インクルード防止)<br>
      <br>
      // 各コンポーネントのひな形<br>
      class Component : public Object<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; std::<b>weak_ptr</b>&lt;GameObject&gt; <b>m_pOwner</b>; // このコンポーネントを所有するPlayerクラスなどへの弱共有ポインタ(弱なので所有権を主張しない)<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // このコンポーネントを所有するプレイヤなどのオーナーへの共有ポインタを得る (オーナーがすでにメモリから削除済の場合は nullptr になる)<br>
      &nbsp;&nbsp;&nbsp; std::<b>shared_ptr</b>&lt;GameObject&gt; <b>owner()</b> const { auto pOwner = m_pOwner<b>.lock()</b>; return (pOwner != nullptr) ? pOwner : nullptr; }<br>
      &nbsp;&nbsp;&nbsp; std::type_index typeID = typeid(Component);<br>
      &nbsp;&nbsp;&nbsp; hash32 typeTag{ "" }; // 小カテゴリ コンポーネントの名前 TilemapColliderなどColliderを継承したコンポーネント本体の名前<br>
      &nbsp;&nbsp;&nbsp; hash32 baseTag{ "" }; // 大カテゴリ コンポーネントの種類(Collider)など https://docs.unity3d.com/ja/current/ScriptReference/Collider.html<br>
      &nbsp;&nbsp;&nbsp; hash32 statusTag{ "" }; // 自由に使えばよいタグ<br>
      &nbsp;&nbsp;&nbsp; bool isEnabled{ true }; // コンポーネントが有効かどうか？<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // 初期化コンストラクタ : このコンポーネントの所有者ownerを内部に持つ<br>
      &nbsp;&nbsp;&nbsp; Component(std::<b>weak_ptr</b>&lt;GameObject&gt; <b>pOwner</b>) : <b>m_pOwner{ pOwner }</b>, Object()<br>
      &nbsp;&nbsp;&nbsp; {};<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 下記関数をoverrideして実装して【コンポーネント志向】を実現する<br>
      &nbsp;&nbsp;&nbsp; //virtual void Initialize(GameObject* obj = nullptr) {}; // Init的な処理 BGMの変更とか<br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) {}; // Update的な役<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw(GameObject* obj = nullptr) {}; // Draw的な役<br>
      &nbsp;&nbsp;&nbsp; //virtual void Finalize(GameObject* obj = nullptr) {}; // Finalize的な役(ステートの終了時)<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual ~Component() {}; // 仮想デストラクタ(無いとstringなど配列を内包するもののデストラクタが暗黙で呼ばれずメモリリーク)<br>
      };<br>
      <br>
      #endif<br>
    </p>
    最初に解説したとおり、オーナーのGameObjectへのリンクは弱共有ポインタstd::weak_ptrで受け取っているのでオーナーが削除されるのを邪魔しません。<br>
    一方で、owner()関数を呼んだときには、.lock()でロックをかけてstd::weak_ptrをstd::shared_ptrに変換して 一時的に共有カウンタを+1 しています。<br>
    owner()関数によって、<b>普段はオーナーが削除されるのを邪魔せず、虎視眈々とstd::weak_ptrをかかえて潜伏し「必要なときだけ 一時的に共有カウンタを+1」して共有ロック状態へ復帰</b>もできます。<br>
    <b>「弱い共有状態とは普段はリンク先が消えるのを邪魔せず、一時的に使ってる最中は消えないように +1 で削除を邪魔する」</b>使い方ができるということです。<br>
    <br>
    つぎにベース基底となるComponentクラスを継承して、派生(Derived)したジャンプや落下の物理系コンポーネントを作成しましょう。<br>
    <p><code>PhysicsComponent.hを新規作成</code>して、物理系のPhysicsComponentクラスを継承してジャンプや落下のコンポーネント作成しましょう。</p>
    <p class="source">#ifndef PHYSICS_COMPONENT_H_<br>
      #define PHYSICS_COMPONENT_H_<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      #include "Component.h"<br>
      #include "GameObject.h"<br>
      <br>
      // 物理系のコンポーネントはこのクラスを継承して実装する<br>
      class PhysicsComponent <b>: public Component</b><br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; inline PhysicsComponent(std::shared_ptr&lt;GameObject&gt; <b>pOwner</b>) : Component(<b>pOwner</b>)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;baseTag = "PhysicsComponent"; // 大まかなカテゴリーとしては物理系コンポーネント<br>
      &nbsp;&nbsp;&nbsp; };<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual ~PhysicsComponent() {};<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // なにか物理系のコンポーネントで共通して更新したいことがあればここに実装<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Draw(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // なにか物理系のコンポーネントで共通して描画したいことがあればここに実装<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      class GravityComponent <b>: public PhysicsComponent</b><br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline GravityComponent(std::shared_ptr&lt;GameObject&gt; <b>pOwner</b>, const std::vector&lt;float&gt;&amp; vyGravity, const std::vector&lt;float&gt;&amp; vyDownSpeedMax)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : PhysicsComponent(<b>pOwner</b>), m_vyGravity{ vyGravity }, m_vyDownSpeedMax{ vyDownSpeedMax }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;typeID = typeid(GravityComponent); //[環境によって差が出るので↓が無難か] https://qiita.com/nil_gawa/items/1fece3eee7ca1f88c71d<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;typeTag = "GravityComponent"; // 個別のカテゴリーとしては重力落下コンポーネント<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; virtual ~GravityComponent() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; size_t m_idx{ 0 }; // 適用する設定配列の番号<br>
      &nbsp;&nbsp;&nbsp; void SetIndex(size_t idx) { m_idx = idx; }<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; m_vyGravity; // 重力の設定値<br>
      &nbsp;&nbsp;&nbsp; float gravity() { return (m_idx &lt; m_vyGravity.size()) ? m_vyGravity[m_idx] : 0.0f; }<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; m_vyDownSpeedMax; // 降下スピードのリミット<br>
      &nbsp;&nbsp;&nbsp; float downSpeedMax() { return (m_idx &lt; m_vyDownSpeedMax.size()) ? m_vyDownSpeedMax[m_idx] : 0.0f; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isEnabled) return; // コンポーネントが有効状態じゃないときは何もせずreturn<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタをロックして得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;isGround == false &amp;&amp; pOwner-&gt;vy &lt;= 0) // 下落開始(vyが 0以上 のときはまだジャンプ中なので上昇を邪魔しないようにする)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;vyForce = -gravity(); // ジャンプ上昇力が0になって以降に初めて重力をオンにする(ジャンプの加速を邪魔しない工夫)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;OnFalling(); // 下落中の処理のコールバック関数を呼び返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;vy &lt;= -downSpeedMax()) // 無限に落下速度が加速しないようにリミットを働かせる(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;vy = -downSpeedMax(); // downSpeedMax()以上の落下速度にならないようにする<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      class JumpComponent : public PhysicsComponent<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline JumpComponent(std::shared_ptr&lt;GameObject&gt; pOwner, const std::vector&lt;float&gt;&amp; vyJumpSpeed, const std::vector&lt;float&gt;&amp; vyForceJump)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : PhysicsComponent(pOwner), m_vyJumpSpeed{ vyJumpSpeed }, m_vyForceJump{ vyForceJump }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;typeID = typeid(JumpComponent); //[環境によって差が出るので↓が無難か] https://qiita.com/nil_gawa/items/1fece3eee7ca1f88c71d<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;typeTag = "JumpComponent"; // 個別のカテゴリーとしてはジャンプ上昇コンポーネント<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; virtual ~JumpComponent() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; size_t m_idx{ 0 }; // 適用する設定配列の番号<br>
      &nbsp;&nbsp;&nbsp; void SetIndex(size_t idx) { m_idx = idx; }<br>
      &nbsp;&nbsp;&nbsp; float yJumpStart{ 0 }; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; m_vyJumpSpeed; // ジャンプの上昇スピードのリミット<br>
      &nbsp;&nbsp;&nbsp; float jumpSpeed() { return (m_idx &lt; m_vyJumpSpeed.size()) ? m_vyJumpSpeed[m_idx] : 0.0f; }<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; m_vyForceJump; // ジャンプ中の下方向の勢いの減速する力<br>
      &nbsp;&nbsp;&nbsp; float forceJump() { return (m_idx &lt; m_vyForceJump.size()) ? m_vyForceJump[m_idx] : 0.0f; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isEnabled) return; // コンポーネントが有効状態じゃないときは何もせずreturn<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;isGround == false &amp;&amp; pOwner-&gt;vy &gt; 0) // vyが0以上のときはまだジャンプ中<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;OnJumping(); // 空中でジャンプの上昇中に呼ばれるコールバック関数を呼び返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void JumpStart(GameObject* obj = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isEnabled) return; // コンポーネントが有効状態じゃないときは何もせずreturn<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;isGround)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;vy = jumpSpeed(); // ジャンプ方向はY上方向<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;vyForce = -forceJump(); // ジャンプの勢いが弱まる力<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; yJumpStart = pOwner-&gt;y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;OnStartJump(); // ジャンプスタート時の処理をコールバックで呼び返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void JumpCancel(GameObject* obj = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isEnabled) return; // コンポーネントが有効状態じゃないときは何もせずreturn<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!pOwner-&gt;isGround &amp;&amp; pOwner-&gt;vy &gt;= 0) // vyが0以上のときはまだジャンプ上昇中<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;y - yJumpStart &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけ始めない<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;vyForce = -pOwner-&gt;gravity(); // ジャンプボタンを離したときには重力をかけ始める<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>GameObject.hを変更</code>して、OnStartJump()やOnFalling()やgravity()などジャンプ中や落下中に呼ばれるoverride元の関数を準備しましょう。</p>
    <p class="source">#ifndef GAMEOBJECT_H_<br>
      #define GAMEOBJECT_H_<br>
      <br>
      #include &lt;memory&gt; // 共有ポインタの定義のため<br>
      <br>
      #include "Vector3.h"<br>
      #include "Quaternion.h"<br>
      <br>
      #include "Object.h" // インスタンスIDや検索タグを持ち、shared_from_this_as&lt;継承先クラス名&gt;などができる<br>
      <br>
      class World; // 前方宣言<br>
      <br>
      // ゲーム上に表示される物体の基底クラス。<br>
      // プレイヤーや敵、アイテムなどはこのクラスを継承して作る。<br>
      class GameObject : public Object<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるのでCreate関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; GameObject(World* world = nullptr, Vector3 position = { 0,0,0 }, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Object(), m_world{ world }, position{ position }, rotation{ rotation }, velocity{ velocity }, force{ force }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~GameObject() {}<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★下記3つはメモリ上で共用状態になる(position、x,y,z、xyzどの名前から数値を変えたり読出してもメモリ上は同じ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 同じデータに3種類の名前を付けたイメージ、しかもVector3の機能や配列としてのアクセスの仕方もできて便利<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // XYZ座標&nbsp; [匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 position; // XYZ座標<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp;&nbsp; }; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
      <br>
      &nbsp;&nbsp;&nbsp; Quaternion rotation; // 回転クオータニオン<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vx, vy, vz; }; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 velocity; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyz;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vxForce, vyForce, vzForce; }; // XYZ方向にかかる力(Unityでいうと AddForce関数 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 force; // XYZ方向の力(物理的には加速度:1フレームごとにvelocityの増える=加速する量)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyzForce;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 重力を返す、重力を変えたいときはoverrideして処理を変えてください、重力を変えてない場合は 0.0f<br>
        &nbsp;&nbsp;&nbsp; virtual inline float gravity() { return 0.0f; }</em><br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; World* m_world; // GameObjectが配置されたワールドへのリンク<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; virtual World* world() { return m_world; }<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
      &nbsp;&nbsp;&nbsp; virtual void world(World* changeWorld) { m_world = changeWorld; }<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; bool isDead{ false }; // 死んだ（削除対象）フラグ<br>
      &nbsp;&nbsp;&nbsp; bool isStatic{ false }; // 動かない(静的オブジェクトか?)<br>
      &nbsp;&nbsp;&nbsp; bool isGround{ false }; // 地面についているか<br>
      &nbsp;&nbsp;&nbsp; bool isFlying{ false }; // 空をとんでいるか<br>
      <br>
      &nbsp;&nbsp;&nbsp; hash32 typeTag{ "" }; // 小カテゴリ Zako0など個別のタイプ<br>
      &nbsp;&nbsp;&nbsp; hash32 baseTag{ "" }; // 大カテゴリ Enemyなど大まかなベースジャンル<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() = 0; // 純粋仮想関数 = 0 にすると【絶対 Update()関数はoverrideしなきゃいけない義務を付与できる 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() = 0; // 純粋仮想関数 = 0 にすると【絶対 Draw()関数はoverrideしなきゃいけない義務を継承先クラスに付与 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// ジャンプ開始した直後に呼ばれる関数<br>
        &nbsp;&nbsp;&nbsp; virtual void OnStartJump()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideしてジャンプした瞬間に音を鳴らしたりする処理などをオブジェクトの種類ごとに実装する<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 空中でジャンプの上昇中に呼ばれる関数<br>
        &nbsp;&nbsp;&nbsp; virtual void OnJumping()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中でジャンプの上昇中にエフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 空中で落ちている最中に呼ばれる関数<br>
        &nbsp;&nbsp;&nbsp; virtual void OnFalling()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中で落ちている最中に音を鳴らしたり、エフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
        &nbsp;&nbsp;&nbsp; };</em><br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    あとはこれらのコンポーネントの処理を、先ほどPlayerに直で書いたジャンプと落下の処理と置き換えます。<br>
    <p><code>Player.hを変更</code>して、ジャンプと重力落下の初期化をコンポーネントへ置き換えます。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Resource.h"<br>
      #include "GameObject.h"<br>
      <em>#include "PhysicsComponent.h"</em><br>
      <br>
      class World; // 前方宣言<br>
      class Camera; // 前方宣言<br>
      <br>
      class Player : public GameObject<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるので、Create関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; Player(World* world, Pad pad, Vector3 position, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pad{ pad }, GameObject(world, position, rotation, velocity, force)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "Player"; // タグは個別の"プレイヤ1"などに使い、タイプはtypeTagで判別する形にしてタイプのジャンルを区別<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~Player() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; Pad pad; // 操作するコントローラー番号<br>
      &nbsp;&nbsp;&nbsp; hash32 worldTag{ "" }; // 現在いるワールドのタグ<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeedMax = 6; // 移動速度Max値<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeed = 0;//移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; float moveAngle = 0; // X軸→方向から何度か<br>
      &nbsp;&nbsp;&nbsp; float deltaAngle = 0; // プレイヤの動く角度の変化率、ハンドルを切ったらだんだんもとに戻る<br>
      &nbsp;&nbsp;&nbsp; int animCount = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image; // プレイヤの板ポリゴンで描くタイル分割画像への共有リンク<br>
      <br>
      &nbsp;&nbsp;&nbsp; Camera* camera{ nullptr }; // プレイヤを追随するカメラ<br>
      &nbsp;&nbsp;&nbsp; void SetCamera(Camera* pCamera) { camera = pCamera; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// overrideして物理落下コンポーネントからの重力値を返す<br>
        &nbsp;&nbsp;&nbsp; virtual float gravity() <b>override</b> { return (gravityPhysics != nullptr) ? gravityPhysics-&gt;gravity() : 0.0f; }<br>
        protected:<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;JumpComponent&gt; jumpPhysics{ nullptr }; // ジャンプの物理処理コンポーネント<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;GravityComponent&gt; gravityPhysics{ nullptr }; // 落下の重力の物理処理コンポーネント<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyJumpSpeed{ 13, 14, 15, 4 }; // ジャンプ開始の初期速度<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyForceJump{ 0.5f, 0.4f, 0.3f, 0.1f }; // ジャンプ上昇にかかる力の初期値<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyGravity{ 0.8f,0.8f,0.8f,0.8f }; // 重力の設定値<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyDownSpeedMax{ 16, 16, 16, 8 }; // 降下スピードのリミット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <b>shared_from_this()を必ず渡してセットで初期化</b>して、オーナーがリンク切れのコンポーネントができないように気をつける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jumpPhysics = std::make_shared&lt;JumpComponent&gt;(<b>shared_from_this_as&lt;Player&gt;()</b>, vyJumpSpeed, vyForceJump);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gravityPhysics = std::make_shared&lt;GravityComponent&gt;(<b>shared_from_this_as&lt;Player&gt;()</b>, vyGravity, vyDownSpeedMax);<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      &nbsp;&nbsp;&nbsp; <u>float yJumpStart{ 0.0f };<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyJumpSpeed{ 13, 14, 15, 4 }; // ジャンプ開始の初期速度<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyForceJump{ 0.5f, 0.4f, 0.3f, 0.1f }; // ジャンプ上昇にかかる力の初期値<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyGravity{ 0.8f,0.8f,0.8f,0.8f }; // 重力の設定値<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyDownSpeedMax{ 16, 16, 16, 8 }; // 降下スピードのリミット</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理<br>
      &nbsp;&nbsp;&nbsp; virtual void HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// ジャンプ開始した直後に呼ばれる関数<br>
        &nbsp;&nbsp;&nbsp; virtual void OnStartJump() <b>override</b>;</em><br>
      };<br>
      <br>
      #endif<br>
    </p>
    着目すべきは、Init()関数やgravity()関数やOnStartJump()関数のoverrideです。<br>
    gravity()関数のoverrideによりプレイヤはGravityComponentから得た重力を採用することができます。<br>
    OnStartJump()関数のoverrideにより、ジャンプ開始時にisGroundのフラグをfalseにしたり、プレイヤごとの効果音を鳴らす処理もここでカスタムできます。<br>
    Init()関数のoverrideにより、Create関数の初期化と連動して、上昇する力や落下の設定値をコンポーネントに渡し、<br>
    もっとも重要なのは、プレイヤへのポインタ<b>shared_from_this_as&lt;Player&gt;()</b>をコンポーネントに初期化と同時に渡せていることです。<br>
    これで、コンポーネント側はプレイヤ側の vy(縦方向の加速度) などに自由にアクセスできる構造を実現できるようになります。<br>
    <br>
    では、あとはプレイヤ側のジャンプや落下の処理をコンポーネントの呼び出しへと置き換えましょう。<br>
    <p><code>Player.cppを変更</code>して、<b>コンポーネントにジャンプや落下の処理を任せましょう</b>。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      void Player::HandleInput()<br>
      {<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_LEFT) <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_A)) )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = - MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += 1; //ハンドルを左に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_RIGHT)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_D)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle -= 1; //ハンドルを右に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_UP)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_W)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = - MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += 0.6f; //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; MoveSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = MoveSpeedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(pad, PAD_INPUT_DOWN)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_S)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed -= 0.6f; //ブレーキを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.9f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = -0.9f;//ちょっとだけバックできるように<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pad == Pad::Key || pad == Pad::One) // コントローラ1またはキーボード操作のプレイヤのときだけ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGUP)) // キーボードのPageUp ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = 2.0f; // テスト用に空中の上方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGDN)) // キーボードのPageDown ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -2.0f; // テスト用に空中の下方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      <em>// ジャンプ開始した直後に呼ばれる関数<br>
        void Player::OnStartJump()<br>
        {<br>
        &nbsp;&nbsp;&nbsp; this-&gt;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
        }</em><br>
      <br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>if (jumpPhysics != nullptr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isGround)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pad, PAD_INPUT_A) // Zキーを押した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを押した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jumpPhysics-&gt;JumpStart(); // ジャンプのスタート処理を発動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (vy &gt; 0 &amp;&amp; Input::GetButtonUp(pad, PAD_INPUT_A) // Zキーを離した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonUp(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを離した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jumpPhysics-&gt;JumpCancel(); // ジャンプのキャンセル処理を発動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jumpPhysics-&gt;Update(); // ジャンプのコンポーネントを更新する<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; if (gravityPhysics != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gravityPhysics-&gt;Update(); // 重力落下のコンポーネントを更新する</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>if (isGround)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pad, PAD_INPUT_A) // Zキーを押した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを押した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = vyJumpSpeed[0]; // ジャンプ方向はY上方向<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vyForce = -vyForceJump[0];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yJumpStart = y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (vy &lt;= 0) // 下落開始(vyが0未満のときはまだジャンプ中)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vyForce = -vyGravity[0]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (Input::GetButtonUp(pad, PAD_INPUT_A) // Zキーを離した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonUp(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを離した瞬間<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (y - yJumpStart &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vyForce = -vyGravity[0]; // ジャンプ上昇中(vy未満のとき)にボタンを離したら早めに重力をかけ始める<br>
        &nbsp;&nbsp;&nbsp; }</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; rotation.SetRotation(VGet(0, (180 - moveAngle) * MyMath::Deg2Rad, 0)); // 前向きの3Dモデルなら180度回転させて奥方向の向きに設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp; x += vx;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp; y += vy;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp; z += vz;<br>
      <br>
      &nbsp;&nbsp;&nbsp; vy += vyForce; // 勢い(力・フォースを加算<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (y &lt;= 0.0f) // 0.0fを地面として 0.0f以下になったら地面に着地したと判定する<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f; // 地面に沿わせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -0.01f; // 下方向への速度をほぼ 0 にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGround = true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>if (vy &lt;= -vyDownSpeedMax[0]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -vyDownSpeedMax[0];</u><br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; // moveAngleは2D画像のX方向右を0度とするから、-90度回すと画像を正面に捉える位置にカメラを置ける<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int animIndex = animCount / 20; // キャラのパラパラアニメの画像番号(最大3)<br>
      &nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp; if (abs_vx &gt; 1.00f || abs_vz &gt; 1.00f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6; // キャラが地面のXとZ方向に少しでもスピードがあったらアニメを走らせる<br>
      &nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // プレイヤのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 9; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // カメラ向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 奥向きの画像<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *image, imgIndex + animIndex, TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    いかがでしょう？無事キーボードのZキーとQキーでキャラをジャンプさせることができましたか？<br>
    ここまでがゲームエンジンを形づくっているコンポーネント指向の仕組みの根幹であり、その仕組みを一通り自作したわけです。<br>
    <br>
    え、Unityみたいに「かっこよくAddComponent&lt;JumpComponent&gt;(..～..);」しないと気分が上がらないですって？<br>
    お若いですね。。<b>「かっこつけるということは、柔軟にテンプレで可変引数...ArgsTを受け入れる」ってこと</b>ですからね。<br>
    それは、つまり「引数のタイプ型や引数の個数などが 自分で定義したJumpComponentのコンストラクタ と合わないとテンプレの謎エラーが出る」ってことです。<br>
    単なる自分の<b>勘違いで初期化コンストラクタの 〇〇Component(Vector3 pos1, int param2, ...)のパラメータparam2に間違ってVector3型を渡しちゃった</b>としましょう。<br>
    そうすると当然、テンプレの謎エラーが出ます<b>「エラー:オーバーロードされた関数ですべての引数の型が変換できませんでした」</b>(ファイルはxutility←テンプレ関連ファイル)<br>
    つまり、普通の初期化コンストラクタで「渡す引数まちがえちゃったケアレスミスの場合」は 〇〇Component.h などのコンストラクタのファイルが案内されるけれども、<br>
    可変引数テンプレ...ArgsT に手を出すと、かっこよさと引き換えに「謎エラー案内」が出るわけですね。<br>
    ゆえに、可変引数テンプレ...ArgsTは 中級者向けの機能とはなるわけです。<br>
    が、しかし、すでにCreate関数で初期化に 可変引数テンプレ...ArgsT は使っておりますし、これなしにはやっていけませんので、<br>
    上記の<b>「謎エラー案内」=「渡す引数まちがえちゃったケアレスミス」の場合が多い</b>ので、ちゃんと初期化で渡すパラメータをよく見て渡しましょう。<br>
    <br>
    では、Unityみたいに「かっこよくAddComponent&lt;JumpComponent&gt;(..～..);」するテンプレ処理を追加しましょう。<br>
    <p><code>GameObject.hを変更</code>して、AddComponentやGetComponentsなどのテンプレ処理を準備しましょう。</p>
    <p class="source">#ifndef GAMEOBJECT_H_<br>
      #define GAMEOBJECT_H_<br>
      <br>
      #include &lt;memory&gt; // 共有ポインタの定義のため<br>
      <br>
      #include "Vector3.h"<br>
      #include "Quaternion.h"<br>
      <br>
      #include "Object.h" // インスタンスIDや検索タグを持ち、shared_from_this_as&lt;継承先クラス名&gt;などができる<br>
      <br>
      class World; // 前方宣言<br>
      <br>
      // ゲーム上に表示される物体の基底クラス。<br>
      // プレイヤーや敵、アイテムなどはこのクラスを継承して作る。<br>
      class GameObject : public Object<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるのでCreate関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; GameObject(World* world = nullptr, Vector3 position = { 0,0,0 }, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Object(), m_world{ world }, position{ position }, rotation{ rotation }, velocity{ velocity }, force{ force }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~GameObject() {}<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★下記3つはメモリ上で共用状態になる(position、x,y,z、xyzどの名前から数値を変えたり読出してもメモリ上は同じ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 同じデータに3種類の名前を付けたイメージ、しかもVector3の機能や配列としてのアクセスの仕方もできて便利<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // XYZ座標&nbsp; [匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 position; // XYZ座標<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp;&nbsp; }; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
      <br>
      &nbsp;&nbsp;&nbsp; Quaternion rotation; // 回転クオータニオン<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vx, vy, vz; }; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 velocity; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyz;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vxForce, vyForce, vzForce; }; // XYZ方向にかかる力(Unityでいうと AddForce関数 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 force; // XYZ方向の力(物理的には加速度:1フレームごとにvelocityの増える=加速する量)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyzForce;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 重力を返す、重力を変えたいときはoverrideして処理を変えてください、重力を変えてない場合は 0.0f<br>
      &nbsp;&nbsp;&nbsp; virtual inline float gravity() { return 0.0f; }<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; World* m_world; // GameObjectが配置されたワールドへのリンク<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; virtual World* world() { return m_world; }<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
      &nbsp;&nbsp;&nbsp; virtual void world(World* changeWorld) { m_world = changeWorld; }<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; bool isDead{ false }; // 死んだ（削除対象）フラグ<br>
      &nbsp;&nbsp;&nbsp; bool isStatic{ false }; // 動かない(静的オブジェクトか?)<br>
      &nbsp;&nbsp;&nbsp; bool isGround{ false }; // 地面についているか<br>
      &nbsp;&nbsp;&nbsp; bool isFlying{ false }; // 空をとんでいるか<br>
      <br>
      &nbsp;&nbsp;&nbsp; hash32 typeTag{ "" }; // 小カテゴリ Zako0など個別のタイプ<br>
      &nbsp;&nbsp;&nbsp; hash32 baseTag{ "" }; // 大カテゴリ Enemyなど大まかなベースジャンル<br>
      <br>
      <em>protected:<br>
        &nbsp;&nbsp;&nbsp; // コンポーネントの&lt;ハッシュID, 共有所有ポインタ&gt; の辞書でコンポーネントの共有カウンタ+1を保持する<br>
        &nbsp;&nbsp;&nbsp; std::unordered_map&lt;size_t, std::<b>shared_ptr</b>&lt;Component&gt;&gt; <b>components</b>;<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; // コンポーネントを得る 例えば GetComponent&lt;BoxCollider&gt;でBoxColliderという名前のコンポーネントをcomponents辞書から得る<br>
        &nbsp;&nbsp;&nbsp; template&lt;class ComponentT&gt;<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;ComponentT&gt;&gt; GetComponents()<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // equal_range 関数を使って、指定したキーの最初と終端の位置を示すイテレータを std::pair&lt;&gt; で取得します。<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto range = components.equal_range(hashID); //https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;ComponentT&gt;&gt; returnList; // "ComponentT" 例."CircleCollider"など をキーとするコンポーネント一覧<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto ite = range.first; ite != range.second; ++ite)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; returnList.emplace_back(ite-&gt;second); // 辞書で見つかったコンポーネントを返すリストに追加<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return returnList;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンポーネントを追加する .AddComponent&lt;BoxCollider&gt;(...)で追加できる<br>
        &nbsp;&nbsp;&nbsp; template&lt;class ComponentT, <b>typename ...ArgsT</b>&gt;<br>
        &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;ComponentT&gt; AddComponent(ArgsT&amp;&amp;...args)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // shared_from_this()を必ず渡してセットで初期化して、オーナーがリンク切れのコンポーネントができないように気をつける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ComponentT&gt; <b>newComponent</b> = std::<b>make_shared</b>&lt;ComponentT&gt;(shared_from_this(), <b>std::forward&lt;ArgsT&gt;(args)...</b>);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // std::unrodered_multimap&lt;&gt; と同型の値を取る std::pair&lt;&gt; を作って insert 関数でcomponents辞書に追加<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>components</b>.insert(std::pair&lt;size_t, std::shared_ptr&lt;ComponentT&gt;&gt;(hashID, <b>newComponent</b>));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return newComponent;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンポーネントを削除する<br>
        &nbsp;&nbsp;&nbsp; template&lt;typename ComponentT&gt;<br>
        &nbsp;&nbsp;&nbsp; bool RemoveComponent(std::shared_ptr&lt;ComponentT&gt; removeComponent)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // equal_range 関数を使って、指定したキーの最初と終端の位置を示すイテレータを std::pair&lt;&gt; で取得します。<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto range = components.equal_range(hashID); //https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[イテレート中に探しながら消す] https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/erase.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto ite = range.first; ite != range.second;)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ite-&gt;second == removeComponent)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; components.erase(ite); // 削除された要素の次を指すイテレータが返される<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // 見つかって消せた場合は true<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++ite; // 次の要素へイテレータを進める<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 見つからずに消せなかった場合は false<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() = 0; // 純粋仮想関数 = 0 にすると【絶対 Update()関数はoverrideしなきゃいけない義務を付与できる 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() = 0; // 純粋仮想関数 = 0 にすると【絶対 Draw()関数はoverrideしなきゃいけない義務を継承先クラスに付与 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ジャンプ開始した直後に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnStartJump()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideしてジャンプした瞬間に音を鳴らしたりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 空中でジャンプの上昇中に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnJumping()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中でジャンプの上昇中にエフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 空中で落ちている最中に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnFalling()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中で落ちている最中に音を鳴らしたり、エフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    コンポーネントが<b>最後まで消えないように「共有カウンタ+1をキープする役割」はcomponents辞書に移りました</b>。<br>
    ですので、Playerクラス側のstd::shared_ptrはstd::weak_ptrに変えておきましょう。+1のキープ元はなるべく1か所に限定しておきたいですから。<br>
    <p><code>Player.hを変更</code>して、UnityっぽくAddComponentでコンポーネントを追加し、プレイヤ側のstd::shared_ptrはstd::weak_ptrに変えておきましょう。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Resource.h"<br>
      #include "GameObject.h"<br>
      #include "PhysicsComponent.h"<br>
      <br>
      class World; // 前方宣言<br>
      class Camera; // 前方宣言<br>
      <br>
      class Player : public GameObject<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるので、Create関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; Player(World* world, Pad pad, Vector3 position, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pad{ pad }, GameObject(world, position, rotation, velocity, force)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "Player"; // タグは個別の"プレイヤ1"などに使い、タイプはtypeTagで判別する形にしてタイプのジャンルを区別<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~Player() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; Pad pad; // 操作するコントローラー番号<br>
      &nbsp;&nbsp;&nbsp; hash32 worldTag{ "" }; // 現在いるワールドのタグ<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeedMax = 6; // 移動速度Max値<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeed = 0;//移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; float moveAngle = 0; // X軸→方向から何度か<br>
      &nbsp;&nbsp;&nbsp; float deltaAngle = 0; // プレイヤの動く角度の変化率、ハンドルを切ったらだんだんもとに戻る<br>
      &nbsp;&nbsp;&nbsp; int animCount = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image; // プレイヤの板ポリゴンで描くタイル分割画像への共有リンク<br>
      <br>
      &nbsp;&nbsp;&nbsp; Camera* camera{ nullptr }; // プレイヤを追随するカメラ<br>
      &nbsp;&nbsp;&nbsp; void SetCamera(Camera* pCamera) { camera = pCamera; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // overrideして物理落下コンポーネントからの重力値を返す<br>
      &nbsp;&nbsp;&nbsp; virtual float gravity() override { <em>auto pGravityPhysics = gravityPhysics.lock();</em> return (<em>pGravityPhysics</em> != nullptr) ? <em>pGravityPhysics</em>-&gt;gravity() : 0.0f; }<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; <em>std::weak_ptr</em>&lt;JumpComponent&gt; jumpPhysics<u>{ nullptr }</u>; // ジャンプの物理処理コンポーネント<br>
      &nbsp;&nbsp;&nbsp; <em>std::weak_ptr</em>&lt;GravityComponent&gt; gravityPhysics<u>{ nullptr }</u>; // 落下の重力の物理処理コンポーネント<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyJumpSpeed{ 13, 14, 15, 4 }; // ジャンプ開始の初期速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyForceJump{ 0.5f, 0.4f, 0.3f, 0.1f }; // ジャンプ上昇にかかる力の初期値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyGravity{ 0.8f,0.8f,0.8f,0.8f }; // 重力の設定値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyDownSpeedMax{ 16, 16, 16, 8 }; // 降下スピードのリミット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <em>AddComponent内部で</em>shared_from_this()を必ず渡してセットで初期化して、オーナーがリンク切れのコンポーネントができないように気をつける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jumpPhysics = <em>AddComponent&lt;JumpComponent&gt;(</em>vyJumpSpeed, vyForceJump);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gravityPhysics = <em>AddComponent&lt;GravityComponent&gt;(</em>vyGravity, vyDownSpeedMax);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理<br>
      &nbsp;&nbsp;&nbsp; virtual void HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ジャンプ開始した直後に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnStartJump() override;<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Player.cppを変更</code>して、std::shared_ptrからstd::weak_ptrに変えたので.lock()でロックして、<br>
      コンポーネントを使っている間(Update関数()の {&nbsp; ～ }のカッコが閉じるまで )はコンポーネントが消えないように +1 キープしながら使うようにしましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      void Player::HandleInput()<br>
      {<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_LEFT) <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_A)) )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = - MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += 1; //ハンドルを左に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_RIGHT)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_D)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle -= 1; //ハンドルを右に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_UP)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_W)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = - MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += 0.6f; //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; MoveSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = MoveSpeedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(pad, PAD_INPUT_DOWN)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_S)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed -= 0.6f; //ブレーキを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.9f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = -0.9f;//ちょっとだけバックできるように<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pad == Pad::Key || pad == Pad::One) // コントローラ1またはキーボード操作のプレイヤのときだけ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGUP)) // キーボードのPageUp ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = 2.0f; // テスト用に空中の上方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGDN)) // キーボードのPageDown ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -2.0f; // テスト用に空中の下方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      // ジャンプ開始した直後に呼ばれる関数<br>
      void Player::OnStartJump()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; this-&gt;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      }<br>
      <br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>auto pJumpPhysics = jumpPhysics.lock();</em><br>
      &nbsp;&nbsp;&nbsp; if (<em>pJumpPhysics</em> != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pad, PAD_INPUT_A) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>pJumpPhysics</em>-&gt;JumpStart(); // ジャンプのスタート処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (vy &gt; 0 &amp;&amp; Input::GetButtonUp(pad, PAD_INPUT_A) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonUp(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>pJumpPhysics</em>-&gt;JumpCancel(); // ジャンプのキャンセル処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>pJumpPhysics</em>-&gt;Update(); // ジャンプのコンポーネントを更新する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; <em>auto pGravityPhysics = gravityPhysics.lock();</em><br>
      &nbsp;&nbsp;&nbsp; if (<em>pGravityPhysics</em> != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>pGravityPhysics</em>-&gt;Update(); // 重力落下のコンポーネントを更新する<br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; rotation.SetRotation(VGet(0, (180 - moveAngle) * MyMath::Deg2Rad, 0)); // 前向きの3Dモデルなら180度回転させて奥方向の向きに設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp; x += vx;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp; y += vy;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp; z += vz;<br>
      <br>
      &nbsp;&nbsp;&nbsp; vy += vyForce; // 勢い(力・フォースを加算<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (y &lt;= 0.0f) // 0.0fを地面として 0.0f以下になったら地面に着地したと判定する<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f; // 地面に沿わせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -0.01f; // 下方向への速度をほぼ 0 にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGround = true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; // moveAngleは2D画像のX方向右を0度とするから、-90度回すと画像を正面に捉える位置にカメラを置ける<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int animIndex = animCount / 20; // キャラのパラパラアニメの画像番号(最大3)<br>
      &nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp; if (abs_vx &gt; 1.00f || abs_vz &gt; 1.00f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6; // キャラが地面のXとZ方向に少しでもスピードがあったらアニメを走らせる<br>
      &nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // プレイヤのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 9; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // カメラ向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 奥向きの画像<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *image, imgIndex + animIndex, TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    いかがでしょう？結局、AddComponentはしましたが、Player側でジャンプや重力などのstd::weak_ptrを保持して、GetComponentsはわざわざしないようにしました。<br>
    GetComponentsは辞書を探す処理が走るので、無駄な計算時間がかかるので避けたかったのも理由の一つです。<br>
    UnityでもGetComponentsなどはなるべくStart()関数でするほうが、処理は高速になります。<br>
    どのみちPlayerなどのメンバ変数としてstd::weak_ptr&lt;JumpComponent&gt; jumpPhysics;などのコンポーネントへの弱リンクを保管するほうが、<br>
    辞書をいちいち探すコストはかからなくなるわけですので、同じようなコードのままになるのは必然なわけです。<br>
    <br>
    では、AddComponentやGetComponentsなどの必要性はどこにあるかというと、<br>
    Unityではインスペクタの[Add Component]ボタンなど画面のUI経由でAddComponentできちゃいますから、<br>
    必ずしもInit経由からAddComponentされるものだけとは限らないわけです。<br>
    または、ジャンプできるようになるアイテムを取った瞬間にAddComponentされるケースもありえます。<br>
    そういう場合、つまりUIから多種多様なコンポーネントが来たり、アイテムの種類が多種多様な場合は、<br>
    メンバ変数のコンポーネントのタイプ型を事前に想定することができにくいわけですね。<br>
    そうなってくるとGetComponentの&lt;～&gt;の中で引き受けたいタイプをそのつど受け取るほうが良いケースもでてくるわけです。<br>
    まあでも、InitでAddComponentしたあと、即 isEnabled = false; で無効にしてジャンプ能力を眠らせておいて、<br>
    アイテムを取ったときだけisEnabled = true; で有効にしてGetComponentsの辞書サーチは走らせないほうが回避策としては優秀ですがね。<br>
    ということで、なるべくUpdateなど毎フレーム繰り返す文脈の中で毎度GetComponentsしないのが、プログラマとしては有能なわけです。<br>
    (まあ、それだとUI経由のコンポーネント追加は検知できないわけで、ゲームエンジンのUIの便利さは計算コストとのトレードオフ ではあるわけです)<br>
    想定可能なコンポーネントはInit()すなわち UnityではStart()関数であらかじめGetComponentsでメンバ変数に保持しておきましょうということですね。<br>
    Update関数の中でGetComponentsするならまだしも、for文のループの中でGetComponentsしている人はいませんか？ 完全アウトです。<br>
    (UnityでFPSを60に保てる限度において、<a href="https://qiita.com/uminohiyoko/items/1dfeae592402697be025">GetComponentは5万回</a>だそうです。。)<br>
    <br>
    <br>
    以上、共有ポインタや可変引数テンプレやoverrideなど、もろもろの基礎の積み上げによりAddComponentにたどりつけました。<br>
    Unityで何気なくつかっているAddComponentのままでは、thisポインタ渡し は完全ブラックボックス化されていて、<br>
    コンポーネントとは「this渡しによる親の変数アクセス」が本質であるという重要な勉強がすっとばされてしまうので、<br>
    ほぼプログラミングの設計サイドにふれあう機会なく、便利さのぬるま湯につかってしまいます。<br>
    ここまでの勉強によって「ゲームエンジンそのものとは何なのか？」の理解に少しは近づけたでしょうか？<br>
    <br>
    <br>
  </body>
</html>
