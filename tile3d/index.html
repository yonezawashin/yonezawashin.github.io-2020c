<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>[C++]3Dタイル描画エンジン</title>
    <link rel="stylesheet" href="../style.css">
    <style>
      
    </style>
  </head>
  <body>
    <p class="title">[C++]3Dタイル描画エンジン1</p>
    <ol id="mozToc">
      <!--mozToc h1 1-->
      <li><a href="#mozTocId0001">試しにボックス型のタイルをポリゴンを表示してみる</a></li>
      <li><a href="#mozTocId0002">複数カメラと複数スクリーンで複数プレイヤ視点で3D空間を描けるようにする</a></li>
      <li><a href="#mozTocId0003">文字タグ判定の代わりに使えるハッシュ(32bit)でカメラにhash32タグをつけて管理する</a></li>
      <li><a href="#mozTocId0004">ワールドを定義して、複数プレイヤと複数カメラをワールドに保持する</a></li>
      <li><a href="#mozTocId0005">シーンを定義して、ゲームシーンの中に複数ワールドを保持する</a></li>
      <li><a href="#mozTocId0006">MyTimerクラスでchronoから得た時刻でゲームの描画のFPSを管理する</a></li>
      <li><a href="#mozTocId0007">共通のベース基底となるGameObjectを定義して、プレイヤなどはそれを継承する形を設計する</a></li>
      <li><a href="#mozTocId0008">Componentクラスを継承して、プレイヤなどに付け離し再利用可能なコンポーネント指向の機能を設計する</a></li>
      <li><a href="#mozTocId0009">何もない空間をグリッド分割して隣接していない空間に所属するものとの当たり判定をスルーして高速化する</a></li>
      <li><a href="#mozTocId0010">タイル情報を.tsxや.jsonや.csvから読み取りタイルマップを表示する</a></li>
      <li><a href="#mozTocId0011">Map/MapSetting.csvの設定に合わせてタイルとの当たり判定をする</a></li>
      <li><a href="#mozTocId0012">Factory.cppにZako生成などの#includeを集約(依存性の逆転)させてMapでZakoなどの敵を出現スポーンさせる</a></li>
      <li><a href="#mozTocId0013">ItemクラスとItemActionクラスを作成し継承して弾やブロックなどのアイテムを取って使用できるようにする</a></li>
    </ol>
    <br>
    <a id="mozTocId0001" class="mozTocH1">
      <h1>試しにボックス型のタイルをポリゴンを表示してみる</h1>
    </a> (DXの<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId0002">プロジェクトはシューティングの別記事を参考</a>に作っておいてください。<br>
    <p><code>Resource.h と Resource.cppは次の記事を参考に作っておきます→</code><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/polygon3d/index.html#mozTocId0011">画像や音声や3Dのファイルを読み込んで辞書で管理するクラス</a><br>
    </p>
    <p><code>Mapフォルダ</code>を作成して、地形画像ファイル<code>mapchip.png</code>は<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/practice.html#mozTocId0010">2Dアクションゲームの別記事を参考</a>にMap/mapchip.pngで保管されている前提で進めます)</p>
    <p><code>main.cppを新規作成</code>して、分割テクスチャ画像でタイルを正しく表示できるかテストします。</p>
    <p class="source"> #include "DxLib.h"<br>
      <br>
      #include "<b>Resource.h</b>"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(960, 540, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(960, 540);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // タイルマップを読み込む <b>縦8マス、横8マス、縦32ピクセル、横32ピクセル</b><br>
      &nbsp;&nbsp;&nbsp; std::string mapChipPath{ "<b>Map/mapchip.png</b>" };<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath,8,8,32,32)-&gt;Load(); // <b>メソッドチェーン</b> -&gt; でMakeShared読込後にLoadもする<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2Dタイル描画処理(位置x, y, 拡大率, 回転, 画像ID, TRUEなら透過有効)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawRotaGraphF(100, 200, 1.0f, 0, Resource::files[mapChipPath]-&gt;m_handles[<b>2</b>], TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    <p><code>MyDraw.hを新規作成</code>して、3Dで分割テクスチャ画像を描画する関数を準備します。</p>
    <p class="source"> #ifndef MYDRAW_H_<br>
      #define MYDRAW_H_<br>
      <br>
      #include &lt;assert.h&gt; // 画像読込み失敗表示用<br>
      #include &lt;cmath&gt; // std::absを使う<br>
      #include &lt;vector&gt;<br>
      <br>
      #include "DxLib.h"<br>
      #include "Resource.h"<br>
      <br>
      // 3Dのタイルを描くための自作描画系処理のクラス<br>
      class MyDraw<br>
      {<br>
      public:<br>
      <br>
      &nbsp;&nbsp;&nbsp; enum class Plane<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // XYZ平面の指定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 1,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ★デフォルトではDXライブラリ2D座標系に合わせて右手系 &amp; Yの矢印を画面下方向に設定<br>
      &nbsp;&nbsp;&nbsp; //static bool isLeftHanded;<br>
      &nbsp;&nbsp;&nbsp; static VECTOR XYZ_ARROW;<br>
      &nbsp;&nbsp;&nbsp; static bool IsReverseX_Texture;<br>
      &nbsp;&nbsp;&nbsp; static bool IsReverseY_Texture;<br>
      &nbsp;&nbsp;&nbsp; static bool IsReverseZ_Texture;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ★【Y矢印の方向と右手・左手系】の設定に合わせたVECTORを取得<br>
      &nbsp;&nbsp;&nbsp; // このVGetを通せば座標系を統一できる<br>
      &nbsp;&nbsp;&nbsp; // 入力される座標x,y,zは左上を(x,y,z) = (0,0,0)としてZの奥方向をプラス<br>
      &nbsp;&nbsp;&nbsp; // Yをマイナス下方向としたDXライブラリの画面座標系を想定<br>
      &nbsp;&nbsp;&nbsp; static VECTOR VGet(float x, float y, float z)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // DXライブラリの3D描画座標系に変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (XYZ_ARROW.x == 1 &amp;&amp; XYZ_ARROW.y == 1 &amp;&amp; XYZ_ARROW.z == 1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // DX デフォルト2D描画座標系<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DxLib::VGet(x, y, z);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (XYZ_ARROW.x == 1 &amp;&amp; XYZ_ARROW.y == -1 &amp;&amp; XYZ_ARROW.z == 1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // DX 3D描画座標系<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DxLib::VGet(x, -y, z);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR Result;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (XYZ_ARROW.x == 1) Result.x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else Result.x = -x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (XYZ_ARROW.y == 1) Result.y = y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else Result.y = -y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (XYZ_ARROW.z == 1) Result.z = z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else Result.z = -z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Result;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline static VECTOR_D VecAngle(Plane plane, double Angle)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D AngleVec = DxLib::VGetD(0.0F, 0.0F, 0.0F);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 平面に合わせて回転軸を選択<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (plane == Plane::X) AngleVec.x = Angle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (plane == Plane::Y) AngleVec.y = Angle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (plane == Plane::Z) AngleVec.z = Angle;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return AngleVec;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 回転行列からXYZ軸周りの角度(単位:ラジアン)に戻す<br>
      &nbsp;&nbsp;&nbsp; inline static VECTOR_D GetAngle(MATRIX_D rotMat)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double threshold = 0.001;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D radAngle; // XYZ軸周りの角度(単位:ラジアン)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[参考:opencvは左手系なので行列位置は斜め鏡映し逆] https://qiita.com/q_tarou/items/46e5045068742dfb2fa6<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (std::abs(rotMat.m[1][2] - 1.0) &lt; threshold) { // rotMat[1][2] = sin(x) = 1の時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.x = DX_PI / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.y = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.z = std::atan2(rotMat.m[0][1], rotMat.m[0][0]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (std::abs(rotMat.m[1][2] + 1.0) &lt; threshold) { // rotMat[1][2] = sin(x) = -1の時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.x = -DX_PI / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.y = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.z = std::atan2(rotMat.m[0][1], rotMat.m[0][0]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.x = std::asin(rotMat.m[1][2]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.y = std::atan2(-rotMat.m[0][2], rotMat.m[2][2]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radAngle.z = std::atan2(-rotMat.m[1][0], rotMat.m[1][1]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return radAngle;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // UnityにならってfarClipPlane(z方向のどこまで遠いものを描くか)<br>
      &nbsp;&nbsp;&nbsp; // https://qiita.com/shoridevel/items/5c4a249ff09244645c93<br>
      &nbsp;&nbsp;&nbsp; //static int farClipPlane;// = 1000;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラの視点、注視点、アップベクトルを設定する( アップベクトルはＹ軸方向から導き出す )<br>
      &nbsp;&nbsp;&nbsp; static int SetCameraPositionAndTarget_UpVecY(VECTOR Position, VECTOR Target)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手・左手系とY軸矢印の方向に従い座標を変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR Position_COVERT_XYZ = VGet(Position.x, Position.y, Position.z);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR Target_COVERT_XYZ = VGet(Target.x, Target.y, Target.z);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DxLib::SetCameraPositionAndTarget_UpVecY(Position_COVERT_XYZ, Target_COVERT_XYZ);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 画像のビルボード描画(常に面がカメラ向き)( 座標指定が float 版 )<br>
      &nbsp;&nbsp;&nbsp; static int DrawDivBillboardGraphF3D(Plane plane, float xf, float yf, float zf, double ExRate, VECTOR_D Angle, Texture&amp; divTexture, int id, int TransFlag = TRUE, int ReverseXFlag = FALSE, int ReverseYFlag = FALSE, int ReverseZFlag = FALSE)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyDraw::DrawDivRotaGraphF3D(plane, xf, yf, zf, ExRate, Angle, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag, true); // ビルボード描画フラグをtrueに<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 画像の回転描画( 座標指定が float 版 )<br>
      &nbsp;&nbsp;&nbsp; static int DrawDivRotaGraphF(float xf, float yf, double ExRate, double Angle, Texture&amp; divTexture, int id, int TransFlag, int ReverseXFlag = FALSE, int ReverseYFlag = FALSE, int ReverseZFlag = FALSE)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // Zの値を0.0Fとして<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyDraw::DrawDivRotaGraphF3D(Plane::Z, xf, yf, 0.0F, ExRate, Angle, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 画像の回転描画( 座標指定が float 版 )【注意！】現状Angle回転機能は未対応<br>
      &nbsp;&nbsp;&nbsp; static int DrawDivRotaGraphF3D(Plane plane, float xf, float yf, float zf, double ExRate, double Angle, Texture&amp; divTexture, int id, int TransFlag = TRUE, int ReverseXFlag = FALSE, int ReverseYFlag = FALSE, int ReverseZFlag = FALSE)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D AngleVec = VecAngle(plane, Angle);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 角度だけ↓VECTOR化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyDraw::DrawDivRotaGraphF3D(plane, xf, yf, zf, ExRate, AngleVec, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp; // ↓すぐ下のAngleベクタ版関数に引き継ぐ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 画像の回転描画( 座標指定が float 版 )【注意！】現状Angle回転機能は未対応<br>
      &nbsp;&nbsp;&nbsp; static int <b>DrawDivRotaGraphF3D</b>(Plane plane, float xf, float yf, float zf, double ExRate, VECTOR_D Angle, Texture&amp; <b>divTexture</b>, int <b>id</b>, int TransFlag = TRUE, int ReverseXFlag = FALSE, int ReverseYFlag = FALSE, int ReverseZFlag = FALSE, bool isBillboard = false)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 遠すぎるものは描かないで即return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (zf &gt; farClipPlane) return -1;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右手・左手系とY軸矢印の方向に従い座標を変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR COVERT_XYZ = MyDraw::VGet(xf, yf, zf);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float Xf = COVERT_XYZ.x, Yf = COVERT_XYZ.y, Zf = COVERT_XYZ.z;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (id &lt; 0 &amp;&amp; divTexture.m_handles.size() &lt;= id) { assert("div画像id指定範囲外" == ""); return -1; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imageWidth = divTexture.m_XSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imageHeight = divTexture.m_YSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float u_X0 = 0.0F, v_Y0 = 0.0F; //点Vertex[0]のuとvの値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float u_X3 = 1.0F, v_Y3 = 1.0F; //点Vertex[3]のuとvの値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (divTexture.m_XNum &gt; 1 || divTexture.m_YNum &gt; 1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // div分割画像の分割位置確定のため横uと縦vの値を計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int divX = id % divTexture.m_XNum;//分割X列番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int divY = id / divTexture.m_XNum;//分割Y行番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u_X0 = (float)divX / (float)(divTexture.m_XNum);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v_Y0 = (float)divY / (float)(divTexture.m_YNum);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u_X3 = (float)(divX + 1) / (float)(divTexture.m_XNum);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v_Y3 = (float)(divY + 1) / (float)(divTexture.m_YNum);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 【拡大縮小率ExRate】をかけて画像サイズを再計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imageWidth = (int)(imageWidth * ExRate);&nbsp; // 拡大縮小した画像の幅<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imageHeight = (int)(imageHeight * ExRate);// 拡大縮小した画像の高さ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float halfWidth = (float)(imageWidth / 2);//画像幅の1/2(先に計算し使いまわして処理削減)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float halfHeight = (float)(imageHeight / 2);//画像高さの1/2(先に計算し使いまわして処理削減)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //【テクスチャ反転処理】幅halfWidthと高さhalfHeightをマイナスにすることで反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★ReverseXFlagとIsReverseX_Texture両方反転は【反転の反転で=反転しない!】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 【反転の反転で=反転しない!】は★XOR【排他的論理和 ^ 演算子】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [排他的論理和 ^ 演算子]http://www7b.biglobe.ne.jp/~robe/cpphtml/html01/cpp01047.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((IsReverseX_Texture ^ (ReverseXFlag == TRUE))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (plane == Plane::Y || plane == Plane::Z))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // マイナス幅でテクスチャ反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; halfWidth = -halfWidth;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((IsReverseY_Texture ^ (ReverseYFlag == TRUE))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (plane == Plane::X || plane == Plane::Z))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // マイナス幅でテクスチャ反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; halfHeight = -halfHeight;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (IsReverseZ_Texture ^ (ReverseZFlag == TRUE))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // マイナス幅でテクスチャ反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (plane == Plane::X) halfWidth = -halfWidth;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (plane == Plane::Y) halfHeight = -halfHeight;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [頂点VERTEXは四角形は6個必要] https://dixq.net/rp/57.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★CGの【最小単位は三角形】2Dはドットの集合で描くが【CGは三角形の集合で描く】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>VERTEX3D</b> Vertex[6]; // ポリゴン２枚なので、頂点は６個(三角3点×2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // VERTEX3DSHADER Vertex[6]; // シェーダの頂点を使う場合<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★頂点情報のセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // Plane=X なら X平面に(Y,Z) = (yf,zf)中心に描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Plane=Y なら Y平面に(X,Z) = (xf,zf)中心に描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Plane=Z なら Z平面に(X,Y) = (xf,yf)中心に描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 回転は以下リンク参照<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=past&amp;no=2749<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX TransformMatrix;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 回転( x, y, z軸回転の順に回転した後、座標移動行列により平行移動)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★★MMultは行列の乗算【乗算した順にx軸回転→y軸回転→z軸回転→平行移動】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★【複数軸回転は頭が混乱するのでクォータニオンをつかうやり方もある】<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isBillboard)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D billboardAngle = (isBillboard) ? GetAngle(DxLib::GetCameraBillboardMatrixD()) : DxLib::VGetD(0, 0, 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Angle.x += billboardAngle.x; Angle.y += billboardAngle.y; Angle.z += billboardAngle.z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MGetRotX((float)Angle.x);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotY((float)Angle.y));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetRotZ((float)Angle.z));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★【座標移動行列により移動】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransformMatrix = MMult(TransformMatrix, MGetTranslate(VGet(Xf, Yf, Zf)));<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (plane == Plane::X)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //座標固定平面→→→→→→→→→↓X平面指定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[0].pos = VTransform(VGet(0.0F, +halfHeight, -halfWidth), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[1].pos = VTransform(VGet(0.0F, +halfHeight, +halfWidth), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[2].pos = VTransform(VGet(0.0F, -halfHeight, -halfWidth), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[3].pos = VTransform(VGet(0.0F, -halfHeight, +halfWidth), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (plane == Plane::Y)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //座標固定平面→→→→→→→→→→→→→→→→↓Y平面指定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[0].pos = VTransform(VGet(-halfWidth, 0.0F, +halfHeight), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[1].pos = VTransform(VGet(+halfWidth, 0.0F, +halfHeight), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[2].pos = VTransform(VGet(-halfWidth, 0.0F, -halfHeight), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[3].pos = VTransform(VGet(+halfWidth, 0.0F, -halfHeight), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // if (plane == Plane::Z)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //座標固定平面→→→→→→→→→→→→→→→→→→→→→→↓Z平面指定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[0].pos = VTransform(VGet(-halfWidth, +halfHeight, 0.0F), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[1].pos = VTransform(VGet(+halfWidth, +halfHeight, 0.0F), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[2].pos = VTransform(VGet(-halfWidth, -halfHeight, 0.0F), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[3].pos = VTransform(VGet(+halfWidth, -halfHeight, 0.0F), TransformMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[4].pos = Vertex[2].pos; // 点2と点4は同じ位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[5].pos = Vertex[1].pos; // 点1と点5は同じ位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //↑点0 点1&amp;5 点4&amp;2 点3 の4点の四角形を描く<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★div分割画像を考慮に入れて【UV展開】切り出し位置を0.0～1.0で指定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[0].u = u_X0; Vertex[0].v = v_Y0; Vertex[0].su = u_X0; Vertex[0].sv = v_Y0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[1].u = u_X3; Vertex[1].v = v_Y0; Vertex[1].su = u_X3; Vertex[1].sv = v_Y0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[2].u = u_X0; Vertex[2].v = v_Y3; Vertex[2].su = u_X0; Vertex[2].sv = v_Y3;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[3].u = u_X3; Vertex[3].v = v_Y3; Vertex[3].su = u_X3; Vertex[3].sv = v_Y3;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[4].u = u_X0; Vertex[4].v = v_Y3; Vertex[4].su = u_X0; Vertex[4].sv = v_Y3;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[5].u = u_X3; Vertex[5].v = v_Y0; Vertex[5].su = u_X3; Vertex[5].sv = v_Y0;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 輝度(拡散光:Diffuseの明るさ)は全地点100% a(拡散光:Diffuseのアルファ不透明度) も最大値(255=不透明 0=透明)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[0].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[1].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[2].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[3].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[4].dif = GetColorU8(255, 255, 255, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[5].dif = GetColorU8(255, 255, 255, 255);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 鏡面反射光(スペキュラ)は全地点30<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[0].spc = GetColorU8(0, 0, 0, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[1].spc = GetColorU8(0, 0, 0, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[2].spc = GetColorU8(0, 0, 0, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[3].spc = GetColorU8(0, 0, 0, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[4].spc = GetColorU8(0, 0, 0, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[5].spc = GetColorU8(0, 0, 0, 255);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 法線を設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[0].norm = VGet(0.0f, 0.0f, -1.0f); // Vertex[0].binorm = // シェーダーを利用するとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[1].norm = VGet(0.0f, 0.0f, -1.0f); // Vertex[1].binorm = <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[2].norm = VGet(0.0f, 0.0f, -1.0f); // Vertex[2].binorm = <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[3].norm = VGet(0.0f, 0.0f, -1.0f); // Vertex[3].binorm = <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[4].norm = VGet(0.0f, 0.0f, -1.0f); // Vertex[4].binorm = <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertex[5].norm = VGet(0.0f, 0.0f, -1.0f); // Vertex[5].binorm = <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 0 1 2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 5 4 3<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //↑上の順の点で点0 点1&amp;5 点4&amp;2 点3 の4点の四角形を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //DxLib::DrawSphere3D(VGet(Xf, Yf, Zf),1, 4, GetColor(255, 255, 255),GetColor(255, 255, 255),FALSE); // テストとして四角形の中心に目印の球体を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ポリゴンを２枚描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::<b>DrawPolygon3D</b>(Vertex, 2, <b>divTexture[id]</b>, TransFlag);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (divTexture[id] != -1) //[シェーダーを利用する場合] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4204<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; DxLib::SetUseTextureToShader(0, divTexture[id]); // 使用するテクスチャを０番にセット<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // シェーダーを利用して描く場合はこちら https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4204<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //DxLib::DrawPolygon3DToShader(Vertex, 2); // シェーダーにも対応できるようにToShader系関数を通して描く<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // 画像ボックスの回転描画( 座標指定が float 版 )<br>
      &nbsp;&nbsp;&nbsp; static void <b>DrawDivBoxF3D</b>(float xf, float yf, float zf, double ExRate, Texture&amp; divTexture, int id, int TransFlag = TRUE, int ReverseXFlag = FALSE, int ReverseYFlag = FALSE, int ReverseZFlag = FALSE)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imageWidth = (int)((double)divTexture.m_XSize * ExRate);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imageHeight = (int)((double)divTexture.m_YSize * ExRate);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D Angle = VGetD(0,0,0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //サイコロの6面を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(Plane::Y, xf, yf - imageHeight / 2, zf, ExRate, Angle, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(Plane::Y, xf, yf + imageHeight / 2, zf, ExRate, Angle, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // X方向の裏側は左右反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(Plane::X, xf - imageWidth / 2, yf, zf, ExRate, Angle, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, !ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(Plane::X, xf + imageWidth / 2, yf, zf, ExRate, Angle, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(Plane::Z, xf, yf, zf - imageHeight / 2, ExRate, Angle, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Z方向の裏側は左右反転<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(Plane::Z, xf, yf, zf + imageHeight / 2, ExRate, Angle, divTexture, id, TransFlag, !ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 床の回転描画( 座標指定が float 版 )<br>
      &nbsp;&nbsp;&nbsp; static int DrawDivRotaFloorF3D(Plane plane, float xf, float yf, float zf, double ExRate, double Angle, Texture&amp; divTexture, int id, int TransFlag = TRUE, int ReverseXFlag = FALSE, int ReverseYFlag = FALSE, int ReverseZFlag = FALSE)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D AngleVec = VecAngle(plane, Angle);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imageHeight = (int)((double)divTexture.m_YSize * ExRate);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 角度だけ↓VECTOR化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyDraw::DrawDivRotaGraphF3D(plane, xf, yf - imageHeight / 2, zf, ExRate, AngleVec, divTexture, id, TransFlag, ReverseXFlag, ReverseYFlag, ReverseZFlag);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 四角形（枠線のみ）を描画する<br>
      &nbsp;&nbsp;&nbsp; static int DrawLineBox(VECTOR startPos, VECTOR endPos, unsigned int color)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DxLib::DrawCube3D(startPos, endPos, color, color, FALSE);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <p><code>MyDraw.cppを新規作成</code>して、staticに関する定義をします。</p>
    <p class="source"> #include "MyDraw.h"<br>
      <br>
      //int MyDraw::farClipPlane = 1000; // 仮にZ=1000までの遠さのものを描く設定で<br>
      <br>
      // ★デフォルトではDXライブラリ2D座標系に合わせて右手系&amp;Yの矢印を画面下方向に設定<br>
      // http://www.f.waseda.jp/moriya/PUBLIC_HTML/education/classes/infomath6/applet/fractal/coord/<br>
      //bool MyDraw::isLeftHanded = false;<br>
      VECTOR MyDraw::XYZ_ARROW = DxLib::VGet(1, -1, 1);<br>
      <br>
      bool MyDraw::IsReverseX_Texture = false;<br>
      bool MyDraw::IsReverseY_Texture = true;<br>
      bool MyDraw::IsReverseZ_Texture = false;<br>
    </p>
    <br>
    <p><code>main.cpp</code>にプログラムを追加し、MyDrawクラスを通して、ポリゴンでサイコロ状のボックスを描いてみましょう。</p>
    <p class="source"> #include "DxLib.h"<br>
      <br>
      #include "Resource.h"<br>
      <em>#include "MyDraw.h"</em><br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(960, 540, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(960, 540);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // タイルマップを読み込む 縦8マス、横8マス、縦32ピクセル、横32ピクセル<br>
      &nbsp;&nbsp;&nbsp; std::string mapChipPath{ "Map/mapchip.png" };<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath,8,8,32,32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込語にLoadもする<br>
      <em></em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 光の明暗計算を無効に<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>// 2Dタイル描画処理(位置x, y, 拡大率, 回転, 画像ID, TRUEなら透過有効)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawRotaGraphF(100, 200, 1.0f, 0, Resource::files[mapChipPath]-&gt;m_handles[2], TRUE);</u><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0,&nbsp; *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    いかがでしょう？謎のバラバラの変な図形がでちゃいましたか？<br>
    よく眺めてみましょう。お互いがお互いを塗りつぶしあっている感じですね。<br>
    これは、<b>カメラからの距離に応じて塗りつぶすかどうかを決める「Zバッファ」</b>が効いてない状態です。<br>
    Zバッファが効いていない状態では、3Dの図形を描いた順に塗りつぶされます。<br>
    <br>
    <p><code>main.cpp</code>のプログラムを変更し、Zバッファを有効にして描いてみましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Resource.h"<br>
      #include "MyDraw.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(960, 540, 32); // 画面サイズ960×540のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(960, 540);// ウィンドウサイズ960×540(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // タイルマップを読み込む 縦8マス、横8マス、縦32ピクセル、横32ピクセル<br>
      &nbsp;&nbsp;&nbsp; std::string mapChipPath{ "Map/mapchip.png" };<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath,8,8,32,32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込語にLoadもする<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// Ｚバッファを有効にする [Zの深度]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }<br>
    </p>
    <br>
    いかがですか？カメラからの距離に応じてタイルがサイコロ状に描画されましたか?<br>
    <br>
    Zバッファが有効ならば、<b>カメラから見た奥行き(=Z)と、すでにZバッファに塗られているドットの奥行きを比較して、手前のものが上に塗られていきます</b>。<br>
    逆にいうなら、岩の裏に隠れてカメラから見えないアイテムを、アイテムを描く際にZバッファを一時的に有効にしたり、無効にさせたりして、チカチカさせれば、<br>
    岩に隠れているアイテムを一番上に塗りつぶして、目立たせるような演出もできなくはないわけです(岩とかマップすべてがアイテムより先に描かれていればだが)<br>
    <br>
    <br>
    <br>
    <br>
    <a id="mozTocId0002" class="mozTocH1">
      <h1>複数カメラと複数スクリーンで複数プレイヤ視点で3D空間を描けるようにする</h1>
    </a>
    <p><code>Input.hとInput.cppを別記事から作成しておきます→</code><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId50020">Inputクラスを拡張してマウス、キーボード対応させる</a></p>
    <p><code>Vector3.hとVector3.cppを別記事から作成しておきます→</code><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/polygon3d/index.html#mozTocId0013">Vector3に色々な関数を用意して3D空間の当たり判定をする</a></p>
    <br>
    さて、複数のプレイヤで遊べるゲームを作るためには、カメラが複数あって、スクリーンに複数の視点が描ける機能が必要ですよね。<br>
    そう、実は、カメラが複数あるということはそれを描く先であるスクリーンも複数だったり、切り替える場合はスクリーン1枚だったりと、<br>
    カメラとそれを描くスクリーンは関連づいたり切り替わったり「リンクしあう関係に」なるのですね。<br>
    そして、GPUでの3Dの描画過程でも3D上のローカル位置→ワールド位置→カメラからのビュー行列変換→スクリーン射影変換→クリッピング...と、<br>
    <b>カメラの行列変換処理(3D)とスクリーン位置(2D)は、実は行列計算をはさんで表裏一体</b>の近い関係なのです。<br>
    <br>
    では、カメラとスクリーンの数だけ、変換行列がDXライブラリの内部に沢山あるのでしょうか？<br>
    実はそうではなくて、カメラのための変換行列は内部で1つだけ、で運用されています。<br>
    え、そうすると複数カメラ視点はどうやるの？と疑問と不安が出てきそうですが、<br>
    描く処理(=<b>Drawコール</b>)の直前に、その都度、カメラのための変換行列の設定値を変える処理を呼びだして、<br>
    カメラの行列のセッティングを変えたい→3Dを描きたい(=Drawコール)→カメラ行列設定を変えたい→.. 以下繰り返し<br>
    のような「コマンドをセットでまとめてGPUに送り付ける」という方式で、<br>
    画面スクリーン(画面に映らないスクリーンにも描ける)にGPUは処理の結果の数値(色など)を格納している、というわけで、<br>
    実はGPU側からすれば「カメラのセッティングを変えろ！」も「描け！(Drawコール)」もコマンドの1種として、<br>
    沢山の届いた一連のコマンドを「コマンドの順番に沿って たんたん と実行」してるにすぎないわけです。<br>
    <br>
    では、複数のカメラの視点を描くにはどうするかというと、<br>
    ①「描く先のスクリーンを変えろ！」→「カメラの位置などの設定を変えろ！」→...→「現在の行列設定でポリゴンを描け」...<br>
    ②「描く先のスクリーンを変えろ！」→「カメラの位置などの設定を変えろ！」→...→「現在の行列設定でポリゴンを描け」...<br>
    上記の一連のコマンドを、複数あるカメラの数①、②..ぶん繰り返せば、スクリーン①②..には違う視点の映像が描かれていくわけです。<br>
    <br>
    上記の世界観をイメージできると、<a href="https://docs.unity3d.com/ja/2021.3/Manual/optimizing-draw-calls.html">ドローコールに関する話題</a>もなんとなくイメージできるようになります。<br>
    そう、ほんとは、DxLib::DrawPolygonIndexed3DToShaderなどを呼ぶ回数を減らすために<br>
    「点のVertexをサイコロの面全部まとめて詰め込めば一気に6面(12ポリゴンぶん)」12コールのかわりに1回だけDrawコールを呼ぶ工夫など、<br>
    GPUの処理の負荷を下げる努力なども実はできて、アピールポイントにすることもできたりするわけです。<br>
    (点をまとめることはできるが、その点に張るテクスチャ指定は1枚=GPUの設計的に←だからUnityの木[同じ共通テクスチャの]が沢山ある森なんかは1回のドローコールにできるかも)<br>
    とりあえずは、基礎を勉強するために、最も愚直な形で1ポリゴンずつ3Dを描く形から始めているわけです。<br>
    一番愚直なスタンダードで愚かな基礎の経験から始めてこそ、それを工夫して変化させた「発展の発想ができる地力につながるわけなので」<br>
    逆に言うなら「便利に慣れすぎて原型に出会えない損失」のほうが危険な「ドローコールってなんですか状態(遊戯王っすか)」に陥るので。<br>
    (同じようなゲームを繰り替えし作るループでは地力は上がらない、次のゲームを作るためにどんな新たな知識を必要とし出会えたか？)<br>
    DXライブラリのDrawPolygonIndexed3DToShaderという関数を知っていることには、世間的には何の意味もないナンセンスだけども、<br>
    ポリゴンを描く「ドローコール」がGPUにどのように届くかの世界観を持っていることは、Unityにも他のゲームエンジンにも共通する意味のあること。<br>
    逆に言うならば、Unityの便利な関数を使いこなして同じようなゲームを作る作業ループも実はナンセンスを浪費してないか？を一旦振り返る必要がある。<br>
    <br>
    MyDraw.hというファイルの名前をつけてあるのも、マイダイアリー(私の日記)みたいなニュアンスで、<br>
    あくまで個人の見解のプログラムというニュアンスで名付けてあります。個人の見解でおのおのが進化させる余地があるということです。<br>
    <br>
    さて、では本題であるところの複数視点の描画に挑戦していきましょう。<br>
    <br>
    <p><code>Screen.hを新規作成</code>して、デフォルトの画面全体の縦横のサイズと<b>違うサイズの別スクリーンがStar()～End()関数で指定</b>されたときにも、<br>
      視野(FOV=<a href="https://www.youtube.com/watch?v=iqAvAFvlLy0">Field Of View</a>:フィールドのビュー)すなわちスクリーンに描かれる3Dの範囲を StartFov()～EndFov()関数でDraw系関数を囲うことで、<br>
      一時的にカメラの射影変換行列(プロジェクション行列)の幅w 高さhの行列のパラメータを変更した状態で、GPUに描かせることができるようにしましょう。</p>
    <p class="source">#ifndef _SCREEN_H<br>
      #define _SCREEN_H<br>
      <br>
      #include "DxLib.h"<br>
      <br>
      #include "Input.h"<br>
      <br>
      #include &lt;assert.h&gt; // アサート警告表示用<br>
      <br>
      // 画面解像度<br>
      class Screen<br>
      {<br>
      public: //publicはC＃と違いpublic:以下にまとめて書かれるスタイル<br>
      &nbsp;&nbsp;&nbsp; static constexpr int Width = 1280; // 幅(Nintendoスイッチの縦横サイズ[いわゆるHD画質16:9]を採用)<br>
      &nbsp;&nbsp;&nbsp; static constexpr int Height = 720; // 高さ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // X,Yがウィンドウの中にあるか<br>
      &nbsp;&nbsp;&nbsp; static bool IsInsideWindow(int screenX = Input::MouseX, int screenY = Input::MouseY) { return (0 &lt;= screenX &amp;&amp; screenX &lt; Width) &amp;&amp; (0 &lt;= screenY &amp;&amp; screenY &lt; Height); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; static int SubWidth, tmpSubWidth; // 現在指定中のサブのスクリーンの幅:SubWidth と 指定前のスクリーンの幅:tmpSubWidth<br>
      &nbsp;&nbsp;&nbsp; static int SubHeight, tmpSubHeight; // 現在指定中のサブのスクリーンの高さ:SubHeight と 指定前のスクリーンの高さ:tmpSubHeight<br>
      &nbsp;&nbsp;&nbsp; static int DrawHandle; // Start()～End()で指定中のハンドル番号<br>
      &nbsp;&nbsp;&nbsp; static int tmpDrawHandle; // Endまでのあいだ一旦変更前のhandleを退避<br>
      &nbsp;&nbsp;&nbsp; static int tmpResetSetting; // SetDrawScreen切り替え前に 設定を一旦tmpに退避<br>
      &nbsp;&nbsp;&nbsp; static MATRIX_D tmpViewportMatrix; // StartFov前に もとのビューポート行列を一旦退避<br>
      &nbsp;&nbsp;&nbsp; static MATRIX_D tmpProjectionMatrix; // StartFov前に もとの射影変換行列を一旦退避<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 射影変換行列とビューポート行列をスクリーンの大きさに合わせて再設定<br>
      &nbsp;&nbsp;&nbsp; static void StartFov(int handle, double fovAngle = 0)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // [描画の縦横領域が変わっても画角維持] https://dxlib.xsrv.jp/cgi/patiobbs/patio.cgi?mode=view&amp;no=4639<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpViewportMatrix = DxLib::GetCameraViewportMatrixD(); // もとのビューポート行列を一旦退避<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpProjectionMatrix = DxLib::GetCameraProjectionMatrixD(); // もとの射影変換行列を一旦退避<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int handleWidth, handleHeight; // <b>描画するスクリーンのサイズ</b>を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetGraphSize(handle, <b>&amp;handleWidth, &amp;handleHeight</b>);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 射影行列を再設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX_D ProjectionMatrix;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double fovRad = (fovAngle == 0) ? DxLib::GetCameraFovD() : DX_PI * fovAngle / 180.0; // スクリーンに描くカメラの画角の設定 0のときは既存のFOVの設定を適用<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto dotAspect = DxLib::GetCameraDotAspectD(); // スクリーンに描くカメラのドットアスペクト比率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::<b>CreatePerspectiveFovMatrixD</b>(&amp;ProjectionMatrix, fovRad, DxLib::GetCameraNear(), DxLib::GetCameraFar(), (double)<b>handleHeight / handleWidth * dotAspect</b>);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToProjectionD(&amp;ProjectionMatrix); // 射影変換行列をスクリーン幅や高さやFOVの設定に合わせて一時的に再設定<br>
      #if 0 // [参考]デフォルトの射影変換行列のDXライブラリの内部計算<br>
      #define FOV&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (60.0 * DX_PI / 180.0)<br>
      #define NEARZ&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (0.0)<br>
      #define FARZ&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (1000.0)<br>
      #define TAN_FOV_HALF&nbsp;&nbsp;&nbsp; (0.52359877559829887307710723054658) // /*(0.57735026918962573)*/ tan( FOV * 0.5 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (略)...<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>w</b> = GSYS.DrawSetting.DrawSizeX;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>h</b> = GSYS.DrawSetting.DrawSizeY;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D = (double)((h / 2) / TAN_FOV_HALF);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (略)...<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreatePerspectiveFovMatrixD(&amp;mat, FOV, D * 0.1, D + FARZ, -1.0f); // デフォルトの射影変換行列 呼び出し<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (略)...<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↓ デフォルトの射影変換行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX_D mat; // ProjectionMatrix 射影行列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double Sin = std::sin(fov / 2), Cos = std::cos(fov / 2); // tan(θ / 2) = Sin / Cos&nbsp;&nbsp; θ = fovのとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (-0.0001 &lt; Sin &amp;&amp; Sin &lt; 0.0001) return -1;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aspect = (double)MathScreenSizeY / (double)MathScreenSizeX;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double <b>w = aspect * (Cos / Sin); // = 高/幅 / tan( θ / 2 )</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double <b>h = 1.0 * (Cos / Sin); // = 1 / tan( θ / 2 )</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat-&gt;m[0][0] = <b>w</b>;&nbsp;&nbsp; mat-&gt;m[0][1] = 0;&nbsp;&nbsp; mat-&gt;m[0][2] = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat-&gt;m[0][3] = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat-&gt;m[1][0] = 0;&nbsp;&nbsp; mat-&gt;m[1][1] = <b>h</b>;&nbsp;&nbsp; mat-&gt;m[1][2] = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat-&gt;m[1][3] = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat-&gt;m[2][0] = 0;&nbsp;&nbsp; mat-&gt;m[2][1] = 0;&nbsp;&nbsp; mat-&gt;m[2][2] = zFar / (zFar - zNear);&nbsp; mat-&gt;m[2][3] = 1.0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat-&gt;m[3][0] = 0;&nbsp;&nbsp; mat-&gt;m[3][1] = 0;&nbsp;&nbsp; mat-&gt;m[3][2] = -zNear * zFar / (zFar - zNear);&nbsp; mat-&gt;m[3][3] = 0.0;<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビューポート行列の再設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[<b>スクリーン上の3Dの消失点をスクリーンのサイズの1/2の真ん中の位置に設定</b>] https://dxlib.xsrv.jp/function/dxfunc_3d_camera.html#R12N12<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetCameraScreenCenter((float)handleWidth / 2.0f, (float)handleHeight / 2.0f);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 射影変換行列とビューポート行列をStartFovする前に戻す<br>
      &nbsp;&nbsp;&nbsp; static void EndFov()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToProjectionD(&amp;tmpViewportMatrix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetTransformToViewportD(&amp;tmpProjectionMatrix);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ★このStartとEndのあいだの描画処理は別スクリーンに描かれるようになる is3Dに<br>
      &nbsp;&nbsp;&nbsp; static int Start(int handle = DX_SCREEN_BACK, bool is3D = false, double fovAngle = 0)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // スクリーンのハンドルが 0以下 なら普通のスクリーンに描画する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (handle &lt; 0) handle = DX_SCREEN_BACK;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::tmpResetSetting = DxLib::GetUseSetDrawScreenSettingReset(); // 設定を一旦tmpに退避<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseSetDrawScreenSettingReset(FALSE); // SetDrawScreen切り替え時に設定をリセットしない(FALSE)(これをやらないとカメラ視点などがリセットされるから)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::tmpDrawHandle = DxLib::GetDrawScreen(); // Endまでのあいだ一旦変更前のhandleを退避<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetGraphSize(tmpDrawHandle, &amp;tmpSubWidth, &amp;tmpSubHeight); // 現在のスクリーンのサイズを一旦退避<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 描く先を別途用意した別スクリーン(指定されたhandle)に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (DxLib::<b>SetDrawScreen(handle)</b> == -1) DxLib::SetDrawScreen(handle = DX_SCREEN_BACK); // -1 失敗したら普通のDX_SCREEN_BACKのほうに描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::DrawHandle = handle; // 現在選択中のスクリーンのハンドル番号を handleに 変更<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 描画するスクリーンのサイズを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (DxLib::GetGraphSize(handle, &amp;Screen::SubWidth, &amp;Screen::SubHeight) == -1) return handle; // -1 失敗したらreturn<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is3D) // 3Dのときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::<b>StartFov(handle, fovAngle); // 射影変換行列とビューポート行列をスクリーンの大きさに合わせて再設定</b><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return handle;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ★このStartとEndのあいだの描画処理は別スクリーンに描かれるようになる<br>
      &nbsp;&nbsp;&nbsp; static void End(bool is3D = false)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ゲームを描く先をもとのデフォルトに戻しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetDrawScreen(tmpDrawHandle = (tmpDrawHandle &lt; 0) ? DX_SCREEN_BACK : tmpDrawHandle);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::DrawHandle = tmpDrawHandle; // 現在選択中のスクリーンのハンドル番号を handleに 変更<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int beforeSubWidth = Screen::SubWidth, beforeSubHeight = Screen::SubHeight; // Start()で変更した幅と高さを 一時退避<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (DxLib::GetGraphSize(tmpDrawHandle, &amp;Screen::SubWidth, &amp;Screen::SubHeight) == -1) return; // -1 失敗したらreturn<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is3D) // 3Dのときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::<b>EndFov(); // 射影変換行列とビューポート行列をStartFovする前に戻す</b><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseSetDrawScreenSettingReset((tmpResetSetting == -1) ? TRUE : tmpResetSetting); // 設定をStart()前の元に戻す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 指定した screenHandle のキャンバスをきれいにまっさらにクリアする<br>
      &nbsp;&nbsp;&nbsp; static void ClearDrawScreen(int screenHandle)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::Start(screenHandle);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen(); // screenHandle のキャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::End();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };// C＃と違ってクラスの定義も;セミコロンで終わる<br>
      <br>
      <br>
      <br>
      #endif</p>
    <br>
    <p><code>Screen.cppを新規作成</code>して、Start()～End()やStartFov()～EndFov()の間にはさんでDrawコールするあいだ、<br>
      Start()で一時的にパラメータを変更する前のカメラの行列のパラメータを一旦保管するtmp～系変数をstatic定義します。<br>
    </p>
    <p class="source">#include "Screen.h"<br>
      <br>
      <br>
      int Screen::SubWidth{ 0 }, Screen::tmpSubWidth{ 0 }; // 現在指定中のサブのスクリーンの幅:SubWidth と 指定前のスクリーンの幅:tmpSubWidth<br>
      int Screen::SubHeight{ 0 }, Screen::tmpSubHeight{ 0 }; // 現在指定中のサブのスクリーンの高さ:SubHeight と 指定前のスクリーンの高さ:tmpSubHeight<br>
      <br>
      int Screen::DrawHandle{ DxLib::GetDrawScreen() }; // Start()～End()で指定中のハンドル番号<br>
      int Screen::tmpDrawHandle{ -1 }; // Endまでのあいだ一旦変更前のhandleを退避<br>
      int Screen::tmpResetSetting{ -1 }; // SetDrawScreen切り替え前に 設定を一旦tmpに退避<br>
      MATRIX_D Screen::tmpViewportMatrix; // StartFov前に もとのビューポート行列を一旦退避<br>
      MATRIX_D Screen::tmpProjectionMatrix; // StartFov前に もとの射影変換行列を一旦退避<br>
      <br>
    </p>
    Start()で一旦もとからのパラメータをtmp～の変数に退避しておいて、End()でそれを元のパラメータ設定に戻すという方式です。<br>
    <br>
    さて、スクリーンのStart()関数にFOV視野の角度を渡さなければならぬということは、<br>
    当然、カメラ側から現在のFOV視野の角度のセッティングなどをDXライブラリ内部のカメラのビュー行列から得るための関数も必要です。<br>
    さらに、複数カメラがあるということは、カメラの位置も複数持てるように、カメラの初期化コンストラクタやカメラの位置の変数を準備する必要があります。<br>
    <p><code>Camera.hを新規作成</code>して、GetCameraSetting関数などで現在のFov視野角などの情報を得たり、個別にカメラをコンストラクタで初期化できるようにしましょう。</p>
    <p class="source">#ifndef CAMERA_H_<br>
      #define CAMERA_H_<br>
      <br>
      #include &lt;functional&gt; // カメラのDraw関数に「引数として関数=ラムダ式」を渡してカメラのDraw関数の外側の呼び出し元から描画したい処理を渡すことができるようにする<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "MyDraw.h"<br>
      #include "Vector3.h"<br>
      <br>
      <br>
      class Camera<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // カメラの位置(ワールド座標)<br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 pos; // カメラの位置(ワールド座標)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // unionしてx,y,zでもアクセスできるように<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; struct Rotate { double V, H, T; }; // カメラの回転角度定義 DXライブラリの内部行列ではfloatじゃなくてdouble型で保持されているので倍精度のdouble型にした<br>
      &nbsp;&nbsp;&nbsp; Rotate rot{ 0.0, 0.0, 0.0 }; // カメラの3軸の回転角度<br>
      &nbsp;&nbsp;&nbsp; double <b>fovAngle</b> = 0; // カメラをスクリーンに描くときの視野角(0～179度) 0のときはDxLib::GetCameraFovD()で得られる値が適用される<br>
      <br>
      &nbsp;&nbsp;&nbsp; float cameraLookAtHeight{ 0.0f }; // LookAtする対象を見下ろす高さ<br>
      <br>
      &nbsp;&nbsp;&nbsp; int <b>screenHandle</b> = DX_SCREEN_BACK; //<b>カメラを描くスクリーンのハンドル番号</b><br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Camera(Vector3 worldPos) : pos{ worldPos } {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; // デストラクタ<br>
      &nbsp;&nbsp;&nbsp; ~Camera() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラを通して描くスクリーンのハンドル番号を設定する<br>
      &nbsp;&nbsp;&nbsp; void <b>SetScreenHandle</b>(int handle) { <b>screenHandle</b> = handle; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラの位置をセットしなおす<br>
      &nbsp;&nbsp;&nbsp; void SetPosition(Vector3 worldPos)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ワールド座標系として保存<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;pos = worldPos;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 指定されたワールド座標が画面の中心に来るように、カメラの位置を変更する<br>
      &nbsp;&nbsp;&nbsp; void LookAt(Vector3 targetXYZ)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // カメラの位置と向きを設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //MyDraw::SetCameraPositionAndTarget_UpVecY(pos, targetXYZ + Vector3(0, cameraLookAtHeight,0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 注視点はターゲットの座標から cameraLookAtHeight 分だけ高い位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndTarget_UpVecY(this-&gt;pos, targetXYZ + Vector3(0, this-&gt;cameraLookAtHeight, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;rot.H = DxLib::GetCameraAngleHRotateD(); // カメラの水平方向の向きを取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;rot.V = DxLib::GetCameraAngleVRotateD();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;rot.T = DxLib::GetCameraAngleTRotateD();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 現在のDX内部のカメラのビュー行列などに入っているカメラの設定パラメータを得る<br>
      &nbsp;&nbsp;&nbsp; static void <b>GetCameraSettings</b>(VECTOR_D* pPosition, double* pRotV = nullptr, double* pRotH = nullptr, double* pRotT = nullptr,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double* <b>pFov</b> = nullptr, double* pNear = nullptr, double* pFar = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pPosition != nullptr) *pPosition = DxLib::GetCameraPositionD(); // カメラ位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pRotV != nullptr) *pRotV = DxLib::GetCameraAngleVRotateD(); // カメラの角度V<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pRotH != nullptr) *pRotH = DxLib::GetCameraAngleHRotateD(); // カメラの角度H<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pRotT != nullptr) *pRotT = DxLib::GetCameraAngleTRotateD(); // カメラの角度T<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pFov != nullptr) *pFov = DxLib::<b>GetCameraFovD</b>(); // カメラの視野角<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pNear != nullptr) *pNear = DxLib::GetCameraNearD(); // カメラ一番近くの描き始めるレンジ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pFar != nullptr) *pFar = DxLib::GetCameraFarD(); // カメラ一番遠くの描くレンジ<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラの視野角に変更があったら変えて射影変換行列を再計算する (現在と同じfovの数値の場合は再計算をしないで負荷を回避)<br>
      &nbsp;&nbsp;&nbsp; static inline void SetupCamera_PerspectiveD(double fov) { if (DxLib::GetCameraFovD() != fov) DxLib::SetupCamera_PerspectiveD(fov); }<br>
      &nbsp;&nbsp;&nbsp; // カメラの視野角に変更があったら変えて射影変換行列を再計算する (現在と同じfovの数値の場合は再計算をしないで負荷を回避)<br>
      &nbsp;&nbsp;&nbsp; static inline void SetCameraNearFarD(double Near, double Far) { if (DxLib::GetCameraNearD() != Near &amp;&amp; DxLib::GetCameraFarD() != Far) DxLib::SetCameraNearFarD(Near, Far); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラの設定を変える<br>
      &nbsp;&nbsp;&nbsp; static void SetCameraSettings(VECTOR_D* pPosition, double* pRotV, double* pRotH, double* pRotT,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double* pFov = nullptr, double* pNear = nullptr, double* pFar = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pPosition != nullptr &amp;&amp; pRotV != nullptr &amp;&amp; pRotH != nullptr &amp;&amp; pRotT != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngleD(*pPosition, *pRotV, *pRotH, *pRotT);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pFov != nullptr) Camera::<b>SetupCamera_PerspectiveD(*pFov)</b>; // カメラの視野角に変化があったら射影変換行列を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pNear != nullptr &amp;&amp; pFar != nullptr) Camera::SetCameraNearFarD(*pNear, *pFar); // カメラ一番近くから遠くまで描くレンジ<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // このワールドに存在するカメラすべてに対して funcで描きたい処理を渡して 全カメラのスクリーンに対して描画処理を走らせる<br>
      &nbsp;&nbsp;&nbsp; inline void Draw(<b>std::function&lt;void()&gt; drawFunc</b>) noexcept<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D beforeCamPos; // 設定変更前のカメラのパラメータを一旦、保管<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double beforeVRot, beforeHRot, beforeTRot, beforeNear, beforeFar, beforeFov;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Camera::<b>GetCameraSettings</b>(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;<b>beforeFov</b>, &amp;beforeNear, &amp;beforeFar);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::<b>SetCameraPositionAndAngle</b>(this-&gt;pos, this-&gt;rot.V, this-&gt;rot.H, this-&gt;rot.T); // カメラの位置、回転を設定<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Screen::Start</b>(this-&gt;<b>screenHandle</b>, true, this-&gt;<b>fovAngle</b>); // <b>カメラに関連付けられたscreenHandleのスクリーンを描画先にする</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>drawFunc(); // 渡された描画処理を実行</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Screen::End</b>(true); // 描画先を元に戻す<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <b>カメラの設定をもとに戻しておく</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Camera::SetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;<b>beforeFov</b>, &amp;beforeNear, &amp;beforeFar);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    個々のカメラには、上記↑のDraw関数を準備して、その引数に std::function型のdrawfunc 経由で描きたい処理(=関数)を渡せるようにしてあります。<br>
    トリッキーに聞こえるかもしれませんが、関数の引数( )内に関数を渡すのです。<br>
    Draw関数に関数を渡せれば、Draw関数を呼び出す外側から色んなDraw系の処理を使う側が自由に渡せます。<br>
    std::function型のラムダ式ならばそれができます。プログラミングの自由度がめちゃめちゃ上がります。<br>
    <br>
    <br>
    では、実際にそのDraw関数にラムダ式[&amp;]{ ～ }で描画処理を渡してみましょう。<br>
    <p><code>main.cppを変更</code>して、複数カメラ視点、複数カメラで3Dを描いてみましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      <em>#include "Screen.h"<br>
        #include "Camera.h"</em><br>
      #include "Resource.h"<br>
      #include "MyDraw.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(<em>Screen::Width, Screen::Height</em>, 32); // 画面サイズ <em>Width×Height</em>のカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(<em>Screen::Width, Screen::Height</em>);// ウィンドウサイズ <em>Width×Height</em>(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // タイルマップを読み込む 縦8マス、横8マス、縦32ピクセル、横32ピクセル<br>
      &nbsp;&nbsp;&nbsp; std::string mapChipPath{ "Map/mapchip.png" };<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath,8,8,32,32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      <br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <em>// SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する<br>
        &nbsp;&nbsp;&nbsp; // ( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを2つ生成 画面の全体の縦方向サイズの Height / 2 にして、上下分割で配置できるようにする<br>
        &nbsp;&nbsp;&nbsp; int screenHandle0 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
        &nbsp;&nbsp;&nbsp; int screenHandle1 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; // カメラを2つ生成して、2つのカメラ視点を2つのスクリーンにそれぞれ関連付ける<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;std::shared_ptr&lt;Camera&gt;&gt; cameras; // 複数のカメラへのポインタを格納する配列<br>
        &nbsp;&nbsp;&nbsp; cameras.emplace_back(std::make_shared&lt;Camera&gt;(Vector3{ 20,40,-50 })); // カメラ0<br>
        &nbsp;&nbsp;&nbsp; cameras.emplace_back(std::make_shared&lt;Camera&gt;(Vector3{ 80,30,-50 })); // カメラ1<br>
        <br>
        &nbsp;&nbsp;&nbsp; cameras[0]-&gt;screenHandle = screenHandle0; // カメラ0 と スクリーン0 を関連付ける<br>
        &nbsp;&nbsp;&nbsp; cameras[1]-&gt;screenHandle = screenHandle1; // カメラ1 と スクリーン1 を関連付ける</em><br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Screen::ClearDrawScreen(screenHandle0); // 一旦スクリーン0のキャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle1); // 一旦スクリーン1のキャンバスをきれいにまっさらに</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファを有効にする [Zの深度]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 複数のカメラを 範囲 for文 で回す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; camera : cameras)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ラムダ式[&amp;](){ ～ }で{}の外側の変数すべてを &amp; キャプチャで&amp;参照として「Draw関数の内側へ引き連れて」処理できる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw関数() の 外側にある変数 mapChipPath も[&amp;]効果で { } の内側で問題なくアクセスできている↓</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 0);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 70, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 4);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// スクリーン0の内容を画面に描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, 0, screenHandle0, FALSE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, 0, Screen::Width, Screen::Height / 2, GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーン1の内容を画面に描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, Screen::Height / 2, screenHandle1, FALSE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, Screen::Height / 2, Screen::Width, Screen::Height, GetColor(0, 255, 0));</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }<br>
    </p>
    いかがでしょう？複数のカメラ視点からの3Dのビューが、上下複数のスクリーンに描画されたでしょうか？<br>
    (見やすいようにタイルのブロックの数も3つに増やしておきました。)<br>
    ラムダ式は便利なのですが、あまり初心者向けのC++の本には出てきたのを見たことがありません。<br>
    私もC++とは関係ない別言語のJavascript経由で、<a href="https://dqn.sakusakutto.jp/2009/01/javascript_1.html">関数の中に関数を渡せると便利</a>だというニーズに気づきました。<br>
    今回のラムダ式はJavascriptでいうところの、<a href="https://dqn.sakusakutto.jp/2009/01/javascript_2.html">無名関数として3Dブロックを描く処理</a>をdrawfuncとしてDraw関数の引数に渡した形という雰囲気でしょうか。<br>
    ある言語においては基本的な文法が、別の言語では初心者向けではない、みたいな扱いになっていたりするのは機会の損失ですよね。<br>
    大事なのは「文法を実際に使いたくなるシチュエーションに出会えるかどうか」です。<br>
    その意味で今回のDrawへの 無名ラムダ式渡し はぴったりの実例だと思います。<br>
    ラムダ式がなかったら...色んな種類のDraw処理を書き分けるのが...どうするよ...難しくなります。<br>
    <br>
    「それでは今回の文法ニーズを振り返っておきましょう。」<br>
    Start() ～ End() で囲い込むスタイルの書き方のニーズがある。→<a href="https://qiita.com/Ushio/items/446d78c881334919e156">imguiのBegin()～End()囲いの雰囲気</a><br>
    関数の中に関数を渡すにはラムダ式が便利。(C++の入門書にはあまり出てこないので学校で勉強してても卒業まで出会えないことも多い)<br>
    <br>
    今回はDraw関数にdrawfuncとして、描きたい処理を渡すことで、<br>
    <p class="source">void Draw関数 (&nbsp;&nbsp;&nbsp; drawfunc &nbsp;&nbsp;&nbsp;)<br>
      {<br>
      &nbsp;&nbsp;Start() ←カメラやスクリーンの設定を変える(もとの設定を一旦保管しておく)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;drawfunc() ←描きたい処理をはさみこんだ真ん中で実行する<br>
      <br>
      &nbsp;&nbsp;End() ←カメラやスクリーンの設定を元に戻す<br>
      }<br>
    </p>
    以上の処理を割と簡単に書くことができました。<br>
    ん、カメラもDrawStart() ～ DrawEnd() みたいに囲うスタイルにもできるんじゃないかって？<br>
    確かに、できますね。<br>
    要はセッティングの変数をDXライブラリ内部やCameraクラスやScreenクラスが蓄えることができれば、<br>
    Start() ～ End() 方式で設計することもできますね。<br>
    では、ラムダ式が真に威力を発揮するのはどういうときでしょうか？<br>
    たとえばStart() End()でさばけないような、データが複雑な木構造のときに、木の枝をたどって、<br>
    目的のデータにたどりついたら drawfunc を実行するとしたらどうでしょう？<br>
    沢山の関節があるCGデータやフォルダの中にフォルダがあるような木の構造をたどって、<br>
    CGの指だったらある処理を走らせたいとか、<br>
    フォルダをたどった先にあるデータが写真形式だったら写真アイコンを描く、<br>
    とか複雑な構造の場合はラムダ式を渡す形が向いているかもしれません。<br>
    <br>
    <br>
    <br>
    <a id="mozTocId0003" class="mozTocH1">
      <h1>文字タグ判定の代わりに使えるハッシュ(32bit)でカメラにhash32タグをつけて管理する</h1>
    </a> まず、最初にハッシュという言葉は色んな意味で使われている(ハッシュドビーフも)ので区別しなければいけない<br>
    英語圏で＃はハッシュと読まれる。だからハッシュタグのハッシュは＃の意味だ。<br>
    それとは<b>全く異なる</b> <b>情報科学の言葉</b>としても「<a href="https://ja.wikipedia.org/wiki/%E6%9A%97%E5%8F%B7%E5%AD%A6%E7%9A%84%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E9%96%A2%E6%95%B0">暗号学的ハッシュ関数</a>」のようなハッシュという言葉がある。<br>
    今回のハッシュはこちらの情報科学のハッシュ関数に近い概念だ。<br>
    例えば、パスワードは入力された文字の羅列をそのままネットで送信すると、個人情報が「もれ放題」になる。<br>
    なので<b>パスワードの文字の羅列を数字などの羅列に変換するパスワード変換の関数を通して</b>から、ネット経由でサーバーに送られる。<br>
    その変換に「法則性がなければ、ないほど」解読が難しい変換の関数として評価される。<br>
    ただし、忘れてはいけないのは、ある文字の羅列に対して、<br>
    変換した後にできる数字などの羅列が他のパスワードを入力した場合にできるものと同じ(かぶる)だと、<br>
    別の間違ったパスワードでログインできちゃうことになりうる。<br>
    なので、ある文字の羅列に対して、変換後にできる数字などの羅列は「<b>ほぼかぶらない(42億分の1とか)</b>」必要がある。<br>
    <b>ハッシュ関数は、この「変換前のパターンに対して、変換後のパターンが※ほぼかぶらない」性質を持つ色んな数式的関数</b>のことを言う。<br>
    <b>逆にいうと「めっちゃかぶる手抜きのハッシュ関数」の計算ルールも考え出すこともできる</b>。<br>
    例えば、ある数字のパスワードを、あるキーとなる数字で割った余りを変換後のパスワードとするとすると<br>
    <b>パスワードの数字が10だったとする。パスワードをキー:8で割るというハッシュ関数を考える</b>とすると<br>
    <b>パスワード:10 が 変換後:2</b> になる。<br>
    そうすると<b>9ではログインできないが10や18なら余りが2になってログインできるハッシュ関数</b>ができあがる。<br>
    やばいじゃん！と思うかもしれないが<b>ハッシュ関数のルールとはそれが8分の1の確率なのか、42億分の1の確率なのかの違いに過ぎない</b>。<br>
    ハッシュの一致判定とは、<b>ある入力を一定のかぶりにくいルールで変換して、その変換後の出力どうしが一致するか判定すること</b>だ。<br>
    そして、もう一つ着目してほしい点がある。<br>
    8で割ると10が2になって、<b>2桁の10 が 1桁の2 の数字になって数字の桁数が減っている！</b><br>
    これは890とか3桁の数字にも当てはまる。<br>
    そう、<b>どんな入力も一定の桁数内に収めてしまう性質をもったハッシュ関数がありうる</b>のだ。<br>
    今回、<b>導入するhash32はどんな文字の羅列でも32桁の0と1の2進数に収めてしまう性質</b>をもったハッシュ関数が採用されている。<br>
    "Zako0"などの判別タグを、文字列のままデータとしてキープしておくと長い文字列のタグでデータはかさばるし、 <br>
    それよりは、<b>用途が「タグが一致するか」だけなら、文字列のままではなく、hash32型の32桁の0と1のビットとして保管</b>しておいて、<b><br>
      32桁の0,1の数字どうしを判別</b>したほうが、<br>
    <b>メモリの消費量</b>(=32bitで一定)的にも、<b>一致判定の速度的</b>にも(文字列どうしの比較はめちゃ遅いので)効率的になる。<br>
    <br>
    <p><code>MyHash.hを新規作成</code>して、文字列をハッシュのルールに基づいて32桁の0と1に変換してhash32型のタグどうしで一致判定できるようにしましょう。</p>
    <p class="source">#ifndef MYHASH_H_<br>
      #define MYHASH_H_<br>
      <br>
      #include &lt;string&gt;<br>
      #include &lt;stdint.h&gt; // uint32_t 型 32ビットの unsined 数値型に変換する<br>
      <br>
      #define CRC32_TABLE_SIZE (256) // CRC32テーブルの要素数<br>
      <br>
      // 言語 C++ C# など や ビルドするコンパイラ VisualStudioやgccなどに関係なく同じハッシュを計算値できる<br>
      // [参考] https://norizn.hatenablog.com/entry/2020/10/18/145628<br>
      <br>
      // <b>生成済みのCRC32テーブル</b> このテーブルをベースとして使用してハッシュ値を計算する<br>
      static constexpr uint32_t s_crc32_table[CRC32_TABLE_SIZE] =<br>
      {<br>
      &nbsp;&nbsp;&nbsp; 0x00000000, 0x04C11DB7, 0x09823B6E, 0x0D4326D9,<br>
      &nbsp;&nbsp;&nbsp; 0x130476DC, 0x17C56B6B, 0x1A864DB2, 0x1E475005,<br>
      &nbsp;&nbsp;&nbsp; 0x2608EDB8, 0x22C9F00F, 0x2F8AD6D6, 0x2B4BCB61,<br>
      &nbsp;&nbsp;&nbsp; 0x350C9B64, 0x31CD86D3, 0x3C8EA00A, 0x384FBDBD,<br>
      &nbsp;&nbsp;&nbsp; 0x4C11DB70, 0x48D0C6C7, 0x4593E01E, 0x4152FDA9,<br>
      &nbsp;&nbsp;&nbsp; 0x5F15ADAC, 0x5BD4B01B, 0x569796C2, 0x52568B75,<br>
      &nbsp;&nbsp;&nbsp; 0x6A1936C8, 0x6ED82B7F, 0x639B0DA6, 0x675A1011,<br>
      &nbsp;&nbsp;&nbsp; 0x791D4014, 0x7DDC5DA3, 0x709F7B7A, 0x745E66CD,<br>
      &nbsp;&nbsp;&nbsp; 0x9823B6E0, 0x9CE2AB57, 0x91A18D8E, 0x95609039,<br>
      &nbsp;&nbsp;&nbsp; 0x8B27C03C, 0x8FE6DD8B, 0x82A5FB52, 0x8664E6E5,<br>
      &nbsp;&nbsp;&nbsp; 0xBE2B5B58, 0xBAEA46EF, 0xB7A96036, 0xB3687D81,<br>
      &nbsp;&nbsp;&nbsp; 0xAD2F2D84, 0xA9EE3033, 0xA4AD16EA, 0xA06C0B5D,<br>
      &nbsp;&nbsp;&nbsp; 0xD4326D90, 0xD0F37027, 0xDDB056FE, 0xD9714B49,<br>
      &nbsp;&nbsp;&nbsp; 0xC7361B4C, 0xC3F706FB, 0xCEB42022, 0xCA753D95,<br>
      &nbsp;&nbsp;&nbsp; 0xF23A8028, 0xF6FB9D9F, 0xFBB8BB46, 0xFF79A6F1,<br>
      &nbsp;&nbsp;&nbsp; 0xE13EF6F4, 0xE5FFEB43, 0xE8BCCD9A, 0xEC7DD02D,<br>
      <br>
      &nbsp;&nbsp;&nbsp; 0x34867077, 0x30476DC0, 0x3D044B19, 0x39C556AE,<br>
      &nbsp;&nbsp;&nbsp; 0x278206AB, 0x23431B1C, 0x2E003DC5, 0x2AC12072,<br>
      &nbsp;&nbsp;&nbsp; 0x128E9DCF, 0x164F8078, 0x1B0CA6A1, 0x1FCDBB16,<br>
      &nbsp;&nbsp;&nbsp; 0x018AEB13, 0x054BF6A4, 0x0808D07D, 0x0CC9CDCA,<br>
      &nbsp;&nbsp;&nbsp; 0x7897AB07, 0x7C56B6B0, 0x71159069, 0x75D48DDE,<br>
      &nbsp;&nbsp;&nbsp; 0x6B93DDDB, 0x6F52C06C, 0x6211E6B5, 0x66D0FB02,<br>
      &nbsp;&nbsp;&nbsp; 0x5E9F46BF, 0x5A5E5B08, 0x571D7DD1, 0x53DC6066,<br>
      &nbsp;&nbsp;&nbsp; 0x4D9B3063, 0x495A2DD4, 0x44190B0D, 0x40D816BA,<br>
      &nbsp;&nbsp;&nbsp; 0xACA5C697, 0xA864DB20, 0xA527FDF9, 0xA1E6E04E,<br>
      &nbsp;&nbsp;&nbsp; 0xBFA1B04B, 0xBB60ADFC, 0xB6238B25, 0xB2E29692,<br>
      &nbsp;&nbsp;&nbsp; 0x8AAD2B2F, 0x8E6C3698, 0x832F1041, 0x87EE0DF6,<br>
      &nbsp;&nbsp;&nbsp; 0x99A95DF3, 0x9D684044, 0x902B669D, 0x94EA7B2A,<br>
      &nbsp;&nbsp;&nbsp; 0xE0B41DE7, 0xE4750050, 0xE9362689, 0xEDF73B3E,<br>
      &nbsp;&nbsp;&nbsp; 0xF3B06B3B, 0xF771768C, 0xFA325055, 0xFEF34DE2,<br>
      &nbsp;&nbsp;&nbsp; 0xC6BCF05F, 0xC27DEDE8, 0xCF3ECB31, 0xCBFFD686,<br>
      &nbsp;&nbsp;&nbsp; 0xD5B88683, 0xD1799B34, 0xDC3ABDED, 0xD8FBA05A,<br>
      <br>
      &nbsp;&nbsp;&nbsp; 0x690CE0EE, 0x6DCDFD59, 0x608EDB80, 0x644FC637,<br>
      &nbsp;&nbsp;&nbsp; 0x7A089632, 0x7EC98B85, 0x738AAD5C, 0x774BB0EB,<br>
      &nbsp;&nbsp;&nbsp; 0x4F040D56, 0x4BC510E1, 0x46863638, 0x42472B8F,<br>
      &nbsp;&nbsp;&nbsp; 0x5C007B8A, 0x58C1663D, 0x558240E4, 0x51435D53,<br>
      &nbsp;&nbsp;&nbsp; 0x251D3B9E, 0x21DC2629, 0x2C9F00F0, 0x285E1D47,<br>
      &nbsp;&nbsp;&nbsp; 0x36194D42, 0x32D850F5, 0x3F9B762C, 0x3B5A6B9B,<br>
      &nbsp;&nbsp;&nbsp; 0x0315D626, 0x07D4CB91, 0x0A97ED48, 0x0E56F0FF,<br>
      &nbsp;&nbsp;&nbsp; 0x1011A0FA, 0x14D0BD4D, 0x19939B94, 0x1D528623,<br>
      &nbsp;&nbsp;&nbsp; 0xF12F560E, 0xF5EE4BB9, 0xF8AD6D60, 0xFC6C70D7,<br>
      &nbsp;&nbsp;&nbsp; 0xE22B20D2, 0xE6EA3D65, 0xEBA91BBC, 0xEF68060B,<br>
      &nbsp;&nbsp;&nbsp; 0xD727BBB6, 0xD3E6A601, 0xDEA580D8, 0xDA649D6F,<br>
      &nbsp;&nbsp;&nbsp; 0xC423CD6A, 0xC0E2D0DD, 0xCDA1F604, 0xC960EBB3,<br>
      &nbsp;&nbsp;&nbsp; 0xBD3E8D7E, 0xB9FF90C9, 0xB4BCB610, 0xB07DABA7,<br>
      &nbsp;&nbsp;&nbsp; 0xAE3AFBA2, 0xAAFBE615, 0xA7B8C0CC, 0xA379DD7B,<br>
      &nbsp;&nbsp;&nbsp; 0x9B3660C6, 0x9FF77D71, 0x92B45BA8, 0x9675461F,<br>
      &nbsp;&nbsp;&nbsp; 0x8832161A, 0x8CF30BAD, 0x81B02D74, 0x857130C3,<br>
      <br>
      &nbsp;&nbsp;&nbsp; 0x5D8A9099, 0x594B8D2E, 0x5408ABF7, 0x50C9B640,<br>
      &nbsp;&nbsp;&nbsp; 0x4E8EE645, 0x4A4FFBF2, 0x470CDD2B, 0x43CDC09C,<br>
      &nbsp;&nbsp;&nbsp; 0x7B827D21, 0x7F436096, 0x7200464F, 0x76C15BF8,<br>
      &nbsp;&nbsp;&nbsp; 0x68860BFD, 0x6C47164A, 0x61043093, 0x65C52D24,<br>
      &nbsp;&nbsp;&nbsp; 0x119B4BE9, 0x155A565E, 0x18197087, 0x1CD86D30,<br>
      &nbsp;&nbsp;&nbsp; 0x029F3D35, 0x065E2082, 0x0B1D065B, 0x0FDC1BEC,<br>
      &nbsp;&nbsp;&nbsp; 0x3793A651, 0x3352BBE6, 0x3E119D3F, 0x3AD08088,<br>
      &nbsp;&nbsp;&nbsp; 0x2497D08D, 0x2056CD3A, 0x2D15EBE3, 0x29D4F654,<br>
      &nbsp;&nbsp;&nbsp; 0xC5A92679, 0xC1683BCE, 0xCC2B1D17, 0xC8EA00A0,<br>
      &nbsp;&nbsp;&nbsp; 0xD6AD50A5, 0xD26C4D12, 0xDF2F6BCB, 0xDBEE767C,<br>
      &nbsp;&nbsp;&nbsp; 0xE3A1CBC1, 0xE760D676, 0xEA23F0AF, 0xEEE2ED18,<br>
      &nbsp;&nbsp;&nbsp; 0xF0A5BD1D, 0xF464A0AA, 0xF9278673, 0xFDE69BC4,<br>
      &nbsp;&nbsp;&nbsp; 0x89B8FD09, 0x8D79E0BE, 0x803AC667, 0x84FBDBD0,<br>
      &nbsp;&nbsp;&nbsp; 0x9ABC8BD5, 0x9E7D9662, 0x933EB0BB, 0x97FFAD0C,<br>
      &nbsp;&nbsp;&nbsp; 0xAFB010B1, 0xAB710D06, 0xA6322BDF, 0xA2F33668,<br>
      &nbsp;&nbsp;&nbsp; 0xBCB4666D, 0xB8757BDA, 0xB5365D03, 0xB1F740B4,<br>
      };<br>
      <br>
      // 言語 C++ C# など や ビルドするコンパイラ VisualStudioやgccなどに関係なく変換後が同じになるハッシュ値を計算する<br>
      class hash32<br>
      <b>#ifdef _DEBUG</b> // [デバッグビルド時だけ _DEBUG が定義] デバッグのときだけ std::string を継承して文字列と同じ扱いにできる(メモリ量は無駄なのでReleaseビルドのときは継承させない)<br>
      &nbsp;&nbsp;&nbsp; : protected std::string // [std::stringはデストラクタがvirtualではないのでprotected:継承] https://mahou-ptr.hatenablog.com/entry/2017/12/05/163120<br>
      <b>#endif</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [std::stringを継承するときの注意点] https://qiita.com/samakusa/items/d6f0bf48a3f1e72edae1<br>
      {<br>
      public:<br>
      <b>#ifndef _DEBUG</b> // Releaseビルドのときは コンストラクタに constexpr をつけて、ビルド中のうちに文字列からハッシュ値へ事前計算を走らせる<br>
      &nbsp;&nbsp;&nbsp; <b>constexpr</b><br>
      <b>#endif</b><br>
      &nbsp;&nbsp;&nbsp; inline hash32(const char* str) : m_hash{ hashcode(str, std::string(str).length()) }<br>
      <b>#ifdef _DEBUG</b> // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; ,std::string(str) // Releaseビルドのときはstd::stringは継承されないのでメモリ量は32ビットになり、コンパクトになる<br>
      <b>#endif</b><br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ちょっと読みにくいけど ここがコンストラクタになってる<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <b>#ifndef _DEBUG</b> // Releaseビルドのときは コンストラクタに constexpr をつけて、ビルド中のうちに文字列からハッシュ値へ事前計算を走らせる<br>
      &nbsp;&nbsp;&nbsp; constexpr<br>
      <b>#endif</b><br>
      &nbsp;&nbsp;&nbsp; inline hash32(const std::string &amp; str) : m_hash{ hashcode(str.c_str(), str.length()) }<br>
      <b>#ifdef _DEBUG</b> // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;&nbsp;&nbsp; ,std::string(str) // Releaseビルドのときはstd::stringは継承されないのでメモリ量は32ビットになり、コンパクトになる<br>
      <b>#endif</b><br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ちょっと読みにくいけど ここがコンストラクタになってる<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <b>#ifdef _DEBUG</b> // デバッグ機能(デバッグの時だけ _DEBUG が定義)<br>
      &nbsp;&nbsp;&nbsp; ~hash32() { std::string().swap(*this); } // デバッグのときだけ念のため継承しているstd::stringを空のstd::string()とswapしておく(stringにはvirtualデストラクタがない)<br>
      <b>#endif</b><br>
      <br>
      &nbsp;&nbsp;&nbsp; // <b>文字列からハッシュ値を計算して返す</b><br>
      &nbsp;&nbsp;&nbsp; static <b>constexpr</b> uint32_t <b>hashcode</b>(const char* str, const size_t length)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // CRC32 Hashの特徴: 計算が簡単で速い 広く利用されている　ハッシュの衝突が発生する確率が低い(1/43億) ハードウェアでの実装が容易<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t hash = 0xffffffff; //[CRC32] https://norizn.hatenablog.com/entry/2020/10/18/145628<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0; i &lt; length; ++i) //[CRC32] https://qiita.com/He3-toolbox/items/3c40ca4b744bad2c0e04<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hash = (hash &lt;&lt; 8) ^ s_crc32_table[((hash &gt;&gt; 24) ^ str[i]) &amp; 0xff];<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hash;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 一致演算子 hash32型 どうしを比較する std::unordered_mapなどのキーにするときにも比較は必須<br>
      &nbsp;&nbsp;&nbsp; constexpr inline bool operator == (const hash32 &amp; other) const { return this-&gt;m_hash == other.m_hash; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 不一致演算子 hash32型 どうしを比較する std::unordered_mapなどのキーにするときにも比較は必須<br>
      &nbsp;&nbsp;&nbsp; constexpr inline bool operator != (const hash32 &amp; other) const { return this-&gt;m_hash != other.m_hash; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 一致演算子 m_hashの値が一致するか判定<br>
      &nbsp;&nbsp;&nbsp; constexpr inline bool operator == (const char* str) const { return m_hash == hashcode(str, std::string(str).length()); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 不一致演算子<br>
      &nbsp;&nbsp;&nbsp; <b>constexpr</b> inline bool operator != (const char* str) const { return m_hash != hashcode(str, std::string(str).length()); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 一致演算子 m_hashの値が一致するか判定<br>
      &nbsp;&nbsp;&nbsp; <b>constexpr</b> inline bool operator == (const std::string &amp; str) const { return m_hash == hashcode(str.c_str(), str.length()); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 一致演算子 m_hashの値が一致するか判定<br>
      &nbsp;&nbsp;&nbsp; <b>constexpr</b> inline bool operator != (const std::string &amp; str) const { return m_hash != hashcode(str.c_str(), str.length()); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ハッシュ値を取得<br>
      &nbsp;&nbsp;&nbsp; <b>constexpr</b> inline operator uint32_t() const { return m_hash; }<br>
      <br>
      private:<br>
      &nbsp;&nbsp;&nbsp; // 文字列から変換した ハッシュ値<br>
      &nbsp;&nbsp;&nbsp; uint32_t m_hash{ 0 }; // 同じ文字列からは必ず同じハッシュ値に計算変換されるので、文字列を比較せずにすむ(文字列の比較は計算が重たいので回避できる)<br>
      };<br>
      <br>
      // <b>std::unordered_map で 自作クラスをキーにできるようにするには operator() と == 一致演算子が必須</b>&nbsp; https://qiita.com/izmktr/items/8e0fd1b6e37de59a9bd0<br>
      namespace std {<br>
      &nbsp;&nbsp;&nbsp; template&lt;&gt;<br>
      &nbsp;&nbsp;&nbsp; class hash&lt;<b>hash32</b>&gt; {<br>
      &nbsp;&nbsp;&nbsp; public: //[<b>std::unordered_mapのキー が uint32_t型のとき</b>の 速度やメモリ使用量比較] https://tech.preferred.jp/ja/blog/sparse-vector/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t operator () (const hash32&amp; hash) const { return std::hash&lt;uint32_t&gt;()(hash); }<br>
      &nbsp;&nbsp;&nbsp; };<br>
      }<br>
      <br>
      // "Zako0"_hash32 などのように 文字列 "～" の後ろに_hash32 をつけるとhash32型 -&gt; uint32_tに変換される オペレータ""_hash32 を定義<br>
      <b>constexpr</b> uint32_t operator""_hash32(const char* str, std::size_t length) // [参考] https://cpprefjp.github.io/lang/cpp11/user_defined_literals.html<br>
      {<br>
      &nbsp;&nbsp;&nbsp; return hash32::hashcode(str, length); // hash32型のハッシュルールで32ビットのuint型に変換して返す<br>
      }<br>
      <br>
      #endif<br>
    </p>
    <br>
    さて、いろいろ難しいコードがでてきたが、最初のほうに出てきたのは<a href="https://ja.wikipedia.org/wiki/%E5%B7%A1%E5%9B%9E%E5%86%97%E9%95%B7%E6%A4%9C%E6%9F%BB">CRC-32 で32桁への変換をするため</a> のテーブルである。<br>
    詳細はwikiをみてもらえば、数学者であれば完全理解できると思うので、そのへんの解説は↑wikiに譲るとしよう。<br>
    <br>
    今回作成したのはhash32クラスである。<br>
    このクラスには<b>「仕掛け」</b>がしてある。<br>
    デバッグ用ビルド ではデバック用に class hash32 : protected std::string の:継承の形でstd::string型を継承して文字タグを残しておき、<br>
    本番リリース用ビルドでは、<b>#ifndef _DEBUG マクロ の効果</b>で↑ 文字タグを継承せず、完全に純粋な32桁の0と1の32bitぶんのデータしか持たず、<br>
    リリース時には文字列タグのムダなメモリ使用を打ち消す工夫が「仕掛け」てある。<br>
    <br>
    さらに、<b>第2の「仕掛け」</b>として、<br>
    == 一致判定 や != 不一致判定の 演算子オペレータoperator の先頭に<br>
    <b>constexpr</b> を付けてある。<br>
    <a href="https://qiita.com/saltheads/items/dd65935878a0901fe9e7">constexprとは何か</a>というと、<br>
    [再生ビルド]ボタンを押して、<b>コンパイルをしている最中に計算できる数値はビルド中に事前計算しておいてくれる</b>ものだ。<br>
    例えば、if (tag == "Zako0") という判別するプログラムがあったとする。<br>
    tag が ただのstd::string型であれば、ゲームの実行中に tag が"Zako0" と一致するかの遅くてムダな計算が走る。<br>
    constexpr をつけたhash32の == オペレータならば<b>[再生ビルド]ボタンを押してビルドをしている最中に"Zako0"が32桁のビットとして事前に計算されうる</b>ので<br>
    ゲームを起動して遊んでいる最中には、ムダな文字列のハッシュへの変換処理も、文字列どうしの比較一致判定処理も まったくいらなくなる。<br>
    <br>
    hash32クラスの導入も簡単だ。<br>
    <b>std::string tag; // 文字列タグ<br>
      ↓<br>
      hash32 tag; // hash32タグ</b> <br>
    たった<b>これだけの変更で、もとの if (tag == "Zako0") の判定の部分は変えなくても高速な32桁の数値どうしの一致判定に変わる</b>。<br>
    <b>必要なのは「hash32とは何なのか」を理解して「自分の言葉で説明できること」</b>のみ。<br>
    (当然「自分の言葉で説明できない」場合は「ハッシュ判定のありがたみ」はわからないわけなのでその人にとっては使う意味もない)<br>
    <br>
    さて、<b>第3の「仕掛け」</b>も理解しておこう。<br>
    今回導入したハッシュ関数の数式の変換ルールは<br>
    <b>「C#やC++などの言語やVisualStudioやgccやclangなどのビルドするコンパイラ」が違っても同じハッシュ値になる</b><br>
    という性質をもっている。<br>
    C++にもデフォルトの std::hash でハッシュ値を計算する機能がある。<br>
    じゃあ、なぜデフォルトを使わないか？<br>
    <b>今回導入したハッシュ関数[CRC32]ならば、ウィンドウズ上でセーブしたデータもスマホのiPhone上でセーブしたデータもハッシュ値に一貫性</b>がある。<br>
    つまり、スマホでセーブしたデータをウィンドウズ上で続きをあそぶときにも、<br>
    "Zako0"のhash32タグが010100001010...32桁のビット値としてスマホでセーブされていれば、<br>
    ウィンドウズでゲームを再開して、セーブされた010100001010...32桁のタグの数値は、ちゃんと"Zako0"として一致判定できるということだ。<br>
    <b>CRC32というルールで変換された、というルールさえ一致していれば、きちんと環境が違っても変換結果は一致</b>する。<br>
    デフォルトの std::hash を使った場合はどうなるか？<br>
    std::hash はVisualStudio(ウインドウズ)やclang(スマホiPhone)のビルドする環境によって、違うハッシュルールでビルドされる可能性がある。(環境依存)<br>
    ゆえに、デフォルトのstd::hashでは変換後の数値をセーブして引き継ぎたいときにはまったくあてにならない。<br>
    <b>どうせハッシュを使うなら「CRC32というルールで保存するぞ」と明確に変換ルールを決めて運用するほうが、機動力や互換性が高くなる</b>。<br>
    <br>
    ゆえに、hash32は保存データを伴うプログラムを作る上での「基本インフラ」として組み込むニーズがある。<br>
    MyRandomクラスの乱数生成のメルセンヌツイスタと同じような「基本の情報科学的インフラ」として、持っておいて損はない。<br>
    では、実際にこのMyHash.hを使って、カメラにhash32でタグを振ってみよう。<br>
    <br>
    <p><code>main.cppを変更</code>して、hash32でカメラをstd::vectorではなくstd::unordered_mapの辞書にhash32タグを振って管理してみましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Screen.h"<br>
      #include "Camera.h"<br>
      <em>#include "MyHash.h"</em><br>
      #include "Resource.h"<br>
      #include "MyDraw.h"<br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ Width×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ Width×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // タイルマップを読み込む 縦8マス、横8マス、縦32ピクセル、横32ピクセル<br>
      &nbsp;&nbsp;&nbsp; std::string mapChipPath{ "Map/mapchip.png" };<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath,8,8,32,32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      <br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp; // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する<br>
      &nbsp;&nbsp;&nbsp; // ( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを2つ生成 画面の全体の縦方向サイズの Height / 2 にして、上下分割で配置できるようにする<br>
      &nbsp;&nbsp;&nbsp; int screenHandle0 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      &nbsp;&nbsp;&nbsp; int screenHandle1 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラを2つ生成して、2つのカメラ視点を2つのスクリーンにそれぞれ関連付ける<br>
      &nbsp;&nbsp;&nbsp; <em>std::unordered_map&lt;hash32, </em>std::shared_ptr&lt;Camera&gt;&gt; cameras; // 複数のカメラへのポインタを格納する<em>タグを振った辞書</em>配列<br>
      &nbsp;&nbsp;&nbsp; cameras.emplace<em>("カメラ0", </em>std::make_shared&lt;Camera&gt;(Vector3{ 20,40,-50 })); // カメラ0<br>
      &nbsp;&nbsp;&nbsp; cameras.emplace<em>("カメラ1", </em>std::make_shared&lt;Camera&gt;(Vector3{ 80,30,-50 })); // カメラ1<br>
      <br>
      &nbsp;&nbsp;&nbsp; cameras<em>["カメラ0"]</em>-&gt;screenHandle = screenHandle0; // カメラ0 と スクリーン0 を関連付ける<br>
      &nbsp;&nbsp;&nbsp; cameras<em>["カメラ1"]</em>-&gt;screenHandle = screenHandle1; // カメラ1 と スクリーン1 を関連付ける<br>
      &nbsp;&nbsp; &nbsp;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle0); // 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle1); // 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファを有効にする [Zの深度]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 複数のカメラを 範囲 for文 で回す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; camera : cameras)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ラムダ式[&amp;](){ ～ }で{}の外側の変数すべてを &amp; キャプチャで&amp;参照として「Draw関数の内側へ引き連れて」処理できる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera<em>.second</em>-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw関数() の 外側にある変数 mapChipPath も[&amp;]効果で { } の内側で問題なくアクセスできている↓<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 70, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 4);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if (camera.first == "カメラ0") <b>//←"カメラ0"はビルド時に事前にハッシュ値が計算され、文字列ではない数値とおきかわっている</b><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらがカメラ0", GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (camera.first == "カメラ1")<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらはカメラ1", GetColor(0, 255, 0));</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーン0の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, 0, screenHandle0, FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, 0, Screen::Width, Screen::Height / 2, GetColor(255, 0, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーン1の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, Screen::Height / 2, screenHandle1, FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, Screen::Height / 2, Screen::Width, Screen::Height, GetColor(0, 255, 0));<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    いかがでしょう？ちゃんと上の画面に赤色の文字で「こちらがカメラ0」、下の画面に緑色の文字で「こららはカメラ1、現場からお伝えします」と出てきましたでしょうか？<br>
    <br>
    一応お伝えしておきますが、CRC32についてはwebで検索すればでてきますが、<br>
    hash32クラスはこの記事で作成したクラスなので当然、web検索してもでてきません。<br>
    std::stringを継承してあたかも文字列のように扱える設計も特にweb検索してもでてくるはずがないです。<br>
    つまり、使うユーザー側が 記事の内容や意図を理解 して、使わない限りは「<b>文字列タグで一致判定しているのとほぼ変わらない</b>」ということです。<br>
    <b>std::のライブラリだって「使う側が特性を理解して使わない限りはプログラムの動作や速度をカスタマイズできない」のと同じ</b>です。<br>
    AIやChatGPTだってそうです。便利な時代になっても、<b>どのみち求められているのは「使う側の基礎知識 = 地力」</b>なのです。<br>
    <br>
    数学すべてを理解する必要はないが「<a href="https://www.1101.com/nintendo/pikmin3/2013-07-19.html">物事の本質や道理を把握するちから</a>」は大事なのです。<br>
    プログラムや数学の専門家じゃない任天堂の宮本先生でも「原理と機能を把握するちから = 地力」は持っている。<br>
    ゲームが計算機をベースにしている以上、その原理や源流を脳みそからシャットアウトする人には、新しいものを生み出す機会を損失するリスクが伴うということです<br>
    誰だって「原理や機能を把握する地力のあるかしこい人」と仕事するほうが実力が発揮できる現場になる、のは あたりまえでしょう。<br>
    その能力はむしろ「ゲームをプランニングするプランナ側」に必要な能力です。プログラマの能力を最大限に引き出される現場で働きたいでしょう。<br>
    ゲームの学科などではプログラミングをあきらめた人がゲームのプランナを逃げで選択し、プログラミングを続ける人を逆に使う側になったりしがちですが、<br>
    ゲームのプランニングはプログラミングやCGやデザインなど確固たるバックグラウンドに持った地力のある人が仕切るほうが対話が現場で生まれ実力が引き出されると思います。<br>
    <br>
    数学やプログラムより、むしろ大事なのは<b>「むずかしいことを自分のことばで把握して説明できること = 脳力」(ものわかりのよさ、話のわかるひと)</b>ではないでしょうか。<br>
    技術側は技術を自分のことばで説明する能力を持つ、それを活かす側はその話を理解できるよう基礎に興味を持ちきちんと時代ともに追いかける、それが理想的開発現場です。<br>
    <br>
    <br>
    <br>
    <br>
    <a id="mozTocId0004" class="mozTocH1">
      <h1>ワールドを定義して、複数プレイヤと複数カメラをワールドに保持する</h1>
    </a>
    <p><code>別記事でImageフォルダにImage/<a href="image/pikkoron.png">pikkoron.png</a>と新たに別に自作したImage/<a

          href="image/satan.png">satan.png</a>を保存しておいてください</code><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/practice.html#mozTocId0008">→CharaMELで自作のキャラのタイル分割画像を作る</a></p>
    <br>
    Unityなどゲームエンジンには「シーン」などの概念がある。<br>
    「シーン」の下に複数のカメラや複数のゲームオブジェクトがヒエラルキーとしてぶら下がっている。<br>
    シーンを閉じるとともにぶら下がっている複数のゲームオブジェクトを巻き込んで「道ずれにシーンごとリセット」される。<br>
    シーンをまたぐためには「<a href="https://rurugamedev-blog.com/entry/2023/04/13/%E3%80%90Unity%E3%80%91SingletonMonobehaviour%E3%81%A8%E3%81%AF%EF%BC%9F%E7%9B%AE%E7%9A%84%E3%82%84%E4%BD%BF%E3%81%84%E6%96%B9%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E8%A7%A3%E8%AA%AC">別シーンをロードしても消えないDontDestoroyOnLoadを前提としたSingletonMonoBehaviorなど</a>」がパターンとして使われる。<br>
    ゆえに、プレイヤが扉に入って、別ワールドに移動するような場合「シーン切り替え=ワールド移動」のようにイメージされていると思う。<br>
    じゃあ、例えばプレイヤ①がワールド①にいて、プレイヤ②がワールド①からワールド②に扉で移動するとしたケースでは、<br>
    ワールド①とワールド② を シーン①とシーン② のように設計しているとすると、シーン②をLoadするときにシーン①が消えてしまうではないか。<br>
    (ワールド①をDontDestoroyOnLoadにしたときには、シーン①とシーン②のステージのXYZ座標のエリアが「かぶらないように」しないと、2つのステージがごっちゃになった世界になっちゃう)<br>
    ゆえに、今回は「シーン」という概念と「ワールド」という概念を明確に区別する設計をしてみよう。<br>
    「シーン」の下に複数の「ワールド」がぶら下がるような設計をするためには、<br>
    複数のカメラやゲームオブジェクトの保持(と道連れリセット)は「ワールド」にて分担する形がいい。<br>
    <br>
    今回は先行して「ワールド」のみの設計に集中する。<br>
    設計するにあたり、<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId00073">シューティングでGameManger(シングルトン)の担った役割</a>をワールドが代わりに担うため、<br>
    色んな別クラスでWorld.hが #include "World.h" されて<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId00071">インクルードのリンクがワールドに集中して循環インクルード問題が起こる</a>ことが事前に予想される。<br>
    ゆえにワールドは「個別の Player.hやCamera.h のインクルードはしない」設計が適切になる。<br>
    #includeするかわりに「前方宣言をして Playerというクラスや Cameraというクラスがありうる」という宣言だけをしてやる。<br>
    <p class="source">class Camera; // 前方宣言だけして#include はしなければポインタ型 Camera* の定義は許される<br>
      class Player;<br>
      <br>
      class World<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Camera* camera; // 前方宣言をすればポインタは定義が許されるようになる<br>
      &nbsp;&nbsp;&nbsp; Player* player;<br>
      };<br>
    </p>
    ポインタの実体は「メモリ上の住所 = 番地番号」である。<br>
    だから64bit環境のマシンではポインタは64ビットの番地を持てるし、少し昔の32bit環境のマシンではポインタは32ビットの番地を持っているに過ぎない<br>
    ようは、void* 型のポインタも Player* 型のポインタも「実は同じ64bitの数字 = int型やshort型などと同類」に過ぎないわけです。<br>
    だから.hヘッダでPlayerのメンバの変数や関数を呼び出したりしない状況にして、ポインタだけならば、<br>
    実は #include しなくてもポインタ番号だけの定義にしてしまえば「インクルードするまでもない」のです。<br>
    Playerのメンバ変数の hp ヒットポイント などまでアクセスしたり、コンストラクタで初期化したいなら #include Playerまで必要だが、<br>
    Worldクラスの中に、Player* player; や Camera* camera; など「ポインタを羅列するだけなら前方宣言だけでいい」のである。<br>
    そして、この「ポインタならばインクルード不要」を応用することで「循環インクルード」を回避できるのである。<br>
    <br>
    ワールドクラスの定義はプレイヤやカメラなどの「ポインタをキープ」することに特化する。<br>
    ようは「住所番地の掲示板」を主とした役割として設計するのだ。<br>
    <br>
    第2の設計要件として必要なのが「キープ = 道連れ」の役割である。<br>
    ワールドを閉じたときにワールド内にカメラやプレイヤがいたら「ワールドもろとも一緒にメモリから消えてお掃除してほしい = バルス」<br>
    「キープ(道ずれ)」は共有ポインタの役目そのものである。<br>
    <a href="https://sleepygamersmemo.blogspot.com/2019/01/unity-optimizing-gc-collect.html">C#で暗に黙々とガベージコレクタがやってくれている役割</a>を共有ポインタで代行する。<br>
    <p class="source">#include &lt;memory&gt; // 共有ポインタを使う<br>
      class Camera; // 前方宣言だけして#include はしなければポインタ型 Camera* の定義は許される<br>
      class Player;<br>
      <br>
      class World<br>
      {<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Camera&gt; camera; // 前方宣言をすればポインタは定義が許されるようになる<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Player&gt; player;<br>
      };<br>
    </p>
    これで、Worldクラスが削除されるとともに、cameraやplayerが別の個所に共有リンクが張られていない状態(共有カウンタが1←ワールドのみの)ならば、<br>
    worldが最後までキープしていた共有カウンタ1が、このworldクラスが閉じられるとともに、共有カウンタが0になり、道ずれにできる。<br>
    つまり、Worldクラスは共有ポインタの最後の命綱(いのちづな)の共有カウント 1 をキープする役割を上記コードで期待できるわけです。<br>
    具体的には、以下のコード例で、プレイヤは命綱をキープして消えずにワールドを移動できます。<br>
    <p class="source">world2-&gt;player = world1-&gt;player; // <b>ワールド2でプレイヤへのリンクが張られた</b>のでplayerポインタの<b>共有カウンタが+1</b>になる<br>
      world1-&gt;player = nullptr; // <b>world1のplayerポインタがnullになる</b>のでplayerの<b>共有カウンタが-1</b>される<br>
      // 結果、playerは<b>ワールド2のぶんは最低限の共有カウンタ1は確保</b>されているので消えない(ワールド移動完了!!!!)<br>
    </p>
    このように、ようはstd::shared_ptr型のリンクがnullptrじゃないリンクされた数だけ共有ポインタのplayer内部の共有カウンタが+1され、<br>
    全リンクがnullptrにならない限り、playerは消えるのを免れられるということ。<br>
    <br>
    例えるならば、メンヘラ系VTuberがいいねが完全に0になったらやめる(引退するする詐欺)みたいな状況をイメージすると、ワールドが最後の推し 1 カウントを保持していて、<br>
    完全にどこからも気にされない状態(共有リンク切れ)ならばワールド消滅とともにさすがに消していいだろ。<br>
    という「この世界(ワールド)にいるうちは最後まで見捨てないよ設計」です。<br>
    なので、<b>デッドロック(互いにどっかのクラス同士で共有リンク張りあい状態)のときは<br>
      「永遠にメンヘラが世界消滅後もメモリに残り続けるという罠」</b>もあったりするので気を付けましょう。<br>
    <br>
    そして、もしPlayerのhpなどメンバ変数にアクセスしたかったり、<br>
    コンストラクタを呼んで初期化したいときはWorld.cppのほうで#include "Player.h"すれば、循環インクルードは回避できる構造を設計できる。<br>
    <p class="source"><b>World.h</b>の例<br>
      #include &lt;memory&gt; // 共有ポインタを使う<br>
      class Camera; // 前方宣言だけして#include はしなければポインタ型 Camera* の定義は許される<br>
      class Player;<br>
      <br>
      class World<br>
      {<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Camera&gt; camera; // 前方宣言をすればポインタは定義が許されるようになる<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Player&gt; player;<br>
      &nbsp;&nbsp;&nbsp; void MakePlayer(); //<b> .hでは初期化を直で呼ばずに、間接的に初期化するための関数だけを定義</b><br>
      };<br>
    </p>
    <p class="source"><b>World.cpp</b>の例 <br>
      #include "World.h";<br>
      <br>
      #include "Player.h"; // <b>.cppでは</b>std::make_sharedで初期化コンストラクタを呼ぶために<b>インクルードは必要</b><br>
      #include "Camera.h";<br>
      <br>
      void World::MakePlayer()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; player = std::make_shared&lt;Player&gt;(); // 初期化コンストラクタを呼ぶ<br>
      &nbsp;&nbsp;&nbsp; player-&gt;hp = 10; // インクルードしてればメンバ変数にもアクセスできる<br>
      };<br>
    </p>
    こういう風にして<b>実際の#includeを.cppに逃がせば</b>、少なくとも<b>Player.h と World.hどうしが循環インクルードすることはない構造を設計できる</b>。<br>
    まあ、普通はめんどくさがらずに「実際の処理は全部 .cpp に書くようにする」のが王道の世間一般のC++のプログラミングスタイルではある。<br>
    ただ、私はVisual Studioで「定義をここに表示」で.hヘッダの処理をワンクリックで追いかけて見たりできて便利なので<br>
    「コードを試行錯誤で書いている最中は.hで処理を書いて考えたり、必要に応じて.cppに処理を移したり、最後に丁寧に.cppに処理を移してきれいにする」<br>
    みたいな形で書き進めがちなので .h書き をおすすめしてるわけではない。<br>
    きれいな理想的なコーディングスタイルは<a href="https://github.com/raulmur/ORB_SLAM/blob/master/include/Map.h">FaceBookの元技術者の人</a>の恐ろしいほど簡潔で「読める」コードをみて真似するのがよい。最終理想形である。<br>
    上記のプロジェクトでも、中身が1行の処理のようなinline展開できそうな簡単な関数の処理は.hに書かれていたりする。<br>
    また、<a href="https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp">ヘッダオンリーなライブラリなどの文化</a>もあるので、<b>スタイルは場合や人や開発現場によりけり</b>である。<br>
    <br>
    <br>
    <br>
    <p><code>World.hを新規作成</code>して、世界で保持する(道ずれにする)要素を共有ポインタで定義しましょう。</p>
    <p class="source">#ifndef WORLD_H_<br>
      #define WORLD_H_<br>
      <br>
      #include &lt;list&gt;<br>
      #include &lt;memory&gt;<br>
      #include &lt;unordered_map&gt;<br>
      #include &lt;functional&gt; // std::functionのラムダ式 で 関数を Draw関数の引数にして、カメラすべてに対して描画処理を発動させる <br>
      <br>
      #include "MyHash.h" // ワールドのタグをhash32型で管理する<br>
      <br>
      <br>
      // [前方宣言] 宣言だけして、#includeはしてないので、ポインタだけはこのファイル内でつかえる<br>
      // #includeはしてないので、hpなどの変数には#include "～.h"しないとアクセスできないので循環インクルード防止のため.cppでインクルードしてください<br>
      class GameScene;<br>
      class Player;<br>
      class PlayerBullet;<br>
      class Enemy;<br>
      class Camera;<br>
      <br>
      // プレイヤや敵や弾などの共有ポインタを管理し、EraseRemoveIfで消して参照カウンタが0になったらそれらを消滅させるクラス(C#のガベージコレクタの代わり)<br>
      class World<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline World(GameScene* pScene, const std::string&amp; worldTag = "") : m_pScene{ pScene }, tag{ worldTag } {}<br>
      &nbsp;&nbsp;&nbsp; inline ~World() {}<br>
      protected: // public:にすると他で外部で後からタグやシーンを書き換えられると辞書での管理などの前提がおかしくなるのでprotected:する<br>
      &nbsp;&nbsp;&nbsp; hash32 tag{ "" }; // ワールド名のタグ<br>
      &nbsp;&nbsp;&nbsp; GameScene* m_pScene{ nullptr }; // ワールドを所有するシーン<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; hash32 Tag() const { return tag; }<br>
      &nbsp;&nbsp;&nbsp; GameScene* scene() { return m_pScene; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::<b>shared_ptr</b>&lt;Player&gt;&gt; players; // プレイヤのタグ辞書<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト <br>
      <br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 削除処理を共通テンプレート関数にする<br>
      &nbsp;&nbsp;&nbsp; // [共通テンプレート関数]https://programming-place.net/ppp/contents/cpp/language/009.html#function_template<br>
      &nbsp;&nbsp;&nbsp; template &lt;typename TypeT, class T_if&gt;<br>
      &nbsp;&nbsp;&nbsp; void EraseRemoveIf(std::list&lt;TypeT&gt;&amp; v, T_if if_condition)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 特定のタイプT↑&nbsp; ↑配列v&nbsp;&nbsp; ↑条件式if_condition<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; v.erase(<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::remove_if(v.begin(), v.end(), if_condition),<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; v.end() //&nbsp; ↓remove_ifの位置<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; );//例.[生][生][死][死][死]← v.end()の位置<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::<b>shared_ptr</b>&lt;Camera&gt;&gt; cameras; // このワールドに存在するカメラの辞書&lt;カメラにつけたタグ, カメラの共有ポインタ&gt;<br>
      &nbsp;&nbsp;&nbsp; // 指定されたタグのカメラへの共有ポインタを得る　カメラ辞書に存在しないタグでアクセスしたときにunordered_mapの特性で勝手に意図しないカメラができるのを防ぐ関数<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Camera&gt; camera(const std::string&amp; cameraTag) { auto itr = cameras.find(cameraTag); return (itr != end(cameras)) ? itr-&gt;second : nullptr; }<br>
      &nbsp;&nbsp;&nbsp; // このワールドに存在するカメラすべてに対して drawFuncで描きたい処理を渡して 全カメラのスクリーンに対して描画処理を走らせる<br>
      &nbsp;&nbsp;&nbsp; void Draw(std::function&lt;void()&gt; drawFunc) noexcept;<br>
      &nbsp;&nbsp;&nbsp; // カメラにタグをつけてワールドに追加 カメラにもワールドへのポインタリンクを張る<br>
      &nbsp;&nbsp;&nbsp; inline bool AddCamera(const std::string&amp; cameraTag, std::shared_ptr&lt;Camera&gt; pCamera);<br>
      &nbsp;&nbsp;&nbsp; // 指定したタグのカメラをこのワールドから削除する カメラ側の worldへのリンクのポインタも nullptr にする<br>
      &nbsp;&nbsp;&nbsp; inline bool EraseCamera(const std::string&amp; cameraTag);<br>
      &nbsp;&nbsp;&nbsp; // カメラを nowWorld から nextWorld に移動させる<br>
      &nbsp;&nbsp;&nbsp; static bool MoveCamera(const std::string&amp; cameraTag, World* nowWorld, World* nextWorld);<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>World.cppを新規作成</code>して、ポインタ以外の実体のインクルードが必要な処理を記述しましょう。</p>
    <p class="source">#include "World.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Camera.h"<br>
      #include "Screen.h"<br>
      <br>
      <br>
      // カメラにタグをつけてワールドに追加 カメラにもワールドへの生ポインタリンクを渡す<br>
      bool World::AddCamera(const std::string&amp; cameraTag, std::shared_ptr&lt;Camera&gt; pCamera)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (pCamera == nullptr) return false;<br>
      &nbsp;&nbsp;&nbsp; if (cameras.count(cameraTag) &gt; 0) return false; // すでに同じタグのカメラがワールドにあったら false<br>
      &nbsp;&nbsp;&nbsp; if (pCamera-&gt;world() != nullptr) pCamera-&gt;world()-&gt;EraseCamera(cameraTag); // すでにカメラが別ワールドに配置されていたら別ワールドから削除<br>
      &nbsp;&nbsp;&nbsp; cameras.emplace(cameraTag, pCamera); // ワールドにカメラを追加する<br>
      &nbsp;&nbsp;&nbsp; pCamera-&gt;world(this); // カメラにもワールドへのポインタリンクを張る<b>(カメラ側に渡すのは共有ポインタではない生ポインタだから共有デッドロックにはならない)</b><br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      // 指定したタグのカメラをこのワールドから削除する カメラ側の worldへのリンクのポインタも nullptr にする<br>
      bool World::EraseCamera(const std::string&amp; cameraTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; auto itr = cameras.find(cameraTag); // 指定したタグのカメラを探す<br>
      &nbsp;&nbsp;&nbsp; if (itr == end(cameras)) return false; // 指定したタグのカメラがワールドにない<br>
      &nbsp;&nbsp;&nbsp; auto pCamera = itr-&gt;second;<br>
      &nbsp;&nbsp;&nbsp; pCamera-&gt;world(nullptr); // カメラ側の worldへのリンクのポインタも nullptrに<br>
      &nbsp;&nbsp;&nbsp; cameras.erase(cameraTag); // カメラを辞書から削除<br>
      <br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      // カメラを nowWorld から nextWorld に移動させる<br>
      bool World::MoveCamera(const std::string&amp; cameraTag, World* nowWorld, World* nextWorld)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (nowWorld == nullptr) return false;<br>
      &nbsp;&nbsp;&nbsp; auto itr = nowWorld-&gt;cameras.find(cameraTag); // タグでカメラを探す<br>
      &nbsp;&nbsp;&nbsp; if (itr == end(nowWorld-&gt;cameras)) return false; // タグに関連づいたカメラがなかった<br>
      &nbsp;&nbsp;&nbsp; auto targetCamera = itr-&gt;second; // カメラの共有ポインタをキープ(次の行でeraseしてもカメラの共有カウンタは0にはならずこのリンクのおかげでカメラはメモリに残存)<br>
      &nbsp;&nbsp;&nbsp; targetCamera-&gt;world(nullptr); // カメラ側の worldへのリンクのポインタを一旦 nullptrに<br>
      &nbsp;&nbsp;&nbsp; nowWorld-&gt;cameras.erase(cameraTag); // nowWorld からは カメラを消す<br>
      &nbsp;&nbsp;&nbsp; if (nextWorld == nullptr) return false;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return nextWorld-&gt;AddCamera(cameraTag, targetCamera); // 次のワールドにカメラを追加する<br>
      }<br>
      <br>
      // このワールドに存在するカメラすべてに対して funcで描きたい処理を渡して 全カメラのスクリーンに対して描画処理を走らせる<br>
      void World::Draw(std::function&lt;void()&gt; drawFunc) noexcept<br>
      {<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : cameras)&nbsp;&nbsp;&nbsp; // このワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR_D beforeCamPos; // 設定変更前のカメラのパラメータを一旦、保管<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; double beforeVRot, beforeHRot, beforeTRot, beforeNear, beforeFar, beforeFov;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Camera::GetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;beforeFov, &amp;beforeNear, &amp;beforeFar);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //camera-&gt;screenID<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngle(camera-&gt;pos, camera-&gt;rot.V, camera-&gt;rot.H, camera-&gt;rot.T); // 各カメラの位置、回転を設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Screen::Start(camera-&gt;screenHandle, true, camera-&gt;fovAngle); // カメラに関連付けられたスクリーンIDを描画先にする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; drawFunc(); // 渡された描画処理を実行<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Screen::End(true); // 描画先を元に戻す<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラの設定をもとに戻しておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Camera::SetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;beforeFov, &amp;beforeNear, &amp;beforeFar);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    <p><code>Camera.hを変更</code>して、ワールドに所有される立場のカメラ側からも自分の今いるワールドの情報にアクセスできるために<br>
      World* 型の生ポインタを初期化と同時に渡しておけるようにしましょう。</p>
    <p class="source">#ifndef CAMERA_H_<br>
      #define CAMERA_H_<br>
      <br>
      #include &lt;functional&gt; // カメラのDraw関数に「引数として関数=ラムダ式」を渡してカメラのDraw関数の外側の呼び出し元から描画したい処理を渡すことができるようにする<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "MyDraw.h"<br>
      #include "Vector3.h"<br>
      <em>#include "World.h"</em><br>
      <br>
      <br>
      class Camera<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // カメラの位置(ワールド座標)<br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 pos; // カメラの位置(ワールド座標)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // unionしてx,y,zでもアクセスできるように<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; struct Rotate { double V, H, T; }; // カメラの回転角度定義 DXライブラリの内部行列ではfloatじゃなくてdouble型で保持されているので倍精度のdouble型にした<br>
      &nbsp;&nbsp;&nbsp; Rotate rot{ 0.0, 0.0, 0.0 }; // カメラの3軸の回転角度<br>
      &nbsp;&nbsp;&nbsp; double fovAngle = 0; // カメラをスクリーンに描くときの視野角(0～179度) 0のときはDxLib::GetCameraFovD()で得られる値が適用される<br>
      <br>
      &nbsp;&nbsp;&nbsp; float cameraLookAtHeight{ 0.0f }; // LookAtする対象を見下ろす高さ<br>
      <br>
      &nbsp;&nbsp;&nbsp; int screenHandle = DX_SCREEN_BACK; //カメラを描くスクリーンのハンドル番号<br>
      <em>protected:<br>
        &nbsp;&nbsp;&nbsp; World* m_world; // カメラが存在するワールドへのポインタ<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; World* world() { return m_world; } //ワールドへのポインタを得る<br>
        &nbsp;&nbsp;&nbsp; Camera&amp; world(World* pWorld) { m_world = pWorld; return *this; } // ワールドへのポインタを再セットする</em><br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Camera(<em>World* pWorld, </em>Vector3 worldPos) : <em>m_world{ pWorld }, </em>pos { worldPos } {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; // デストラクタ<br>
      &nbsp;&nbsp;&nbsp; ~Camera() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラを通して描くスクリーンのハンドル番号を設定する<br>
      &nbsp;&nbsp;&nbsp; void SetScreenHandle(int handle) { screenHandle = handle; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラの位置をセットしなおす<br>
      &nbsp;&nbsp;&nbsp; void SetPosition(Vector3 worldPos)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ワールド座標系として保存<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;pos = worldPos;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 指定されたワールド座標が画面の中心に来るように、カメラの位置を変更する<br>
      &nbsp;&nbsp;&nbsp; void LookAt(Vector3 targetXYZ)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // カメラの位置と向きを設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //MyDraw::SetCameraPositionAndTarget_UpVecY(pos, targetXYZ + Vector3(0, cameraLookAtHeight,0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 注視点はターゲットの座標から cameraLookAtHeight 分だけ高い位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndTarget_UpVecY(this-&gt;pos, targetXYZ + Vector3(0, this-&gt;cameraLookAtHeight, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // カメラ回転後の角度を保存<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;rot.H = DxLib::GetCameraAngleHRotateD(); // カメラの水平方向の向きを取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;rot.V = DxLib::GetCameraAngleVRotateD();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;rot.T = DxLib::GetCameraAngleTRotateD();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 現在のDX内部のカメラのビュー行列などに入っているカメラの設定パラメータを得る<br>
      &nbsp;&nbsp;&nbsp; static void GetCameraSettings(VECTOR_D* pPosition, double* pRotV = nullptr, double* pRotH = nullptr, double* pRotT = nullptr,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double* pFov = nullptr, double* pNear = nullptr, double* pFar = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pPosition != nullptr) *pPosition = DxLib::GetCameraPositionD(); // カメラ位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pRotV != nullptr) *pRotV = DxLib::GetCameraAngleVRotateD(); // カメラの角度V<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pRotH != nullptr) *pRotH = DxLib::GetCameraAngleHRotateD(); // カメラの角度H<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pRotT != nullptr) *pRotT = DxLib::GetCameraAngleTRotateD(); // カメラの角度T<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pFov != nullptr) *pFov = DxLib::GetCameraFovD(); // カメラの視野角<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pNear != nullptr) *pNear = DxLib::GetCameraNearD(); // カメラ一番近くの描き始めるレンジ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pFar != nullptr) *pFar = DxLib::GetCameraFarD(); // カメラ一番遠くの描くレンジ<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラの視野角に変更があったら変えて射影変換行列を再計算する (現在と同じfovの数値の場合は再計算をしないで負荷を回避)<br>
      &nbsp;&nbsp;&nbsp; static inline void SetupCamera_PerspectiveD(double fov) { if (DxLib::GetCameraFovD() != fov) DxLib::SetupCamera_PerspectiveD(fov); }<br>
      &nbsp;&nbsp;&nbsp; // カメラの視野角に変更があったら変えて射影変換行列を再計算する (現在と同じfovの数値の場合は再計算をしないで負荷を回避)<br>
      &nbsp;&nbsp;&nbsp; static inline void SetCameraNearFarD(double Near, double Far) { if (DxLib::GetCameraNearD() != Near &amp;&amp; DxLib::GetCameraFarD() != Far) DxLib::SetCameraNearFarD(Near, Far); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラの設定を変える<br>
      &nbsp;&nbsp;&nbsp; static void SetCameraSettings(VECTOR_D* pPosition, double* pRotV, double* pRotH, double* pRotT,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double* pFov = nullptr, double* pNear = nullptr, double* pFar = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pPosition != nullptr &amp;&amp; pRotV != nullptr &amp;&amp; pRotH != nullptr &amp;&amp; pRotT != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngleD(*pPosition, *pRotV, *pRotH, *pRotT);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pFov != nullptr) Camera::SetupCamera_PerspectiveD(*pFov); // カメラの視野角に変化があったら射影変換行列を更新<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pNear != nullptr &amp;&amp; pFar != nullptr) Camera::SetCameraNearFarD(*pNear, *pFar); // カメラ一番近くから遠くまで描くレンジ<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // このワールドに存在するカメラすべてに対して funcで描きたい処理を渡して 全カメラのスクリーンに対して描画処理を走らせる<br>
      &nbsp;&nbsp;&nbsp; inline void Draw(std::function&lt;void()&gt; drawFunc) noexcept<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D beforeCamPos; // 設定変更前のカメラのパラメータを一旦、保管<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double beforeVRot, beforeHRot, beforeTRot, beforeNear, beforeFar, beforeFov;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Camera::GetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;beforeFov, &amp;beforeNear, &amp;beforeFar);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngle(this-&gt;pos, this-&gt;rot.V, this-&gt;rot.H, this-&gt;rot.T); // カメラの位置、回転を設定<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::Start(this-&gt;screenHandle, true, this-&gt;fovAngle); // カメラに関連付けられたscreenHandleのスクリーンを描画先にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawFunc(); // 渡された描画処理を実行<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::End(true); // 描画先を元に戻す<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // カメラの設定をもとに戻しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Camera::SetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;beforeFov, &amp;beforeNear, &amp;beforeFar);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>MyMath.hを新規作成</code>して、プレイヤが歩き回るさいの計算に必要な円周率などの定数を定義しましょう。</p>
    <p class="source">#ifndef MYMATH_H_<br>
      #define MYMATH_H_<br>
      <br>
      // 数学関連クラス<br>
      class MyMath<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // [<b>static constexprを使うことでstaticな定数を.hヘッダで初期化</b>] https://onihusube.hatenablog.com/entry/2019/06/30/230431<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; static constexpr float Sqrt2 = 1.41421356237f; // ルート2<br>
      &nbsp;&nbsp;&nbsp; static constexpr float PI = 3.14159265359f; // 円周率<br>
      &nbsp;&nbsp;&nbsp; static constexpr float Deg2Rad = PI / 180.0f; // 度からラジアンに変換する定数<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Player.hを新規作成</code>して、ワールドを歩きまわるプレイヤをタイル分割画像でパラパラアニメ描画できるようにしましょう。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Resource.h"<br>
      #include "MyHash.h" // hash32型でプレイヤが現在いるワールドのタグを管理する<br>
      #include "Vector3.h"<br>
      <br>
      class World; // 前方宣言<br>
      class Camera; // 前方宣言<br>
      <br>
      class Player<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Player(World* world, Pad pad, Vector3 position)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pad{ pad }, m_world{ world }, position{ position }, velocity{ 0,0,0 }, force{0,0,0}<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tag = "Player";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~Player() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★下記3つはメモリ上で共用状態になる(position、x,y,z、xyzどの名前から数値を変えたり読出してもメモリ上は同じ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 同じデータに3種類の名前を付けたイメージ、しかもVector3の機能や配列としてのアクセスの仕方もできて便利<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // XYZ座標&nbsp; [匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 position; // XYZ座標<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp;&nbsp; };// unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vx, vy, vz; }; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 velocity; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyz;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vxForce, vyForce, vzForce; }; // XYZ方向にかかる力(Unityでいうと AddForce関数 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 force; // XYZ方向の力(物理的には加速度:1フレームごとにvelocityの増える=加速する量)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyzForce;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; hash32 tag{ "" }; // プレイヤにつけるタグ<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; World* m_world; // 配置されたワールドへのリンク<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; virtual World* world() { return m_world; }<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
      &nbsp;&nbsp;&nbsp; virtual void world(World* changeWorld) { m_world = changeWorld; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; Pad pad; // 操作するコントローラー番号<br>
      &nbsp;&nbsp;&nbsp; hash32 worldTag{ "" }; // 現在いるワールドのタグ<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeedMax = 6; // 移動速度Max値<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeed = 0;//移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; float moveAngle = 0; // X軸→方向から何度か<br>
      &nbsp;&nbsp;&nbsp; float deltaAngle = 0; // プレイヤの動く角度の変化率、ハンドルを切ったらだんだんもとに戻る<br>
      &nbsp;&nbsp;&nbsp; int animCount = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image; // プレイヤの板ポリゴンで描くタイル分割画像への共有リンク<br>
      <br>
      &nbsp;&nbsp;&nbsp; Camera* camera{ nullptr }; // プレイヤを追随するカメラ<br>
      &nbsp;&nbsp;&nbsp; void SetCamera(Camera* pCamera) { camera = pCamera; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理<br>
      &nbsp;&nbsp;&nbsp; virtual void HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw();<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>Player.cppを新規作成</code>して、ワールドを歩きまわる処理を記述にしましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      void Player::HandleInput()<br>
      {<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_LEFT) <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_A)) )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = - MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += 1; //ハンドルを左に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_RIGHT)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_D)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle -= 1; //ハンドルを右に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_UP)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_W)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = - MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += 0.6f; //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; MoveSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = MoveSpeedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(pad, PAD_INPUT_DOWN)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_S)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed -= 0.6f; //ブレーキを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.9f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = -0.9f;//ちょっとだけバックできるように<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pad == Pad::Key || pad == Pad::One) // コントローラ1またはキーボード操作のプレイヤのときだけ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGUP)) // キーボードのPageUp ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = 2.0f; // テスト用に空中の上方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGDN)) // キーボードのPageDown ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -2.0f; // テスト用に空中の下方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp; x += vx;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp; y += vy;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp; z += vz;<br>
      <br>
      &nbsp;&nbsp;&nbsp; vy += vyForce; // 勢い(力・フォースを加算<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int animIndex = animCount / 20; // キャラのパラパラアニメの画像番号(最大3)<br>
      &nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp; if (abs_vx &gt; 1.00f || abs_vz &gt; 1.00f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6; // キャラが地面のXとZ方向に少しでもスピードがあったらアニメを走らせる<br>
      &nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // プレイヤのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 9; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // カメラ向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 奥向きの画像<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *image, imgIndex + animIndex, TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    <br>
    <p><code>main.cppを変更</code>して、Worldクラスに移したカメラとプレイヤをworld1経由で描画してみましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Screen.h"<br>
      #include "Camera.h"<br>
      #include "MyHash.h"<br>
      #include "Resource.h"<br>
      #include "MyDraw.h"<br>
      <em>#include "Player.h"<br>
        #include "World.h"</em><br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ Width×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ Width×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // タイルマップを読み込む 縦8マス、横8マス、縦32ピクセル、横32ピクセル<br>
      &nbsp;&nbsp;&nbsp; std::string mapChipPath{ "Map/mapchip.png" };<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath,8,8,32,32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>std::string playerImgPath1{ "Image/<b>pikkoron.png</b>" };<br>
        &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath1, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; std::string playerImgPath2{ "Image/<b>satan.png</b>" };<br>
        &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath2, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする</em><br>
      <br>
      &nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp; // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する<br>
      &nbsp;&nbsp;&nbsp; // ( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを2つ生成 画面の全体の縦方向サイズの Height / 2 にして、上下分割で配置できるようにする<br>
      &nbsp;&nbsp;&nbsp; int screenHandle0 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      &nbsp;&nbsp;&nbsp; int screenHandle1 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// ワールドを生成<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;World&gt; world1 = std::make_shared&lt;World&gt;(nullptr, "ワールド1");</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラを2つ生成して、2つのカメラ視点を2つのスクリーンにそれぞれ関連付ける<br>
      &nbsp;&nbsp;&nbsp; <u>std::unordered_map&lt;hash32, std::shared_ptr&lt;Camera&gt;&gt; cameras; // 複数のカメラへのポインタを格納するタグを振った辞書配列</u><br>
      &nbsp;&nbsp;&nbsp; <em>world1-&gt;</em>cameras.emplace("カメラ0", std::make_shared&lt;Camera&gt;(<em>world1.get(), </em>Vector3{ 20,40,-50 })); // カメラ0<br>
      &nbsp;&nbsp;&nbsp; <em>world1-&gt;</em>cameras.emplace("カメラ1", std::make_shared&lt;Camera&gt;(<em>world1.get(), </em>Vector3{ 80,30,-50 })); // カメラ1<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>world1-&gt;</em>cameras["カメラ0"]-&gt;screenHandle = screenHandle0; // カメラ0 と スクリーン0 を関連付ける<br>
      &nbsp;&nbsp;&nbsp; <em>world1-&gt;</em>cameras["カメラ1"]-&gt;screenHandle = screenHandle1; // カメラ1 と スクリーン1 を関連付ける<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <em>world1-&gt;players.emplace("プレイヤ0", std::make_shared&lt;Player&gt;(world1.get(), Pad::Key, Vector3{ 20,30,-50 }));<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players.emplace("プレイヤ1", std::make_shared&lt;Player&gt;(world1.get(), Pad::Two, Vector3{ 80,30,0 }));<br>
        <br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ0"]-&gt;SetCamera(world1-&gt;cameras["カメラ0"].get()); // .get()で共有ポインタstd::shared_ptrから生の*ポインタへ変換<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ1"]-&gt;SetCamera(world1-&gt;cameras["カメラ1"].get());<br>
        <br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ0"]-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath1]);<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ1"]-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath2]);<br>
        <br>
        &nbsp;&nbsp;&nbsp; Input::Init(); // 入力状態を初期化</em><br>
      &nbsp;&nbsp;&nbsp; <br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle0); // 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle1); // 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Input::Update(); // 入力状態を更新</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファを有効にする [Zの深度]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// world1のプレイヤを更新する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; pair : world1-&gt;players)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer = pair.second;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer-&gt;Update();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // world1のプレイヤを描画する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; pair : world1-&gt;players)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer = pair.second;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer-&gt;Draw();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 複数のカメラを 範囲 for文 で回す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; camera : <em>world1-&gt;</em>cameras)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ラムダ式[&amp;](){ ～ }で{}の外側の変数すべてを &amp; キャプチャで&amp;参照として「Draw関数の内側へ引き連れて」処理できる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera.second-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw関数() の 外側にある変数 mapChipPath も[&amp;]効果で { } の内側で問題なくアクセスできている↓<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 70, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 4);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (camera.first == "カメラ0")<b> </b>//←"カメラ0"はビルド時に事前にハッシュ値が計算され、文字列ではない数値とおきかわっている<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらがカメラ0", GetColor(255, 0, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (camera.first == "カメラ1")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらはカメラ1", GetColor(0, 255, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーン0の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, 0, screenHandle0, FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, 0, Screen::Width, Screen::Height / 2, GetColor(255, 0, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーン1の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, Screen::Height / 2, screenHandle1, FALSE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, Screen::Height / 2, Screen::Width, Screen::Height, GetColor(0, 255, 0));<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    いかがでしょう？実行したら、キーボードの上下左右矢印キーで上画面のプレイヤ0を、WASDキーで下画面のプレイヤ1を操作することができたでしょうか？<br>
    worldを間にはさんだことで、cameraとplayerがworldのポインタを経由して互いのデータにアクセスできるため、<br>
    違うキャラのカメラと自分のキャラの位置など、トリッキーなデータどうしのアクセスもworldを通してできるようになっています。<br>
    また、違うワールドにいるときはカメラのforループでは違うワールドにあるカメラはfor文に引っかからないわけなので、<br>
    別の世界にいるキャラは当然、描かれない仕組みがワールドの配下にcamaraやplayerのポインタが管理されることによって実現できています。<br>
    <br>
    <br>
    <a id="mozTocId0005" class="mozTocH1">
      <h1>シーンを定義して、ゲームシーンの中に複数ワールドを保持する</h1>
    </a>
    <p><code>前提として乱数クラスMyRandomを別記事から作成しておきます</code>←<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/#mozTocId20052">乱数で散乱弾を作成する</a><br>
    </p>
    <br>
    つぎは、シーンを定義して、ワールドはGameSceneの中で複数保持できるように設計していきましょう。<br>
    <br>
    <p><code>Scene.hを新規作成</code>して、様々なシーンの基底ベースとなるクラスを定義します(UpdateやDrawなどを純粋仮想関数としてoverride必須にしておく)。<br>
    </p>
    <p class="source">#ifndef SCENE_H_<br>
      #define SCENE_H_<br>
      <br>
      #include &lt;string&gt; // シーンの判別文字列tagに使う<br>
      #include "MyHash.h" // hash32型をタグ判別に使う<br>
      <br>
      // シーンの基底クラス あいまいなabstract型タイプ(virtual ～() = 0;の純粋仮想関数を含む)<br>
      class Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; std::string tag{ "" }; // シーンでロードするファイル名などに使う<br>
      &nbsp;&nbsp;&nbsp; hash32 typeTag{ "" }; // シーンのタイプの判別に使う<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Scene(const std::string&amp; sceneTag = "") : tag{ sceneTag }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //仮想デストラクタ【忘れるとメモリがヤバいダメ絶対】<br>
      &nbsp;&nbsp;&nbsp; virtual ~Scene()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 特に配列とかなくても★string文字列も内部では実質配列だから！5文字分のメモリとかがすり減ってく..<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 仮想デストラクタはstringなど暗黙に内部に配列を持つ要素のデストラクタを暗黙に呼んでくれている！<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //★純粋仮想関数=0は継承したGameSceneなどの必須機能(継承したら絶対override必須縛り)<br>
      &nbsp;&nbsp;&nbsp; // 必須縛りによってSceneを継承したものは【Update,Drawが実装されてるはずの確証があるので】<br>
      &nbsp;&nbsp;&nbsp; // for文であいまいなSceneのまま【まとめてUpdate,Drawできる】のだ。<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Initialize() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 終了処理(大抵Initializeと同じくリセット処理を行うがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp;&nbsp; virtual void Finalize() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() = 0; //純粋仮想関数に(継承したらoverride必須)<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    次に、シーンを管理するマネージャーが欲しいので、シングルトンのテンプレートクラスを準備します。<br>
    <p><code>Singleton.hを新規作成</code>して、シングルトンのテンプレートクラスを定義します。<br>
    </p>
    <p class="source">#ifndef SINGLETON_H_<br>
      #define SINGLETON_H_<br>
      <br>
      // テンプレートT型シングルトンSingleton&lt;～&gt; ～になんでも指定して唯一物にできる<br>
      // ★Singleton&lt;TypeT&gt;型は【必ず唯一で複製不可】(使い方:どこからでもアクセスし変数を共有するクラス向き)<br>
      // ★ゲーム内の【どこからアクセスしても統一性が保たれる】(唯一だから)「クラス名と実体が一致」<br>
      template&lt;class TypeT&gt;<br>
      class Singleton<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // Instance()を通して【しか】T型クラスをつくれないうえに、<br>
      &nbsp;&nbsp;&nbsp; // ★作ったものは【かならず唯一で複製不可】<br>
      &nbsp;&nbsp;&nbsp; // それが【シングルトン型】！<br>
      &nbsp;&nbsp;&nbsp; // ゲーム中で唯一で複製不可にしたい【ゲームを一律管理するクラス】などに最適！<br>
      &nbsp;&nbsp;&nbsp; // https://teratail.com/questions/17416<br>
      &nbsp;&nbsp;&nbsp; // http://rudora7.blog81.fc2.com/blog-entry-393.html<br>
      &nbsp;&nbsp;&nbsp; // ②↓同じ関数の定義はプログラム全体で１つだけしか許されません。(static関数名は被らない)<br>
      &nbsp;&nbsp;&nbsp; static inline TypeT&amp; Instance()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //①↓関数の中で定義されたstatic変数は、関数の定義毎に１つ領域が確保されます。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static TypeT instance; //メモリ上にstatic変数確保(静かに常に待機するinstance)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return instance; //①=(常駐)②=(唯一) ①と②両方満たすinstanceは【メモリ上に唯一】<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; Singleton() {} // 外部でのインスタンス作成は禁止(protected:内部公開、外部禁止)<br>
      &nbsp;&nbsp;&nbsp; virtual ~Singleton() {} // 仮想デストラクタ(シングルトンを【継承するためには忘れちゃダメ】)<br>
      <br>
      private:<br>
      &nbsp;&nbsp;&nbsp; void operator=(const Singleton&amp; obj) {} // 代入演算子禁止<br>
      &nbsp;&nbsp;&nbsp; Singleton(const Singleton&amp; obj) {} // コピーコンストラクタ禁止(コピーできない【唯一】)<br>
      &nbsp;&nbsp;&nbsp; static TypeT* instance; // private:だから外部アクセスできない【GetInstance()経由しか無理】<br>
      };<br>
      <br>
      // いつもcppで書いたstatic変数初期化も★【Tテンプレートクラスだからすべて.hヘッダにまとめて書いた】<br>
      template&lt; class TypeT &gt;<br>
      TypeT* Singleton&lt; TypeT &gt;::instance = 0; //cppでの定義を.h内に書いた(static変数はclass内で初期化できないから)<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>SceneManager.hを新規作成</code>して、シングルトンを継承してどこからでもアクセスできるマネージャを定義します。<br>
    </p>
    <p class="source">#ifndef SCNENEMANAGER_H_<br>
      #define SCNENEMANAGER_H_<br>
      <br>
      #include &lt;vector&gt;<br>
      #include &lt;memory&gt;<br>
      #include &lt;string&gt;<br>
      #include &lt;assert.h&gt; // シーン読み込みの失敗表示用<br>
      <br>
      #include "MyHash.h" // hash32型でタグを管理する<br>
      #include "Singleton.h"<br>
      <br>
      class Scene; //クラス宣言だけで★インクルードしないのでこのマネージャファイルで循環は止まる<br>
      <br>
      class SceneManager : public Singleton&lt;SceneManager&gt;//←&lt;～&gt;として継承すると唯一のシングルトン型タイプとなる<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; friend class Singleton&lt;SceneManager&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Scene&gt; prevScene{ nullptr }; // 一つ前のシーン<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Scene&gt; currentScene{ nullptr }; // 現在のシーン<br>
      <br>
      &nbsp;&nbsp;&nbsp; hash32 currentSceneType{ "" }; // 現在のシーン名を保管しておく<br>
      &nbsp;&nbsp;&nbsp; std::string currentSceneTag{ "" }; // 現在のシーンのタグを保管しておく<br>
      <br>
      &nbsp;&nbsp;&nbsp; hash32 changingSceneType{ "" }; // 予約された次のシーンのクラス名(次に移動予定のシーン名を保管しておく)<br>
      &nbsp;&nbsp;&nbsp; std::string changingSceneTag{ "" }; // 予約された次のシーンのタグ(次に移動予定のシーンのタグを保管しておく)<br>
      <br>
      &nbsp;&nbsp;&nbsp; // シーン名を比較、何の変化もなければfalseでシーン移動不必要の判定<br>
      &nbsp;&nbsp;&nbsp; bool isChanging(const std::string&amp; nextSceneType, const std::string&amp; nextSceneTag = "");<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次のシーンの予約だけしてLoadScene()を引数なしで呼び出したタイミングで遷移する(ループの途中じゃないキリのいいタイミングを狙って遷移させる)<br>
      &nbsp;&nbsp;&nbsp; void NextScene(const std::string&amp; nextSceneName, const std::string&amp; nextSceneTag = "");<br>
      <br>
      &nbsp;&nbsp;&nbsp; // シーンをチェンジし遷移する(前のシーンのリセット処理もする)<br>
      &nbsp;&nbsp;&nbsp; void LoadScene(const std::string&amp; sceneName = "", const std::string&amp; nextSceneTag = "");<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; SceneManager() {}; // 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp;&nbsp; virtual ~SceneManager() {}; //外部からのインスタンス破棄も禁止<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>SceneManager.cppを新規作成</code>して、先行してGameSceneなどをロード・切り替えする処理を先に書いておきます。<br>
    </p>
    <p class="source">#include "SceneManager.h"<br>
      <br>
      #include "Scene.h"<br>
      #include "TitleScene.h"<br>
      #include "GameScene.h"<br>
      #include "GameOverScene.h"<br>
      <br>
      bool SceneManager::isChanging(const std::string&amp; nextSceneType, const std::string&amp; nextSceneTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (currentSceneType != nextSceneType) //シーンのタイプ不一致<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // シーンのタイプが変更<br>
      &nbsp;&nbsp;&nbsp; if (currentSceneTag != nextSceneTag) //シーンのタグ不一致<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // シーンのタグが変更<br>
      <br>
      &nbsp;&nbsp;&nbsp; return false; // シーンに変更無し<br>
      }<br>
      <br>
      void SceneManager::NextScene(const std::string&amp; nextSceneType, const std::string&amp; nextSceneTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 遷移予定nextシーン名と現在のシーン名を比較、何の変化もなければfalseでシーン移動不必要の判定<br>
      &nbsp;&nbsp;&nbsp; if (isChanging(nextSceneType) == false) return; //特に変更なしでシーン移動の必要なし<br>
      <br>
      &nbsp;&nbsp;&nbsp; changingSceneType = nextSceneType; // 次に移動予定のシーン名を保管しておく<br>
      }<br>
      <br>
      void SceneManager::LoadScene(const std::string&amp; nextSceneType, const std::string&amp; nextSceneTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; hash32 loadSceneType = nextSceneType;<br>
      &nbsp;&nbsp;&nbsp; std::string loadSceneTag = nextSceneTag;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // nextSceneTypeの指定が空の場合にはNextScene()での事前のシーン変更予約があるかチェック<br>
      &nbsp;&nbsp;&nbsp; if (nextSceneType == "" &amp;&amp; changingSceneType != "")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loadSceneType = changingSceneType;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loadSceneTag = changingSceneTag;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (loadSceneType == "") return; // シーン指定がないときは終了<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 現在のシーンの終了処理<br>
      &nbsp;&nbsp;&nbsp; if (currentScene != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentScene-&gt;Finalize(); // 終了処理を呼び出す<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (loadSceneType == "TitleScene")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次のシーンの生成<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentScene = std::make_shared&lt;TitleScene&gt;(loadSceneTag);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (loadSceneType == "GameScene")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次のシーンの生成<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentScene = std::make_shared&lt;GameScene&gt;(loadSceneTag);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (loadSceneType == "GameOverScene")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次のシーンの生成<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentScene = std::make_shared&lt;GameOverScene&gt;(loadSceneTag);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert("指定されたシーンの生成処理が見つからなかった→SceneManager.cppを見直しましょう" == "");<br>
      <br>
      &nbsp;&nbsp;&nbsp; currentSceneType = loadSceneType; // 現在のシーン名の更新<br>
      &nbsp;&nbsp;&nbsp; currentSceneTag = loadSceneTag; // 現在のシーンのタグの更新<br>
      <br>
      &nbsp;&nbsp;&nbsp; changingSceneType = ""; // NextScenceのシーン予約名をリセット<br>
      &nbsp;&nbsp;&nbsp; changingSceneTag = ""; // NextScenceのシーン予約タグをリセット<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次のシーンの初期化<br>
      &nbsp;&nbsp;&nbsp; currentScene-&gt;Initialize(); // 初期化を呼び出す<br>
      }<br>
    </p>
    今回はシューティングのときと違って、初期化のときにシーンのタグを渡せるように設計しました。<br>
    たとえば、同じ"GameScene"のシーンタイプでも、どのステージを遊ぶのかなどをタグを通して渡せれば、<br>
    ステージごとにシーンタイプを増やして別定義しなくてすむようになりますし、柔軟性が増します。<br>
    <br>
    <p><code>TitleScene.hを新規作成</code>して、特に今回は処理を書きませんが実際に制作するときにはタイトル画面を実装するためのひな形だけ作っておきます。<br>
    </p>
    <p class="source">#ifndef TITLESCENE_H_<br>
      #define TITLESCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      <br>
      #include "SceneManager.h"<br>
      <br>
      class TitleScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; SceneManager&amp; sm = SceneManager::Instance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; TitleScene(const std::string&amp; sceneTag = "") : Scene(sceneTag)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "TitleScene";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp;&nbsp; void Finalize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(Pad::All, PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sm.LoadScene("GameScene"); //シーン遷移<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "TitleSceneです。ボタン押下でGameSceneへ。", GetColor(255, 255, 255));<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>GameOverScene.hを新規作成</code>して、特に今回は処理を書きませんが実際に制作するときにはゲームオーバー画面を実装するためのひな形だけ作っておきます。<br>
    </p>
    <p class="source">#ifndef GAMEOVERSCENE_H_<br>
      #define GAMEOVERSCENE_H_<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      <br>
      #include "SceneManager.h"<br>
      <br>
      class GameOverScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; SceneManager&amp; sm = SceneManager::Instance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; GameOverScene(const std::string&amp; sceneTag = "") : Scene(sceneTag)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "GameOverScene";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp;&nbsp; void Finalize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(Pad::All, PAD_INPUT_1))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sm.LoadScene("TitleScene"); //シーン遷移<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return; // シーンをロードしたらUpdateを即終了しないとUpdateの他の処理が走っちゃう<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "GameOver....ボタン押下でPlaySceneへ", GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    さて、今回の本題のGameSceneを作成する前に、シーンに関するセッティングをCSVファイルから読みだせるようにすれば、<br>
    ゲームシーンに関する情報、例えば、ステージのマップのファイルの場所一覧、などをプランナがエクセルで管理でき、それをCSVに吐き出して、<br>
    そのセッティングに合わせて、ゲームのシーンの初期化と同時に、ワールドのマップ読出しに必要な情報をCSVファイルから柔軟に得ることができます。<br>
    <p><code>DataCsv.hを新規作成</code>して、CSV形式のファイルをロードできるようにします。<br>
    </p>
    <p class="source">#ifndef DATACSV_H_<br>
      #define DATACSV_H_<br>
      <br>
      #include &lt;vector&gt;<br>
      #include &lt;string&gt;<br>
      <br>
      #include &lt;fstream&gt; // ファイル読み出しifstreamに必要<br>
      #include &lt;string&gt; //文字列に必要<br>
      #include &lt;sstream&gt; // 文字列ストリームに必要<br>
      <br>
      #include &lt;assert.h&gt; // 読込み失敗表示用<br>
      <br>
      <br>
      //★CsvValue型をint型や文字列string型や小数float型として【カメレオン】のように使える。<br>
      // 【エクセルはマス目がカメレオン】整数も小数も文字列もありうる。<br>
      // それを解消して統一して扱える便利な★CsvValue型。<br>
      class CsvValue<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; enum class Type : unsigned char<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Int,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Float,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; String,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; NUM<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; Type type = Type::String;<br>
      protected: // 内部データを書き換え禁止:書き換えられるとintと文字列とのずれが起きうる<br>
      &nbsp;&nbsp;&nbsp; // エクセルのCsvデータはマス目がint,float,stringの3種類ありうる<br>
      &nbsp;&nbsp;&nbsp; union {&nbsp; // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int intData = 0; // 整数int型データを格納<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float floatData; // 小数float型データを格納<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string stringData{ "" }; // 文字列string型データを格納<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; CsvValue() = default;<br>
      &nbsp;&nbsp;&nbsp; // 3種類のコンストラクタ<br>
      &nbsp;&nbsp;&nbsp; CsvValue(float floatData) : type{ Type::Float }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;floatData = floatData;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;stringData = std::to_string(floatData);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; CsvValue(const std::string&amp; stringData) : type{ Type::String }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;stringData = stringData;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; ~CsvValue() {}; // 仮想デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; void operator=(const int&amp; intValue) // 代入演算子<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;intData = intValue;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; void copy(const CsvValue&amp; value)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; type = value.type;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (value.type == Type::Int) { this-&gt;intData = value.intData; this-&gt;stringData = std::to_string(value.intData); }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (value.type == Type::Float) { this-&gt;floatData = value.floatData; this-&gt;stringData = std::to_string(value.floatData); }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (value.type == Type::String) { this-&gt;stringData = value.stringData; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; void operator=(const CsvValue&amp; value) { copy(value); } // 代入演算子<br>
      &nbsp;&nbsp;&nbsp; CsvValue(const CsvValue&amp; value) { copy(value); } // コピーコンストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 変換演算子によりCSVのセルをintとしてもstringとしても扱えるように<br>
      &nbsp;&nbsp;&nbsp; // https://programming-place.net/ppp/contents/cpp/language/019.html#conversion_op<br>
      &nbsp;&nbsp;&nbsp; // 3種類の読み取りオペレータ<br>
      &nbsp;&nbsp;&nbsp; operator int()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (type == Type::Float) return (int)floatData;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (type == Type::String &amp;&amp; intData == 0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; intData = intFromString(); // デフォルトで文字列として読込んだデータをintに変換<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return intData;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline operator float()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (type == Type::Int) return (float)intData;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (type == Type::String &amp;&amp; intData == 0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; floatData = floatFromString(); // デフォルトで文字列として読込んだデータをfloatに変換<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return floatData;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline operator std::string() const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return stringData;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; int intFromString() // 文字列データからint型への変換する関数<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::istringstream ss(stringData); //文字列ストリームの初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ss &gt;&gt; num; // 文字列ストリームから数字への変換<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return num;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; float floatFromString() // 文字列データからfloat型への変換する関数<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::istringstream ss(stringData); //文字列ストリームの初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ss &gt;&gt; num; // 文字列ストリームから数字への変換<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return num;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      // CSVの1行を[]オペレータでアクセスした際1行のサイズが足りない場合に自動resizeする機能を[]オペレータに実装する<br>
      struct CsvLine : public std::vector&lt;CsvValue&gt;<br>
      {<br>
      &nbsp;&nbsp;&nbsp; inline std::vector&lt;CsvValue&gt;&amp; operator[](std::size_t index) {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (index &gt;= size()) { resize(index + 1); }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return (*this)[index]; // 読み書き<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      // CSVファイルを読込み幅や高さとデータ本体を保持するデータ型<br>
      struct DataCsv<br>
      {<br>
      &nbsp;&nbsp;&nbsp; enum class CsvType<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IntMap,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CsvValue<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; CsvType type;<br>
      &nbsp;&nbsp;&nbsp; bool isInitialized = false; //[継承2重ロード対策]ベース基底でロードしたらtrueに<br>
      &nbsp;&nbsp;&nbsp; // 読込んだデータファイルの情報<br>
      &nbsp;&nbsp;&nbsp; std::string FilePath{ "" };<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;CsvLine&gt; Data;// csvデータ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ★スムーズに[][]でアクセスできるように[]演算子を独自定義する<br>
      &nbsp;&nbsp;&nbsp; // https://www.hiramine.com/programming/c_cpp/operator.html<br>
      &nbsp;&nbsp;&nbsp; inline std::vector&lt;CsvValue&gt;&amp; operator[](std::size_t index) { <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (index &gt;= Data.size())<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Data.resize(index + 1); // 範囲外アクセス時は自動リサイズ(使う人が大きな数字間違っていれるとやばいので注意)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Data[index]; // 読取り<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::size_t size()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // size()関数の名前をvectorと被らせることで使う側はvectorインvectorのままのコードで使える<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Data.size();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // 初期化コンストラクタでファイル名を指定して初期化と同時にファイル読込<br>
      &nbsp;&nbsp;&nbsp; DataCsv(std::string FilePath = "", CsvType csvType = CsvType::IntMap) : type{csvType}, FilePath { FilePath }<br>
      &nbsp;&nbsp;&nbsp; {// csvファイルの読込み★【初期化と同時なのでファイルとデータ型が一心同体で使いやすい】<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (FilePath != "")<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Load(FilePath, csvType); // ファイル読込み<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; virtual ~DataCsv()<br>
      &nbsp;&nbsp;&nbsp; {// 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; clear();// 2次元配列データのお掃除<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // データをクリアしてメモリを節約する<br>
      &nbsp;&nbsp;&nbsp; virtual void clear()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // [確実にメモリを空にするには] http://vivi.dyndns.org/tech/cpp/vector.html#shrink_to_fit<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::vector&lt;CsvLine&gt;().swap(Data); // 空のテンポラリオブジェクトでリセット<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitialized = false; //ロード済みフラグをOFF<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // csvファイルの読み込み<br>
      &nbsp;&nbsp;&nbsp; virtual void Load(std::string filePath, CsvType csvType = CsvType::IntMap)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (filePath == "" || isInitialized) return; //ファイル名がないもしくはロード済<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;FilePath = filePath; // ファイル名を保管<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;type = csvType;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Data.clear(); //データを一旦クリア<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 読み込むcsvファイルを開く(std::ifstreamのコンストラクタで開く)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::ifstream ifs_csv_file(filePath);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string line; //1行単位の読込み文字列<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int readWidth = 0, readHeight = 0; //読込みデータの幅と高さ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int maxWidth = 0; //今から読み込んだ時のMAXの幅<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (std::getline(ifs_csv_file, line)) // ファイルを行ごとに読み込む<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CsvLine valuelist; // 1行の数字リスト<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::istringstream linestream(line); // 各行の文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string splitted; // カンマ分割文字列<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int widthCount = 0; //この行の幅をカウント<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;type == CsvType::IntMap)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (std::getline(linestream, splitted, { ',' }))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::istringstream ss; //文字列ストリームの初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ss = std::istringstream(splitted); //文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int num; // 数字単体<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ss &gt;&gt; num; // 文字列ストリームから数字への変換<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; valuelist.push_back(CsvValue(num)); // 数字をリスト(1行リスト)に追加<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; widthCount++; //この行の幅をカウントアップ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (this-&gt;type == CsvType::CsvValue)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (std::getline(linestream, splitted, { ',' }))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (splitted.size() &gt; 1 &amp;&amp; splitted[0] == '\"')<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; splitted = splitted.substr(1, splitted.size() - 2);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; valuelist.emplace_back(splitted); // 数字を数字のリスト(1行リスト)に追加<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; widthCount++; //この行の幅をカウントアップ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (widthCount &gt; maxWidth) maxWidth = widthCount; //暫定Max幅を更新<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 1行分をvectorに追加<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (valuelist.size() != 0) Data.emplace_back(valuelist);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; readHeight++; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; readWidth = maxWidth; //MAX幅の王者を確定<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(readWidth &gt; 0); // マップ幅がおかしい<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(readHeight &gt; 0); // マップ高さがおかしい<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // コンストラクタで初期化でロードの場合とLoad関数経由で読む経路があるから<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitialized = true; // 読込み初期化済みフラグをON<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Mapフォルダの中に<a href="image/GameSceneSetting.csv">GameSceneSetting.csv</a>を新規作成</code>して、下記内容のcsvのデータで、シーン1というタグでGameSceneを初期生成するとき、<br>
      ステージ1というタグのついたワールドにMap/stage1.jsonから読みだしたマップを読み出し生成する、という情報を記述し保存しておきましょう。(マップのjson読み出しはのちの章でやる予定です)<br>
    </p>
    <p class="source">"//","GameSceneでシーン名を指定するとその行以降をそのシーンで使うworldsとしてロードする",,,,<br>
      "GameScene","シーン1",,,,<br>
      "ステージ1","Map/stage1.json",,,,<br>
      <br>
    </p>
    <br>
    <br>
    <p><code>GameScene.hを新規作成</code>して、ゲームを実際にUpdateしたりDrawしたりするためのシーンを定義しましょう(ワールドの定義もシーンの中にある)。<br>
    </p>
    <p class="source">#ifndef GAMESCENE_H_<br>
      #define GAMESCENE_H_<br>
      <br>
      #include &lt;memory&gt; // 共有ポインタ std::shared_ptrを使う<br>
      #include &lt;unordered_map&gt; // ワールドにタグをつけて複数のワールドを管理 複数あれば(扉→別マップへの移動→元のマップへ戻っても敵が消えずに残せる)<br>
      <br>
      #include "Scene.h"<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Resource.h"<br>
      #include "Screen.h"<br>
      #include "Camera.h"<br>
      #include "DataCsv.h"<br>
      <br>
      #include "SceneManager.h"<br>
      <br>
      struct GameSceneSetting // ゲームシーン情報をGameSceneSetting.csvなどから読みだす<br>
      {<br>
      &nbsp;&nbsp;&nbsp; GameSceneSetting(const std::string&amp; csvFileName = "")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (csvFileName != "") Load(csvFileName);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; ~GameSceneSetting() {}; //デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; struct WorldTag_Path<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WorldTag_Path() = default;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline WorldTag_Path(const std::string&amp; tag, const std::string&amp; mapFilePath) : tag{ tag }, mapFilePath{ mapFilePath } {}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline ~WorldTag_Path() {}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string tag{ "" }; // ワールドにつけるtag<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string mapFilePath{ "" }; // マップのファイルパス<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; struct Info : public std::unordered_map&lt;hash32, WorldTag_Path&gt; // &lt;ワールド名のタグ, ワールドのファイルパス&gt;<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Info() = default;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline Info(const std::string&amp; gameSceneTag) : gameSceneTag{ gameSceneTag } {};<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~Info() {};<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string gameSceneTag{ "" }; // シーン名のタグ<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, Info&gt; info; //[辞書]シーン名のタグ → ワールド情報<br>
      &nbsp;&nbsp;&nbsp; bool isInitialized = false; //[継承2重ロード対策]<br>
      &nbsp;&nbsp;&nbsp; std::string FilePath{ "" }; // csvのファイルパス<br>
      <br>
      &nbsp;&nbsp;&nbsp; Info&amp; operator[](const std::string&amp; gameSceneTag) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(info.count(gameSceneTag) != 0 &amp;&amp; "シーン情報が読み取れていません Map/GameSceneSettings.csv に情報があるか確認！");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return info[gameSceneTag]; // 読み書き<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; void Load(const std::string&amp; csvFileName = "")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isInitialized) return; // 2重ロード対策<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (csvFileName != "") this-&gt;FilePath = csvFileName;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;FilePath == "") return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataCsv Data; // マップ情報一覧のデータ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data.Load(csvFileName, DataCsv::CsvType::CsvValue);// CSVファイルからデータをロード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string gameSceneTag; //ゲームシーン名<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; Data.size(); ++j)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((std::string)Data[j][0] == "//") continue; // 一番左の列が//なら読み飛ばしのコメント行<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((std::string)Data[j][0] == "GameScene")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gameSceneTag = Data[j][1]; //ゲームシーン名<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info.emplace(std::piecewise_construct, std::forward_as_tuple(gameSceneTag), std::forward_as_tuple(gameSceneTag));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (gameSceneTag == "") continue; //ステージファイル名が未確定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((std::string)Data[j][0] != "")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info[gameSceneTag][(std::string)Data[j][0]] = std::move(WorldTag_Path(Data[j][0], Data[j][1])); //ワールド名 → ワールドのファイルのパスを読み取り<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      <br>
      class GameScene : public Scene<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; static GameSceneSetting settings; // ゲームシーンの設定情報 デフォルトは{ "Map/GameSceneSetting.csv" } を読み取り<br>
      <br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; SceneManager&amp; sm = SceneManager::Instance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>int screenHandle0{ -1 }; // 上画面スクリーンのハンドル<br>
        &nbsp;&nbsp;&nbsp; int screenHandle1{ -1 }; // 下画面スクリーンのハンドル<br>
        <br>
        &nbsp;&nbsp;&nbsp; // タイルマップを読み込む 縦8マス、横8マス、縦32ピクセル、横32ピクセル<br>
        &nbsp;&nbsp;&nbsp; std::string mapChipPath{ "Map/mapchip.png" };<br>
        &nbsp;&nbsp;&nbsp; std::string playerImgPath1{ "Image/pikkoron.png" };<br>
        &nbsp;&nbsp;&nbsp; std::string playerImgPath2{ "Image/satan.png" };</em><br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;World&gt;&gt; worlds; // 複数ワールドの共有ポインタ辞書<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // ワールドをタグをつけて生成する<br>
      &nbsp;&nbsp;&nbsp; void CreateWorld(const std::string&amp; worldTag) { if (worlds.count(worldTag) == 0) { worlds.emplace(worldTag, std::make_shared&lt;World&gt;(this, worldTag)); } }<br>
      &nbsp;&nbsp;&nbsp; // タグからワールドへのポインタリンクを得る<br>
      &nbsp;&nbsp;&nbsp; World* world(const std::string&amp; worldTag) { auto itr = worlds.find(worldTag); return (itr != end(worlds)) ? itr-&gt;second.get() : nullptr; }<br>
      &nbsp;&nbsp;&nbsp; // 指定したゲームシーンのタグに関連づいたファイル名に対応したワールドを初期化する<br>
      &nbsp;&nbsp;&nbsp; bool LoadWorlds(const std::string&amp; gameSceneTag);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤはタイトル画面などでも初期選択できるようにあえてworld配下の管理ではなく<br>
      &nbsp;&nbsp;&nbsp; // GameScene配下の管理でゲーム開始時から直接生成できるようにここに定義<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;Player&gt;&gt; players; // &lt;タグ,プレイヤへの共有ポインタ&gt;辞書[複数プレイヤ可能]<br>
      &nbsp;&nbsp;&nbsp; void ChangeWorld(const std::string&amp; worldTag, std::shared_ptr&lt;Player&gt; pPlayer); // プレイヤのいるワールドを移動する<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; int score = 0; // プレイ中のゲームのスコア:短期的数値でシーン遷移ごとにリセットされる<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; GameScene(const std::string&amp; sceneTag = "") : Scene(sceneTag)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "GameScene";<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;tag != "") // this-&gt;tag には : Scene(sceneTag) 経由で sceneTag が設定されている<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadWorlds(this-&gt;tag); // GameSceneSetting.csv に設定したタグに対応したファイルをロード<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; void Initialize() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 終了処理(大抵Initializeと同じリセットだがInitと区別して終了時だけやりたいリセットもある)<br>
      &nbsp;&nbsp;&nbsp; void Finalize() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ここにプレイ終了時のリセット処理(ゲームクリアやゲームオーバーなど)<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override;<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>World.hを変更</code>して、AddPlayerでシーンにプレイヤ追加する関数などを定義しましょう。</p>
    <p class="source">#ifndef WORLD_H_<br>
      #define WORLD_H_<br>
      <br>
      #include &lt;list&gt;<br>
      #include &lt;memory&gt;<br>
      #include &lt;unordered_map&gt;<br>
      #include &lt;functional&gt; // std::functionのラムダ式 で 関数を Draw関数の引数にして、カメラすべてに対して描画処理を発動させる <br>
      <br>
      #include "MyHash.h" // ワールドのタグをhash32型で管理する<br>
      <br>
      <br>
      // [前方宣言] 宣言だけして、#includeはしてないので、ポインタだけはこのファイル内でつかえる<br>
      // #includeはしてないので、hpなどの変数には#include "～.h"しないとアクセスできないので循環インクルード防止のため.cppでインクルードしてください<br>
      class GameScene;<br>
      class Player;<br>
      class PlayerBullet;<br>
      class Enemy;<br>
      class Camera;<br>
      <br>
      // プレイヤや敵や弾などの共有ポインタを管理し、EraseRemoveIfで消して参照カウンタが0になったらそれらを消滅させるクラス(C#のガベージコレクタの代わり)<br>
      class World<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline World(GameScene* pScene, const std::string&amp; worldTag = "") : m_pScene{ pScene }, tag{ worldTag } {}<br>
      &nbsp;&nbsp;&nbsp; inline ~World() {}<br>
      protected: // public:にすると他で外部で後からタグやシーンを書き換えられると辞書での管理などの前提がおかしくなるのでprotected:する<br>
      &nbsp;&nbsp;&nbsp; hash32 tag{ "" }; // ワールド名のタグ<br>
      &nbsp;&nbsp;&nbsp; GameScene* m_pScene{ nullptr }; // ワールドを所有するシーン<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; hash32 Tag() const { return tag; }<br>
      &nbsp;&nbsp;&nbsp; GameScene* scene() { return m_pScene; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// ワールドを所有するシーンにプレイヤを追加する<br>
        &nbsp;&nbsp;&nbsp; void AddPlayer(const std::string&amp; playerTag, std::shared_ptr&lt;Player&gt; pPlayer);<br>
        &nbsp;&nbsp;&nbsp; // ワールドにいるプレイヤを得る<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;Player&gt;&gt; GetPlayers();</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;Player&gt;&gt; players; // プレイヤのタグ辞書<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト <br>
      <br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 削除処理を共通テンプレート関数にする<br>
      &nbsp;&nbsp;&nbsp; // [共通テンプレート関数]https://programming-place.net/ppp/contents/cpp/language/009.html#function_template<br>
      &nbsp;&nbsp;&nbsp; template &lt;typename TypeT, class T_if&gt;<br>
      &nbsp;&nbsp;&nbsp; void EraseRemoveIf(std::list&lt;TypeT&gt;&amp; v, T_if if_condition)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 特定のタイプT↑&nbsp; ↑配列v&nbsp;&nbsp; ↑条件式if_condition<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; v.erase(<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::remove_if(v.begin(), v.end(), if_condition),<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; v.end() //&nbsp; ↓remove_ifの位置<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; );//例.[生][生][死][死][死]← v.end()の位置<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;Camera&gt;&gt; cameras; // このワールドに存在するカメラの辞書&lt;カメラにつけたタグ, カメラの共有ポインタ&gt;<br>
      &nbsp;&nbsp;&nbsp; // 指定されたタグのカメラへの共有ポインタを得る　カメラ辞書に存在しないタグでアクセスしたときにunordered_mapの特性で勝手に意図しないカメラができるのを防ぐ関数<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Camera&gt; camera(const std::string&amp; cameraTag) { auto itr = cameras.find(cameraTag); return (itr != end(cameras)) ? itr-&gt;second : nullptr; }<br>
      &nbsp;&nbsp;&nbsp; // このワールドに存在するカメラすべてに対して drawFuncで描きたい処理を渡して 全カメラのスクリーンに対して描画処理を走らせる<br>
      &nbsp;&nbsp;&nbsp; void Draw(std::function&lt;void()&gt; drawFunc) noexcept;<br>
      &nbsp;&nbsp;&nbsp; // カメラにタグをつけてワールドに追加 カメラにもワールドへのポインタリンクを張る<br>
      &nbsp;&nbsp;&nbsp; inline bool AddCamera(const std::string&amp; cameraTag, std::shared_ptr&lt;Camera&gt; pCamera);<br>
      &nbsp;&nbsp;&nbsp; // 指定したタグのカメラをこのワールドから削除する カメラ側の worldへのリンクのポインタも nullptr にする<br>
      &nbsp;&nbsp;&nbsp; inline bool EraseCamera(const std::string&amp; cameraTag);<br>
      &nbsp;&nbsp;&nbsp; // カメラを nowWorld から nextWorld に移動させる<br>
      &nbsp;&nbsp;&nbsp; static bool MoveCamera(const std::string&amp; cameraTag, World* nowWorld, World* nextWorld);<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>World.cppを変更</code>して、シーンにプレイヤを追加するAddPlayer関数などを追加しましょう。</p>
    <p class="source">#include "World.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Camera.h"<br>
      #include "Screen.h"<br>
      <br>
      <em>#include "GameScene.h"</em><br>
      <br>
      <em>void World::AddPlayer(const std::string&amp; playerTag, std::shared_ptr&lt;Player&gt; pPlayer)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (m_pScene != nullptr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_pScene-&gt;players.emplace(playerTag, pPlayer); // シーンにプレイヤを追加する<br>
        &nbsp;&nbsp;&nbsp; }<br>
        }<br>
        <br>
        // このワールドにいるプレイヤを得る<br>
        std::vector&lt;std::weak_ptr&lt;Player&gt;&gt; World::GetPlayers()<br>
        {<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;Player&gt;&gt; players;<br>
        &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; pPlayer : players)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; players.emplace_back(pPlayer);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; return players;<br>
        }</em><br>
      <br>
      // カメラにタグをつけてワールドに追加 カメラにもワールドへの生ポインタリンクを渡す<br>
      bool World::AddCamera(const std::string&amp; cameraTag, std::shared_ptr&lt;Camera&gt; pCamera)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (pCamera == nullptr) return false;<br>
      &nbsp;&nbsp;&nbsp; if (cameras.count(cameraTag) &gt; 0) return false; // すでに同じタグのカメラがワールドにあったら false<br>
      &nbsp;&nbsp;&nbsp; if (pCamera-&gt;world() != nullptr) pCamera-&gt;world()-&gt;EraseCamera(cameraTag); // すでにカメラが別ワールドに配置されていたら別ワールドから削除<br>
      &nbsp;&nbsp;&nbsp; cameras.emplace(cameraTag, pCamera); // ワールドにカメラを追加する<br>
      &nbsp;&nbsp;&nbsp; pCamera-&gt;world(this); // カメラにもワールドへのポインタリンクを張る<b>(カメラ側に渡すのは共有ポインタではない生ポインタだから共有デッドロックにはならない)</b><br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      // 指定したタグのカメラをこのワールドから削除する カメラ側の worldへのリンクのポインタも nullptr にする<br>
      bool World::EraseCamera(const std::string&amp; cameraTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; auto itr = cameras.find(cameraTag); // 指定したタグのカメラを探す<br>
      &nbsp;&nbsp;&nbsp; if (itr == end(cameras)) return false; // 指定したタグのカメラがワールドにない<br>
      &nbsp;&nbsp;&nbsp; auto pCamera = itr-&gt;second;<br>
      &nbsp;&nbsp;&nbsp; pCamera-&gt;world(nullptr); // カメラ側の worldへのリンクのポインタも nullptrに<br>
      &nbsp;&nbsp;&nbsp; cameras.erase(cameraTag); // カメラを辞書から削除<br>
      <br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      // カメラを nowWorld から nextWorld に移動させる<br>
      bool World::MoveCamera(const std::string&amp; cameraTag, World* nowWorld, World* nextWorld)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (nowWorld == nullptr) return false;<br>
      &nbsp;&nbsp;&nbsp; auto itr = nowWorld-&gt;cameras.find(cameraTag); // タグでカメラを探す<br>
      &nbsp;&nbsp;&nbsp; if (itr == end(nowWorld-&gt;cameras)) return false; // タグに関連づいたカメラがなかった<br>
      &nbsp;&nbsp;&nbsp; auto targetCamera = itr-&gt;second; // カメラの共有ポインタをキープ(次の行でeraseしてもカメラの共有カウンタは0にはならずこのリンクのおかげでカメラはメモリに残存)<br>
      &nbsp;&nbsp;&nbsp; targetCamera-&gt;world(nullptr); // カメラ側の worldへのリンクのポインタを一旦 nullptrに<br>
      &nbsp;&nbsp;&nbsp; nowWorld-&gt;cameras.erase(cameraTag); // nowWorld からは カメラを消す<br>
      &nbsp;&nbsp;&nbsp; if (nextWorld == nullptr) return false;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return nextWorld-&gt;AddCamera(cameraTag, targetCamera); // 次のワールドにカメラを追加する<br>
      }<br>
      <br>
      // このワールドに存在するカメラすべてに対して funcで描きたい処理を渡して 全カメラのスクリーンに対して描画処理を走らせる<br>
      void World::Draw(std::function&lt;void()&gt; drawFunc) noexcept<br>
      {<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : cameras)&nbsp;&nbsp;&nbsp; // このワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR_D beforeCamPos; // 設定変更前のカメラのパラメータを一旦、保管<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; double beforeVRot, beforeHRot, beforeTRot, beforeNear, beforeFar, beforeFov;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Camera::GetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;beforeFov, &amp;beforeNear, &amp;beforeFar);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //camera-&gt;screenID<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngle(camera-&gt;pos, camera-&gt;rot.V, camera-&gt;rot.H, camera-&gt;rot.T); // 各カメラの位置、回転を設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Screen::Start(camera-&gt;screenHandle, true, camera-&gt;fovAngle); // カメラに関連付けられたスクリーンIDを描画先にする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; drawFunc(); // 渡された描画処理を実行<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Screen::End(true); // 描画先を元に戻す<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラの設定をもとに戻しておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Camera::SetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;beforeFov, &amp;beforeNear, &amp;beforeFar);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    <br>
    <p><code>GameScene.cppを新規作成</code>して、ゲームをUpdateしたりDrawしたりする処理を実装しましょう。<br>
    </p>
    <p class="source">#include "GameScene.h"<br>
      <br>
      #include "Player.h"<br>
      <br>
      GameSceneSetting GameScene::settings{ "Map/GameSceneSetting.csv" }; // ゲームシーンの設定情報<br>
      <br>
      // 指定したゲームシーンのタグに関連づいたファイル名に対応したワールドを初期化する<br>
      bool GameScene::LoadWorlds(const std::string&amp; gameSceneTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (settings.info.count(gameSceneTag) == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto&amp; info = settings[gameSceneTag];<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; tag_mapPath : info)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateWorld(tag_mapPath.second.tag); // ワールドをタグをつけて生成<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      void GameScene::ChangeWorld(const std::string&amp; worldTag, std::shared_ptr&lt;Player&gt; pPlayer)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (pPlayer == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp; if (worlds.count(worldTag) == 0) return; // 存在しないタグだった<br>
      <br>
      &nbsp;&nbsp;&nbsp; pPlayer-&gt;world(worlds[worldTag].get()); // ワールドへのリンクをすげ替える<br>
      }<br>
      <br>
      <br>
      void GameScene::Initialize()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Ｚバッファを有効にする [Zの深度]<br>
      &nbsp;&nbsp;&nbsp; //[参考]https://docs.google.com/presentation/d/1Z23t1yAS7uzPDVakgW_M02p20qt9DeTs4ku4IiMDLco/edit?usp=sharing<br>
      &nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する<br>
      &nbsp;&nbsp;&nbsp; // ( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを2つ生成 画面の全体の縦方向サイズの Height / 2 にして、上下分割で配置できるようにする<br>
      &nbsp;&nbsp;&nbsp; screenHandle0 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      &nbsp;&nbsp;&nbsp; screenHandle1 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath, 8, 8, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath1, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath2, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの生成<br>
      &nbsp;&nbsp;&nbsp; if (pWorld != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pWorld-&gt;AddCamera("カメラ1", Camera::defaultCamera); // カメラ1というタグをデフォルトカメラにつけてワールドにデフォルトカメラを配置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ1", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera1 = pWorld-&gt;camera("カメラ1"); // カメラ1 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera1-&gt;SetScreenHandle(screenHandle0); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer1 = std::make_shared&lt;Player&gt;(pWorld, Pad::Key, Vector3(90 + 256, 32, 95 + 256));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ1", pPlayer1); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath1]);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;camera = pCamera1.get(); // カメラをプレイヤにリンクする<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ2", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera2 = pWorld-&gt;camera("カメラ2"); // プレイヤ2 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera2-&gt;SetScreenHandle(screenHandle1); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer2 = std::make_shared&lt;Player&gt;(pWorld, Pad::Two, Vector3(190, 32, 195));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ2", pPlayer2); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath2]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;camera = pCamera2.get(); // カメラをプレイヤにリンクする<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      <br>
      void GameScene::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle0); // 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle1); // 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; player : players)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player.second-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      }<br>
      <br>
      void GameScene::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; player : players)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player.second-&gt;Draw(); // プレイヤの描画【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // プレイヤのいるワールドのカメラのみを描けば、プレイヤのいないワールドは描かずに済む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 複数のカメラを 範囲 for文 で回す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; camera : player.second-&gt;world()-&gt;cameras)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ラムダ式[&amp;](){ ～ }で{}の外側の変数すべてを &amp; キャプチャで&amp;参照として「Draw関数の内側へ引き連れて」処理できる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera.second-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw関数() の 外側にある変数 mapChipPath も[&amp;]効果で { } の内側で問題なくアクセスできている↓<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 70, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 8);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (camera.first == "カメラ1")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらがプレイヤ1", GetColor(255, 0, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (camera.first == "カメラ2")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらはプレイヤ2", GetColor(0, 255, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーン0の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, 0, screenHandle0, FALSE);<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, 0, Screen::Width, Screen::Height / 2, GetColor(255, 0, 0));<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーン1の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, Screen::Height / 2, screenHandle1, FALSE);<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, Screen::Height / 2, Screen::Width, Screen::Height, GetColor(0, 255, 0));<br>
      <br>
      }<br>
    </p>
    さて、このまま、main.cppでシーンを直接Update、Drawしていいものか？<br>
    なぜなら、タイトルシーンやゲームオーバー、ゲーム中のシーンで共通するような処理はあるでしょうから、<br>
    シーンとmain.cppの間にもう一つGameというクラスをはさんで、共通の処理はそちらにさせるようにしましょう。<br>
    <br>
    <br>
    <p><code>Game.hを新規作成</code>して、各シーンで共通する処理をUpdateしたりDrawしたりする処理を実装しましょう。<br>
    </p>
    <p class="source">#ifndef GAME_H_<br>
      #define GAME_H_<br>
      <br>
      #include "Screen.h"<br>
      #include "SceneManager.h"<br>
      #include "Scene.h"<br>
      #include "MyRandom.h"<br>
      #include "Input.h"<br>
      <br>
      class Game<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; Game() {}; // 初期化コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; ~Game() {}; // 破棄処理デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; //★【仲介者パターン】ゲーム内のもの同士はマネージャを通して一元化してやり取り<br>
      &nbsp;&nbsp;&nbsp; SceneManager&amp; sm = SceneManager::Instance(); //唯一のシーンマネージャへの参照(&amp;)を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; void Init()<br>
      &nbsp;&nbsp;&nbsp; {// Init処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 各種Init中に、<b>ユーザーにお待ちいただく間、不安を和らげるためのメッセージをScreenFlipで表示</b>してからInit開始<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string loadingStr("ゲーム起動中...&nbsp; 必要なファイルをロードしています");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int strSize = DxLib::GetFontSize() * loadingStr.size();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawString(Screen::Width / 2 - strSize / 2, Screen::Height / 2, loadingStr.c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Input::Init(); // 入力機能の初期化<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MyRandom::Init(); // 乱数のシードを現時点の時刻に連動して初期化<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ゲーム開始して最初のシーンに遷移<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.LoadScene("<b>GameScene</b>", "<b>シーン1</b>");<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; void Update() {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Input::Update(); //【注意】これ忘れるとキー入力押してもキャラ動かない<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // シーンの更新処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.currentScene-&gt;Update();<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // NextScene関数で次のシーン移動予約があったらシーンを移動する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.LoadScene(); // 引数無し呼び出しの場合、事前に NextScene関数で予約がない場合はスルーされる<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; void Draw()<br>
      &nbsp;&nbsp;&nbsp; {// 描画処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // シーンの描画処理<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sm.currentScene-&gt;Draw();<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>main.cppを変更</code>して、Gameクラスを通じてシーンをInit、Update、Drawしましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      <em>#include "Game.h"</em><br>
      <br>
      #include "Screen.h"<br>
      <u>#include "Camera.h"<br>
        #include "MyHash.h"<br>
        #include "Resource.h"<br>
        #include "MyDraw.h"<br>
        #include "Player.h"<br>
        #include "World.h"</u><br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ Width×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ Width×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 初期化処理<br>
        &nbsp;&nbsp;&nbsp; Game game;<br>
        &nbsp;&nbsp;&nbsp; game.Init(); // gameのInit準備</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>// タイルマップを読み込む 縦8マス、横8マス、縦32ピクセル、横32ピクセル<br>
        &nbsp;&nbsp;&nbsp; std::string mapChipPath{ "Map/mapchip.png" };<br>
        &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath,8,8,32,32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::string playerImgPath1{ "Image/pikkoron.png" };<br>
        &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath1, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; std::string playerImgPath2{ "Image/satan.png" };<br>
        &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath2, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
        <br>
        &nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp;&nbsp; // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する<br>
        &nbsp;&nbsp;&nbsp; // ( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // サブのスクリーンを2つ生成 画面の全体の縦方向サイズの Height / 2 にして、上下分割で配置できるようにする<br>
        &nbsp;&nbsp;&nbsp; int screenHandle0 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
        &nbsp;&nbsp;&nbsp; int screenHandle1 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // ワールドを生成<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;World&gt; world1 = std::make_shared&lt;World&gt;(nullptr, "ワールド1");<br>
        <br>
        &nbsp;&nbsp;&nbsp; // カメラを2つ生成して、2つのカメラ視点を2つのスクリーンにそれぞれ関連付ける<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;cameras.emplace("カメラ0", std::make_shared&lt;Camera&gt;(world1.get(), Vector3{ 20,40,-50 })); // カメラ0<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;cameras.emplace("カメラ1", std::make_shared&lt;Camera&gt;(world1.get(), Vector3{ 80,30,-50 })); // カメラ1<br>
        <br>
        &nbsp;&nbsp;&nbsp; world1-&gt;cameras["カメラ0"]-&gt;screenHandle = screenHandle0; // カメラ0 と スクリーン0 を関連付ける<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;cameras["カメラ1"]-&gt;screenHandle = screenHandle1; // カメラ1 と スクリーン1 を関連付ける<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players.emplace("プレイヤ0", std::make_shared&lt;Player&gt;(world1.get(), Pad::Key, Vector3{ 20,30,-50 }));<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players.emplace("プレイヤ1", std::make_shared&lt;Player&gt;(world1.get(), Pad::Two, Vector3{ 80,30,0 }));<br>
        <br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ0"]-&gt;SetCamera(world1-&gt;cameras["カメラ0"].get()); // .get()で共有ポインタstd::shared_ptrから生の*ポインタへ変換<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ1"]-&gt;SetCamera(world1-&gt;cameras["カメラ1"].get());<br>
        <br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ0"]-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath1]);<br>
        &nbsp;&nbsp;&nbsp; world1-&gt;players["プレイヤ1"]-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath2]);<br>
        <br>
        &nbsp;&nbsp;&nbsp; Input::Init(); // 入力状態を初期化</u><br>
      &nbsp;&nbsp;&nbsp; <br>
      <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>game.Update(); //ゲームの更新処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; game.Draw(); // パラパラ漫画の描画処理</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle0); // 一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle1); // 一旦キャンバスをきれいにまっさらに<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input::Update(); // 入力状態を更新<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファを有効にする [Zの深度]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // world1のプレイヤを更新する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; pair : world1-&gt;players)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer = pair.second;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer-&gt;Update();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // world1のプレイヤを描画する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; pair : world1-&gt;players)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer = pair.second;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer-&gt;Draw();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 複数のカメラを 範囲 for文 で回す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; camera : world1-&gt;cameras)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ラムダ式[&amp;](){ ～ }で{}の外側の変数すべてを &amp; キャプチャで&amp;参照として「Draw関数の内側へ引き連れて」処理できる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera.second-&gt;Draw([&amp;]()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw関数() の 外側にある変数 mapChipPath も[&amp;]効果で { } の内側で問題なくアクセスできている↓<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 0);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 70, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 4);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (camera.first == "カメラ0") //←"カメラ0"はビルド時に事前にハッシュ値が計算され、文字列ではない数値とおきかわっている<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらがカメラ0", GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (camera.first == "カメラ1")<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらはカメラ1", GetColor(0, 255, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーン0の内容を画面に描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, 0, screenHandle0, FALSE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, 0, Screen::Width, Screen::Height / 2, GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スクリーン1の内容を画面に描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, Screen::Height / 2, screenHandle1, FALSE);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, Screen::Height / 2, Screen::Width, Screen::Height, GetColor(0, 255, 0));</u><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    いかがでしょう？無事、2つのプレイヤから見える世界が映し出され、操作できましたか？<br>
    Gameクラスに任せることで、main.cppはすっきり見通しがよくなりました。<br>
    <br>
    <a id="mozTocId0006" class="mozTocH1">
      <h1>MyTimerクラスでchronoから得た時刻でゲームの描画のFPSを管理する</h1>
    </a> さて、板ポリとはいえ3Dを描画するので、描画のフレームレート[単位 FPS:Frame Per Second]を管理したいところです。<br>
    <p><code>MyTimer.hを新規作成</code>して、chrono経由で現在時刻などを計測できる機能をシングルトンとして準備しましょう。</p>
    <p class="source">#ifndef MYTIMER_H_<br>
      #define MYTIMER_H_<br>
      <br>
      <br>
      #include &lt;chrono&gt; // 精度の高い時刻を得る(C++ならWindows,Macなど色んな環境で使える)<br>
      #include &lt;thread&gt; // 処理休止sleep_forするために必要<br>
      #include &lt;string&gt; // 文字列string型に必要<br>
      #include &lt;sstream&gt; // ostringstreamに必要 標準出力(ostringstreamで文字列に標準出力を)<br>
      #include &lt;iomanip&gt; // 時間の文字列出力put_time()に必要<br>
      <br>
      #include "Singleton.h"<br>
      <br>
      // マルチプラットフォーム対応のchrono使用の時刻取り扱いクラス(C++11対応なら移植容易)<br>
      class MyTimer : public Singleton&lt;MyTimer&gt;<br>
      {<br>
      public:<br>
      &nbsp;&nbsp; &nbsp;friend class Singleton&lt;MyTimer&gt;; // Singleton でのインスタンス作成は許可<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 最初にsystem_clockとsteady_clockの両方で現在時間を取得<br>
      &nbsp;&nbsp; &nbsp;// ★system_clockは【WindowなどOSの時刻(ユーザーが変更したら巻き戻しもありうる)】<br>
      &nbsp;&nbsp; &nbsp;// ★steady_clockは【↑OSに依存しない時刻(不可逆なので時間計測に向いている)】<br>
      &nbsp;&nbsp; &nbsp;std::chrono::system_clock::time_point systemInitTime = std::chrono::system_clock::now();<br>
      &nbsp;&nbsp; &nbsp;std::chrono::steady_clock::time_point steadyInitTime = std::chrono::steady_clock::now();<br>
      &nbsp;&nbsp; &nbsp;std::chrono::steady_clock::time_point steadyNowTime = std::chrono::steady_clock::now();<br>
      <br>
      &nbsp;&nbsp; &nbsp;std::chrono::system_clock::time_point systemTimeFromStart = UpdateSystemTimeFromStart();<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 時刻を保管する文字列【注意】UpdateSystemTimeFromStart()呼ばないうちは最新に更新されない<br>
      &nbsp;&nbsp; &nbsp;std::string timeStringSystemClock = GetTimeString("%Y年%m月%d日%H時%M分%S秒");<br>
      &nbsp;&nbsp; &nbsp;float timeScale = 1.0f;//[実験機能]main.cppで画面を描く速度と連動させてスローモーションや早送りも<br>
      &nbsp;&nbsp; &nbsp;bool isTimeScaleMode = false; //[実験機能]スローモーション、早送りモードをON OFF<br>
      <br>
      <br>
      &nbsp;&nbsp; &nbsp;// 起動時間の記録の初期化/リセット(Initし直せば再取得もできる)<br>
      &nbsp;&nbsp; &nbsp;inline void Init()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // 最初にsystem_clockとsteady_clockの両方で現在時間を取得(再取得も)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; systemInitTime = std::chrono::system_clock::now();<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; steadyInitTime = <b>std::chrono::steady_clock::now();</b><br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 現時刻をOSに左右されず求める(計算結果はsystemTimeFromStartに保管)<br>
      &nbsp;&nbsp; &nbsp;inline std::chrono::system_clock::time_point <b>UpdateSystemTimeFromStart</b>()<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; steadyNowTime = <b>std::chrono::steady_clock::now(); //現時刻を得る(OSの時刻じゃない方)</b><br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // <b>開始時のsteady_clock::nowとの差</b>をとって、開始時のsystem_clock::nowに足す<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // [参考] https://techblog.kayac.com/steady_clock<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; systemTimeFromStart =<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; systemInitTime + std::chrono::duration_cast&lt;std::chrono::seconds&gt;(<b>steadyNowTime - steadyInitTime</b>);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return systemTimeFromStart;<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 現時刻を特定の文字列フォーマットで得る(得たものはsteadyNowTimeとtimeStringSystemClockに保管)<br>
      &nbsp;&nbsp; &nbsp;// 出力は"%c"ならフォーマットは[Mon Nov 27 10:58:32 2017]<br>
      &nbsp;&nbsp; &nbsp;// "%Y年%m月%d日%H時%M分%S秒"なら[2020年12月11日14時30分15秒](デフォルト)<br>
      &nbsp;&nbsp; &nbsp;// [フォーマット例] https://cpprefjp.github.io/reference/chrono/local_time.html<br>
      &nbsp;&nbsp; &nbsp;inline std::string&amp; GetTimeString(const char* timeStringFormat = "%Y年%m月%d日%H時%M分%S秒")<br>
      &nbsp;&nbsp; &nbsp;{<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; systemTimeFromStart = UpdateSystemTimeFromStart();//現時刻をOS時刻に左右されず得る<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // 時刻タイプ型をsystem_clockのtime_point型からtime_t型に変換する。<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::time_t timeFromStart = std::chrono::system_clock::to_time_t(systemTimeFromStart);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // ローカルタイムを得る(ローカルタイムについては以下リンク参照)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // https://programming.pc-note.net/c/time.html<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct tm localTimeFromStart;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; localtime_s(&amp;localTimeFromStart, &amp;timeFromStart);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //【ostringstream】は文字列ストリームに&lt;&lt;演算子などの方法でデータを流し込んでいく<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // https://programming-place.net/ppp/contents/cpp/library/029.html#write_to_string_stream<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::ostringstream oss;<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //↓この一行で文字列ストリームに流し込み<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; oss &lt;&lt; std::put_time(&amp;localTimeFromStart, timeStringFormat) &lt;&lt; std::endl;<br>
      <br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; timeStringSystemClock = oss.std::ostringstream::str(); //str()で文字列string化して保管<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return timeStringSystemClock; //現時刻を文字列として返す<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      <br>
      &nbsp;&nbsp; &nbsp;// Initしてから現在までの経過時間を得る(単位Tick = 100ナノ秒 = 1/10000000秒)<br>
      &nbsp;&nbsp; &nbsp;inline long GetElapsedTicks()<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 時刻を更新<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <b>UpdateSystemTimeFromStart</b>();<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // Initしてから現在までの経過時間(ナノ秒)<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; auto durationFromInit = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(steadyNowTime - steadyInitTime);<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // Tick数。1Tick = 100ナノ秒 = 1/10000000秒<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return (long)(durationFromInit.count() / 100);<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 指定ナノ秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;inline void SleepForNanoSec(int waittime)<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 指定ナノ秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::nanoseconds(waittime));<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 指定マイクロ秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;inline void SleepForMicroSec(int waittime)<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 指定ミリ秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::microseconds(waittime));<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 指定ミリ秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;inline void SleepForMilliSec(int waittime)<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 指定ミリ秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(waittime));<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 指定 秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;inline void SleepForSec(int waittime)<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 指定 秒 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::seconds(waittime));<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      &nbsp;&nbsp; &nbsp;// 指定 分 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;inline void SleepForMinutes(int waittime)<br>
      &nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; &nbsp;// 指定 分 プログラムを休止<br>
      &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::minutes(waittime));<br>
      &nbsp;&nbsp; &nbsp;}<br>
      <br>
      protected:<br>
      &nbsp;&nbsp; &nbsp;// 外部からのインスタンス作成は禁止<br>
      &nbsp;&nbsp; &nbsp;MyTimer() {};<br>
      &nbsp;&nbsp; &nbsp;//外部からのインスタンス破棄も禁止<br>
      &nbsp;&nbsp; &nbsp;virtual ~MyTimer() {};<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>main.cppを変更</code>して、MyTimerクラスでゲームの毎フレーム描画処理(GameDraw)を「スキップやウェイト待ち処理」などしてフレームレートを安定させましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Game.h"<br>
      <em>#include "MyTimer.h"</em><br>
      #include "Screen.h"<br>
      <br>
      <em>//[g_グローバル変数 と s_スタティックグローバル変数の違い] https://zenn.dev/melos/articles/1ddb67d024220f<br>
        // グローバル変数は「他のファイルからもアクセス可能な変数」になる<br>
        // staticグローバル変数は「他のファイルからはアクセスできないこのファイル限定呼び出し可能変数」になる<br>
        <br>
        // FPS 60フレームを目標にして描画に時間がかかるときに描画をスキップして1秒あたりのフレームレートを安定させる<br>
        <br>
        int g_targetFPS{ 60 }; // 目標のFPS(Frame Per Second, 1秒あたりのフレーム数)<br>
        static bool s_isEnableFrameSkip{ true }; // 高負荷時にフレームスキップするか（falseの場合は処理落ち（スロー））<br>
        double g_maxAllowSkipTime{ 0.2 }; // フレームスキップする最大間隔（秒）これ以上の間隔が空いた場合はスキップせずに処理落ちにする。<br>
        long g_intervalTicks = (long)(1.0 / g_targetFPS * 10000000); // フレーム間のTick数 1Tick = 100ナノ秒 = 1/10000000秒<br>
        int g_maxAllowSkipCount = (int)(g_targetFPS * g_maxAllowSkipTime); // フレームスキップを許す最大数<br>
        <br>
        static long s_nextFrameTicks = g_intervalTicks; // 次のフレームの目標時刻<br>
        static long s_fpsTicks{ 0 }; // FPS計測のためのTicks<br>
        static int s_skipCount{ 0 }; // 何回連続でフレームスキップしたか<br>
        static int s_fpsFrameCount{ 0 }; // FPS計測のためのフレームカウント 60回数えるごとに、要した時間からFPSを算出する<br>
        <br>
        <br>
        static float s_currentFPS; // 現在のFPS (Frame per Second)<br>
        <br>
        // ゲームを描く処理<br>
        static inline void GameDraw(Game&amp; game)<br>
        {//↑staticグローバル関数は「他のファイルからはアクセスできないこのファイル限定呼び出し可能関数」になる<br>
        &nbsp;&nbsp;&nbsp; DxLib::ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
        &nbsp;&nbsp;&nbsp; game.Draw(); // パラパラ漫画の描画処理<br>
        #ifdef DEBUG_DRAW_FPS<br>
        &nbsp;&nbsp;&nbsp; DxLib::DrawString(Screen::Width - 130, 30, (std::string("FPS:") + std::to_string(s_currentFPS)).c_str(), GetColor(255, 255, 255));<br>
        #endif<br>
        &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); // 裏で描いておいたパラパラ漫画を表面に入れ替えフリップ<br>
        &nbsp;&nbsp;&nbsp; s_skipCount = 0; // フレームスキップのカウントをリセット<br>
        }</em><br>
      <br>
      <br>
      // 設定画面の【リンカー】→【システム】の【サブシステム】をWindows(SUBSYSTEM:WINDOWS)に設定するとWinMainからプログラムが開始する<br>
      int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; <em>// [Windowsの機能]このプログラム実行の処理優先度を上げたいときに呼ぶ<br>
        &nbsp;&nbsp;&nbsp; SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; // ★垂直同期とはモニターへの描画が完了するまで処理全体を停止し、<br>
        &nbsp;&nbsp;&nbsp; // 描画処理と更新処理の間隔を双方一定となるように処理の間隔を調整すること<br>
        &nbsp;&nbsp;&nbsp; // https://qiita.com/Seiten_Minagawa/items/615312ebe5e688ffee7f<br>
        &nbsp;&nbsp;&nbsp; // 画面リフレッシュレートと目標フレームレートが等しい場合は垂直同期を有効に、等しくない場合は垂直同期を無効にする<br>
        &nbsp;&nbsp;&nbsp; DxLib::SetWaitVSyncFlag( (DxLib::GetRefreshRate() == g_targetFPS) ? TRUE : FALSE ); //垂直同期を切るか?<br>
        &nbsp;&nbsp;&nbsp; //DxLib::SetWaitVSyncFlag(0); // 垂直同期を強制的に切りたい場合はコメントをはずす https://www.ay3s-room.com/entry/dxlib-framerate-controll</em><br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // 画面モードの設定<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetGraphMode(Screen::Width, Screen::Height, 32); // 画面サイズ Width×Heightのカラービット数32ビットで起動<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWindowSize(Screen::Width, Screen::Height);// ウィンドウサイズ Width×Height(こことSetGraphModeのサイズが異なると画像がゆがむ)<br>
      &nbsp;&nbsp;&nbsp; DxLib::ChangeWindowMode(TRUE);//フルスクリーン表示かウィンドウ表示か<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMouseDispFlag(TRUE);// ここをFALSEにするとマウスカーソル非表示<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetMainWindowText("3Dタイルゲーム");//この行でエラーになったら【設定】マルチバイト文字セットが間違ってるかも<br>
      &nbsp;&nbsp;&nbsp; <em>DxLib::SetAlwaysRunFlag(TRUE); // ウィンドウが非アクティブでも動作させるか?</em><br>
      &nbsp;&nbsp;&nbsp; //↑ここまでの設定は↓下のDXライブラリ初期化より先にやらないとDxLib_Init()中は画面がフルスクリーンになって終わってからウィンドウサイズが変更になり見苦しい<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの初期化<br>
      &nbsp;&nbsp;&nbsp; if (DxLib_Init() &lt; 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DXの初期化にエラーが発生したらプログラム自体を終了(returnで)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 独自時刻クラスの参照を得る(シングルトン型)<br>
        &nbsp;&nbsp;&nbsp; MyTimer&amp; timer = MyTimer::Instance();<br>
        &nbsp;&nbsp;&nbsp; timer.Init(); // 時刻計測開始</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化処理<br>
      &nbsp;&nbsp;&nbsp; Game game;<br>
      &nbsp;&nbsp;&nbsp; game.Init(); // gameのInit準備<br>
      <em>#ifdef _DEBUG // デバッグ用にgameのinit終了までの秒数を一瞬画面に出す(初期化ロード時間計測のため)<br>
        &nbsp;&nbsp;&nbsp; long initTime = timer.GetElapsedTicks(); // デバッグ用にInitの経過時間を取得<br>
        &nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, std::to_string(initTime / 10000000.0).c_str(), GetColor(255, 255, 255));<br>
        #endif</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; DxLib::ScreenFlip();<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <em>timer.Init(); // 時刻計測開始時間リセット(game.Initにかかった時間は計測時間に含めないため)</em><br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // アニメーション(パラパラ漫画)するにはWhile文<br>
      &nbsp;&nbsp;&nbsp; while (DxLib::ProcessMessage() == 0)<br>
      &nbsp;&nbsp;&nbsp; {// ProcessMessage() == 0になるのは×ボタン押したときなど<br>
      <em>#ifdef DEBUG_DRAW_FPS // ←#defineされていたら FPSを画面右上に描画する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // FPSの計測(FPS = 1秒あたりのパラパラ漫画枚数)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++s_fpsFrameCount; // フレーム数のカウントを +1<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s_fpsFrameCount &gt;= 60) // 60フレームを超えたら<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 経過時間 1Tick = 100ナノ秒 = 1/10000000秒 (elasped=経過)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long elapsedTicks = timer.GetElapsedTicks() - s_fpsTicks;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float elapsedSec = (float)elapsedTicks / 10000000; // 単位を秒(s:Second)に変換<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_currentFPS = s_fpsFrameCount / elapsedSec;// 現在のFPS<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_fpsFrameCount = 0; // 60枚数えたら0リセット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 60枚数えたら現在のFPS(パラパラ速度)を記録<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_fpsTicks = timer.GetElapsedTicks();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        #endif</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; game.Update(); //ゲームの更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>game.Draw(); // パラパラ漫画の描画処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::ScreenFlip(); //隠れて裏側で描いておいた画像を表面に入れ替え</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>//[実験機能]スローモーション、早送り(time.timeScaleが 2で2倍速 0.5で1/2スロー)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (timer.isTimeScaleMode &amp;&amp; timer.timeScale &gt; 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // フレームレートを再計算し早送りやスローモーション<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_targetFPS = (int)(60 * timer.timeScale); // 目標のFPS(Frame Per Second, 1秒あたりのフレーム数)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_maxAllowSkipTime = 0.2; // フレームスキップする最大間隔（秒）。これ以上の間隔が空いた場合はスキップせずに処理落ちにする。<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_intervalTicks = (long)(1.0 / g_targetFPS * 10000000); // フレーム間のTick数。1Tick = 100ナノ秒 = 1/10000000秒<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_maxAllowSkipCount = (int)(g_targetFPS * g_maxAllowSkipTime);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★垂直同期がDX設定で効いているならDXライブラリにWait処理を任せられる(フレームスキップだけ自分でやる)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (DxLib::GetWaitVSyncFlag() == TRUE &amp;&amp; timer.isTimeScaleMode == false)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ★フレームスキップとは描画処理が重い時にパラパラ漫画を1枚飛ばすか?<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s_isEnableFrameSkip)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ★余った時刻 = 次のパラパラ予定時刻 - 現在の時刻<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long waitTicks = s_nextFrameTicks - timer.GetElapsedTicks();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (waitTicks &lt; 0) // 目標時刻をオーバーしている<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★あまりにも漫画のパラパラページ数を飛ばすとキャラがワープして見えるので限度をつけてる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s_skipCount &lt; g_maxAllowSkipCount) // 連続フレームスキップ数が最大スキップ数を超えていなければ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++s_skipCount; // フレームスキップした数を +1（描画処理を飛ばした数）<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 最大スキップ数を超えてるので、フレームスキップしないで描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_nextFrameTicks = timer.GetElapsedTicks();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GameDraw(game); // ★限度越えでスロー描画処理に切替え<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 目標時刻OKなのでフレームスキップしないで描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★DXライブラリが自動で液晶の60Hzとタイミング合わせて描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GameDraw(game); // 描画処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次のパラパラ予定時刻はIntervalTicks(単位:100ナノ秒)あと<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_nextFrameTicks += g_intervalTicks;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ここのelseは何があってもフレームスキップしない設定の時に来る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GameDraw(game); // ★スロー描画処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ★垂直同期がDX設定で【効いてない】ならWait処理を自力でやる(フレームスキップも自分でやる)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↓こちらはフレームスキップ処理(waitTicks = 次のパラパラ予定時刻 - 現在の時刻)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long waitTicks = s_nextFrameTicks - timer.GetElapsedTicks(); // 余った時間（待機が必要な時間）<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s_isEnableFrameSkip &amp;&amp; waitTicks &lt; 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // あまりにも漫画のパラパラページ数を飛ばしすぎるとキャラがワープして見えるので限度をつけてる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s_skipCount &lt; g_maxAllowSkipCount)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++s_skipCount; // フレームスキップ（描画処理を飛ばす）<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // スキップ数の許容限度をオーバーしたら、FPSを落としてでもスローで無理してでも描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 次のパラパラ予定時刻を現時刻に設定するので次も絶対遅れてwaitTicks &lt; 0になる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_nextFrameTicks = timer.GetElapsedTicks();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GameDraw(game); //遅れつつもスローモーションで描いてゆく設定の時はここ(当然Updateも遅れていく)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ★自力でWait処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (waitTicks &gt; 20000) // あと2ミリ秒以上待つ必要がある<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ★自作TimeクラスのSleepで一定時間プログラム休止<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://marycore.jp/prog/objective-c/sleep-process/#sleep_for<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Sleepは指定した時間でピッタリ戻ってくるわけではないので、<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 余裕を持って、「待たなければならない時間-2ミリ秒」Sleepする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int waitMillsec = (int)(waitTicks / 10000) - 2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timer.SleepForMilliSec(waitMillsec);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 時間が来るまで何もしないループを回して待機する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (timer.GetElapsedTicks() &lt; s_nextFrameTicks)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 所定の時間になるまで空ループ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GameDraw(game); // 所定の時間になったら描画処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次のパラパラ予定時刻はIntervalTicks(単位:100ナノ秒)あと<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s_nextFrameTicks += g_intervalTicks;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // キー入力待ちをする<br>
      &nbsp;&nbsp;&nbsp; DxLib::WaitKey();<br>
      &nbsp;&nbsp;&nbsp; // ＤＸライブラリの後始末<br>
      &nbsp;&nbsp;&nbsp; DxLib::DxLib_End();<br>
      &nbsp;&nbsp;&nbsp; // ソフトの終了<br>
      &nbsp;&nbsp;&nbsp; return 0;<br>
      }</p>
    <br>
    いかがでしょう？フレームレートを安定させる処理をいれました。<br>
    といわれても実感があまり湧きませんね。<br>
    では、画面にFPSを表示させてみましょう。<br>
    <p><code>main.cppを変更</code>して、#define DEBUG_DRAW_FPSで FPSを画面右上に表示させるマクロを発動させましょう。</p>
    <p class="source">#include "DxLib.h"<br>
      <br>
      #include "Game.h"<br>
      #include "MyTimer.h"<br>
      #include "Screen.h"<br>
      <br>
      <br>
      <em>#define DEBUG_DRAW_FPS // ここをコメントアウトすると画面にFPSを文字で表示しない</em><br>
      <br>
      <br>
      //[g_グローバル変数 と s_スタティックグローバル変数の違い] https://zenn.dev/melos/articles/1ddb67d024220f<br>
      // グローバル変数は「他のファイルからもアクセス可能な変数」になる<br>
      // staticグローバル変数は「他のファイルからはアクセスできないこのファイル限定呼び出し可能変数」になる<br>
      <br>
      // FPS 60フレームを目標にして描画に時間がかかるときに描画をスキップして1秒あたりのフレームレートを安定させる<br>
      <br>
      int g_targetFPS{ 60 }; // 目標のFPS(Frame Per Second, 1秒あたりのフレーム数)<br>
      static bool s_isEnableFrameSkip{ true }; // 高負荷時にフレームスキップするか（falseの場合は処理落ち（スロー））<br>
      double g_maxAllowSkipTime{ 0.2 }; // フレームスキップする最大間隔（秒）これ以上の間隔が空いた場合はスキップせずに処理落ちにする。<br>
      long g_intervalTicks = (long)(1.0 / g_targetFPS * 10000000); // フレーム間のTick数 1Tick = 100ナノ秒 = 1/10000000秒<br>
      int g_maxAllowSkipCount = (int)(g_targetFPS * g_maxAllowSkipTime); // フレームスキップを許す最大数<br>
      <br>
      (中略)..........................<br>
      <br>
      // ゲームを描く処理<br>
      static inline void GameDraw(Game&amp; game)<br>
      {//↑staticグローバル関数は「他のファイルからはアクセスできないこのファイル限定呼び出し可能関数」になる<br>
      &nbsp;&nbsp;&nbsp; ClearDrawScreen();// 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp; game.Draw(); // パラパラ漫画の描画処理<br>
      #ifdef <b>DEBUG_DRAW_FPS</b><em> // game.Drawを描いたあとに上のレイヤにぬりつぶす形でFPSを文字で画面右上に表示</em><br>
      &nbsp;&nbsp;&nbsp; DxLib::<b>DrawString</b>(Screen::Width - 130, 30, (std::string("FPS:") + std::to_string(<b>s_currentFPS</b>)).c_str(), GetColor(255, 255, 255));<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; ScreenFlip(); // 裏で描いておいたパラパラ漫画を表面に入れ替えフリップ<br>
      &nbsp;&nbsp;&nbsp; s_skipCount = 0; // フレームスキップのカウントをリセット<br>
      }<br>
      <br>
      <br>
      (以下略).....<br>
    </p>
    <br>
    いかがでしょう？game.Draw()の「あとにFPSを描画」しているので、<br>
    ゲーム本体の描画のレイヤの上を、必ず塗りつぶして画面右上に現在のFPSを表示させることができます。<br>
    今は快適なFPSで描画できていますが、今後、ゲームの描画を複雑化させたときにFPSの状況をモニタリングする必要もでてくるかもしれません。<br>
    留意しなければいけないのが、Drawはスキップしていますが、Updateはスキップしていないということです。<br>
    今後、Update文にAIの経路の探索など重い処理を入れた場合はFPSは当然落ちます。<br>
    そのため、Unityなどでは <b>Update文(毎フレーム) と FixedUpdate文(固定フレームレート毎)</b> を分けているわけですね。<br>
    とりあえずこのゲームでは初心者にもとっつきやすい「固定フレームレート」前提の仕組みで制作していきます。<br>
    つまり、このゲームにおける Update文 = FixedUpdate文 の意味に読み替えて理解しておいたほうがいいです。<br>
    <br>
    <br>
    <a id="mozTocId0007" class="mozTocH1">
      <h1>共通のベース基底となるGameObjectを定義して、プレイヤなどはそれを継承する形を設計する</h1>
    </a>
    <p><code>前提としてクラスQuaternionを別記事から作成しておきます</code>←<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/polygon3d/index.html#mozTocId0015">クオータニオンで安定して回転できるようにする</a><br>
    </p>
    <br>
    さて、次はゲームエンジンの基礎となる共通のベース基底となるGameObjectクラスを設計していきましょう。<br>
    UnityではGameObjectという名前ですし、Unreal EngineではActor(アクター)と呼ばれる概念です。<br>
    名前は好みの問題ですのでGameObjectという名前にしましょう。<br>
    さて、GameObjectの使われ方を考えておきましょう。<br>
    重大なのは、<b>シーンの配下にあり「シーンと道ずれに消えてリセットされるべき」</b>という要件です。<br>
    これは、<b>最初から共有ポインタとしてstd::make_sharedされる前提で設計すべき</b>、ということです。<br>
    そして、共有ポインタ前提で設計する際に厄介なのは GameObjectクラス内部の関数で this を使いたいときです。<br>
    <b>this も「自分自身を指すポインタ」である</b>以上、その<b>thisポインタが共有されたときにも、カウント +1 しなければ、つじつまが崩れてしまいます</b>。<br>
    <b>ただの this では共有カウンタは +1 されない</b>ので、代わりに <a href="https://cpprefjp.github.io/reference/memory/enable_shared_from_this/shared_from_this.html">shared_from_this</a> を使って<b>「共有カウントを +1 したthis」を使う必要</b>があります。<br>
    shared_from_this を使う資格は「<a href="https://cpprefjp.github.io/reference/memory/enable_shared_from_this.html">std::enable_shared_from_this</a> を継承したクラスに与えられる」ので<b>GameObjectはstd::enable_shared_from_this を継承したクラスでないといけません</b>。<br>
    そして、さらなる<b>「重大なる厄介さ」</b>が待ち構えています。<br>
    <br>
    <b>「shared_from_thisは初期化コンストラクタで呼んではならない」という制約</b>です。<br>
    <br>
    この「厄介な制約」により、<b>事実上「shared_from_thisを使いたいような処理は初期化コンストラクタではできない」</b>ことを回避せねばならなくなってしまいました。<br>
    ゆえに、<b>代わりにInit()関数とか、UnityでいうStart()やAwake()関数のようなものを初期化の代替としてコンストラクタの後追いで一緒に呼ぶ、という回避策が必要</b>になります。<br>
    逆にいうと、<b>GameObjectを継承するクラスは「使う側が自由にnew GameObject(～)やstd::make_sharedできてはいけない」設計が必要</b>となってきます。<br>
    まあ、どのみちUnityでもシーンにGameObjectを生成するときにはInstatiate()関数を経由して生成していますよね。<br>
    直接生成を封じるためには<b>「クラスの初期化コンストラクタをprotected:にして外部から直接コンストラクタ経由の初期化生成するのを封じる」対策が必要</b>です。<br>
    上記までの事情を分かっているプログラマなら初期化コンストラクタとInit()関数をセットで呼んで初期生成するでしょうが、<br>
    事情を知らないプログラマは普通に初期化コンストラクタ経由で初期生成をしようとするでしょう。それをprotected:で邪魔するのです。<br>
    代わりに<b>コンストラクタのコメントに// Create関数経由で初期生成してください とただし書きをしておけば「空気読んでくれ」</b>は伝わります。<br>
    関数の名前はMake()関数でもいいし、Create()関数でもいいですが、わりとwebに出てくる動画などではcreate()関数にしていることが多い感はありますね。<br>
    なのでcreate()関数などが共有ポインタを返すような文脈で出てきているwebの動画などは「暗に上記事情の設計」をしている雰囲気がかもし出されている、と感じるべきです。<br>
    <br>
    さてと、上記事情をGameObjectが 直接std::enable_shared_from_thisを継承する 形でも設計はできるのですが、<br>
    今後<b>「GameObjectじゃないものも上記事情をかかえる場合もありそう」</b>だと予測できますよね。<br>
    ですので、さらに「ベース基底となるObjectクラス(std::enable_shared_from_thisを継承)」を間に入れるほうがよさそうです。<br>
    GameObjectは上記のObjectクラスを継承して「間接的にstd::enable_shared_from_thisを孫として継承」する形にします。<br>
    ついでにObjectクラスにはUnityにもあるように<br>
    「通し番号インスタンスIDを初期化と同時にカウントアップして保持して == で同じインスタンスIDか判定」<br>
    「タグを振ってFindWithTagで辞書からタグでオブジェクトを検索できる機能」<br>
    なども組み入れてしまいましょう。<br>
    <br>
    <p><code>Object.hを新規作成</code>して、継承するとshared_from_this_asでき、<br>
      Create関数経由で初期化とInitをセットでできて、インスタンスIDやタグを振って検索できるベース基底クラスを準備しましょう。</p>
    <p class="source">#ifndef OBJECT_H_<br>
      #define OBJECT_H_<br>
      <br>
      #include &lt;memory&gt; // 共有ポインタを使う<br>
      #include &lt;unordered_map&gt;<br>
      #include "MyHash.h" // hash32でタグ→オブジェクトを辞書検索できるようにする<br>
      <br>
      <br>
      // <b>Objectクラスのコンストラクタでは shared_from_this を使えない</b>から<br>
      // <b>Initをoverride継承</b>して<b> Initの中で shared_from_thisを必要</b>とする<b>初期化する際に渡すパラメタ</b>を<br>
      // このベース基底クラスを継承して定義する<br>
      struct <b>InitParams</b><br>
      {<br>
      &nbsp;&nbsp;&nbsp; InitParams() = default;<br>
      <br>
      &nbsp;&nbsp;&nbsp; <b>// このクラスを継承したクラスで、初期化に必要なパラメタを渡す(初期化に必要なパラメタはそれぞれ違うので)</b><br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual ~InitParams() {}<br>
      };<br>
      <br>
      <br>
      // GameObjectなどをこの Object型を継承して新規生成することで シリアルIDを自動で振り、shared_from_this_as&lt;Player&gt;()などで 共有状態のthisを得られるようにする<br>
      class Object <b>: public std::enable_shared_from_this</b>&lt;Object&gt;<br>
      {&nbsp;&nbsp;&nbsp; // [std::shared_ptrでthisポインタをつかうためには]↑ https://www.kabuku.co.jp/developers/cpp_enable_shared_from_this<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 通し番号(シリアルID)をstaticで管理してインスタンスが生成されるたびにシリアル番号を++して返す<br>
      &nbsp;&nbsp;&nbsp; static unsigned int <b>newID</b>() { <b>static unsigned int _serialID_ = 0;</b> return _serialID_<b>++</b>; }<br>
      protected: // protected:にしてクラス外からの直接のアクセスを阻む<br>
      &nbsp;&nbsp;&nbsp; const unsigned int m_InstanceID; // オブジェクトのインスタンスID (0 ～ 約42億までの番号)<br>
      &nbsp;&nbsp;&nbsp; hash32 m_Tag{ "" }; // オブジェクトに振ったタグ デフォルトの空文字""の場合は検索可能な辞書に登録しない<br>
      <br>
      &nbsp;&nbsp;&nbsp; // <b>コンストラクタはprotected:にしてある</b>ので <b>Create関数経由で初期化</b>してください<br>
      &nbsp;&nbsp;&nbsp; Object() : m_InstanceID{ Object::<b>newID</b>() } {&nbsp; };<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; unsigned int InstanceID() { return m_InstanceID; };<br>
      &nbsp;&nbsp;&nbsp; inline hash32 Tag() const { return m_Tag; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ (辞書にタグが登録されていたら、そのタグを辞書からも消しておく)<br>
      &nbsp;&nbsp;&nbsp; virtual ~Object() { if (m_Tag != "") umTagObjects().erase(m_Tag); };<br>
      <br>
      &nbsp;&nbsp;&nbsp; //[protectedなコンストラクタでもstd::make_sharedで呼ぶテク] https://gintenlabo.hatenablog.com/entry/20131211/1386771626<br>
      &nbsp;&nbsp;&nbsp; template&lt;typename ObjectT&gt;<br>
      &nbsp;&nbsp;&nbsp; struct ProtectedCall : public ObjectT<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // <b>ダミーとなる ProtectedCallクラスが public:だからそれを経由して間接的にコンストラクタがprotected:なクラスでもmake_sharedを呼ぶ</b>テク<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class... ArgsT&gt; // std::make_sharedはprotectedな継承クラスは呼べないのでそれを回避するテクニック<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; explicit ProtectedCall(ArgsT&amp;&amp;... args)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : ObjectT(std::forward&lt;ArgsT&gt;(args)...) { } //std::forwardで複数引数を完全転送で引き渡し https://proc-cpuinfo.fixstars.com/2016/03/c-html/<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // <b>コンストラクタでは shared_from_this を使えないから、Initをoverride継承</b>して Initの中で <b>shared_from_thisを必要とする初期化</b>をする<br>
      &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;<b>InitParams</b>&gt; initParams = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>// overrideして shared_from_this_as が必要な パラメータの初期化を行ってください</b><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // <b>Objectを継承した型はこの create関数を経由して新規生成</b>する<br>
      &nbsp;&nbsp;&nbsp; template &lt;typename DerivedT, typename OutTypeT = DerivedT, <b>typename ...ArgsT</b>&gt;<br>
      &nbsp;&nbsp;&nbsp; static auto <b>Create</b>(std::shared_ptr&lt;InitParams&gt; initParams, ArgsT&amp;&amp;...args)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pObject = std::static_pointer_cast&lt;OutTypeT&gt;(<b>std::make_shared</b>&lt;ProtectedCall&lt;DerivedT&gt;&gt;(std::forward&lt;ArgsT&gt;(args)...));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pObject-&gt;<b>Init(initParams)</b>; // <b>コンストラクタでは shared_from_this_as できないものをmake_sharedが終わったタイミングで一緒に初期化</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pObject;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // <b>shared_from_this() を DerivedT型にキャストして返す</b> [参考] https://qiita.com/terukazu/items/e4129105b12442e42651<br>
      &nbsp;&nbsp;&nbsp; template &lt;typename DerivedT&gt;<br>
      &nbsp;&nbsp;&nbsp; auto <b>shared_from_this_as()</b> noexcept {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::dynamic_pointer_cast&lt;DerivedT&gt;(<b>Object::shared_from_this()</b>);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // &lt;振ったタグ, オブジェクトへの弱共有リンク&gt; の辞書を関数内staticで保持して検索できるようにしてある<br>
      &nbsp;&nbsp;&nbsp; static inline std::unordered_map&lt;hash32, std::weak_ptr&lt;Object&gt;&gt;&amp; umTagObjects()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 関数内staticで タグから オブジェクトへの弱共有ポインタを保持<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static std::unordered_map&lt;hash32, std::weak_ptr&lt;Object&gt;&gt; _umTagObjects_;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _umTagObjects_;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // オブジェクトにタグを振って検索できるようにしておく (空文字 "" のタグが指定されたら辞書から消す)<br>
      &nbsp;&nbsp;&nbsp; template &lt;typename DerivedT&gt;<br>
      &nbsp;&nbsp;&nbsp; inline auto SetTag(const std::string&amp; tag)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_Tag != "" &amp;&amp; tag == "") // 空文字 "" のタグが指定されたら辞書から消す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umTagObjects().erase(m_Tag); // 既存のタグが辞書に登録されてたら辞書から消す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Tag = ""; // タグを空文字へリセット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return shared_from_this_as&lt;DerivedT&gt;(); // メソッドチェーンで-&gt;で連鎖アクセスできるように thisを返す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Tag = tag; // タグを設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umTagObjects().emplace(m_Tag, shared_from_this_as&lt;DerivedT&gt;()); // タグと弱共有リンクをペアで辞書に登録<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return shared_from_this_as&lt;DerivedT&gt;(); // メソッドチェーンで-&gt;で連鎖アクセスできるように thisを返す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // オブジェクトに振っておいたタグで検索する<br>
      &nbsp;&nbsp;&nbsp; template &lt;typename DerivedT&gt;<br>
      &nbsp;&nbsp;&nbsp; static std::weak_ptr&lt;DerivedT&gt; FindWithTag(const std::string&amp; tag)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto found = umTagObjects().find(tag); // 辞書からtagと一致するものを見つける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (found == end(umTagObjects())) // 結果がendのときは見つからなかった<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::weak_ptr&lt;DerivedT&gt;(); // 空の弱共有ポインタを返す(空の弱共有ポインタはlock()してもnullptrになる)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (found-&gt;second.lock() == nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 辞書には found が見つかったが lock()したら nullptr のときはすでにリンク先本体が消されているから辞書からもeraseで消す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umTagObjects().erase(tag);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::weak_ptr&lt;DerivedT&gt;(); // 空の弱ポインタを返す(lock()してもnullptrになる)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::dynamic_pointer_cast&lt;DerivedT&gt;(found); // DerivedT型(継承先の型タイプ)に変換してreturn する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 比較演算子 == ではインスタンスIDを比較する<br>
      &nbsp;&nbsp;&nbsp; inline bool operator == (const Object&amp; other) const { return this-&gt;m_InstanceID == other.m_InstanceID; }<br>
      &nbsp;&nbsp;&nbsp; // 不一致演算子 != ではインスタンスIDを比較する<br>
      &nbsp;&nbsp;&nbsp; inline bool operator != (const Object&amp; other) const { return !(*this == other); }<br>
      };<br>
      <br>
      <br>
      #endif<br>
    </p>
    <br>
    template &lt;typename DerivedT&gt;などテンプレートでかなり読みづらいとは思いますが、<br>
    ようはCreate関数の中でstd::make_sharedで初期化して、それとセットでInit関数も呼び出しているということです。<br>
    初期化コンストラクタでは例えば、World* worldやVector3 positionなど色々初期化で渡したい引数があるしクラスごとに引数の数も増えるとおもいますが、<br>
    Create関数のテンプレートの <b>typename ...ArgsT</b>←これのおかげで魔法のように<b>引数が</b>ワールドやポジション以外に<b>何個増えても</b>、<br>
    Create( world, position, ～その他いろんな引数が増えても...) のように呼び出しかたがテンプレで拡張可能になっています。<br>
    <br>
    あとはこのObjectクラスを継承すれば、GameObjectは<b>shared_from_this_as&lt;Player&gt;()</b>などで 「共有カウンタを+1できるthis」 を使える準備が整います。<br>
    <br>
    <p><code>GameObject.hを新規作成</code>して、PlayerやZakoなどの基底ベースとなるクラスを準備しましょう。</p>
    <p class="source">#ifndef GAMEOBJECT_H_<br>
      #define GAMEOBJECT_H_<br>
      <br>
      #include &lt;memory&gt; // 共有ポインタの定義のため<br>
      <br>
      #include "Vector3.h"<br>
      #include "Quaternion.h"<br>
      <br>
      #include "Object.h" // インスタンスIDや検索タグを持ち、shared_from_this_as&lt;継承先クラス名&gt;などができる<br>
      <br>
      class World; // 前方宣言<br>
      <br>
      // ゲーム上に表示される物体の基底クラス。<br>
      // プレイヤーや敵、アイテムなどはこのクラスを継承して作る。<br>
      class GameObject : public Object<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるのでCreate関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; GameObject(World* world = nullptr, Vector3 position = { 0,0,0 }, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Object(), m_world{ world }, position{ position }, rotation{ rotation }, velocity{ velocity }, force{ force }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~GameObject() {}<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★下記3つはメモリ上で共用状態になる(position、x,y,z、xyzどの名前から数値を変えたり読出してもメモリ上は同じ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 同じデータに3種類の名前を付けたイメージ、しかもVector3の機能や配列としてのアクセスの仕方もできて便利<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // XYZ座標&nbsp; [匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 position; // XYZ座標<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp;&nbsp; }; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
      <br>
      &nbsp;&nbsp;&nbsp; Quaternion rotation; // 回転クオータニオン<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vx, vy, vz; }; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 velocity; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyz;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vxForce, vyForce, vzForce; }; // XYZ方向にかかる力(Unityでいうと AddForce関数 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 force; // XYZ方向の力(物理的には加速度:1フレームごとにvelocityの増える=加速する量)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyzForce;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; World* m_world; // GameObjectが配置されたワールドへのリンク<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; virtual World* world() { return m_world; }<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
      &nbsp;&nbsp;&nbsp; virtual void world(World* changeWorld) { m_world = changeWorld; }<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; bool isDead{ false }; // 死んだ（削除対象）フラグ<br>
      &nbsp;&nbsp;&nbsp; bool isStatic{ false }; // 動かない(静的オブジェクトか?)<br>
      &nbsp;&nbsp;&nbsp; bool isGround{ false }; // 地面についているか<br>
      &nbsp;&nbsp;&nbsp; bool isFlying{ false }; // 空をとんでいるか<br>
      <br>
      &nbsp;&nbsp;&nbsp; hash32 typeTag{ "" }; // 小カテゴリ Zako0など個別のタイプ<br>
      &nbsp;&nbsp;&nbsp; hash32 baseTag{ "" }; // 大カテゴリ Enemyなど大まかなベースジャンル<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() = 0; // 純粋仮想関数 = 0 にすると【絶対 Update()関数はoverrideしなきゃいけない義務を付与できる 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() = 0; // 純粋仮想関数 = 0 にすると【絶対 Draw()関数はoverrideしなきゃいけない義務を継承先クラスに付与 】<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    とりあえずは位置positionなどは「親子構造をもたない形」で定義しました。<br>
    親子構造を持つtransformなどを考え出すと、xを一つ変えるだけでもそのxの変化を子供に伝搬させる必要が出てきたりして、<br>
    x = x + 1; したあとにいちいち UpdateChildX() などしないと子供に伝搬されず、忘れると「なぜだー状態」になり、<br>
    非常に頭が混乱して、初心者にはとっつきにくいプログラミングになってしまうので、シンプル化して他に注力するため今回は導入を見送ります。<br>
    <br>
    <p><code>Player.hを変更</code>して、GameObjectを継承しましょう。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Resource.h"<br>
      <em>#include "GameObject.h"</em><br>
      <u>#include "MyHash.h" // hash32型でプレイヤが現在いるワールドのタグを管理する<br>
        #include "Vector3.h"</u><br>
      <br>
      class World; // 前方宣言<br>
      class Camera; // 前方宣言<br>
      <br>
      class Player<em> : public GameObject</em><br>
      {<br>
      <em>protected:</em><br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<em>はprotected:にしてあるので、Create関数経由で初期生成してください</em><br>
      &nbsp;&nbsp;&nbsp; Player(World* world, Pad pad, Vector3 position<em>, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 }</em>)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pad{ pad }, <em>GameObject(world, position, rotation, velocity, force)</em> <u>m_world{ world }, position{ position }, velocity{ 0,0,0 }, force{0,0,0}</u><br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;<em>typeTag</em> = "Player";<em> // タグは個別の"プレイヤ1"などに使い、タイプはtypeTagで判別する形にしてタイプのジャンルを区別</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <em>public:</em><br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~Player() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★下記3つはメモリ上で共用状態になる(position、x,y,z、xyzどの名前から数値を変えたり読出してもメモリ上は同じ)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 同じデータに3種類の名前を付けたイメージ、しかもVector3の機能や配列としてのアクセスの仕方もできて便利<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // XYZ座標&nbsp; [匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 position; // XYZ座標<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
        &nbsp;&nbsp;&nbsp; };// unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
        <br>
        &nbsp;&nbsp;&nbsp; union {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vx, vy, vz; }; // XYZ方向の速度<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 velocity; // XYZ方向の速度<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyz;<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; union {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vxForce, vyForce, vzForce; }; // XYZ方向にかかる力(Unityでいうと AddForce関数 )<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 force; // XYZ方向の力(物理的には加速度:1フレームごとにvelocityの増える=加速する量)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyzForce;<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; hash32 tag{ "" }; // プレイヤにつけるタグ<br>
        protected:<br>
        &nbsp;&nbsp;&nbsp; World* m_world; // 配置されたワールドへのリンク<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
        &nbsp;&nbsp;&nbsp; virtual World* world() { return m_world; }<br>
        &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
        &nbsp;&nbsp;&nbsp; virtual void world(World* changeWorld) { m_world = changeWorld; }</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; Pad pad; // 操作するコントローラー番号<br>
      &nbsp;&nbsp;&nbsp; hash32 worldTag{ "" }; // 現在いるワールドのタグ<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeedMax = 6; // 移動速度Max値<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeed = 0;//移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; float moveAngle = 0; // X軸→方向から何度か<br>
      &nbsp;&nbsp;&nbsp; float deltaAngle = 0; // プレイヤの動く角度の変化率、ハンドルを切ったらだんだんもとに戻る<br>
      &nbsp;&nbsp;&nbsp; int animCount = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image; // プレイヤの板ポリゴンで描くタイル分割画像への共有リンク<br>
      <br>
      &nbsp;&nbsp;&nbsp; Camera* camera{ nullptr }; // プレイヤを追随するカメラ<br>
      &nbsp;&nbsp;&nbsp; void SetCamera(Camera* pCamera) { camera = pCamera; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理<br>
      &nbsp;&nbsp;&nbsp; virtual void HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update()<em> override</em>;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw()<em> override</em>;<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>Player.cppを変更</code>して、GameObjectを継承する記述にしましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      void Player::HandleInput()<br>
      {<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_LEFT) <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_A)) )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = - MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += 1; //ハンドルを左に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_RIGHT)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_D)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle -= 1; //ハンドルを右に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_UP)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_W)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = - MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += 0.6f; //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; MoveSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = MoveSpeedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(pad, PAD_INPUT_DOWN)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_S)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed -= 0.6f; //ブレーキを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.9f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = -0.9f;//ちょっとだけバックできるように<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pad == Pad::Key || pad == Pad::One) // コントローラ1またはキーボード操作のプレイヤのときだけ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGUP)) // キーボードのPageUp ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = 2.0f; // テスト用に空中の上方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGDN)) // キーボードのPageDown ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -2.0f; // テスト用に空中の下方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>rotation.SetRotation(VGet(0, (180 - moveAngle) * MyMath::Deg2Rad, 0)); // 前向きの3Dモデルなら180度回転させて奥方向の向きに設定</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp; x += vx;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp; y += vy;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp; z += vz;<br>
      <br>
      &nbsp;&nbsp;&nbsp; vy += vyForce; // 勢い(力・フォースを加算<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; // moveAngleは2D画像のX方向右を0度とするから、-90度回すと画像を正面に捉える位置にカメラを置ける<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int animIndex = animCount / 20; // キャラのパラパラアニメの画像番号(最大3)<br>
      &nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp; if (abs_vx &gt; 1.00f || abs_vz &gt; 1.00f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6; // キャラが地面のXとZ方向に少しでもスピードがあったらアニメを走らせる<br>
      &nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // プレイヤのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 9; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // カメラ向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 奥向きの画像<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *image, imgIndex + animIndex, TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    <br>
    <p><code>GameScene.cppを変更</code>して、ObjectのCreate関数を呼び出す形でPlayerを新規生成する記述にしましょう。</p>
    <p class="source">#include "GameScene.h"<br>
      <br>
      #include "Player.h"<br>
      <br>
      (中略).................<br>
      <br>
      <br>
      void GameScene::Initialize()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; (中略).................<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの生成<br>
      &nbsp;&nbsp;&nbsp; if (pWorld != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pWorld-&gt;AddCamera("カメラ1", Camera::defaultCamera); // プレイヤ1というタグをカメラにつけてワールドにカメラを配置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ1", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera1 = pWorld-&gt;camera("カメラ1"); // カメラ1 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera1-&gt;SetScreenHandle(screenHandle0); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer1 = <em>Object::Create&lt;Player&gt;(nullptr, </em>pWorld, Pad::Key, Vector3(90 + 256, 32, 95 + 256));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ1", pPlayer1); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath1]);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;camera = pCamera1.get(); // カメラをプレイヤにリンクする<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ2", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera2 = pWorld-&gt;camera("カメラ2"); // カメラ2 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera2-&gt;SetScreenHandle(screenHandle1); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer2 = <em>Object::Create&lt;Player&gt;(nullptr, </em>pWorld, Pad::Two, Vector3(190, 32, 195));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ2", pPlayer2); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath2]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;camera = pCamera2.get(); // カメラをプレイヤにリンクする<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      <br>
      (以下、略)......<br>
    </p>
    <br>
    いかがでしょう？カメラも今後必要あらば、ObjectやGameObjectを継承させることもできなくはありません。<br>
    現状は、shared_from_this_as&lt;Player&gt;を使ってInitで初期化しなきゃいけないようなものはありません。<br>
    次は、上記のshared_from_this_asを使ったInit初期化処理が必要になるような「コンポーネントの仕組み」を導入してみましょう。<br>
    <br>
    <a id="mozTocId0008" class="mozTocH1">
      <h1>Componentクラスを継承して、プレイヤなどに付け離し再利用可能なコンポーネント指向の機能を設計する</h1>
    </a> Unityなどのゲームエンジンの便利さを担保している仕組みとして「コンポーネント」があります。<br>
    ベースとなるGameObjectに[AddComponentボタン]を押して機能を付けたり外したりできる仕組みです。<br>
    では、そもそもコンポーネントとは何なのかを考えてみる必要がありそうです。<br>
    コンポーネントはいろいろな機能を持ちますが、それらはしょせんは継承した先の追加の機能にすぎません。<br>
    ですからコンポーネントそのものとは何なのか？ということに対する1つの重要な答えは、<br>
    <br>
    <b>「そのコンポーネントの所有者(オーナー)のパラメータにアクセスでき、オーナーに付着することができる」</b><br>
    <br>
    ゲームでいうところの装備みたいなイメージでしょうか？<br>
    装備すると、装備したオーナーのHPを毎ターン回復、するとするなら、オーナーのHPのパラメータにアクセスして、書き換えられなきゃいけません。<br>
    つまり、コンポーネントは<b>初期化するときに「所有者オーナーの this ポインタを受け取り、そのthis経由でオーナーのパラメタを書き換える」</b><br>
    ことができれば、装備主にいろいろな影響を与えることができるわけです。<br>
    すなわち<b>「コンストラクタでオーナーのthisを受け取り、オーナーに所有:共有ポインタで所持され、オーナーと道連れにリセットされる」</b>という<br>
    shared_from_this_as と std::shared_ptrの組み合わせが、コンポーネントの設計の根幹であることが導かれます。<br>
    <br>
    では、下記のシンプル化したComponentの仕組みを見てみましょう。<br>
    <p class="source">Componentの例<br>
      struct Component<br>
      {<br>
      &nbsp;&nbsp; GameObject* m_owner{ nullptr }; // オーナーのパラメータへアクセスするためのポインタ<br>
      &nbsp;&nbsp; Component(GameObject* owner) : m_owner{ owner } {}<br>
      <br>
      &nbsp;&nbsp; void Update()<br>
      &nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owner-&gt;x += 1; // ポインタ経由でオーナーの位置を+1ずつずらす<br>
      &nbsp;&nbsp; }<br>
      } </p>
    そうです。コンストラクタの初期化のときに宿主である所有者オーナーのポインタ ownerさえ受け取ってリンクを取っておけば、<br>
    毎回のUpdate()ごとに宿主オーナーのパラメタの x を +1 するなり、毒で宿主のHPを減らし続けるなり、<br>
    オーナーのパラメタに影響を及ぼすことができます。<br>
    <br>
    オーナー側は下記のようになります。<br>
    <p class="source">Playerの例<br>
      struct Player<br>
      {<br>
      &nbsp;&nbsp; <b>std::shared_ptr&lt;Component&gt;</b> m_component{ nullptr }; // コンポーネントへの共有カウンタ +1をキープして消えないように所持する<br>
      &nbsp;&nbsp; Player() : m_component{ this } {}<br>
      <br>
      &nbsp;&nbsp; void Update()<br>
      &nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_component-&gt;Update(); // コンポーネントのUpdate経由でオーナーの位置を+1ずつずらす<br>
      &nbsp;&nbsp; }<br>
      } </p>
    所有者のオーナー側はコンポーネントへの共有ポインタに最低限 +1 のカウンタをキープし続けることでコンポーネントが消えないようにキープします。<br>
    そして、Playerクラス側のUpdate関数内でm_component-&gt;Update(); のように所有するコンポーネントのUpdateを経由して自分のx位置のパラメタを変化させます。<br>
    これが一番シンプルな形のコンポーネントの仕組みです。<br>
    <br>
    ただし、コンポーネント側のポインタは生ポインタの this ではなく共有ポインタのほうがよいでしょう。<br>
    一旦、生ポインタになってしまうと、例えば、コンポーネントを継承した当たり判定のコライダがあるとしましょう。<br>
    コライダ同士が衝突した際に、どれとどれがぶつかったかの衝突情報にはぶつかったGameObjectの共有ポインタが必要になります。<br>
    なぜ、生ポインタだとだめなの？と思うかもしれませんが、<br>
    衝突した情報を見ている時点ですでにそのぶつかったGameObjectが消えてしまっているとしたら、<br>
    <b>生ポインタでは、住所は空の番号(=nullptr) ではないけど、すでにその住所にあった データ本体は メモリから削除済 ということ</b>が起こりえます。<br>
    例えるなら、<b>スマホに遠い昔の知人の電話番号はまだ登録されているが、電話をかけてみると「この番号は現在使われておりません」となる状態</b>です。<br>
    この状態の生ポインタは、VisualStudioの環境ではデバッグでアクセスすると0xccccccccc.. という16進数のcで埋まった番号になっています。<br>
    この<b>すでにメモリから削除済の0xcccccc...状態になっているポインタを「ダングリングポインタ」</b>と呼びます。<br>
    <b>「ダングリング状態 = 0xcccccc....」で「ヌルポインタ状態 = 0x000000....」ですからダングリング状態は if (p == nullptr) では判定できません</b>。<br>
    ですから、ダングリング状態が予想される状況では、共有ポインタを使うことになります。<br>
    共有ポインタには std::shared_ptr だけではなく 弱共有ポインタ std::weak_ptr もあります。<br>
    <b>弱共有ポインタ std::weak_ptr は 共有ポインタstd::shared_ptr と違って、リンクを張っただけでは 共有カウンタを +1 しません</b>。<br>
    <br>
    弱共有ポインタは使うときだけ、<br>
    <b>std::shared_ptr&lt;Component&gt; pComponent = weak_pComponent.lock();</b> のように <br>
    <b>.lock() でロックすることによって、ふつうの共有ポインタ std::shared_ptr型に戻すことができます</b>。<br>
    当然、<b>戻した共有ポインタ pComponent が使われなくなれば、lock()も外れて、再び共有カウンタは -1 </b>されます。<br>
    では、もし <b>弱共有ポインタstd::weak_ptrの指す先がすでに「この番号は現在使われておりません状態」のとき</b>はどうなるのでしょうか？<br>
    この場合は<b>生ポインタと違って if (pComponent == nullptr) の判定で引っ掛けることができます</b>。<br>
    <br>
    このように<b>生ポインタではなくstd::weak_ptrの弱共有ポインタなら、使いたいときだけ.lockして共有ポインタに戻したり、ダングリング判定もできます</b>。<br>
    なので、<b>やはり大元「おおもと」のGameObjectは生ポインタの this では心もとない</b>ので shared_from_this_as で 共有ポインタ状態で初期生成できる必要があります。<br>
    <br>
    <b>大元が生ポインタ発祥であると、衝突など「大元がすでに現在使われておりません状態」のダングリング判定が必要な状況で詰んでしまう</b>ことになるのです。<br>
    <br>
    では、下記のstd::weak_ptr化したComponentの例を見てみましょう。<br>
    <p class="source">Componentの例<br>
      struct Component<br>
      {<br>
      &nbsp;&nbsp; <em>std::weak_ptr&lt;GameObject&gt;</em> m_owner{ nullptr }; // オーナーのパラメータへアクセスするためのポインタ<br>
      &nbsp;&nbsp; Component(<em>std::shared_ptr&lt;GameObject&gt;</em> owner) : m_owner{ owner } {}<br>
      <br>
      &nbsp;&nbsp; void Update()<br>
      &nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>auto pPlayer = owner.lock(); // 共有ポインタに戻す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pPlayer != nullptr) // ダングリング状態じゃないか？<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pPlayer-</em>&gt;x += 1; // ポインタ経由でオーナーの位置を+1ずつずらす<br>
      &nbsp;&nbsp; }<br>
      } </p>
    これでダングリング状態の心配もなくなりました。<br>
    なぜ m_owner は std::shared_ptrじゃなくわざわざstd::weak_ptrにする必要があるのか？って？<br>
    これは、<b>Componentが「所有される側だから」</b>です。<br>
    オーナーであるPlayerは「共有カウンタが 0」にならない限りはメモリから削除されません。<br>
    でも、もし<b>「所有しているコンポーネント内部にstd::shared_ptrのリンクがあるとずっと +1 が残ってしまう」</b>わけですね。<br>
    「プレイヤと道連れにプレイヤの所有するコンポーネントも消えてほしい」はずなのに<b>逆に「コンポーネント側の +1」の呪いにかかって成仏できない</b>わけです。<br>
    <b>コンポーネント内部の m_owner が 弱共有ポインタ std::weak_ptr ならば 共有カウンタは +1 されない</b>ので、呪われる心配はありません。<br>
    <br>
    この<b>「所有する側と所有される側が互いに std::shared_ptr のリンクを持ち続ける 呪い」はデッドロックの実例として注意が必要</b>です。<br>
    なので、一時的に使ってすぐにリンクを捨てる場合以外は、できる限りstd::weak_ptrで使うときだけ.lock()して使うほうがデッドロックの心配は減ります。<br>
    <b>使う側は「std::shared_ptrをメンバ変数などとして長期保持する際は、デッドロックしないかを気にする必要」</b>があります。<br>
    std::shared_ptrが共有だけでなく「+1のキープ」を意味することを意識した上で「むやみにクラスのメンバ変数としてstd::shared_ptr型を持たず」に<br>
    <b>どこが共有状態の「最低限の+1のキープ」のおおもとか</b>をプログラミングする人は明確に知っておかないと「メモリから成仏しない状態」に悩むことになるでしょう。<br>
    <br>
    共有ポインタの使い手はつねに「いかに道連れにしてやろうか」を考えながらプログラミングする必要があるのです。<br>
    <br>
    実はこれはC++だけじゃなくC#でも同じです。<br>
    暗黙のリンクがあちこちに張られている限り「メモリから成仏されない」=「メモリもれ」=「メモリリーク」が起こっている可能性があります。<br>
    「C#はポインタを意識しなくてすむ」=「すべてが暗黙の共有リンク状態」であるわけで、<br>
    <b>実は「普通の共有ポインタ」と「弱共有ポインタ」を自分でちゃんと区別して使い分けられるC++のほうがまだ怖くない説</b>、すらあるわけです。<br>
    <br>
    <b>「その変数のリンク先、ほんとにメモリから消えてくれてますか？」(怪談調)のことばを意識しながらプログラムしてください</b>ね。<br>
    <br>
    ではPlayerに付着できるジャンプ上昇と重力落下のコンポーネントを設計していきましょう。<br>
    設計を始める前に、まずはコンポーネント設計無しのPlayerクラスへの直打ちでのジャンプと重力落下のコードを書いてみましょう。<br>
    ジャンプのコードはこちらの記事を参考に3D対応します→<a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/practice.html#mozTocId0004">キャラをZキーでジャンプさせるプログラム</a> <br>
    <p><code>Player.hを変更</code>して、ジャンプと重力落下の処理を直打ちで追加します。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Resource.h"<br>
      #include "GameObject.h"<br>
      <br>
      class World; // 前方宣言<br>
      class Camera; // 前方宣言<br>
      <br>
      class Player : public GameObject<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるので、Create関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; Player(World* world, Pad pad, Vector3 position, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pad{ pad }, GameObject(world, position, rotation, velocity, force)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "Player"; // タグは個別の"プレイヤ1"などに使い、タイプはtypeTagで判別する形にしてタイプのジャンルを区別<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~Player() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; Pad pad; // 操作するコントローラー番号<br>
      &nbsp;&nbsp;&nbsp; hash32 worldTag{ "" }; // 現在いるワールドのタグ<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeedMax = 6; // 移動速度Max値<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeed = 0;//移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; float moveAngle = 0; // X軸→方向から何度か<br>
      &nbsp;&nbsp;&nbsp; float deltaAngle = 0; // プレイヤの動く角度の変化率、ハンドルを切ったらだんだんもとに戻る<br>
      &nbsp;&nbsp;&nbsp; int animCount = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image; // プレイヤの板ポリゴンで描くタイル分割画像への共有リンク<br>
      <br>
      &nbsp;&nbsp;&nbsp; Camera* camera{ nullptr }; // プレイヤを追随するカメラ<br>
      &nbsp;&nbsp;&nbsp; void SetCamera(Camera* pCamera) { camera = pCamera; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>float yJumpStart{ 0.0f };<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyJumpSpeed{ 13, 14, 15, 4 }; // ジャンプ開始の初期速度<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyForceJump{ 0.5f, 0.4f, 0.3f, 0.1f }; // ジャンプ上昇にかかる力の初期値<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyGravity{ 0.8f,0.8f,0.8f,0.8f }; // 重力の設定値<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyDownSpeedMax{ 16, 16, 16, 8 }; // 降下スピードのリミット</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理<br>
      &nbsp;&nbsp;&nbsp; virtual void HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() override;<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>Player.cppを変更</code>して、GameObjectを継承する記述にしましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      void Player::HandleInput()<br>
      {<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_LEFT) <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_A)) )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = - MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += 1; //ハンドルを左に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_RIGHT)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_D)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle -= 1; //ハンドルを右に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_UP)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_W)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = - MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += 0.6f; //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; MoveSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = MoveSpeedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(pad, PAD_INPUT_DOWN)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_S)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed -= 0.6f; //ブレーキを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.9f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = -0.9f;//ちょっとだけバックできるように<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pad == Pad::Key || pad == Pad::One) // コントローラ1またはキーボード操作のプレイヤのときだけ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGUP)) // キーボードのPageUp ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = 2.0f; // テスト用に空中の上方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGDN)) // キーボードのPageDown ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -2.0f; // テスト用に空中の下方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>if (isGround)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pad, PAD_INPUT_A) // Zキーを押した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを押した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = vyJumpSpeed[0]; // ジャンプ方向はY上方向<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vyForce = -vyForceJump[0];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yJumpStart = y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (vy &lt;= 0) // 下落開始(vyが0未満のときはまだジャンプ中)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vyForce = -vyGravity[0]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (Input::GetButtonUp(pad, PAD_INPUT_A) // Zキーを離した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonUp(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを離した瞬間<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (y - yJumpStart &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vyForce = -vyGravity[0]; // ジャンプ上昇中(vy未満のとき)にボタンを離したら早めに重力をかけ始める<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; rotation.SetRotation(VGet(0, (180 - moveAngle) * MyMath::Deg2Rad, 0)); // 前向きの3Dモデルなら180度回転させて奥方向の向きに設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp; x += vx;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp; y += vy;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp; z += vz;<br>
      <br>
      &nbsp;&nbsp;&nbsp; vy += vyForce; // 勢い(力・フォースを加算<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>if (y &lt;= 0.0f) // 0.0fを地面として 0.0f以下になったら地面に着地したと判定する<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f; // 地面に沿わせる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -0.01f; // 下方向への速度をほぼ 0 にする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGround = true;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (vy &lt;= -vyDownSpeedMax[0]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -vyDownSpeedMax[0];</em><br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; // moveAngleは2D画像のX方向右を0度とするから、-90度回すと画像を正面に捉える位置にカメラを置ける<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int animIndex = animCount / 20; // キャラのパラパラアニメの画像番号(最大3)<br>
      &nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp; if (abs_vx &gt; 1.00f || abs_vz &gt; 1.00f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6; // キャラが地面のXとZ方向に少しでもスピードがあったらアニメを走らせる<br>
      &nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // プレイヤのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 9; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // カメラ向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 奥向きの画像<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *image, imgIndex + animIndex, TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    いかかでしょう？上のカメラの"プレイヤ1"は<b>キーボードのZキー(コントローラ1はA)を押したらジャンプ</b>しましたか？<br>
    下のカメラの"プレイヤ2"は<b>キーボードのQキー(コントローラ2はA)を押したらジャンプ</b>しましたか？<br>
    いちいち追加のコントローラをPCに用意しなくてもプレイヤ2もキーボードでデバッグできるようにしました。<br>
    <br>
    まあ、これで全然OKじゃん、と思う人もいますでしょうが、コンポーネントで着脱可能にすれば「アイテムを取ったらジャンプできるようになる」<br>
    もしくは、プレイヤ以外の「敵にもジャンプや重力のコンポーネントを付着して再利用」することも可能になり、柔軟性があがるわけです。<br>
    それがわざわざ頑張って「コンポーネント化」する意義なわけですね。<br>
    <br>
    ではここからはこの「ジャンプするコンポーネント」と「重力落下するコンポーネント」を作成していきましょう。<br>
    <br>
    まずはベース基底となるComponentクラスを準備します。<br>
    <p><code>Component.hを新規作成</code>して、コンポーネントのベース基底となるクラスを作成しましょう。</p>
    <p class="source">#ifndef COMPONENT_H_<br>
      #define COMPONENT_H_<br>
      <br>
      #include &lt;unordered_map&gt; // コンポーネントの辞書配列に使う<br>
      #include &lt;typeindex&gt; // intやComponentなどの「型」をsize_t型の IDの数値 へ typeid(int)などを使って変換する<br>
      #include "MyHash.h" // MyHashクラスで 言語 C++ C# など や ビルドするコンパイラ VisualStudioやgccなどに関係なく同じハッシュを計算<br>
      #include &lt;string&gt;<br>
      #include &lt;memory&gt; // 共有ポインタを使う<br>
      <br>
      #include "Object.h" // コンポーネントもObjectクラスを継承してshared_from_thisできるようにする<br>
      <br>
      class GameObject; //前方宣言(循環インクルード防止)<br>
      <br>
      // 各コンポーネントのひな形<br>
      class Component : public Object<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; std::<b>weak_ptr</b>&lt;GameObject&gt; <b>m_pOwner</b>; // このコンポーネントを所有するPlayerクラスなどへの弱共有ポインタ(弱なので所有権を主張しない)<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // このコンポーネントを所有するプレイヤなどのオーナーへの共有ポインタを得る (オーナーがすでにメモリから削除済の場合は nullptr になる)<br>
      &nbsp;&nbsp;&nbsp; std::<b>shared_ptr</b>&lt;GameObject&gt; <b>owner()</b> const { auto pOwner = m_pOwner<b>.lock()</b>; return (pOwner != nullptr) ? pOwner : nullptr; }<br>
      &nbsp;&nbsp;&nbsp; std::type_index typeID = typeid(Component);<br>
      &nbsp;&nbsp;&nbsp; hash32 typeTag{ "" }; // 小カテゴリ コンポーネントの名前 TilemapColliderなどColliderを継承したコンポーネント本体の名前<br>
      &nbsp;&nbsp;&nbsp; hash32 baseTag{ "" }; // 大カテゴリ コンポーネントの種類(Collider)など https://docs.unity3d.com/ja/current/ScriptReference/Collider.html<br>
      &nbsp;&nbsp;&nbsp; hash32 statusTag{ "" }; // 自由に使えばよいタグ<br>
      &nbsp;&nbsp;&nbsp; bool isEnabled{ true }; // コンポーネントが有効かどうか？<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // 初期化コンストラクタ : このコンポーネントの所有者ownerを内部に持つ<br>
      &nbsp;&nbsp;&nbsp; Component(std::<b>weak_ptr</b>&lt;GameObject&gt; <b>pOwner</b>) : <b>m_pOwner{ pOwner }</b>, Object()<br>
      &nbsp;&nbsp;&nbsp; {};<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 下記関数をoverrideして実装して【コンポーネント志向】を実現する<br>
      &nbsp;&nbsp;&nbsp; //virtual void Initialize(GameObject* obj = nullptr) {}; // Init的な処理 BGMの変更とか<br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) {}; // Update的な役<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw(GameObject* obj = nullptr) {}; // Draw的な役<br>
      &nbsp;&nbsp;&nbsp; //virtual void Finalize(GameObject* obj = nullptr) {}; // Finalize的な役(ステートの終了時)<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual ~Component() {}; // 仮想デストラクタ(無いとstringなど配列を内包するもののデストラクタが暗黙で呼ばれずメモリリーク)<br>
      };<br>
      <br>
      #endif<br>
    </p>
    最初に解説したとおり、オーナーのGameObjectへのリンクは弱共有ポインタstd::weak_ptrで受け取っているのでオーナーが削除されるのを邪魔しません。<br>
    一方で、owner()関数を呼んだときには、.lock()でロックをかけてstd::weak_ptrをstd::shared_ptrに変換して 一時的に共有カウンタを+1 しています。<br>
    owner()関数によって、<b>普段はオーナーが削除されるのを邪魔せず、虎視眈々とstd::weak_ptrをかかえて潜伏し「必要なときだけ 一時的に共有カウンタを+1」して共有ロック状態へ復帰</b>もできます。<br>
    <b>「弱い共有状態とは普段はリンク先が消えるのを邪魔せず、一時的に使ってる最中は消えないように +1 で削除を邪魔する」</b>使い方ができるということです。<br>
    <br>
    つぎにベース基底となるComponentクラスを継承して、派生(Derived)したジャンプや落下の物理系コンポーネントを作成しましょう。<br>
    <p><code>PhysicsComponent.hを新規作成</code>して、物理系のPhysicsComponentクラスを継承してジャンプや落下のコンポーネント作成しましょう。</p>
    <p class="source">#ifndef PHYSICS_COMPONENT_H_<br>
      #define PHYSICS_COMPONENT_H_<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      #include "Component.h"<br>
      #include "GameObject.h"<br>
      <br>
      // 物理系のコンポーネントはこのクラスを継承して実装する<br>
      class PhysicsComponent <b>: public Component</b><br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; inline PhysicsComponent(std::shared_ptr&lt;GameObject&gt; <b>pOwner</b>) : Component(<b>pOwner</b>)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;baseTag = "PhysicsComponent"; // 大まかなカテゴリーとしては物理系コンポーネント<br>
      &nbsp;&nbsp;&nbsp; };<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual ~PhysicsComponent() {};<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // なにか物理系のコンポーネントで共通して更新したいことがあればここに実装<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Draw(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // なにか物理系のコンポーネントで共通して描画したいことがあればここに実装<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      class GravityComponent <b>: public PhysicsComponent</b><br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline GravityComponent(std::shared_ptr&lt;GameObject&gt; <b>pOwner</b>, const std::vector&lt;float&gt;&amp; vyGravity, const std::vector&lt;float&gt;&amp; vyDownSpeedMax)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : PhysicsComponent(<b>pOwner</b>), m_vyGravity{ vyGravity }, m_vyDownSpeedMax{ vyDownSpeedMax }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;typeID = typeid(GravityComponent); //[環境によって差が出るので↓が無難か] https://qiita.com/nil_gawa/items/1fece3eee7ca1f88c71d<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;typeTag = "GravityComponent"; // 個別のカテゴリーとしては重力落下コンポーネント<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; virtual ~GravityComponent() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; size_t m_idx{ 0 }; // 適用する設定配列の番号<br>
      &nbsp;&nbsp;&nbsp; void SetIndex(size_t idx) { m_idx = idx; }<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; m_vyGravity; // 重力の設定値<br>
      &nbsp;&nbsp;&nbsp; float gravity() { return (m_idx &lt; m_vyGravity.size()) ? m_vyGravity[m_idx] : 0.0f; }<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; m_vyDownSpeedMax; // 降下スピードのリミット<br>
      &nbsp;&nbsp;&nbsp; float downSpeedMax() { return (m_idx &lt; m_vyDownSpeedMax.size()) ? m_vyDownSpeedMax[m_idx] : 0.0f; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isEnabled) return; // コンポーネントが有効状態じゃないときは何もせずreturn<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタをロックして得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;isGround == false &amp;&amp; pOwner-&gt;vy &lt;= 0) // 下落開始(vyが 0以上 のときはまだジャンプ中なので上昇を邪魔しないようにする)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;vyForce = -gravity(); // ジャンプ上昇力が0になって以降に初めて重力をオンにする(ジャンプの加速を邪魔しない工夫)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;OnFalling(); // 下落中の処理のコールバック関数を呼び返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;vy &lt;= -downSpeedMax()) // 無限に落下速度が加速しないようにリミットを働かせる(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;vy = -downSpeedMax(); // downSpeedMax()以上の落下速度にならないようにする<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      class JumpComponent : public PhysicsComponent<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline JumpComponent(std::shared_ptr&lt;GameObject&gt; pOwner, const std::vector&lt;float&gt;&amp; vyJumpSpeed, const std::vector&lt;float&gt;&amp; vyForceJump)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : PhysicsComponent(pOwner), m_vyJumpSpeed{ vyJumpSpeed }, m_vyForceJump{ vyForceJump }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;typeID = typeid(JumpComponent); //[環境によって差が出るので↓が無難か] https://qiita.com/nil_gawa/items/1fece3eee7ca1f88c71d<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;typeTag = "JumpComponent"; // 個別のカテゴリーとしてはジャンプ上昇コンポーネント<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; virtual ~JumpComponent() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; size_t m_idx{ 0 }; // 適用する設定配列の番号<br>
      &nbsp;&nbsp;&nbsp; void SetIndex(size_t idx) { m_idx = idx; }<br>
      &nbsp;&nbsp;&nbsp; float yJumpStart{ 0 }; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; m_vyJumpSpeed; // ジャンプの上昇スピードのリミット<br>
      &nbsp;&nbsp;&nbsp; float jumpSpeed() { return (m_idx &lt; m_vyJumpSpeed.size()) ? m_vyJumpSpeed[m_idx] : 0.0f; }<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; m_vyForceJump; // ジャンプ中の下方向の勢いの減速する力<br>
      &nbsp;&nbsp;&nbsp; float forceJump() { return (m_idx &lt; m_vyForceJump.size()) ? m_vyForceJump[m_idx] : 0.0f; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isEnabled) return; // コンポーネントが有効状態じゃないときは何もせずreturn<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;isGround == false &amp;&amp; pOwner-&gt;vy &gt; 0) // vyが0以上のときはまだジャンプ中<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;OnJumping(); // 空中でジャンプの上昇中に呼ばれるコールバック関数を呼び返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void JumpStart(GameObject* obj = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isEnabled) return; // コンポーネントが有効状態じゃないときは何もせずreturn<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;isGround)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;vy = jumpSpeed(); // ジャンプ方向はY上方向<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;vyForce = -forceJump(); // ジャンプの勢いが弱まる力<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; yJumpStart = pOwner-&gt;y;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;OnStartJump(); // ジャンプスタート時の処理をコールバックで呼び返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void JumpCancel(GameObject* obj = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isEnabled) return; // コンポーネントが有効状態じゃないときは何もせずreturn<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!pOwner-&gt;isGround &amp;&amp; pOwner-&gt;vy &gt;= 0) // vyが0以上のときはまだジャンプ上昇中<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;y - yJumpStart &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけ始めない<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;vyForce = -pOwner-&gt;gravity(); // ジャンプボタンを離したときには重力をかけ始める<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>GameObject.hを変更</code>して、OnStartJump()やOnFalling()やgravity()などジャンプ中や落下中に呼ばれるoverride元の関数を準備しましょう。</p>
    <p class="source">#ifndef GAMEOBJECT_H_<br>
      #define GAMEOBJECT_H_<br>
      <br>
      #include &lt;memory&gt; // 共有ポインタの定義のため<br>
      <br>
      #include "Vector3.h"<br>
      #include "Quaternion.h"<br>
      <br>
      #include "Object.h" // インスタンスIDや検索タグを持ち、shared_from_this_as&lt;継承先クラス名&gt;などができる<br>
      <br>
      class World; // 前方宣言<br>
      <em>class Component; // 前方宣言</em><br>
      <br>
      // ゲーム上に表示される物体の基底クラス。<br>
      // プレイヤーや敵、アイテムなどはこのクラスを継承して作る。<br>
      class GameObject : public Object<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるのでCreate関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; GameObject(World* world = nullptr, Vector3 position = { 0,0,0 }, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Object(), m_world{ world }, position{ position }, rotation{ rotation }, velocity{ velocity }, force{ force }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~GameObject() {}<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★下記3つはメモリ上で共用状態になる(position、x,y,z、xyzどの名前から数値を変えたり読出してもメモリ上は同じ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 同じデータに3種類の名前を付けたイメージ、しかもVector3の機能や配列としてのアクセスの仕方もできて便利<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // XYZ座標&nbsp; [匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 position; // XYZ座標<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp;&nbsp; }; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
      <br>
      &nbsp;&nbsp;&nbsp; Quaternion rotation; // 回転クオータニオン<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vx, vy, vz; }; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 velocity; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyz;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vxForce, vyForce, vzForce; }; // XYZ方向にかかる力(Unityでいうと AddForce関数 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 force; // XYZ方向の力(物理的には加速度:1フレームごとにvelocityの増える=加速する量)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyzForce;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 重力を返す、重力を変えたいときはoverrideして処理を変えてください、重力を変えてない場合は 0.0f<br>
        &nbsp;&nbsp;&nbsp; virtual inline float gravity() { return 0.0f; }</em><br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; World* m_world; // GameObjectが配置されたワールドへのリンク<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; virtual World* world() { return m_world; }<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
      &nbsp;&nbsp;&nbsp; virtual void world(World* changeWorld) { m_world = changeWorld; }<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; bool isDead{ false }; // 死んだ（削除対象）フラグ<br>
      &nbsp;&nbsp;&nbsp; bool isStatic{ false }; // 動かない(静的オブジェクトか?)<br>
      &nbsp;&nbsp;&nbsp; bool isGround{ false }; // 地面についているか<br>
      &nbsp;&nbsp;&nbsp; bool isFlying{ false }; // 空をとんでいるか<br>
      <br>
      &nbsp;&nbsp;&nbsp; hash32 typeTag{ "" }; // 小カテゴリ Zako0など個別のタイプ<br>
      &nbsp;&nbsp;&nbsp; hash32 baseTag{ "" }; // 大カテゴリ Enemyなど大まかなベースジャンル<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() = 0; // 純粋仮想関数 = 0 にすると【絶対 Update()関数はoverrideしなきゃいけない義務を付与できる 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() = 0; // 純粋仮想関数 = 0 にすると【絶対 Draw()関数はoverrideしなきゃいけない義務を継承先クラスに付与 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// ジャンプ開始した直後に呼ばれる関数<br>
        &nbsp;&nbsp;&nbsp; virtual void OnStartJump()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideしてジャンプした瞬間に音を鳴らしたりする処理などをオブジェクトの種類ごとに実装する<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 空中でジャンプの上昇中に呼ばれる関数<br>
        &nbsp;&nbsp;&nbsp; virtual void OnJumping()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中でジャンプの上昇中にエフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 空中で落ちている最中に呼ばれる関数<br>
        &nbsp;&nbsp;&nbsp; virtual void OnFalling()<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中で落ちている最中に音を鳴らしたり、エフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
        &nbsp;&nbsp;&nbsp; };</em><br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    あとはこれらのコンポーネントの処理を、先ほどPlayerに直で書いたジャンプと落下の処理と置き換えます。<br>
    <p><code>Player.hを変更</code>して、ジャンプと重力落下の初期化をコンポーネントへ置き換えます。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Resource.h"<br>
      #include "GameObject.h"<br>
      <em>#include "PhysicsComponent.h"</em><br>
      <br>
      class World; // 前方宣言<br>
      class Camera; // 前方宣言<br>
      <br>
      class Player : public GameObject<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるので、Create関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; Player(World* world, Pad pad, Vector3 position, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pad{ pad }, GameObject(world, position, rotation, velocity, force)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "Player"; // タグは個別の"プレイヤ1"などに使い、タイプはtypeTagで判別する形にしてタイプのジャンルを区別<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~Player() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; Pad pad; // 操作するコントローラー番号<br>
      &nbsp;&nbsp;&nbsp; hash32 worldTag{ "" }; // 現在いるワールドのタグ<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeedMax = 6; // 移動速度Max値<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeed = 0;//移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; float moveAngle = 0; // X軸→方向から何度か<br>
      &nbsp;&nbsp;&nbsp; float deltaAngle = 0; // プレイヤの動く角度の変化率、ハンドルを切ったらだんだんもとに戻る<br>
      &nbsp;&nbsp;&nbsp; int animCount = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image; // プレイヤの板ポリゴンで描くタイル分割画像への共有リンク<br>
      <br>
      &nbsp;&nbsp;&nbsp; Camera* camera{ nullptr }; // プレイヤを追随するカメラ<br>
      &nbsp;&nbsp;&nbsp; void SetCamera(Camera* pCamera) { camera = pCamera; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// overrideして物理落下コンポーネントからの重力値を返す<br>
        &nbsp;&nbsp;&nbsp; virtual float gravity() <b>override</b> { return (gravityPhysics != nullptr) ? gravityPhysics-&gt;gravity() : 0.0f; }<br>
        protected:<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;JumpComponent&gt; jumpPhysics{ nullptr }; // ジャンプの物理処理コンポーネント<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;GravityComponent&gt; gravityPhysics{ nullptr }; // 落下の重力の物理処理コンポーネント<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyJumpSpeed{ 13, 14, 15, 4 }; // ジャンプ開始の初期速度<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyForceJump{ 0.5f, 0.4f, 0.3f, 0.1f }; // ジャンプ上昇にかかる力の初期値<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyGravity{ 0.8f,0.8f,0.8f,0.8f }; // 重力の設定値<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyDownSpeedMax{ 16, 16, 16, 8 }; // 降下スピードのリミット<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <b>shared_from_this()を必ず渡してセットで初期化</b>して、オーナーがリンク切れのコンポーネントができないように気をつける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jumpPhysics = std::make_shared&lt;JumpComponent&gt;(<b>shared_from_this_as&lt;Player&gt;()</b>, vyJumpSpeed, vyForceJump);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gravityPhysics = std::make_shared&lt;GravityComponent&gt;(<b>shared_from_this_as&lt;Player&gt;()</b>, vyGravity, vyDownSpeedMax);<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      &nbsp;&nbsp;&nbsp; <u>float yJumpStart{ 0.0f };<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyJumpSpeed{ 13, 14, 15, 4 }; // ジャンプ開始の初期速度<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyForceJump{ 0.5f, 0.4f, 0.3f, 0.1f }; // ジャンプ上昇にかかる力の初期値<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyGravity{ 0.8f,0.8f,0.8f,0.8f }; // 重力の設定値<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyDownSpeedMax{ 16, 16, 16, 8 }; // 降下スピードのリミット</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理<br>
      &nbsp;&nbsp;&nbsp; virtual void HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// ジャンプ開始した直後に呼ばれる関数<br>
        &nbsp;&nbsp;&nbsp; virtual void OnStartJump() <b>override</b>;</em><br>
      };<br>
      <br>
      #endif<br>
    </p>
    着目すべきは、Init()関数やgravity()関数やOnStartJump()関数のoverrideです。<br>
    gravity()関数のoverrideによりプレイヤはGravityComponentから得た重力を採用することができます。<br>
    OnStartJump()関数のoverrideにより、ジャンプ開始時にisGroundのフラグをfalseにしたり、プレイヤごとの効果音を鳴らす処理もここでカスタムできます。<br>
    Init()関数のoverrideにより、Create関数の初期化と連動して、上昇する力や落下の設定値をコンポーネントに渡し、<br>
    もっとも重要なのは、プレイヤへのポインタ<b>shared_from_this_as&lt;Player&gt;()</b>をコンポーネントに初期化と同時に渡せていることです。<br>
    これで、コンポーネント側はプレイヤ側の vy(縦方向の加速度) などに自由にアクセスできる構造を実現できるようになります。<br>
    <br>
    では、あとはプレイヤ側のジャンプや落下の処理をコンポーネントの呼び出しへと置き換えましょう。<br>
    <p><code>Player.cppを変更</code>して、<b>コンポーネントにジャンプや落下の処理を任せましょう</b>。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      void Player::HandleInput()<br>
      {<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_LEFT) <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_A)) )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = - MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += 1; //ハンドルを左に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_RIGHT)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_D)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle -= 1; //ハンドルを右に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_UP)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_W)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = - MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += 0.6f; //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; MoveSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = MoveSpeedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(pad, PAD_INPUT_DOWN)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_S)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed -= 0.6f; //ブレーキを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.9f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = -0.9f;//ちょっとだけバックできるように<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pad == Pad::Key || pad == Pad::One) // コントローラ1またはキーボード操作のプレイヤのときだけ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGUP)) // キーボードのPageUp ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = 2.0f; // テスト用に空中の上方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGDN)) // キーボードのPageDown ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -2.0f; // テスト用に空中の下方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      <em>// ジャンプ開始した直後に呼ばれる関数<br>
        void Player::OnStartJump()<br>
        {<br>
        &nbsp;&nbsp;&nbsp; this-&gt;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
        }</em><br>
      <br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>if (jumpPhysics != nullptr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isGround)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pad, PAD_INPUT_A) // Zキーを押した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを押した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jumpPhysics-&gt;JumpStart(); // ジャンプのスタート処理を発動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (vy &gt; 0 &amp;&amp; Input::GetButtonUp(pad, PAD_INPUT_A) // Zキーを離した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonUp(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを離した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jumpPhysics-&gt;JumpCancel(); // ジャンプのキャンセル処理を発動<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jumpPhysics-&gt;Update(); // ジャンプのコンポーネントを更新する<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; if (gravityPhysics != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gravityPhysics-&gt;Update(); // 重力落下のコンポーネントを更新する</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>if (isGround)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pad, PAD_INPUT_A) // Zキーを押した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを押した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = vyJumpSpeed[0]; // ジャンプ方向はY上方向<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vyForce = -vyForceJump[0];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yJumpStart = y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (vy &lt;= 0) // 下落開始(vyが0未満のときはまだジャンプ中)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vyForce = -vyGravity[0]; // ジャンプ上昇力が0になって以降に初めて重力をオンにする<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; else if (Input::GetButtonUp(pad, PAD_INPUT_A) // Zキーを離した瞬間<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonUp(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを離した瞬間<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (y - yJumpStart &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけない<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vyForce = -vyGravity[0]; // ジャンプ上昇中(vy未満のとき)にボタンを離したら早めに重力をかけ始める<br>
        &nbsp;&nbsp;&nbsp; }</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; rotation.SetRotation(VGet(0, (180 - moveAngle) * MyMath::Deg2Rad, 0)); // 前向きの3Dモデルなら180度回転させて奥方向の向きに設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp; x += vx;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp; y += vy;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp; z += vz;<br>
      <br>
      &nbsp;&nbsp;&nbsp; vy += vyForce; // 勢い(力・フォースを加算<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (y &lt;= 0.0f) // 0.0fを地面として 0.0f以下になったら地面に着地したと判定する<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f; // 地面に沿わせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -0.01f; // 下方向への速度をほぼ 0 にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGround = true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>if (vy &lt;= -vyDownSpeedMax[0]) // 無限に落下速度が加速しないようにリミット(空気抵抗みたいなもの)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -vyDownSpeedMax[0];</u><br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; // moveAngleは2D画像のX方向右を0度とするから、-90度回すと画像を正面に捉える位置にカメラを置ける<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int animIndex = animCount / 20; // キャラのパラパラアニメの画像番号(最大3)<br>
      &nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp; if (abs_vx &gt; 1.00f || abs_vz &gt; 1.00f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6; // キャラが地面のXとZ方向に少しでもスピードがあったらアニメを走らせる<br>
      &nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // プレイヤのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 9; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // カメラ向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 奥向きの画像<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *image, imgIndex + animIndex, TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    いかがでしょう？無事キーボードのZキーとQキーでキャラをジャンプさせることができましたか？<br>
    ここまでがゲームエンジンを形づくっているコンポーネント指向の仕組みの根幹であり、その仕組みを一通り自作したわけです。<br>
    <br>
    え、Unityみたいに「かっこよくAddComponent&lt;JumpComponent&gt;(..～..);」しないと気分が上がらないですって？<br>
    お若いですね。。<b>「かっこつけるということは、柔軟にテンプレで可変引数...ArgsTを受け入れる」ってこと</b>ですからね。<br>
    それは、つまり「引数のタイプ型や引数の個数などが 自分で定義したJumpComponentのコンストラクタ と合わないとテンプレの謎エラーが出る」ってことです。<br>
    単なる自分の<b>勘違いで初期化コンストラクタの 〇〇Component(Vector3 pos1, int param2, ...)のパラメータparam2に間違ってVector3型を渡しちゃった</b>としましょう。<br>
    そうすると当然、テンプレの謎エラーが出ます<b>「エラー:オーバーロードされた関数ですべての引数の型が変換できませんでした」</b>(ファイルはxutility←テンプレ関連ファイル)<br>
    つまり、普通の初期化コンストラクタで「渡す引数まちがえちゃったケアレスミスの場合」は 〇〇Component.h などのコンストラクタのファイルが案内されるけれども、<br>
    可変引数テンプレ...ArgsT に手を出すと、かっこよさと引き換えに「謎エラー案内」が出るわけですね。<br>
    ゆえに、可変引数テンプレ...ArgsTは 中級者向けの機能とはなるわけです。<br>
    が、しかし、すでにCreate関数で初期化に 可変引数テンプレ...ArgsT は使っておりますし、これなしにはやっていけませんので、<br>
    上記の<b>「謎エラー案内」=「渡す引数まちがえちゃったケアレスミス」の場合が多い</b>ので、ちゃんと初期化で渡すパラメータをよく見て渡しましょう。<br>
    <br>
    では、Unityみたいに「かっこよくAddComponent&lt;JumpComponent&gt;(..～..);」するテンプレ処理を追加しましょう。<br>
    <p><code>GameObject.hを変更</code>して、AddComponentやGetComponentsなどのテンプレ処理を準備しましょう。</p>
    <p class="source">#ifndef GAMEOBJECT_H_<br>
      #define GAMEOBJECT_H_<br>
      <br>
      #include &lt;memory&gt; // 共有ポインタの定義のため<br>
      <br>
      #include "Vector3.h"<br>
      #include "Quaternion.h"<br>
      <br>
      #include "Object.h" // インスタンスIDや検索タグを持ち、shared_from_this_as&lt;継承先クラス名&gt;などができる<br>
      <br>
      class World; // 前方宣言<br>
      <em>class Component; // 前方宣言</em><br>
      <br>
      // ゲーム上に表示される物体の基底クラス。<br>
      // プレイヤーや敵、アイテムなどはこのクラスを継承して作る。<br>
      class GameObject : public Object<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるのでCreate関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; GameObject(World* world = nullptr, Vector3 position = { 0,0,0 }, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Object(), m_world{ world }, position{ position }, rotation{ rotation }, velocity{ velocity }, force{ force }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~GameObject() {}<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★下記3つはメモリ上で共用状態になる(position、x,y,z、xyzどの名前から数値を変えたり読出してもメモリ上は同じ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 同じデータに3種類の名前を付けたイメージ、しかもVector3の機能や配列としてのアクセスの仕方もできて便利<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // XYZ座標&nbsp; [匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 position; // XYZ座標<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp;&nbsp; }; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
      <br>
      &nbsp;&nbsp;&nbsp; Quaternion rotation; // 回転クオータニオン<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vx, vy, vz; }; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 velocity; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyz;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vxForce, vyForce, vzForce; }; // XYZ方向にかかる力(Unityでいうと AddForce関数 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 force; // XYZ方向の力(物理的には加速度:1フレームごとにvelocityの増える=加速する量)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyzForce;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 重力を返す、重力を変えたいときはoverrideして処理を変えてください、重力を変えてない場合は 0.0f<br>
      &nbsp;&nbsp;&nbsp; virtual inline float gravity() { return 0.0f; }<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; World* m_world; // GameObjectが配置されたワールドへのリンク<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; virtual World* world() { return m_world; }<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
      &nbsp;&nbsp;&nbsp; virtual void world(World* changeWorld) { m_world = changeWorld; }<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; bool isDead{ false }; // 死んだ（削除対象）フラグ<br>
      &nbsp;&nbsp;&nbsp; bool isStatic{ false }; // 動かない(静的オブジェクトか?)<br>
      &nbsp;&nbsp;&nbsp; bool isGround{ false }; // 地面についているか<br>
      &nbsp;&nbsp;&nbsp; bool isFlying{ false }; // 空をとんでいるか<br>
      <br>
      &nbsp;&nbsp;&nbsp; hash32 typeTag{ "" }; // 小カテゴリ Zako0など個別のタイプ<br>
      &nbsp;&nbsp;&nbsp; hash32 baseTag{ "" }; // 大カテゴリ Enemyなど大まかなベースジャンル<br>
      <br>
      <em>protected:<br>
        &nbsp;&nbsp;&nbsp; // コンポーネントの&lt;ハッシュID, 共有所有ポインタ&gt; の辞書でコンポーネントの共有カウンタ+1を保持する<br>
        &nbsp;&nbsp;&nbsp; std::unordered_map&lt;size_t, std::<b>shared_ptr</b>&lt;Component&gt;&gt; <b>components</b>;<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; // コンポーネントを得る 例えば GetComponent&lt;BoxCollider&gt;でBoxColliderという名前のコンポーネントをcomponents辞書から得る<br>
        &nbsp;&nbsp;&nbsp; template&lt;class ComponentT&gt;<br>
        &nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;ComponentT&gt;&gt; GetComponents()<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // equal_range 関数を使って、指定したキーの最初と終端の位置を示すイテレータを std::pair&lt;&gt; で取得します。<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto range = components.equal_range(hashID); //https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;ComponentT&gt;&gt; returnList; // "ComponentT" 例."CircleCollider"など をキーとするコンポーネント一覧<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto ite = range.first; ite != range.second; ++ite)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; returnList.emplace_back(ite-&gt;second); // 辞書で見つかったコンポーネントを返すリストに追加<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return returnList;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンポーネントを追加する .AddComponent&lt;BoxCollider&gt;(...)で追加できる<br>
        &nbsp;&nbsp;&nbsp; template&lt;class ComponentT, <b>typename ...ArgsT</b>&gt;<br>
        &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;ComponentT&gt; AddComponent(ArgsT&amp;&amp;...args)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // shared_from_this()を必ず渡してセットで初期化して、オーナーがリンク切れのコンポーネントができないように気をつける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ComponentT&gt; <b>newComponent</b> = std::<b>make_shared</b>&lt;ComponentT&gt;(shared_from_this_as&lt;GameObject&gt;(), <b>std::forward&lt;ArgsT&gt;(args)...</b>);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // std::unrodered_multimap&lt;&gt; と同型の値を取る std::pair&lt;&gt; を作って insert 関数でcomponents辞書に追加<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>components</b>.insert(std::pair&lt;size_t, std::shared_ptr&lt;ComponentT&gt;&gt;(hashID, <b>newComponent</b>));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return newComponent;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // コンポーネントを削除する<br>
        &nbsp;&nbsp;&nbsp; template&lt;typename ComponentT&gt;<br>
        &nbsp;&nbsp;&nbsp; bool RemoveComponent(std::shared_ptr&lt;ComponentT&gt; removeComponent)<br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // equal_range 関数を使って、指定したキーの最初と終端の位置を示すイテレータを std::pair&lt;&gt; で取得します。<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto range = components.equal_range(hashID); //https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[イテレート中に探しながら消す] https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/erase.html<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto ite = range.first; ite != range.second;)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ite-&gt;second == removeComponent)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; components.erase(ite); // 削除された要素の次を指すイテレータが返される<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // 見つかって消せた場合は true<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++ite; // 次の要素へイテレータを進める<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 見つからずに消せなかった場合は false<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() = 0; // 純粋仮想関数 = 0 にすると【絶対 Update()関数はoverrideしなきゃいけない義務を付与できる 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() = 0; // 純粋仮想関数 = 0 にすると【絶対 Draw()関数はoverrideしなきゃいけない義務を継承先クラスに付与 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ジャンプ開始した直後に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnStartJump()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideしてジャンプした瞬間に音を鳴らしたりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 空中でジャンプの上昇中に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnJumping()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中でジャンプの上昇中にエフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 空中で落ちている最中に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnFalling()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中で落ちている最中に音を鳴らしたり、エフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    コンポーネントが<b>最後まで消えないように「共有カウンタ+1をキープする役割」はcomponents辞書に移りました</b>。<br>
    ですので、Playerクラス側のstd::shared_ptrはstd::weak_ptrに変えておきましょう。+1のキープ元はなるべく1か所に限定しておきたいですから。<br>
    <p><code>Player.hを変更</code>して、UnityっぽくAddComponentでコンポーネントを追加し、プレイヤ側のstd::shared_ptrはstd::weak_ptrに変えておきましょう。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Resource.h"<br>
      #include "GameObject.h"<br>
      #include "PhysicsComponent.h"<br>
      <br>
      class World; // 前方宣言<br>
      class Camera; // 前方宣言<br>
      <br>
      class Player : public GameObject<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるので、Create関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; Player(World* world, Pad pad, Vector3 position, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pad{ pad }, GameObject(world, position, rotation, velocity, force)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "Player"; // タグは個別の"プレイヤ1"などに使い、タイプはtypeTagで判別する形にしてタイプのジャンルを区別<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~Player() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; Pad pad; // 操作するコントローラー番号<br>
      &nbsp;&nbsp;&nbsp; hash32 worldTag{ "" }; // 現在いるワールドのタグ<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeedMax = 6; // 移動速度Max値<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeed = 0;//移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; float moveAngle = 0; // X軸→方向から何度か<br>
      &nbsp;&nbsp;&nbsp; float deltaAngle = 0; // プレイヤの動く角度の変化率、ハンドルを切ったらだんだんもとに戻る<br>
      &nbsp;&nbsp;&nbsp; int animCount = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image; // プレイヤの板ポリゴンで描くタイル分割画像への共有リンク<br>
      <br>
      &nbsp;&nbsp;&nbsp; Camera* camera{ nullptr }; // プレイヤを追随するカメラ<br>
      &nbsp;&nbsp;&nbsp; void SetCamera(Camera* pCamera) { camera = pCamera; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // overrideして物理落下コンポーネントからの重力値を返す<br>
      &nbsp;&nbsp;&nbsp; virtual float gravity() override { <em>auto pGravityPhysics = gravityPhysics.lock();</em> return (<em>pGravityPhysics</em> != nullptr) ? <em>pGravityPhysics</em>-&gt;gravity() : 0.0f; }<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; <em>std::weak_ptr</em>&lt;JumpComponent&gt; jumpPhysics<u>{ nullptr }</u>; // ジャンプの物理処理コンポーネント<br>
      &nbsp;&nbsp;&nbsp; <em>std::weak_ptr</em>&lt;GravityComponent&gt; gravityPhysics<u>{ nullptr }</u>; // 落下の重力の物理処理コンポーネント<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyJumpSpeed{ 13, 14, 15, 4 }; // ジャンプ開始の初期速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyForceJump{ 0.5f, 0.4f, 0.3f, 0.1f }; // ジャンプ上昇にかかる力の初期値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyGravity{ 0.8f,0.8f,0.8f,0.8f }; // 重力の設定値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyDownSpeedMax{ 16, 16, 16, 8 }; // 降下スピードのリミット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <em>AddComponent内部で</em>shared_from_this()を必ず渡してセットで初期化して、オーナーがリンク切れのコンポーネントができないように気をつける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jumpPhysics = <em>AddComponent&lt;JumpComponent&gt;(</em>vyJumpSpeed, vyForceJump);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gravityPhysics = <em>AddComponent&lt;GravityComponent&gt;(</em>vyGravity, vyDownSpeedMax);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理<br>
      &nbsp;&nbsp;&nbsp; virtual void HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ジャンプ開始した直後に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnStartJump() override;<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Player.cppを変更</code>して、std::shared_ptrからstd::weak_ptrに変えたので.lock()でロックして、<br>
      コンポーネントを使っている間(Update関数()の {&nbsp; ～ }のカッコが閉じるまで )はコンポーネントが消えないように +1 キープしながら使うようにしましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      void Player::HandleInput()<br>
      {<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_LEFT) <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_A)) )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = - MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += 1; //ハンドルを左に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_RIGHT)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_D)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle -= 1; //ハンドルを右に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_UP)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_W)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = - MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += 0.6f; //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; MoveSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = MoveSpeedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(pad, PAD_INPUT_DOWN)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_S)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed -= 0.6f; //ブレーキを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.9f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = -0.9f;//ちょっとだけバックできるように<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pad == Pad::Key || pad == Pad::One) // コントローラ1またはキーボード操作のプレイヤのときだけ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGUP)) // キーボードのPageUp ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = 2.0f; // テスト用に空中の上方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGDN)) // キーボードのPageDown ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -2.0f; // テスト用に空中の下方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      // ジャンプ開始した直後に呼ばれる関数<br>
      void Player::OnStartJump()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; this-&gt;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      }<br>
      <br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>auto pJumpPhysics = jumpPhysics.lock();</em><br>
      &nbsp;&nbsp;&nbsp; if (<em>pJumpPhysics</em> != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pad, PAD_INPUT_A) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>pJumpPhysics</em>-&gt;JumpStart(); // ジャンプのスタート処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (vy &gt; 0 &amp;&amp; Input::GetButtonUp(pad, PAD_INPUT_A) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonUp(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>pJumpPhysics</em>-&gt;JumpCancel(); // ジャンプのキャンセル処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>pJumpPhysics</em>-&gt;Update(); // ジャンプのコンポーネントを更新する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; <em>auto pGravityPhysics = gravityPhysics.lock();</em><br>
      &nbsp;&nbsp;&nbsp; if (<em>pGravityPhysics</em> != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>pGravityPhysics</em>-&gt;Update(); // 重力落下のコンポーネントを更新する<br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; rotation.SetRotation(VGet(0, (180 - moveAngle) * MyMath::Deg2Rad, 0)); // 前向きの3Dモデルなら180度回転させて奥方向の向きに設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp; x += vx;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp; y += vy;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp; z += vz;<br>
      <br>
      &nbsp;&nbsp;&nbsp; vy += vyForce; // 勢い(力・フォースを加算<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (y &lt;= 0.0f) // 0.0fを地面として 0.0f以下になったら地面に着地したと判定する<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f; // 地面に沿わせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -0.01f; // 下方向への速度をほぼ 0 にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGround = true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; // moveAngleは2D画像のX方向右を0度とするから、-90度回すと画像を正面に捉える位置にカメラを置ける<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int animIndex = animCount / 20; // キャラのパラパラアニメの画像番号(最大3)<br>
      &nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp; if (abs_vx &gt; 1.00f || abs_vz &gt; 1.00f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6; // キャラが地面のXとZ方向に少しでもスピードがあったらアニメを走らせる<br>
      &nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // プレイヤのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 9; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // カメラ向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 奥向きの画像<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *image, imgIndex + animIndex, TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    いかがでしょう？結局、AddComponentはしましたが、Player側でジャンプや重力などのstd::weak_ptrを保持して、GetComponentsはわざわざしないようにしました。<br>
    GetComponentsは辞書を探す処理が走るので、無駄な計算時間がかかるので避けたかったのも理由の一つです。<br>
    UnityでもGetComponentsなどはなるべくStart()関数でするほうが、処理は高速になります。<br>
    どのみちPlayerなどのメンバ変数としてstd::weak_ptr&lt;JumpComponent&gt; jumpPhysics;などのコンポーネントへの弱リンクを保管するほうが、<br>
    辞書をいちいち探すコストはかからなくなるわけですので、同じようなコードのままになるのは必然なわけです。<br>
    <br>
    では、AddComponentやGetComponentsなどの必要性はどこにあるかというと、<br>
    Unityではインスペクタの[Add Component]ボタンなど画面のUI経由でAddComponentできちゃいますから、<br>
    必ずしもInit経由からAddComponentされるものだけとは限らないわけです。<br>
    または、ジャンプできるようになるアイテムを取った瞬間にAddComponentされるケースもありえます。<br>
    そういう場合、つまりUIから多種多様なコンポーネントが来たり、アイテムの種類が多種多様な場合は、<br>
    メンバ変数のコンポーネントのタイプ型を事前に想定することができにくいわけですね。<br>
    そうなってくるとGetComponentの&lt;～&gt;の中で引き受けたいタイプをそのつど受け取るほうが良いケースもでてくるわけです。<br>
    まあでも、InitでAddComponentしたあと、即 isEnabled = false; で無効にしてジャンプ能力を眠らせておいて、<br>
    アイテムを取ったときだけisEnabled = true; で有効にしてGetComponentsの辞書サーチは走らせないほうが回避策としては優秀ですがね。<br>
    ということで、なるべくUpdateなど毎フレーム繰り返す文脈の中で毎度GetComponentsしないのが、プログラマとしては有能なわけです。<br>
    (まあ、それだとUI経由のコンポーネント追加は検知できないわけで、ゲームエンジンのUIの便利さは計算コストとのトレードオフ ではあるわけです)<br>
    想定可能なコンポーネントはInit()すなわち UnityではStart()関数であらかじめGetComponentsでメンバ変数に保持しておきましょうということですね。<br>
    Update関数の中でGetComponentsするならまだしも、for文のループの中でGetComponentsしている人はいませんか？ 完全アウトです。<br>
    (UnityでFPSを60に保てる限度において、<a href="https://qiita.com/uminohiyoko/items/1dfeae592402697be025">GetComponentは5万回</a>だそうです。。)<br>
    <br>
    <br>
    以上、共有ポインタや可変引数テンプレやoverrideなど、もろもろの基礎の積み上げによりAddComponentにたどりつけました。<br>
    Unityで何気なくつかっているAddComponentのままでは、thisポインタ渡し は完全ブラックボックス化されていて、<br>
    コンポーネントとは「this渡しによる親の変数アクセス」が本質であるという重要な勉強がすっとばされてしまうので、<br>
    ほぼプログラミングの設計サイドにふれあう機会なく、便利さのぬるま湯につかってしまいます。<br>
    ここまでの勉強によって「ゲームエンジンそのものとは何なのか？」の理解に少しは近づけたでしょうか？<br>
    <br>
    <br>
    <a id="mozTocId0009" class="mozTocH1">
      <h1>何もない空間をグリッド分割して隣接していない空間に所属するものとの当たり判定をスルーして高速化する</h1>
    </a>
    <p><code>Plane4.hとCollision3D.hは別記事を参考に作っておきます→</code>Vector3の記事の下のほうにPlane4.hとCollision3D.hがあります→<a

        href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/polygon3d/index.html#mozTocId0013">Vector3に色々な関数を用意して3D空間の当たり判定をする</a><br>
    </p>
    <br>
    さあAddComponentもできてあとは広大なマップを冒険だ！と思った人もおられるでしょう。<br>
    しかし、まだ甘い、修業は続きます。<br>
    マップが広がってからでは実感できないことを、この「何もない精神と時の部屋」にいるうちにやってしまったほうがよいでしょう。<br>
    <br>
    マップがなくても、空間は分割できるのです。<br>
    なんだか空間とか言い出し始めたら「<a href="https://note.com/yakikoimo/n/n440612a79297">無量空処に適応する魔虚羅</a>」みたいな、わけわからん概念の世界に迷い込みそうですが、<br>
    ようは、XYZの<b>位置を10ごとに区切れば</b>、<br>
    <b>0～10のエリアにいる人と31～40のエリアにいる人のように離れたエリアにいる人どうしは当たり判定をスルーできる</b>ということです。<br>
    これは、別にマップがなくても空間は区切れます。<br>
    Unityなどゲームエンジンでは上位互換の「<a href="https://edom18.hateblo.jp/entry/2017/07/28/083153">8分木</a>」を使うことが多いですが、<br>
    今回は入門として、単なる上記のような10とか64とか128の<a href="https://book.impress.co.jp/books/1114101121">倍数などで空間を区切るグリッド分割</a>をとりいれてみましょう。<br>
    <br>
    <br>
    まずは所属する空間のマス目を表現するためのCellXYZクラスを準備します。(マス目はAIの経路探索などでも多用します)<br>
    <p><code>CellXYZ.hを新規作成</code>して、将棋などのようなマス目位置をハッシュ値変換できて辞書で管理できるクラスを準備しましょう。</p>
    <p class="source">#ifndef CELLXYZ_H_<br>
      #define CELLXYZ_H_<br>
      <br>
      #include &lt;unordered_map&gt; // ハッシュ値計算 std::hashに必要<br>
      <br>
      #include &lt;cmath&gt;<br>
      #include &lt;algorithm&gt; // std::maxに必要<br>
      <br>
      // マス目のXとYとZを保持するデータ型<br>
      struct CellXYZ<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int X = 0, Y = 0, Z = 0;<br>
      &nbsp;&nbsp;&nbsp; CellXYZ() = default;<br>
      &nbsp;&nbsp;&nbsp; inline ~CellXYZ() {};<br>
      &nbsp;&nbsp;&nbsp; inline CellXYZ(int X, int Y, int Z = 0) : X{ X }, Y{ Y }, Z{ Z } {};<br>
      &nbsp;&nbsp;&nbsp; // <b>連想配列mapのキーで使う</b>ため &lt; 比較演算子(連想配列並べ替えのため)をカスタム定義 http://programming-tips.info/use_struct_as_key_of_map/cpp/index.html<br>
      &nbsp;&nbsp;&nbsp; inline bool operator &lt; (const CellXYZ&amp; other) const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;Z &lt; other.Z) return true; // Z優先並べ替え(std::map並び順ではZの大きいものが一番あとに[並び順]X行⇒Y列⇒Zのエクセル順)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (this-&gt;Z &gt; other.Z) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;Y &lt; other.Y) return true; // Zが同じ時はYを比較 Z Y の順に並べばCSVのように左上から列→行の順にならぶ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (this-&gt;Y &gt; other.Y) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;X &lt; other.X) return true; // Z,Yが同じ時はXを比較<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (this-&gt;X &gt; other.X) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // X と Y と Z がすべて等しい場合<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // == 比較演算子カスタム定義 https://sygh.hatenadiary.jp/entry/2014/02/13/222356<br>
      &nbsp;&nbsp;&nbsp; inline bool operator == (const CellXYZ&amp; other) const {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this-&gt;X == other.X &amp;&amp; this-&gt;Y == other.Y &amp;&amp; this-&gt;Z == other.Z;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; inline bool operator != (const CellXYZ&amp; other) const {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return !(this-&gt;operator==(other));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; inline size_t <b>GetHashCode</b>() const // <b>X,Y,Zの値からハッシュ値を計算</b> https://sygh.hatenadiary.jp/entry/2014/02/13/222356<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::hash&lt;decltype(X)&gt;()(this-&gt;X) ^<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::hash&lt;decltype(Y)&gt;()(this-&gt;Y) ^<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::hash&lt;decltype(Z)&gt;()(this-&gt;Z);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; struct <b>Hash</b> // ハッシュ値取得用の関数オブジェクト(<b>std::unordered_map のキーで使うため</b>) https://sygh.hatenadiary.jp/entry/2014/02/13/222356<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t operator ()(const CellXYZ&amp; cellXYZ) const<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cellXYZ.<b>GetHashCode</b>();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline CellXYZ up() const { return CellXYZ(X, Y - 1, Z); }; // 上方向<br>
      &nbsp;&nbsp;&nbsp; inline CellXYZ down() const { return CellXYZ(X, Y + 1, Z); }; // 下方向<br>
      &nbsp;&nbsp;&nbsp; inline CellXYZ left() const { return CellXYZ(X - 1, Y, Z); }; // 左方向<br>
      &nbsp;&nbsp;&nbsp; inline CellXYZ right() const { return CellXYZ(X + 1, Y, Z); }; // 右方向<br>
      &nbsp;&nbsp;&nbsp; inline CellXYZ upZ() const { return CellXYZ(X, Y, Z - 1); }; // 上方向(Z方向)<br>
      &nbsp;&nbsp;&nbsp; inline CellXYZ downZ() const { return CellXYZ(X, Y, Z + 1); }; // 下方向(Z方向)<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 方向の種類:2D(4方向,8方向) 3D(6方向,26方向)<br>
      &nbsp;&nbsp;&nbsp; enum class DirType : unsigned char { Direction4, Direction8, Direction6, Direction26 };<br>
      <br>
      &nbsp;&nbsp;&nbsp; //[enum定義:4方向]上下左右(反時計回り順:上→左→下→右)<br>
      &nbsp;&nbsp;&nbsp; enum class Direction4 : unsigned char { Up = 0, Left, Down, Right };<br>
      &nbsp;&nbsp;&nbsp; //[enum定義:8方向] 反時計回り順:上→左上→左→左下→下→右下→右→右上<br>
      &nbsp;&nbsp;&nbsp; enum class Direction8 : unsigned char { Up = 0, LeftUp, Left, LeftDown, Down, RightDown, Right, RightUp };<br>
      &nbsp;&nbsp;&nbsp; //[enum定義:6方向] 反時計回り順:上→左→下→右→右上→3D上→3D下<br>
      &nbsp;&nbsp;&nbsp; enum class Direction6 : unsigned char { Up = 0, Left, Down, Right, UpZ, DownZ };<br>
      &nbsp;&nbsp;&nbsp; //[enum定義:26方向] 反時計回り順:上→左上→左→左下→下→右下→右→右上→3D下→..反時計回り..→3D上→..反時計回り<br>
      &nbsp;&nbsp;&nbsp; enum class Direction26 : unsigned char {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Up = 0, LeftUp, Left, LeftDown, Down, RightDown, Right, RightUp,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DownZ, Up_DownZ, LeftUp_DownZ, Left_DownZ, LeftDown_DownZ, Down_DownZ, RightDown_DownZ, Right_DownZ, RightUp_DownZ,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpZ, Up_UpZ, LeftUp_UpZ, Left_UpZ, LeftDown_UpZ, Down_UpZ, RightDown_UpZ, Right_UpZ, RightUp_UpZ,<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; //4方向[2D] [constexprで実行前に固定値化して高速化]<br>
      &nbsp;&nbsp;&nbsp; static constexpr const std::tuple&lt;int, int, int&gt; dir4[4] = { {0,-1,0},{-1,0,0},{0,+1,0},{+1,0,0} };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // マス目の上下左右 4方向 をvector配列として返す ★配列順 と enum定義順 を合わせてある<br>
      &nbsp;&nbsp;&nbsp; static inline std::vector&lt;CellXYZ&gt; directions4()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // moveで右辺値の所有権をそのまま { }の外へreturnで渡す https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::move(std::vector&lt;CellXYZ&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, -1), // 上(0時方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(-1, 0), // 左(9時方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, +1), // 下(6時方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(+1, 0), // 右(3時方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // マス目の上下左右 4方向 をvector配列として返す ★配列順 と enum定義順 を合わせてある<br>
      &nbsp;&nbsp;&nbsp; inline std::vector&lt;CellXYZ&gt; getDirections4() const<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // moveで右辺値の所有権をそのまま { }の外へreturnで渡す https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::move(std::vector&lt;CellXYZ&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y - 1, Z), // 上(0時方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X - 1, Y, Z), // 左(9時方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y + 1, Z), // 下(6時方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X + 1, Y, Z) // 右(3時方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //8方向[2D] [constexprで実行前に固定値化して高速化]<br>
      &nbsp;&nbsp;&nbsp; static constexpr const std::tuple&lt;int, int, int&gt; dir8[8] = { {0,-1,0},{-1,-1,0},{-1,0,0},{-1,+1,0},{0,+1,0},{+1,+1,0},{+1,0,0},{+1,-1,0} };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // マス目の上下左右斜め 8方向 をvector配列として返す ★配列順 と enum定義順 を合わせてある<br>
      &nbsp;&nbsp;&nbsp; static inline std::vector&lt;CellXYZ&gt; directions8()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // moveで右辺値の所有権をそのまま { }の外へreturnで渡す https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::move(std::vector&lt;CellXYZ&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, -1), //&nbsp; 上(12時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(-1, -1), //左上(10時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(-1, 0), //&nbsp; 左( 9時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(-1, +1), //左下( 7時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, +1), //&nbsp; 下( 6時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(+1, +1), //右下( 4時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(+1, 0), //&nbsp; 右( 3時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(+1, -1)&nbsp; //右上( 1時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // マス目の上下左右斜め 8方向 をvector配列として返す ★配列順 と enum定義順 を合わせてある<br>
      &nbsp;&nbsp;&nbsp; inline std::vector&lt;CellXYZ&gt; getDirections8() const<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // moveで右辺値の所有権をそのまま { }の外へreturnで渡す https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::move(std::vector&lt;CellXYZ&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y - 1, Z), //&nbsp; 上(12時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X - 1, Y - 1, Z), //左上(10時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X - 1, Y, Z), //&nbsp; 左( 9時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X - 1, Y + 1, Z), //左下( 7時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y + 1, Z), //&nbsp; 下( 6時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X + 1, Y + 1, Z), //右下( 4時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X + 1, Y, Z), //&nbsp; 右( 3時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X + 1, Y - 1, Z)&nbsp; //右上( 1時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //6方向[3D] [constexprで実行前に固定値化して高速化]<br>
      &nbsp;&nbsp;&nbsp; static constexpr const std::tuple&lt;int, int, int&gt; dir6[6] = { {0,-1,0},{-1,0,0},{0,+1,0},{+1,0,0},{0,0,-1},{0,0,+1} };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // マス目の[2D]上下左右、[3D]上下 6方向 をvector配列として返す ★配列順 と enum定義順 を合わせてある<br>
      &nbsp;&nbsp;&nbsp; static inline std::vector&lt;CellXYZ&gt; directions6()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // moveで右辺値の所有権をそのまま { }の外へreturnで渡す https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::move(std::vector&lt;CellXYZ&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, -1), //&nbsp; 上(12時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(-1, 0), //&nbsp; 左( 9時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, +1), //&nbsp; 下( 6時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(+1, 0), //&nbsp; 右( 3時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, 0, -1), // 下方向(Z方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, 0, +1)&nbsp; // 上方向(Z方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // マス目の[2D]上下左右、[3D]上下 6方向 をvector配列として返す ★配列順 と enum定義順 を合わせてある<br>
      &nbsp;&nbsp;&nbsp; inline std::vector&lt;CellXYZ&gt; getDirections6() const<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // moveで右辺値の所有権をそのまま { }の外へreturnで渡す https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::move(std::vector&lt;CellXYZ&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y - 1, Z), //&nbsp; 上(12時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X - 1, Y, Z), //&nbsp; 左( 9時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y + 1, Z), //&nbsp; 下( 6時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X + 1, Y, Z), //&nbsp; 右( 3時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y, Z - 1), // 下方向(Z方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y, Z + 1)&nbsp; // 上方向(Z方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //26方向[3D] [constexprで実行前に固定値化して高速化]<br>
      &nbsp;&nbsp;&nbsp; static constexpr const std::tuple&lt;int, int, int&gt; dir26[26] = {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0,-1, 0},{-1,-1, 0},{-1,0, 0},{-1,+1, 0},{0,+1, 0},{+1,+1, 0},{+1,0, 0},{+1,-1, 0},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0,0,-1},{0,-1,-1},{-1,-1,-1},{-1,0,-1},{-1,+1,-1},{0,+1,-1},{+1,+1,-1},{+1,0,-1},{+1,-1,-1},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0,0,+1},{0,-1,+1},{-1,-1,+1},{-1,0,+1},{-1,+1,+1},{0,+1,+1},{+1,+1,+1},{+1,0,+1},{+1,-1,+1},<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // マス目の[2D]上下左右、[3D]上下 6方向 をvector配列として返す ★配列順 と enum定義順 を合わせてある<br>
      &nbsp;&nbsp;&nbsp; static inline std::vector&lt;CellXYZ&gt; directions26()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // moveで右辺値の所有権をそのまま { }の外へreturnで渡す https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::move(std::vector&lt;CellXYZ&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, -1, 0), //&nbsp; 上(12時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(-1, -1, 0), //左上(10時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(-1, 0, 0), //&nbsp; 左( 9時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(-1, +1, 0), //左下( 7時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, +1, 0), //&nbsp; 下( 6時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(+1, +1, 0), //右下( 4時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(+1, 0, 0), //&nbsp; 右( 3時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(+1, -1, 0), //右上( 1時半方向)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, 0, -1), //[3D下]下方向(Z方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, -1, -1), //[3D下]&nbsp; 上(12時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(-1, -1, -1), //[3D下]左上(10時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(-1, 0, -1), //[3D下]&nbsp; 左( 9時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(-1, +1, -1), //[3D下]左下( 7時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, +1, -1), //[3D下]&nbsp; 下( 6時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(+1, +1, -1), //[3D下]右下( 4時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(+1, 0, -1), //[3D下]&nbsp; 右( 3時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(+1, -1, -1), //[3D下]右上( 1時半方向)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, 0, +1), //[3D上]上方向(Z方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, -1, +1), //[3D上]&nbsp; 上(12時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(-1, -1, +1), //[3D上]左上(10時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(-1, 0, +1), //[3D上]&nbsp; 左( 9時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(-1, +1, +1), //[3D上]左下( 7時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(0, +1, +1), //[3D上]&nbsp; 下( 6時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(+1, +1, +1), //[3D上]右下( 4時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(+1, 0, +1), //[3D上]&nbsp; 右( 3時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(+1, -1, +1)&nbsp; //[3D上]右上( 1時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // マス目の[2D]上下左右、[3D]下反時計周り 上反時計回り 26方向 をvector配列として返す ★配列順 と enum定義順 を合わせてある<br>
      &nbsp;&nbsp;&nbsp; inline std::vector&lt;CellXYZ&gt; getDirections26() const<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // moveで右辺値の所有権をそのまま { }の外へreturnで渡す https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::move(std::vector&lt;CellXYZ&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y - 1, Z), //&nbsp; 上(12時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X - 1, Y - 1, Z), //左上(10時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X - 1, Y, Z), //&nbsp; 左( 9時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X - 1, Y + 1, Z), //左下( 7時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y + 1, Z), //&nbsp; 下( 6時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X + 1, Y + 1, Z), //右下( 4時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X + 1, Y, Z), //&nbsp; 右( 3時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X + 1, Y - 1, Z), //右上( 1時半方向)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y, Z - 1), //[3D下]下方向(Z方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y - 1, Z - 1), //[3D下]&nbsp; 上(12時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X - 1, Y - 1, Z - 1), //[3D下]左上(10時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X - 1, Y, Z - 1), //[3D下]&nbsp; 左( 9時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X - 1, Y + 1, Z - 1), //[3D下]左下( 7時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y + 1, Z - 1), //[3D下]&nbsp; 下( 6時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X + 1, Y + 1, Z - 1), //[3D下]右下( 4時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X + 1, Y, Z - 1), //[3D下]&nbsp; 右( 3時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X + 1, Y - 1, Z - 1), //[3D下]右上( 1時半方向)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y, Z + 1), //[3D上]上方向(Z方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y - 1, Z + 1), //[3D上]&nbsp; 上(12時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X - 1, Y - 1, Z + 1), //[3D上]左上(10時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X - 1, Y, Z + 1), //[3D上]&nbsp; 左( 9時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X - 1, Y + 1, Z + 1), //[3D上]左下( 7時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X, Y + 1, Z + 1), //[3D上]&nbsp; 下( 6時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X + 1, Y + 1, Z + 1), //[3D上]右下( 4時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X + 1, Y, Z + 1), //[3D上]&nbsp; 右( 3時&nbsp; 方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ(X + 1, Y - 1, Z + 1)&nbsp; //[3D上]右上( 1時半方向)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline CellXYZ&amp; operator += (const CellXYZ&amp; other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;X = this-&gt;X + other.X;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;Y = this-&gt;Y + other.Y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;Z = this-&gt;Z + other.Z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline CellXYZ operator -= (const CellXYZ&amp; other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;X = this-&gt;X - other.X;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;Y = this-&gt;Y - other.Y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;Z = this-&gt;Z - other.Z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; enum class DistType : unsigned char//[距離の種類] https://datachemeng.com/use_of_distance/<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None = 0,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Manhattan, // マンハッタン距離(都市のブロック単位の距離、京都の碁盤の目の距離)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Euclidian, // ユークリッド距離(√直線距離:三平方の定理の距離)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Euclidian2, // ユークリッド距離(2乗直線距離:ルート計算を省いて高速化)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chebyshev, // チェビシェフ距離(縦か横か高さの差のどれか一番大きい値)<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // マス目距離を求める Aスターアルゴリズムのヒューリスティックコストなどに使われる<br>
      &nbsp;&nbsp;&nbsp; inline float distance(const CellXYZ&amp; cell, DistType type = DistType::Manhattan)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (type == DistType::Manhattan)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (float)(std::abs(cell.X - X) + std::abs(cell.Y - Y) + std::abs(cell.Z - Z));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (type == DistType::Euclidian || type == DistType::Euclidian2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float dist2 = (float)((cell.X - X) * (cell.X - X) + (cell.Y - Y) * (cell.Y - Y) + (cell.Z - Z) * (cell.Z - Z));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (type == DistType::Euclidian2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dist2; // 2乗のまま返す(√計算コスト省く)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::sqrt(dist2); // √距離<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // &lt;windows.h&gt;をインクルードするとmaxという名前の関数マクロが定義され、std::max()と衝突してしまうので(std::max)(a, b);のように関数名をカッコで囲んで使用 https://cpprefjp.github.io/reference/algorithm/max.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (float)(std::max)({ std::abs(cell.X - X), std::abs(cell.Y - Y), std::abs(cell.Z - Z) }); // チェビシェフ距離 3変数のmax https://moxtsuan.hatenablog.com/entry/2014/12/01/235957<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      inline CellXYZ operator + (const CellXYZ&amp; left, const CellXYZ&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; return std::move(CellXYZ{ left.X + right.X, left.Y + right.Y, left.Z + right.Z });<br>
      }<br>
      <br>
      inline CellXYZ operator - (const CellXYZ&amp; left, const CellXYZ&amp; right)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; return std::move(CellXYZ{ left.X - right.X, left.Y - right.Y, left.Z - right.Z });<br>
      }<br>
      <br>
      // CellXYZに追加機能として原点(0,0,0)からの距離を事前計算する機能を追加<br>
      struct CellDistXYZ<br>
      {<br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { int X, Y, Z; };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ XYZ;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; int distpow2{ 0 }; // 原点(0,0,0)からの距離の2乗<br>
      <br>
      &nbsp;&nbsp;&nbsp; operator CellXYZ&amp; () { return XYZ; } // CellXYZ型への変換オペレータ<br>
      <br>
      &nbsp;&nbsp;&nbsp; CellDistXYZ() = default;<br>
      &nbsp;&nbsp;&nbsp; inline ~CellDistXYZ() {};<br>
      &nbsp;&nbsp;&nbsp; inline CellDistXYZ(int X, int Y, int Z = 0) : X{ X }, Y{ Y }, Z{ Z }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; distpow2 = X * X + Y * Y + Z * Z; // 原点(0,0,0)からの距離比較のため事前初期計算<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ★連想配列mapのキーで使うため &lt; 比較演算子(連想配列並べ替えのため)をカスタム定義 http://programming-tips.info/use_struct_as_key_of_map/cpp/index.html<br>
      &nbsp;&nbsp;&nbsp; inline bool operator &lt; (const CellDistXYZ&amp; other) const {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★原点からの距離distpow2順になるようにするとstd::mapにいれれば自動で原点からの距離順にならぶ(敵の近い順に使える)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;distpow2 &lt; other.distpow2) return true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;Z &lt; other.Z) return true; // Z優先並べ替え(std::map並び順ではZの大きいものが一番あとに[並び順]X行⇒Y列⇒Zのエクセル順)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (this-&gt;Z &gt; other.Z) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;Y &lt; other.Y) return true; // Zが同じ時はYを比較 Z Y の順に並べばCSVのように左上から列→行の順にならぶ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (this-&gt;Y &gt; other.Y) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;X &lt; other.X) return true; // Z,Yが同じ時はXを比較<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (this-&gt;X &gt; other.X) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // X と Y と Z がすべて等しい場合<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 一致演算子 == std::unordered_map のキーで使うため == 比較演算子カスタム定義 https://sygh.hatenadiary.jp/entry/2014/02/13/222356<br>
      &nbsp;&nbsp;&nbsp; inline bool operator == (const CellXYZ&amp; other) const {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this-&gt;X == other.X &amp;&amp; this-&gt;Y == other.Y &amp;&amp; this-&gt;Z == other.Z;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // 不一致演算子 !=<br>
      &nbsp;&nbsp;&nbsp; inline bool operator != (const CellXYZ&amp; other) const {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return !(this-&gt;operator==(other));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; inline size_t GetHashCode() const { return XYZ.GetHashCode(); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; struct Hash // ハッシュ値取得用の関数オブジェクト(std::unordered_map のキーで使うため) https://sygh.hatenadiary.jp/entry/2014/02/13/222356<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline size_t operator ()(const CellDistXYZ&amp; cell) const { return cell.XYZ.GetHashCode(); }<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline CellDistXYZ&amp; operator += (const CellXYZ&amp; other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;XYZ += other;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;distpow2 = X * X + Y * Y + Z * Z; // 原点(0,0,0)からの距離比較のため<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; inline CellDistXYZ&amp; operator += (const CellDistXYZ&amp; other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;XYZ += other.XYZ;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;distpow2 = X * X + Y * Y + Z * Z; // 原点(0,0,0)からの距離比較のため<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline CellDistXYZ&amp; operator -= (const CellXYZ&amp; other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;XYZ -= other;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;distpow2 = X * X + Y * Y + Z * Z; // 原点(0,0,0)からの距離比較のため<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; inline CellDistXYZ&amp; operator -= (const CellDistXYZ&amp; other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;XYZ -= other.XYZ;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;distpow2 = X * X + Y * Y + Z * Z; // 原点(0,0,0)からの距離比較のため<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ムーブコンストラクタ distpow2を再計算せずにそのまま代入 https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html<br>
      &nbsp;&nbsp;&nbsp; inline CellDistXYZ(CellDistXYZ&amp;&amp; other) noexcept : XYZ{ other.XYZ }, distpow2{ other.distpow2 } {}<br>
      };<br>
      <br>
      <br>
      inline CellDistXYZ operator + (const CellDistXYZ&amp; left, const CellDistXYZ&amp; right)<br>
      {&nbsp;&nbsp; // ムーブコンストラクタで { }内 の一時変数 を いちいち無駄にコピーせず { }外 へそのまま所有権ごと移動させるので { }内 のデータは消えずに { }外へ<br>
      &nbsp;&nbsp;&nbsp; return std::move(CellDistXYZ{ left.X + right.X,left.Y + right.Y,left.Z + right.Z });<br>
      }<br>
      <br>
      inline CellDistXYZ operator - (const CellDistXYZ&amp; left, const CellDistXYZ&amp; right)<br>
      {&nbsp;&nbsp; // ムーブコンストラクタで { }内 の一時変数 を いちいち無駄にコピーせず { }外 へそのまま所有権ごと移動させるので { }内 のデータは消えずに { }外へ<br>
      &nbsp;&nbsp;&nbsp; return std::move(CellDistXYZ{ left.X - right.X,left.Y - right.Y,left.Z - right.Z });<br>
      }<br>
      <br>
      // 空間をグリッドでマス目として分割する<br>
      template&lt;typename TypeT&gt;<br>
      class <b>CellGrid</b><br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int cellWidth, cellHeight, cellDepth; // マス目セルのサイズ(当たり判定の半径よりは大きくないとあかん)<br>
      <br>
      &nbsp;&nbsp;&nbsp; // CellXYZをキーにそのマス目にあるTypeTを得る辞書配列<br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;CellXYZ, TypeT, CellXYZ::<b>Hash</b>&gt; <b>cellData</b>;<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline CellGrid(int cellWidth = 64, int cellHeight = 64, int cellDepth = 64)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : cellWidth{ cellWidth }, cellHeight{ cellHeight }, cellDepth{ cellDepth }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual ~CellGrid()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual int cellX(float worldX)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // マイナス方向にも対応<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (worldX &gt;= 0) ? (int)<b>worldX / cellWidth</b> : (int)worldX / cellWidth - 1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual int cellY(float worldY)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // マイナス方向にも対応<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (worldY &gt;= 0) ? (int)worldY / cellHeight : (int)worldY / cellHeight - 1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual int cellZ(float worldZ)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // マイナス方向にも対応<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (worldZ &gt;= 0) ? (int)worldZ / cellDepth : (int)worldZ / cellDepth - 1;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual float centerX(int cellX)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // マイナス方向にも対応<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (cellX &gt;= 0) ? (float)cellX * cellWidth + cellWidth / 2 : (float)(cellX + 1) * cellWidth - cellWidth / 2;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual float centerY(int cellY)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // マイナス方向にも対応<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (cellY &gt;= 0) ? (float)cellY * cellHeight + cellHeight / 2 : (float)(cellY + 1) * cellHeight - cellHeight / 2;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual float centerZ(int cellZ)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // マイナス方向にも対応<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (cellZ &gt;= 0) ? (float)cellZ * cellDepth + cellDepth / 2 : (float)(cellZ + 1) * cellDepth - cellDepth / 2;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; inline TypeT top(float worldX, float worldY, float worldZ = 0) // マス目に入っている先頭の要素へのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return top(cellX(worldX), cellY(worldY), cellZ(worldZ));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; inline TypeT top(int cellX, int cellY, int cellZ = 0) // マス目に入っている先頭の要素へのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return top(CellXYZ(cellX, cellY, cellZ));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; inline TypeT top(const CellXYZ&amp; searchXYZ) { // マス目に入っている先頭の要素を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cellData.count(searchXYZ) == 0) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto ret = cellData[searchXYZ]; //TypeTのデフォルトコンストラクタを走らせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cellData.erase(searchXYZ); // 即消す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ret;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cellData[searchXYZ];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; inline int cellID(int cellX, int cellY, int cellZ = 0) // マス目番号IDを返す(見つからない場合は-1が返る)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ searchXYZ(cellX, cellY, cellZ);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cellData.count(searchXYZ) == 0) return -1; // 見つからない場合は-1が返る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return top(searchXYZ).posID;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; inline int cellID(const CellXYZ&amp; searchXYZ)&nbsp; // マス目番号IDを返す(見つからない場合は-1が返る)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cellData.count(searchXYZ) == 0) return -1; // 見つからない場合は-1が返る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return top(searchXYZ).posID;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; inline TypeT&amp; operator()(float worldX, float worldY, float worldZ = 0) { // マス目に入っている先頭の参照を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cellData[CellXYZ(cellX(worldX), cellY(worldY), cellZ(worldZ))];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; inline TypeT&amp; operator()(int cellX, int cellY, int cellZ = 0) { // マス目に入っている先頭の参照を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cellData[CellXYZ(cellX, cellY, cellZ)];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline TypeT&amp; operator[](const CellXYZ&amp; searchXYZ) { // マス目に入っている先頭の参照を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cellData[searchXYZ];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; struct LineZ {//★ []オペレータの数珠つなぎで[][][]3つ四角で3次元配列のようにアクセスできるように<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellGrid* parent{ nullptr };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int X, Y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline LineZ(int X, int Y, CellGrid* parent) : X{ X }, Y{ Y }, parent{ parent } {};<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline TypeT&amp; operator[](int Z) { // マス目に入っている先頭の参照を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (*parent)[CellXYZ(X, Y, Z)];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline operator TypeT&amp; () { // [][]の2つ[]のときはZ無し辞書にアクセスして返す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (*parent)[CellXYZ(X, Y)];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline TypeT&amp; operator = (TypeT other) { //　代入 [X][Y] = ～;の時の挙動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (*parent)[CellXYZ(X, Y)] = other;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; struct LineY {//★ []オペレータの数珠つなぎで[][][]3つ四角で3次元配列のようにアクセスできるように<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellGrid* parent{ nullptr };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int X;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline LineY(int X, CellGrid* parent) : X{ X }, parent{ parent } {};<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline LineZ operator[](int Y) { // []オペレータの数珠つなぎで[][][]3つ四角で3次元配列のようにアクセスできるように<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return LineZ(X, Y, parent);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; inline LineY operator[](int X) { // マス目に入っている要素へ[][][]3つ四角でアクセスできるように<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return LineY(X, this);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void clear(CellXYZ* targetXYZ = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (targetXYZ == nullptr) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;CellXYZ&gt; cells;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; cell : cellData)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cells.emplace_back(cell.first);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; cell : cells)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear(&amp;cell);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cellData.clear(); //格子をクリア<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //std::unordered_map&lt;CellXYZ, TypeT, CellXYZ::Hash&gt;().swap(cellData); // 空のテンポラリオブジェクトでリセット https://stackoverflow.com/questions/42114044/how-to-release-unordered-map-memory/42115076<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 継承してTypeTクラスがリンクリスト構造ならoverrideして数珠つなぎのリストをクリアしたほうがいい(そのままだと先頭しかclearされないから)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*else if (targetXYZ != nullptr &amp;&amp; cellData.count(*targetXYZ) != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cellData[*targetXYZ]-&gt;clearLinkList();*/<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Update() {}; // Update仮想関数<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() {}; // Draw仮想関数<br>
      <br>
      &nbsp;&nbsp;&nbsp; // マス目の上下左右4方向をvector配列として返す<br>
      &nbsp;&nbsp;&nbsp; inline std::vector&lt;CellXYZ&gt; getDirections4(const CellXYZ&amp; center, bool ifExists = false) // ifExists = trueにすると存在しているときだけget<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;CellXYZ&gt; directions;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; cell : center.getDirections4())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ifExists == true &amp;&amp; cellData.count(cell) &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; directions.emplace_back(cell);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return directions;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // マス目の上下左右斜め方向をvector配列として返す<br>
      &nbsp;&nbsp;&nbsp; inline std::vector&lt;CellXYZ&gt; getDirections8(const CellXYZ&amp; center, bool ifExists = false) // ifExists = trueにすると存在しているときだけget<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;CellXYZ&gt; directions;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; cell : center.getDirections8())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ifExists == true &amp;&amp; cellData.count(cell))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; directions.emplace_back(cell);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return directions;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; //[3D] マス目の上下左右 と 3D上下 方向をvector配列として返す<br>
      &nbsp;&nbsp;&nbsp; inline std::vector&lt;CellXYZ&gt; getDirections6(const CellXYZ&amp; center, bool ifExists = false) // ifExists = trueにすると存在しているときだけget<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;CellXYZ&gt; directions;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; cell : center.getDirections6())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ifExists == true &amp;&amp; cellData.count(cell))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; directions.emplace_back(cell);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return directions;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; //[3D] マス目の[2D]上下左右斜め 8方向 と [3D下]反時計回り9方向 と [3D上]反時計回り9方向 計26方向をvector配列として返す<br>
      &nbsp;&nbsp;&nbsp; inline std::vector&lt;CellXYZ&gt; getDirections26(const CellXYZ&amp; center, bool ifExists = false) // ifExists = trueにすると存在しているときだけget<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;CellXYZ&gt; directions;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; cell : center.getDirections26())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ifExists == true &amp;&amp; cellData.count(cell))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; directions.emplace_back(cell);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return directions;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    なかなか長いですが、<br>
    ようは<b>「何もないマス目の情報をもたないためにはマス目のハッシュ値をキーにして辞書で管理したい」</b>ということです。<br>
    例えば、普通の辞書を考えてみてください。<br>
    辞書のア行にアイスという言葉は登録されていますが「あああああ」という言葉は登録されていませんよね。<br>
    あたりまえのように聞こえるかもしれませんが、それをマス目に入れ替えるとどうでしょう。<br>
    空間のほとんどにはキャラはおらず「マス目は空」ですよね。<br>
    なのにこれをもしstd::vector&lt;std::vector&lt;std::vector&lt;Chara&gt;&gt;&gt;型の3次元配列で管理しようとするとどうでしょう。<br>
    ほとんどの[2][3][6]の位置にだけキャラがいたとして、その他の[z][y][x]のマス目のほとんどは「キャラがいないのにデータとしてはメモリを食う」ことになります。<br>
    これは「あああ」「ああい」「ああう」「ああえ」など意味のないキーのために辞書のページを無駄づかいしているようなものです。<br>
    ハッシュ値をキーにした辞書なら、キャラのいないマス目はそもそも辞書にはのっていない = ページ無駄がない ということが実現できます。<br>
    上記のCellXYZでは Hash を定義して、<br>
    CellGridクラスのメンバのstd::unordered_map&lt;CellXYZ, TypeT, <b>CellXYZ::Hash</b>&gt; cellData;ではそのハッシュをキーとした辞書を持っています。<br>
    そして、CellGridクラスの下記の関数<br>
    &nbsp;&nbsp;&nbsp; virtual int cellX(float worldX)<br>
    &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // マイナス方向にも対応<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (worldX &gt;= 0) ? (int)<b>worldX / cellWidth</b> : (int)worldX / cellWidth - 1;<br>
    &nbsp;&nbsp;&nbsp; }<br>
    上記の<b>worldX / cellWidth</b> の割り算で例えば <b>cellWidthが10だとすると、x = 92.0の位置は 92 / 10 = 9番のマス目の位置に変換</b>されます。<br>
    (マイナスのときは、x = -12.0の位置は -12 / 10 - 1 = -2番、x = -4.0の位置は -4 / 10 - 1 = -1番 の位置に変換されます←int型割り算の余り-4は切り捨て)<br>
    マス目は、ようするに<b>float型のワールド位置をint型にキャストして、マス目のサイズで割って(余りは切り捨て)、int型のマス目番号に変換するというのがポイント</b>ですね。<br>
    逆にいうと、<b>マス目のサイズ(縦と横と高さ)が確定しないと、ワールド位置をマス目の番号に変換することはできない</b>ということです。<br>
    <br>
    <br>
    では、次はCellGridに入れるオブジェクト、GridObjectを作成していきましょう。<br>
    <p><code>GridObject.hを新規作成</code>して、マス目にいれるオブジェクトのクラスを準備しましょう。</p>
    <p class="source">#ifndef GRID_OBJECT_H_<br>
      #define GRID_OBJECT_H_<br>
      <br>
      #include "CellXYZ.h"<br>
      #include "GameObject.h"<br>
      <br>
      class GridObject; // 前方宣言<br>
      <br>
      // GridObjectに特化したGridをCellGridを継承して定義<br>
      class <b>Grid</b> : public <b>CellGrid</b>&lt;GridObject*&gt;<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 継承overrideしてGridObjectのリンクリスト構造を頭から最後まで全部クリアする<br>
      &nbsp;&nbsp;&nbsp; virtual void clear(CellXYZ* targetXYZ = nullptr) override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; Grid(int cellWidth = 64, int cellHeight = 64, int cellDepth = 64)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : CellGrid(cellWidth, cellHeight, cellDepth)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual ~Grid()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      <br>
      // GameProgramingPatternsの第20章:空間分割を参考に独自実装(コンポーネント化、マイナス空間も対応)<br>
      // https://www.amazon.co.jp/gp/offer-listing/4844338900/ref=tmm_pap_used_olp_0?ie=UTF8&amp;condition=used<br>
      <br>
      // グリッドに入れるオブジェクト、<b>前と後のオブジェクトへのリンクを数珠繋ぎリンクリスト構造で持つ</b>ことができる<br>
      class GridObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline GridObject(Grid* <b>pGrid</b> = nullptr) : <b>m_pGrid</b>{ pGrid } {}<br>
      &nbsp;&nbsp;&nbsp; virtual ~GridObject() { erase(); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ beforeXYZ{ 0,0,0 }; // 1フレーム前のマス目位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { int X, Y, Z; };<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // <b>前と次への双方向のポインタ矢印を持つ数珠繋ぎリンクリスト構造</b><br>
      &nbsp;&nbsp;&nbsp; GridObject* <b>m_pPrev</b>{ nullptr }; //<b>前の点ノードに戻る</b>矢印ポインタ<br>
      &nbsp;&nbsp;&nbsp; GridObject* <b>m_pNext</b>{ nullptr }; //<b>次の点ノードに進む</b>矢印ポインタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; Grid* <b>m_pGrid</b>{ nullptr }; // GridObject自身が入っているグリッドへのリンク<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // override して グリッドの隣接グリッド探索などの処理を実装する<br>
      &nbsp;&nbsp;&nbsp; virtual void checkCell()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // override して グリッドの隣接グリッド探索などの処理を実装してください<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // リンク構造のリセットとm_pGridへのリンクのクリア(<b>ドミノ倒し的に全部リセット</b>)<br>
      &nbsp;&nbsp;&nbsp; virtual void clearLinkList()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GridObject* next = m_pNext; // eraseでpNextのリンクが消える前にリンクを一時退避<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; erase();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pGrid = nullptr;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (next != nullptr) next-&gt;clearLinkList(); // 最初に取っておいた次のリンク先も連鎖的にクリアさせる(<b>ドミノ倒し的に全部リセット</b>)<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // グリッドにthisを追加 (m_pGridのnowXYZのマス目位置に追加)<br>
      &nbsp;&nbsp;&nbsp; virtual void <b>add</b>(CellXYZ* nowXYZ)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nowXYZ == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_pGrid == nullptr) return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //↓<b>リンクリスト構造のリストを使って先頭に追加</b>する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pPrev = nullptr; //先頭だから自分より前はない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pNext = m_pGrid-&gt;top(*nowXYZ); // 次→grid配列の<b>先頭に元から入っていたもの</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*m_pGrid)[*nowXYZ] = this; // grid配列の<b>先頭をthisにすげかえる</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_pNext != nullptr) // <b>先頭に元から入っていたものがnullptrじゃなかったら</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pNext-&gt;m_pPrev = this; // this←元からの先頭(<b>先頭に割り込んだので元の先頭の人の前矢印をthisへリンク</b>)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //↑ここまでの処理で数珠つなぎのリンクリスト構造になる<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beforeXYZ = *nowXYZ; // 一つ前のx,y,zの位置を保存して次に備える<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // グリッドからthisを削除<br>
      &nbsp;&nbsp;&nbsp; void <b>erase</b>(CellXYZ* nowXYZ = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // リンクリスト構造からのリンク削除処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_pPrev != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pPrev-&gt;m_pNext = m_pNext; // <b>前要素とのリンク削除</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_pNext != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pNext-&gt;m_pPrev = m_pPrev; // <b>次要素とのリンク削除</b><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // デバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (nowXYZ == nullptr) printfDx("(%d,%d,%d)\n", beforeXYZ.X, beforeXYZ.Y, beforeXYZ.Z);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nowXYZ == nullptr) nowXYZ = &amp;beforeXYZ;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printfDx("(%d,%d,%d)\n", fromXYZ-&gt;X, fromXYZ-&gt;Y, fromXYZ-&gt;Z); // デバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_pGrid == nullptr) return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_pGrid-&gt;top(*nowXYZ) == this) // このグリッド<b>(this)がリンクリスト構造の一番最初(top)だった場合はtopの置き換えが必要</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_pNext != nullptr) // リンクリスト構造の<b>数珠つなぎの後ろ側(m_pNext)があるとき</b>には<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*m_pGrid)[*nowXYZ] = m_pNext; // gridのマス目配列の<b>先頭を thisのかわりに pNextで上書きしてthisを上書きで消す</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // 数珠つなぎの後ろがいないときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*m_pGrid).cellData.erase(*nowXYZ); // マス目辞書配列の目次から削除(辞書の目次数が多いと重くなりやすいから)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Draw(GameObject* obj = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_pGrid == nullptr) return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cellX = beforeXYZ.X; int cellY = beforeXYZ.Y; int cellZ = beforeXYZ.Z;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float leftX = (float)cellX * m_pGrid-&gt;cellWidth;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float topY = (float)cellY * m_pGrid-&gt;cellHeight;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float leftTopZ = (float)cellZ * m_pGrid-&gt;cellDepth;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float rightX = (float)(cellX + 1) * m_pGrid-&gt;cellWidth;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float bottomY = (float)(cellY + 1) * m_pGrid-&gt;cellHeight;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float rightBottomZ = (float)(cellZ + 1) * m_pGrid-&gt;cellDepth;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int color = GetColor(0, 255, 255); // グリッドを 水色 で描画<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 四角Boxで GridObjectが存在するグリッド を描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawCube3D(VGet(leftX, topY, leftTopZ),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VGet(rightX, bottomY, rightBottomZ),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; color, color, FALSE);<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    ここで、GridObjectの重要なデータ構造「<b>リンクリスト構造</b>」について触れなければなりません。<br>
    &nbsp;&nbsp;&nbsp; // <b>前と次への双方向のポインタ矢印を持つ数珠繋ぎリンクリスト構造</b><br>
    &nbsp;&nbsp;&nbsp; GridObject* <b>m_pPrev</b>{ nullptr }; //<b>前の点ノードに戻る</b>矢印ポインタ<br>
    &nbsp;&nbsp;&nbsp; GridObject* <b>m_pNext</b>{ nullptr }; //<b>次の点ノードに進む</b>矢印ポインタ<br>
    リンクリストは上記のように<b>2つ「数珠(じゅず)つなぎ用」ポインタ</b>を持ちます。<br>
    <b>数珠つなぎをイメージするために「左手を前に右手を後ろに出してみてください」</b><br>
    自分の後ろに人がいるときには、自分の右手(m_pNext) と 後ろの人の左手(m_pPrev) とをつなぎます。<br>
    ポインタをつなぐとは、<br>
    自分(this)の右手(m_pNext) <b>this-&gt;m_pNext = 後ろの人のデータへのポインタ;</b><br>
    後ろの人(m_pNext)の左手(m_pPrev) <b>m_pNext-&gt;m_pPrev = this 自分;</b><br>
    上記のように、2行で書きます。<b>2行必要なのは自分の手に相手をつなぐ1行だけでなく、相手側の手から自分へのポインタをつなぐ1行も必要だから</b>です。<br>
    このように「リンクリスト構造とは自分の前と後ろのポインタの手をつなぐ構造」です。<br>
    <br>
    <b>リンクリスト構造はstd::vectorなどの配列を別途用意していないのに「前から後ろへの順番 = 数珠(じゅず)繋ぎ」を持てるという強力なテクニック</b>です。<br>
    そして、驚くべきことに<b>リンクリスト構造なら「先頭の人を1人だけ辞書に登録してるだけなのに」「先頭の人からたどれば沢山の人を登録したのと実質同じ」である</b>ということです。<br>
    さらに、<b>どんなに沢山データがあるときでも「列から離れるときには右手と左手を離せばよいだけ[計算速度O(1)] 」</b>です。<br>
    <br>
    つまり<b>「登録する辞書は全くかさばらないし、データ1つずつのつけ離しも高速」</b>なわけです。<br>
    これは<b>空間をグリッドで区切ったマス目を辞書としたときに、キャラをマス目位置を目次とした辞書に頻繁に入れたり出したりする</b>のに非常に適しています。<br>
    <b>敵キャラが一つのマス目に集中したとしても、辞書には先頭の敵キャラへのポインタリンクが1つ入っているだけで済みます</b>。<br>
    <br>
    上記の性質から、リンクリスト構造は「プログラマが自由に自作できるべき基礎データ構造」として知られています。<br>
    つまり、<b>今回はGridObjectというクラス名で作成しましたが、必要な別件に出くわせば別のクラス名で別途、自分で自作できるようになるべきデータ構造</b>です。<br>
    <br>
    <p><code>GridObject.cppを新規作成</code>して、グリッドのマス目辞書から指定したターゲットとなるGridObjectのリンクリスト数珠つなぎをclearLinkList()でリセットできるようにしましょう。</p>
    <p class="source">#include "GridObject.h"<br>
      <br>
      // 継承overrideしてGridObjectのリンクリスト構造を頭から最後まで全部クリアする<br>
      void Grid::<b>clear(CellXYZ* targetXYZ)</b><br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (targetXYZ == nullptr) // ターゲットの指定がないときは辞書cellDataに入っているすべてをclearにかける<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;CellXYZ&gt; cells;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; cell : cellData) // 一旦辞書cellDataに入っているマス目をすべてcellsに移す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cells.emplace_back(cell.first);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; targetCell : cells) // 辞書のすべてのマス目をループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>clear(&amp;targetCell)</b>; // 辞書のすべてのマス目をtargetXYZにすえて、clearをひとつひとつ実行(辞書を全部クリア)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cellData.clear(); //辞書をクリアして目次が一つもない状態にする<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (targetXYZ != nullptr &amp;&amp; cellData.count(*targetXYZ) != 0) // ターゲットが辞書の目次で見つかったら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cellData[*targetXYZ]-&gt;<b>clearLinkList()</b>; // 辞書に入っている<b>GridObjectのリンクリストの数珠つなぎをドミノ倒し的にクリア</b><br>
      }<br>
    </p>
    グリッドをクリアするときは、中に入っているGridObject同士の数珠つなぎもclearLinkList()で解消する必要があるわけですね。<br>
    なぜなら、辞書と数珠つなぎは形式としては別物のデータなので、上記clear関数のように連動させない限り、<br>
    辞書にはないのに数珠つなぎだけ残っちゃう可能性が出てきてしまうので。<br>
    <br>
    <br>
    続いては、コンポーネントとGridObjectを継承してGridComponentクラスを準備します。<br>
    <p><code>GridComponent.hを新規作成</code>して、オーナーが今いるグリッドと隣接するグリッドのマス目辞書の先頭のGridObjectから数珠つなぎにチェックできるようにしましょう。</p>
    <p class="source">#ifndef GRIDCOMPONENT_H_<br>
      #define GRIDCOMPONENT_H_<br>
      <br>
      #include "Component.h"<br>
      <br>
      #include &lt;list&gt;<br>
      #include &lt;memory&gt; // 共有ポインタ std::shared_ptr を使用する<br>
      #include &lt;unordered_map&gt;<br>
      #include &lt;string&gt;<br>
      #include &lt;assert.h&gt; // OnCheck()を継承先でoverrideしていないことの警告用<br>
      <br>
      #include "CellXYZ.h"<br>
      #include "GameObject.h"<br>
      <br>
      #include "Camera.h"<br>
      <br>
      #include "GridObject.h"<br>
      #include "Collider.h"<br>
      <br>
      <br>
      // GameProgramingPatternsの第20章:空間分割を参考に独自実装(コンポーネント化、マイナス空間も対応)<br>
      // https://www.amazon.co.jp/gp/offer-listing/4844338900/ref=tmm_pap_used_olp_0?ie=UTF8&amp;condition=used<br>
      <br>
      // 空間分割の機能をコンポーネントとして継承。[弾×敵]や[プレイヤ×敵]などを作り分けられる設計に<br>
      class GridComponent : public GridObject, public Component<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; GridComponent(std::shared_ptr&lt;GameObject&gt; pOwner, const std::string&amp; typeTag, CellXYZ::DirType dirType = CellXYZ::DirType::Direction8)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Component(pOwner), dirType{ dirType },<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GridObject((pOwner-&gt;world() == nullptr) ? nullptr : pOwner-&gt;world()-&gt;<b>makeGrid()</b>) // <b>グリッドをmakeGridで初期生成</b><br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = typeTag;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;baseTag = "GridComponent";<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;beforeXYZ = CellXYZ(m_pGrid-&gt;cellX(pOwner-&gt;x), m_pGrid-&gt;cellY(pOwner-&gt;y), m_pGrid-&gt;cellZ(pOwner-&gt;z));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add(); // 初期化と同時にgridに追加<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; virtual ~GridComponent() { erase(); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //GridManager&amp; grids = GridManager::GetInstance();<br>
      &nbsp;&nbsp;&nbsp; CellXYZ::DirType dirType; // 当たり判定でたどる周りのセルのタイプ: [2D]4方向,8方向,[3D]6方向,26方向<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 継承overrideしてコライダがあるときはそのリストを返す<br>
      &nbsp;&nbsp;&nbsp; virtual std::list&lt;std::weak_ptr&lt;Collider&gt;&gt;* colliders() { return nullptr; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // グリッドにthisを追加<br>
      &nbsp;&nbsp;&nbsp; virtual void add(CellXYZ* nowXYZ = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ nowCellXYZ(m_pGrid-&gt;cellX(pOwner-&gt;x), m_pGrid-&gt;cellY(pOwner-&gt;y), m_pGrid-&gt;cellZ(pOwner-&gt;z));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nowXYZ == nullptr) nowXYZ = &amp;nowCellXYZ;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GridObject::add(nowXYZ); // 基底ベースクラスのaddを呼び出す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 移動時のグリッドのマス目の隣への移動処理<br>
      &nbsp;&nbsp;&nbsp; void moveCell(CellXYZ* nowXYZ = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) // オーナーがすでにメモリから解放済のときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; erase(); // オーナーがすでにメモリから解放済のときは リンクリストから削除して return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //移動先のセル(マス目)の指定 nowXYZ がnullptrで指定がなかったら現在オーナーのいる位置を nowXYZに指定する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ nowCellXYZ(m_pGrid-&gt;cellX(pOwner-&gt;x), m_pGrid-&gt;cellY(pOwner-&gt;y), m_pGrid-&gt;cellZ(pOwner-&gt;z));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nowXYZ == nullptr) nowXYZ = &amp;nowCellXYZ;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (beforeXYZ == *nowXYZ) return; // 移動しても同一のマス目なら即return<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; erase(&amp;beforeXYZ); // 前のマス目の位置でのリンクリストから一旦削除<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add(nowXYZ); // 今のマス目位置(nowXYZ)の先頭に thisを割り込みでaddで追加する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 隣接するグリッドのレンジ内にいてcheck関数がよばれたときに実行したい処理をoverrideして実装する<br>
      &nbsp;&nbsp;&nbsp; virtual void <b>OnCheck</b>(GridComponent* other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert("OnCheckを継承したクラスでoverrideして独自の当たり判定処理などを実装しないと意味ないよ(例.GridCollisionComponent.hを見てください)" == "");<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // <b>リンクリストの数珠つなぎを順にたどってOnCheck関数を呼ぶ</b><br>
      &nbsp;&nbsp;&nbsp; inline void checkLinkList(GridObject* other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (other != nullptr) // <b>while文で数珠つなぎのm_pNextを次々とたどって最後にたどり着くと次がなくてnullptrになる</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this != other) // otherが自分自身のときは自分自身どうしのチェックはしない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>OnCheck</b>((GridComponent*)other); // <b>OnCheckを継承したクラスで書き分ける</b>ことで[弾×敵]や[プレイヤ×敵]などを作り分けられる設計に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; other = other-&gt;m_pNext; // リンクリスト構造の次をwhileで次々とたどる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // グリッドのマス目内と隣接するマス目内に格納されている要素(敵や弾)のチェック<br>
      &nbsp;&nbsp;&nbsp; // 実際のチェック処理はOnCheck関数でやる。隣接するマス目しか調べないので高速<br>
      &nbsp;&nbsp;&nbsp; void checkCell() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) // オーナーがすでにメモリから解放済のときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; erase(); // オーナーがすでにメモリから解放済のときは リンクリストから削除して return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // オーナーのいるグリッドの<b>マス目辞書から先頭を取り出し、その同一グリッドにいるオブジェクトをチェック</b>する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto <b>center</b> = (GridComponent*)m_pGrid-&gt;<b>top</b>(pOwner-&gt;x, pOwner-&gt;y, pOwner-&gt;z);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (center == nullptr) return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;checkLinkList(<b>center</b>); // 中心centerの<b>同一マスに他にもオブジェクトがある場合にそれらのオブジェクトをチェック</b>する<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cellX = m_pGrid-&gt;cellX(pOwner-&gt;x);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cellY = m_pGrid-&gt;cellY(pOwner-&gt;y);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cellZ = m_pGrid-&gt;cellZ(pOwner-&gt;z);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t iSize = 4;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto* dir = &amp;CellXYZ::dir4[0]; //[2D] 隣接 4方向グリッド調べる constexpr で高速化を狙う<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dirType == CellXYZ::DirType::Direction8) { iSize = 8; dir = &amp;CellXYZ::dir8[0]; } //[2D] 隣接 8方向グリッド調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dirType == CellXYZ::DirType::Direction6) { iSize = 6; dir = &amp;CellXYZ::dir6[0]; } //[3D] 隣接 6方向グリッド調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (dirType == CellXYZ::DirType::Direction26) { iSize = 26; dir = &amp;CellXYZ::dir26[0]; } //[3D] 隣接 26方向グリッド調べる<br>
      <br>
      #define DIR_X( i )&nbsp;&nbsp;&nbsp; std::get&lt;0&gt;(dir[i]) // std::get&lt;0&gt;(dir[i]) と書くより少し見やすく DIR_X(i) と書けるように<br>
      #define DIR_Y( i )&nbsp;&nbsp;&nbsp; std::get&lt;1&gt;(dir[i])<br>
      #define DIR_Z( i )&nbsp;&nbsp;&nbsp; std::get&lt;2&gt;(dir[i])<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0; i &lt; iSize; ++i) //<b>隣接するグリッドを先頭から数珠つなぎにチェック</b>して調べる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;checkLinkList(m_pGrid-&gt;top(cellX + DIR_X(i), cellY + DIR_Z(i), cellZ + DIR_Y(i)));<br>
      <br>
      #undef DIR_X<br>
      #undef DIR_Y<br>
      #undef DIR_Z<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; colider : *colliders())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pCollider = colider.lock())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCollider-&gt;UpdateIsCollision(); // 衝突情報を一旦リセット(m_isPrevCollisionとm_isCollisionなどをリセット)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; moveCell(); // 所属するマス目セルを更新する(現在のオーナーがいるマス目位置のグリッドに移動)<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Draw(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner-&gt;world() != nullptr) // コンポーネントを所有するオーナーのいるワールドのカメラすべてに描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;world()-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 四角Boxで GameObjectが存在するグリッド を描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GridObject::Draw(obj);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp; };<br>
      };<br>
      <br>
      #endif<br>
    </p>
    隣接するグリッド(設定:[2D]4方向、8方向、[3D]6方向、26方向)に入っているGridObjectのOnCheck関数しか呼ばれなくなるので、<br>
    広大なフィールドにぽつぽつと離れているキャラ同士の当たり判定などムダな判定はスキップして高速化が望めます。<br>
    例えば、フィールドにぼつぼつ離れて1万個キャラがいるとき、隣接グリッド以外を<b>スキップしないと、総当たりだと1万×1万=1億回の判定になってしまいます</b>。<br>
    <br>
    では次はOnCheck関数で呼ぶ当たり判定用のコライダーを準備しましょう。<br>
    <p><code>Collider.hを新規作成</code>して、Collision3D.hのカプセルや球などの当たり判定を呼んで衝突を判定しましょう。</p>
    <p class="source">#ifndef COLLIDER_H_<br>
      #define COLLIDER_H_<br>
      <br>
      #include "Component.h"<br>
      #include &lt;memory&gt; // 共有ポインタ std::shared_ptr を使用する<br>
      #include &lt;unordered_set&gt; // std::unordered_setで衝突している他のコライダのIDを保管してかぶらないようにする<br>
      <br>
      #include "GameObject.h"<br>
      #include "Collision3D.h"<br>
      <br>
      class Collider; // 前方宣言<br>
      <br>
      //[衝突情報:参考] https://docs.unity3d.com/jp/2018.4/ScriptReference/Collision.html<br>
      class Collision<br>
      {&nbsp;&nbsp;&nbsp; // 衝突はGameObjectに所有されているComponent同士の衝突により生成される 衝突後、発生元のGameObjectはCollisionと関係なく消えてしまうかもしれない <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;GameObject&gt; m_pGameObject; // 衝突を発生させたGameObjectへのリンクを保管する(GameObjectはすでに消えているかもしれないから弱リンクに)<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; Collision(std::weak_ptr&lt;GameObject&gt; pGameObject) : m_pGameObject{ pGameObject } {}<br>
      &nbsp;&nbsp;&nbsp; class ContactPoint //[衝突点の情報] https://docs.unity3d.com/jp/2018.4/ScriptReference/ContactPoint.html<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; public:<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ContactPoint() = default;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ContactPoint(Vector3 point_, Vector3 normal_, float separation_, std::weak_ptr&lt;Collider&gt; thisCollider_, std::weak_ptr&lt;Collider&gt; otherCollider_)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : point{ point_ }, normal{ normal_ }, separation{ separation_ }, thisCollider{ thisCollider_ }, otherCollider{ otherCollider_ } {}<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; virtual ~ContactPoint() {}<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 point{ 0.0f,0.0f,0.0f }; // 接触点<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 normal{ 0.0f,0.0f,0.0f }; // 接触点の法線<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float separation{ 0.0f }; // 接触点でのコライダー間の距離<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;Collider&gt; thisCollider{ std::weak_ptr&lt;Collider&gt;() }; //[衝突元]接触したコライダー情報<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;Collider&gt; otherCollider{ std::weak_ptr&lt;Collider&gt;() }; //[衝突先] 接触している他のコライダー情報<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;ContactPoint&gt; contacts; // 全ての接触点の配列<br>
      &nbsp;&nbsp;&nbsp; // 基本的にthis側のコライダーのオーナーのGameObjectを返す<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;GameObject&gt; gameObject() { return m_pGameObject; };<br>
      };<br>
      <br>
      <br>
      class Collider; // 前方宣言<br>
      <br>
      // 関数の前方宣言<br>
      inline bool isCollisionColliders(std::shared_ptr&lt;Collider&gt; pThis, std::shared_ptr&lt;Collider&gt; pOther,<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Collision&gt;* ppThisResult = nullptr, std::shared_ptr&lt;Collision&gt;* ppOtherResult = nullptr);<br>
      <br>
      class Collider : public Component<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // コライダの当たり判定のタイプ<br>
      &nbsp;&nbsp;&nbsp; enum class Type : unsigned char<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //Point = 0, // 点<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Sphere, // 球<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Capsule, // カプセル<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //Box, // ボックス<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //Plane, // 平面<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline Collider(std::shared_ptr&lt;GameObject&gt; pOwner, Type type) : Component(pOwner), m_type{ type } {}<br>
      &nbsp;&nbsp;&nbsp; virtual ~Collider() {}<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; const Type m_type; // コライダのタイプ<br>
      &nbsp;&nbsp;&nbsp; inline operator Type () { return m_type; }<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; bool m_isPrevCollision = false; // 前回衝突したか?<br>
      &nbsp;&nbsp;&nbsp; bool m_isCollision = false; // 今回衝突したか?<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; bool isTrigger = false; // コライダーがトリガーですり抜けるかどうか?<br>
      &nbsp;&nbsp;&nbsp; bool enabled = true; // コライダーが有効か?<br>
      &nbsp;&nbsp;&nbsp; unsigned int hitColor = DxLib::GetColor(255, 255, 255); // 描画するときの色<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;Collision::ContactPoint&gt; m_contacts; // 全ての接触点の配列<br>
      &nbsp;&nbsp;&nbsp; std::unordered_set&lt;unsigned int&gt; <b>m_prevCollisionIDs</b>; // <b>前のフレームで衝突した他のコライダのInstanceID</b><br>
      &nbsp;&nbsp;&nbsp; std::unordered_set&lt;unsigned int&gt; <b>m_collisionIDs</b>; // <b>接触している他のコライダのInstanceID</b><br>
      &nbsp;&nbsp;&nbsp; bool IsPrevCollision() { return m_isPrevCollision; }<br>
      &nbsp;&nbsp;&nbsp; void IsPrevCollision(bool isPrevCollision) { m_isPrevCollision = isPrevCollision; return; }<br>
      &nbsp;&nbsp;&nbsp; bool IsCollision() { return m_isCollision; }<br>
      &nbsp;&nbsp;&nbsp; //void IsCollision(bool isCollision) { m_isCollision = isCollision; return; }<br>
      &nbsp;&nbsp;&nbsp; //&nbsp; コライダのワールド座標位置(ownerをたどったワールド座標値)<br>
      &nbsp;&nbsp;&nbsp; inline Vector3 worldPos(Vector3 localPosition) const { return owner()-&gt;position + localPosition; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コライダの含まれるワールド位置のx,y,z最小値を求める(8分木のエリア分別などに使うため)<br>
      &nbsp;&nbsp;&nbsp; virtual Vector3 minXYZ() const = 0; // = 0で純粋仮想関数にして必ずoverride継承しないとエラーになるようにする<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コライダの含まれるワールド位置のx,y,z最大値を求める(8分木のエリア分別などに使うため)<br>
      &nbsp;&nbsp;&nbsp; virtual Vector3 maxXYZ() const = 0; // = 0で純粋仮想関数にして必ずoverride継承しないとエラーになるようにする<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 継承override してカプセルや球やボックスなどのコライダの判定を実装する デフォルトは isCollisionColliders関数を呼び出す<br>
      &nbsp;&nbsp;&nbsp; virtual inline bool isCollision(std::shared_ptr&lt;Collider&gt; pOther,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Collision&gt;* ppThisResult = nullptr, std::shared_ptr&lt;Collision&gt;* ppOtherResult = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (<b>m_collisionIDs</b>.count(pOther-&gt;InstanceID()) &gt; 0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // <b>すでに調べたコライダのIDのペアだったらfalse</b><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 継承override してカプセルや球やボックスなどのコライダの判定を実装する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return isCollisionColliders(shared_from_this_as&lt;Collider&gt;(), pOther, ppThisResult, ppOtherResult);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 毎フレーム isPrev(=m_isCollision)とisCollision(=false)に更新してから当たり判定する<br>
      &nbsp;&nbsp;&nbsp; virtual void UpdateIsCollision() // 前フレームで当たってなくて今当たっていればOnCollisionEnterに使える<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::vector&lt;Collision::ContactPoint&gt;().swap(m_contacts); // 衝突点情報の配列をクリア<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 今のフレームで衝突しているIDを↓prevに移しておけば次のフレームでのOnCollision<b>Enter</b>やOnCollision<b>Exitを呼ぶタイミングの判定</b>に使える<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_collisionIDs.<b>swap(m_prevCollisionIDs)</b>;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::unordered_set&lt;unsigned int&gt;<b>()</b>.swap(m_collisionIDs); // 衝突していたID一覧は、一旦空<b>()と入れ替え</b>て今フレームの衝突検査に備える<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_isPrevCollision = m_isCollision; // 前のフレームで衝突したかを保管<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_isCollision = false; // 一旦、今のフレームでは衝突していない状態として設定して後で当たり判定して書換<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      class SphereCollider : public Collider<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; SphereCollider(std::shared_ptr&lt;GameObject&gt; pOwner, Vector3 center, float radius, unsigned int hitColor_ = GetColor(255, 0, 0))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : Collider(pOwner, Type::Sphere), m_center{ center }, m_radius{ radius }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;hitColor = hitColor_;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual ~SphereCollider() {}<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; Vector3 m_center{ 0.0f,0.0f,0.0f }; // コライダのローカル座標での中心位置<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 球体の半径<br>
      &nbsp;&nbsp;&nbsp; float m_radius{ 0.0f };<br>
      &nbsp;&nbsp;&nbsp; // 球体のローカル座標での中心座標<br>
      &nbsp;&nbsp;&nbsp; inline Vector3 center() const { return m_center; }<br>
      &nbsp;&nbsp;&nbsp; //&nbsp; 球体のワールド座標での中心位置(ownerをたどったワールド座標値)<br>
      &nbsp;&nbsp;&nbsp; inline Vector3 worldCenter() const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return pOwner-&gt;position + center();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // 球体の含まれるワールド位置のx,y,z最小値を求める(8分木のエリア分別などに使うため)<br>
      &nbsp;&nbsp;&nbsp; inline Vector3 minXYZ() const override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 center = worldCenter();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector3{ (m_radius &lt; 0) ? center.x + m_radius : center.x - m_radius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (m_radius &lt; 0) ? center.y + m_radius : center.y - m_radius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (m_radius &lt; 0) ? center.z + m_radius : center.z - m_radius };<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // 球体の含まれるワールド位置のx,y,z最大値を求める(8分木のエリア分別などに使うため)<br>
      &nbsp;&nbsp;&nbsp; inline Vector3 maxXYZ() const override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 center = worldCenter();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector3{ (m_radius &lt; 0) ? center.x - m_radius : center.x + m_radius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (m_radius &lt; 0) ? center.y - m_radius : center.y + m_radius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (m_radius &lt; 0) ? center.z - m_radius : center.z + m_radius };<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // デバッグ用に球体コライダを描く<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (owner() == nullptr) return; // このコンポーネントを所有しているオーナーがすでにメモリから解放されていたら return<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 center = worldCenter();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(center, m_radius, 2, (m_isCollision) ? hitColor : GetColor(255, 255, 255), GetColor(255, 255, 255), FALSE);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (m_isCollision)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (auto&amp; contact : m_contacts) // 衝突点と法線を描く<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(contact.point, 1.0f, 3, hitColor, GetColor(255, 255, 255), TRUE);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(contact.point, contact.point + contact.normal, GetColor(255, 255, 0));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      class CapsuleCollider : public Collider<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; CapsuleCollider(std::shared_ptr&lt;GameObject&gt; pOwner, Vector3 center, float radius, float height, Axis3D direction = Axis3D::Y, unsigned int hitColor_ = GetColor(255, 0, 0))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : Collider(pOwner, Type::Capsule), m_center{ center }, m_radius{ radius }, m_height{ height }, m_direction{ direction }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;hitColor = hitColor_;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual ~CapsuleCollider() {}<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; Vector3 m_center{ 0.0f,0.0f,0.0f }; // コライダのローカル座標での中心位置<br>
      &nbsp;&nbsp;&nbsp; float m_height{ 1.0f }; // コライダの高さ<br>
      &nbsp;&nbsp;&nbsp; Axis3D m_direction{ Axis3D::Y };<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // カプセルの半径<br>
      &nbsp;&nbsp;&nbsp; float m_radius{ 0.0f };<br>
      &nbsp;&nbsp;&nbsp; // カプセルのローカル座標での中心座標<br>
      &nbsp;&nbsp;&nbsp; inline Vector3 center() const { return m_center; }<br>
      &nbsp;&nbsp;&nbsp; //&nbsp; ワールド座標での中心位置(ownerをたどったワールド座標値)<br>
      &nbsp;&nbsp;&nbsp; inline Vector3 worldCenter() const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return pOwner-&gt;position + center();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // カプセルの高さ<br>
      &nbsp;&nbsp;&nbsp; inline Vector3 height() const { return m_height; }<br>
      &nbsp;&nbsp;&nbsp; // カプセルの向く方向軸(height高さの方向軸)<br>
      &nbsp;&nbsp;&nbsp; inline Axis3D direction() const { return m_direction; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カプセルの始点(pOwnerから見たローカル座標値)<br>
      &nbsp;&nbsp;&nbsp; inline Vector3 start() const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return m_center - Vector3{ (m_direction == Axis3D::X) ? m_height / 2.0f : 0.0f,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; (m_direction == Axis3D::Y) ? m_height / 2.0f : 0.0f,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; (m_direction == Axis3D::Z) ? m_height / 2.0f : 0.0f };<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //&nbsp; カプセルの始点(ownerをたどったワールド座標値)<br>
      &nbsp;&nbsp;&nbsp; inline Vector3 worldStart() const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return pOwner-&gt;position + start();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //&nbsp; カプセルの終点(ownerをたどったワールド座標値)<br>
      &nbsp;&nbsp;&nbsp; inline Vector3 worldEnd() const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return pOwner-&gt;position + end();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カプセルの終点(pOwnerから見たローカル座標値)<br>
      &nbsp;&nbsp;&nbsp; inline Vector3 end() const<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return m_center + Vector3{ (m_direction == Axis3D::X) ? m_height / 2.0f : 0.0f,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; (m_direction == Axis3D::Y) ? m_height / 2.0f : 0.0f,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; (m_direction == Axis3D::Z) ? m_height / 2.0f : 0.0f };<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カプセルの含まれるワールド位置のx,y,z最小値を求める(8分木のエリア分別などに使うため)<br>
      &nbsp;&nbsp;&nbsp; inline Vector3 minXYZ() const override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 start = worldStart();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 end = worldEnd();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector3{ (start.x &lt; end.x) ? start.x - m_radius : end.x - m_radius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (start.y &lt; end.y) ? start.y - m_radius : end.y - m_radius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (start.z &lt; end.z) ? start.z - m_radius : end.z - m_radius };<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // カプセルの含まれるワールド位置のx,y,z最大値を求める(8分木のエリア分別などに使うため)<br>
      &nbsp;&nbsp;&nbsp; inline Vector3 maxXYZ() const override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 start = worldStart();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 end = worldEnd();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Vector3{ (start.x &gt; end.x) ? start.x + m_radius : end.x + m_radius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (start.y &gt; end.y) ? start.y + m_radius : end.y + m_radius,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (start.z &gt; end.z) ? start.z + m_radius : end.z + m_radius };<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // デバッグ用にカプセルコライダを描く<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (owner() == nullptr) return; // このコンポーネントを所有しているオーナーがすでにメモリから解放されていたら return<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 start = worldStart();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector3 end = worldEnd();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawCapsule3D(start, end, m_radius, 4, (m_isCollision) ? hitColor : GetColor(255, 255, 255), GetColor(255, 255, 255), FALSE);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (m_isCollision)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (auto&amp; contact : m_contacts) // 衝突点と法線を描く<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawSphere3D(contact.point, 0.1f, 3, hitColor, GetColor(255, 255, 255), TRUE);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::DrawLine3D(contact.point, contact.point + contact.normal, GetColor(255, 255, 0));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      // カプセル同士が衝突しているかを判定する(ppThisResultとppOtherResult:衝突したら衝突情報が返される)<br>
      inline bool <b>isCollisionCapsule_Capsule</b>(std::shared_ptr&lt;Collider&gt; pThis0, std::shared_ptr&lt;Collider&gt; pOther1,<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Collision&gt;* ppThisResult = nullptr, std::shared_ptr&lt;Collision&gt;* ppOtherResult = nullptr)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; auto gameObject0 = pThis0-&gt;owner(), gameObject1 = pOther1-&gt;owner();<br>
      &nbsp;&nbsp;&nbsp; if (gameObject0 == nullptr || gameObject1 == nullptr) return false;<br>
      &nbsp;&nbsp;&nbsp; if (gameObject0-&gt;isStatic || gameObject1-&gt;isStatic) return false; // どちらも静的オブジェクト(isStatic)の場合は当たり判定しない<br>
      <br>
      &nbsp;&nbsp;&nbsp; float radius0 = 0, radius1 = 0;<br>
      &nbsp;&nbsp;&nbsp; Vector3 start0, end0, start1, end1, result0, result1, center0, center1;<br>
      &nbsp;&nbsp;&nbsp; // col0はthis<br>
      &nbsp;&nbsp;&nbsp; if (*pThis0 == Collider::Type::Capsule)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto col0 = std::static_pointer_cast&lt;CapsuleCollider&gt;(pThis0);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; start0 = col0-&gt;worldStart(), end0 = col0-&gt;worldEnd(), center0 = col0-&gt;worldCenter();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; radius0 = col0-&gt;m_radius;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (*pThis0 == Collider::Type::Sphere)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 球体のときはstartとendが両方、球の中心にすればカプセルの当たり判定を使いまわせる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto col0 = std::static_pointer_cast&lt;SphereCollider&gt;(pThis0);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; start0 = col0-&gt;worldCenter(), end0 = col0-&gt;worldCenter(), center0 = col0-&gt;worldCenter();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; radius0 = col0-&gt;m_radius;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // col1はother<br>
      &nbsp;&nbsp;&nbsp; if (*pOther1 == Collider::Type::Capsule)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto col1 = std::static_pointer_cast&lt;CapsuleCollider&gt;(pOther1);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; start1 = col1-&gt;worldStart(), end1 = col1-&gt;worldEnd(), center1 = col1-&gt;worldCenter();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; radius1 = col1-&gt;m_radius;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (*pOther1 == Collider::Type::Sphere)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 球体のときはstartとendが両方、球の中心にすればカプセルの当たり判定を使いまわせる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto col1 = std::static_pointer_cast&lt;SphereCollider&gt;(pOther1);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; start1 = col1-&gt;worldCenter(), end1 = col1-&gt;worldCenter(), center1 = col1-&gt;worldCenter();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; radius1 = col1-&gt;m_radius;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // <b>Collision3D.hの当たり判定関数を使ってチェック</b><br>
      &nbsp;&nbsp;&nbsp; bool isCollision = <b>isCollisionCapsule_Capsule</b>(start0, end0, radius0, start1, end1, radius1, &amp;result0, &amp;result1);<br>
      &nbsp;&nbsp;&nbsp; if (!isCollision) return false;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // collisionの <b>法線ベクトル:norm</b> と <b>距離:mag</b> を求める<br>
      &nbsp;&nbsp;&nbsp; Vector3 v01 = result1 - result0; // 最短距離の2点 result0 から result1 へ向かうベクトル<br>
      &nbsp;&nbsp;&nbsp; float mag01 = v01.magnitude(); // result0とresult1の距離<br>
      &nbsp;&nbsp;&nbsp; Vector3 norm01 = v01.normalized(); // 正規化normalizeする<br>
      &nbsp;&nbsp;&nbsp; if (mag01 == 0.0f) // カプセルの軸が交差しているときはresult0とresult1が同じ点になっちゃう<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; norm01 = (center1 - center0).normalized(); // 中心同士の差ベクトルを法線に<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (center0 == center1) // 中心位置が完全一致するときは<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; norm01 = Vector3{ 1.0f,0.0f,0.0f }; // 仕方ないからx軸方向に引き離す(2DでもつじつまあうようにX軸で)<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; pThis0-&gt;<b>m_collisionIDs</b>.emplace(pOther1-&gt;InstanceID()); // 接触している other のIDを this側 に登録して同じペアの判定を2度しないようにする<br>
      &nbsp;&nbsp;&nbsp; pOther1-&gt;<b>m_collisionIDs</b>.emplace(pThis0-&gt;InstanceID()); // 接触している this のIDを other側 に登録して同じペアの判定を2度しないようにする<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 衝突点 pThisContactとpOtherContact を生成<br>
      &nbsp;&nbsp;&nbsp; Collision::ContactPoint <b>thisContact</b>{ result0, <b>-norm01</b>, <b>mag01</b>, pThis0, pOther1 };<br>
      &nbsp;&nbsp;&nbsp; Collision::ContactPoint <b>otherContact</b>{ result1,&nbsp; <b>norm01</b>, <b>mag01</b>, pOther1, pThis0 };<br>
      &nbsp;&nbsp;&nbsp; pThis0-&gt;<b>m_contacts</b>.emplace_back(<b>thisContact</b>); // コライダ0のm_contactsにも情報登録<br>
      &nbsp;&nbsp;&nbsp; pOther1-&gt;<b>m_contacts</b>.emplace_back(<b>otherContact</b>); // コライダ1のm_contactsにも情報登録<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (ppThisResult != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *ppThisResult = <b>std::make_shared&lt;Collision&gt;</b>(gameObject0); // this側の衝突点をpResultでreturnする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (*ppThisResult)-&gt;contacts.emplace_back(<b>thisContact</b>); //[0] this側の衝突点の情報をcontacts配列に格納<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (*ppThisResult)-&gt;contacts.emplace_back(<b>otherContact</b>); //[1] other側の衝突点の情報をcontacts配列に格納<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (ppOtherResult != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *ppOtherResult = <b>std::make_shared&lt;Collision&gt;</b>(gameObject1); // other側の衝突点をpResultでreturnする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (*ppOtherResult)-&gt;contacts.emplace_back(<b>otherContact</b>); //[0] other側の衝突点の情報をcontacts配列に格納<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (*ppOtherResult)-&gt;contacts.emplace_back(<b>thisContact</b>); //[1] this側の衝突点の情報をcontacts配列に格納<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      // コライダー同士の当たり判定 当たったら衝突情報が ppThisResult,ppOtherResult がnullptrじゃなければ代入されて返却<br>
      inline bool <b>isCollisionColliders</b>(std::shared_ptr&lt;Collider&gt; pThis, std::shared_ptr&lt;Collider&gt; pOther,<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Collision&gt;* ppThisResult, std::shared_ptr&lt;Collision&gt;* ppOtherResult)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 現状はカプセルと球だけの当たり判定しか実装していない<br>
      &nbsp;&nbsp;&nbsp; if ((*pThis == Collider::Type::Sphere || *pThis == Collider::Type::Capsule)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &amp;&amp; (*pOther == Collider::Type::Sphere || *pOther == Collider::Type::Capsule))<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // カプセルの当たり判定で球の当たり判定も兼用する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return <b>isCollisionCapsule_Capsule</b>(pThis, pOther, ppThisResult, ppOtherResult);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ここに<b>カプセルと球以外の当たり判定も追加すればボックスなどとの当たり判定もできるようになる</b><br>
      <br>
      &nbsp;&nbsp;&nbsp; return false;<br>
      }<br>
      <br>
      // 衝突したカプセル同士が当たらないようにコライダがついているGameObjectを押し戻してずらして当たらない位置に移動<br>
      inline bool resolveCollisionCapsule_Capsule(const Collision::ContactPoint&amp; thisContact, const Collision::ContactPoint&amp; otherContact)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; //[共有ポインタのキャスト] https://cpprefjp.github.io/reference/memory/shared_ptr/dynamic_pointer_cast.html<br>
      &nbsp;&nbsp;&nbsp; auto thisCollider = std::dynamic_pointer_cast&lt;CapsuleCollider&gt;(thisContact.thisCollider.lock());<br>
      &nbsp;&nbsp;&nbsp; auto otherCollider = std::dynamic_pointer_cast&lt;CapsuleCollider&gt;(otherContact.thisCollider.lock());<br>
      &nbsp;&nbsp;&nbsp; auto thisGameObject = thisCollider-&gt;owner();<br>
      &nbsp;&nbsp;&nbsp; auto otherGameObject = otherCollider-&gt;owner();<br>
      &nbsp;&nbsp;&nbsp; if (!thisGameObject || !otherGameObject || !thisCollider || !otherCollider)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // どれかがnullptrのときはfalse<br>
      &nbsp;&nbsp;&nbsp; if (thisGameObject-&gt;isStatic &amp;&amp; otherGameObject-&gt;isStatic)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // どちらも静的オブジェクト(isStatic)の場合は当たり判定を押し戻ししない<br>
      &nbsp;&nbsp;&nbsp; Vector3 p0 = thisContact.point;<br>
      &nbsp;&nbsp;&nbsp; Vector3 p1 = otherContact.point;<br>
      &nbsp;&nbsp;&nbsp; if (p0 == p1) // カプセル0とカプセル1の軸が交差しているとき<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // カプセルの中心位置を使って引き離す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; p0 = thisCollider-&gt;worldPos(thisCollider-&gt;center());<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; p1 = otherCollider-&gt;worldPos(otherCollider-&gt;center());<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // 押し戻しの量を計算<br>
      &nbsp;&nbsp;&nbsp; float overlap = (thisCollider-&gt;m_radius + otherCollider-&gt;m_radius) - (p1 - p0).magnitude() + 0.00001f;<br>
      &nbsp;&nbsp;&nbsp; // 押し戻し方向に移動<br>
      &nbsp;&nbsp;&nbsp; Vector3 correction = thisContact.normal * (overlap / 2.0f); // 2で割って両方±動いて当たらないようにする<br>
      &nbsp;&nbsp;&nbsp; if (otherGameObject-&gt;isStatic) // 片方がisStaticなら↓2倍動かしてもう片方はそのまま<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; thisGameObject-&gt;position += correction * 2.0f;<br>
      &nbsp;&nbsp;&nbsp; else if (thisGameObject-&gt;isStatic)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; otherGameObject-&gt;position += -correction * 2.0f;<br>
      &nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 両方isStaticじゃないときは * 2.0fせずに両方移動させる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; thisGameObject-&gt;position += correction;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; otherGameObject-&gt;position += -correction;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      <br>
      #endif<br>
    </p>
    <br>
    では次は同一グリッドにある他のコライダーと当たり判定するためのコンポーネントを準備しましょう。<br>
    <p><code>GridCollidersComponent.hを新規作成</code>して、<b>m_colliders</b>変数に複数のコライダを<b>LinkCollider</b>関数でリンクして、OnCheck関数をoverrideしてコライダ同士の当たり判定をcppで実装できるようにしましょう。</p>
    <p class="source">#ifndef GRID_COLLIDERS_COMPONENT_H_<br>
      #define GRID_COLLIDERS_COMPONENT_H_<br>
      <br>
      #include "GridComponent.h"<br>
      #include &lt;list&gt;<br>
      #include &lt;memory&gt; // 共有ポインタ std::shared_ptr を使用する<br>
      <br>
      class Collider; // 前方宣言<br>
      <br>
      class GridCollidersComponent : public GridComponent<br>
      {<br>
      &nbsp;&nbsp;&nbsp; friend Component;<br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::weak_ptr&lt;Collider&gt;&gt; <b>m_colliders</b>; // GridComponentを所有するGameObjectが持つコライダーのリスト<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; GridCollidersComponent(std::shared_ptr&lt;GameObject&gt; pOwner, const std::string&amp; typeTag, CellXYZ::DirType dirType = CellXYZ::DirType::Direction8)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : GridComponent(pOwner, typeTag, dirType)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コライダのリスト(弱共有ポインタ)へのポインタを返す<br>
      &nbsp;&nbsp;&nbsp; virtual std::list&lt;std::weak_ptr&lt;Collider&gt;&gt;* colliders() override { return <b>&amp;m_colliders</b>; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コライダの弱共有ポインタを グリッドで当たり判定する対象として リンクを リスト m_colliders に追加する<br>
      &nbsp;&nbsp;&nbsp; virtual void <b>LinkCollider</b>(std::weak_ptr&lt;Collider&gt; pColliderLink) { <b>m_colliders.emplace_back</b>(pColliderLink); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // OnCheckを<b>overrideすることで[弾×敵]や[プレイヤ×敵]などの当たり判定処理をCollision3D.hの関数でする</b><br>
      &nbsp;&nbsp;&nbsp; virtual void <b>OnCheck</b>(GridComponent* other) <b>override</b>;<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    ではcppファイルの<b>OnCheck関数</b>でCollision3D.hのisCollision関数で当たり判定をしてGameObjectのOnCollision関数に衝突結果を引き渡してコールバックしましょう。<br>
    <p><code>GridCollidersComponent.cppを新規作成</code>して、Collider.hのisCollision関数経由でCollision3D.hの各種当たり判定を衝突結果をGameObjectのOnCollision関数に渡しましょう。</p>
    <p class="source">#include "GridCollidersComponent.h"<br>
      <br>
      #include "Collider.h"<br>
      <br>
      void GridCollidersComponent::<b>OnCheck</b>(GridComponent* other)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンポーネントのオーナーが死んでたらスキップする<br>
      &nbsp;&nbsp;&nbsp; //if (pOwner-&gt;isDead) return;<br>
      &nbsp;&nbsp;&nbsp; //if (other-&gt;owner()-&gt;isDead) return;<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (auto&amp; pCollider : this-&gt;m_colliders) // this側のコライダすべてをループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto collider = pCollider.lock(); // 弱共有ポインタをロックして共有ポインタに変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (collider == nullptr) continue; // 共有ポインタが削除されすでに解放済の場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; pOtherCollider : *(other-&gt;colliders()))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto otherCollider = pOtherCollider.lock(); // 弱共有ポインタをロックして共有ポインタに変換<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (otherCollider == nullptr) continue; // 共有ポインタが削除されすでに解放済の場合<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Collision&gt; pThisResult{ nullptr }; // 衝突したら情報が入ってきてnullptrじゃなくなる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Collision&gt; pOtherResult{ nullptr }; // 衝突したら情報が入ってきてnullptrじゃなくなる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (collider-&gt;<b>isCollision</b>(otherCollider, &amp;<b>pThisResult</b>, &amp;<b>pOtherResult</b>))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (collider-&gt;<b>m_prevCollisionIDs</b>.count(otherCollider-&gt;InstanceID()) == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //[<b>OnEnter</b>]前のフレームでcolliderがotherと衝突してなくて、<b>今フレームで衝突開始したらOnEnter</b>を呼ぶ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collider-&gt;owner()-&gt;OnCollision<b>Enter(pThisResult)</b>; // collider側の衝突開始したときの関数をコールバックで呼び返す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; otherCollider-&gt;owner()-&gt;OnCollision<b>Enter(pOtherResult)</b>; // other側の衝突開始したときの関数をコールバックで呼び返す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[<b>OnCollision</b>] <b>衝突していたらコールバックを呼び続ける</b><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collider-&gt;owner()-&gt;OnCollision(<b>pThisResult</b>); // collider側の衝突したときの関数をコールバックで呼び返す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; otherCollider-&gt;owner()-&gt;OnCollision(<b>pOtherResult</b>); // other側の衝突したときの関数をコールバックで呼び返す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // 衝突していなかったら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[<b>OnExit</b>]前のフレームでcolliderがotherと衝突していて<b>今フレームで衝突しなくなったらOnExit</b>を呼ぶ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (collider-&gt;<b>m_prevCollisionIDs</b>.count(otherCollider-&gt;InstanceID()) &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collider-&gt;owner()-&gt;OnCollisionExit(<b>pThisResult</b>); // collider側の衝突終了したときの関数をコールバックで呼び返す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    <p><code>GameObject.hを変更</code>して、OnCollisionなどの衝突判定のコールバック関数を準備しましょう。</p>
    <p class="source">#ifndef GAMEOBJECT_H_<br>
      #define GAMEOBJECT_H_<br>
      <br>
      #include &lt;memory&gt; // 共有ポインタの定義のため<br>
      <br>
      #include "Vector3.h"<br>
      #include "Quaternion.h"<br>
      <br>
      #include "Object.h" // インスタンスIDや検索タグを持ち、shared_from_this_as&lt;継承先クラス名&gt;などができる<br>
      <br>
      class World; // 前方宣言<br>
      class Component; // 前方宣言<br>
      <em>class Collision; // 前方宣言</em><br>
      <br>
      // ゲーム上に表示される物体の基底クラス。<br>
      // プレイヤーや敵、アイテムなどはこのクラスを継承して作る。<br>
      class GameObject : public Object<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるのでCreate関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; GameObject(World* world = nullptr, Vector3 position = { 0,0,0 }, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Object(), m_world{ world }, position{ position }, rotation{ rotation }, velocity{ velocity }, force{ force }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~GameObject() {}<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★下記3つはメモリ上で共用状態になる(position、x,y,z、xyzどの名前から数値を変えたり読出してもメモリ上は同じ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 同じデータに3種類の名前を付けたイメージ、しかもVector3の機能や配列としてのアクセスの仕方もできて便利<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // XYZ座標&nbsp; [匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 position; // XYZ座標<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp;&nbsp; }; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
      <br>
      &nbsp;&nbsp;&nbsp; Quaternion rotation; // 回転クオータニオン<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vx, vy, vz; }; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 velocity; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyz;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vxForce, vyForce, vzForce; }; // XYZ方向にかかる力(Unityでいうと AddForce関数 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 force; // XYZ方向の力(物理的には加速度:1フレームごとにvelocityの増える=加速する量)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyzForce;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 重力を返す、重力を変えたいときはoverrideして処理を変えてください、重力を変えてない場合は 0.0f<br>
      &nbsp;&nbsp;&nbsp; virtual inline float gravity() { return 0.0f; }<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; World* m_world; // GameObjectが配置されたワールドへのリンク<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; virtual World* world() { return m_world; }<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
      &nbsp;&nbsp;&nbsp; virtual void world(World* changeWorld) { m_world = changeWorld; }<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; bool isDead{ false }; // 死んだ（削除対象）フラグ<br>
      &nbsp;&nbsp;&nbsp; bool isStatic{ false }; // 動かない(静的オブジェクトか?)<br>
      &nbsp;&nbsp;&nbsp; bool isGround{ false }; // 地面についているか<br>
      &nbsp;&nbsp;&nbsp; <em>bool isJumping{ false }; // ジャンプ中か</em><br>
      &nbsp;&nbsp;&nbsp; bool isFlying{ false }; // 空をとんでいるか<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>float pushPower{ 5.0f }; // コライダで接触したときに押し返す力(相手側が強いと押される)<br>
        &nbsp;&nbsp;&nbsp; float mass{ 1.0f }; // 質量(重さ)コライダで接触したときに重さでforceを割り算すると動きにくくなる</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; hash32 typeTag{ "" }; // 小カテゴリ Zako0など個別のタイプ<br>
      &nbsp;&nbsp;&nbsp; hash32 baseTag{ "" }; // 大カテゴリ Enemyなど大まかなベースジャンル<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンポーネントの&lt;ハッシュID, 共有所有ポインタ&gt; の辞書でコンポーネントの共有カウンタ+1を保持する<br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;size_t, std::shared_ptr&lt;Component&gt;&gt; components;<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // コンポーネントを得る 例えば GetComponent&lt;BoxCollider&gt;でBoxColliderという名前のコンポーネントをcomponents辞書から得る<br>
      &nbsp;&nbsp;&nbsp; template&lt;class ComponentT&gt;<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;ComponentT&gt;&gt; GetComponents()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // equal_range 関数を使って、指定したキーの最初と終端の位置を示すイテレータを std::pair&lt;&gt; で取得します。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto range = components.equal_range(hashID); //https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;ComponentT&gt;&gt; returnList; // "ComponentT" 例."CircleCollider"など をキーとするコンポーネント一覧<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto ite = range.first; ite != range.second; ++ite)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; returnList.emplace_back(ite-&gt;second); // 辞書で見つかったコンポーネントを返すリストに追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return returnList;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンポーネントを追加する .AddComponent&lt;BoxCollider&gt;(...)で追加できる<br>
      &nbsp;&nbsp;&nbsp; template&lt;class ComponentT, typename ...ArgsT&gt;<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;ComponentT&gt; AddComponent(ArgsT&amp;&amp;...args)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // shared_from_this()を必ず渡してセットで初期化して、オーナーがリンク切れのコンポーネントができないように気をつける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ComponentT&gt; newComponent = std::make_shared&lt;ComponentT&gt;(shared_from_this_as&lt;GameObject&gt;(), std::forward&lt;ArgsT&gt;(args)<b>...</b>);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // std::unrodered_multimap&lt;&gt; と同型の値を取る std::pair&lt;&gt; を作って insert 関数でcomponents辞書に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; components.insert(std::pair&lt;size_t, std::shared_ptr&lt;ComponentT&gt;&gt;(hashID, newComponent));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return newComponent;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンポーネントを削除する<br>
      &nbsp;&nbsp;&nbsp; template&lt;typename ComponentT&gt;<br>
      &nbsp;&nbsp;&nbsp; bool RemoveComponent(std::shared_ptr&lt;ComponentT&gt; removeComponent)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // equal_range 関数を使って、指定したキーの最初と終端の位置を示すイテレータを std::pair&lt;&gt; で取得します。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto range = components.equal_range(hashID); //https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[イテレート中に探しながら消す] https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/erase.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto ite = range.first; ite != range.second;)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ite-&gt;second == removeComponent)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; components.erase(ite); // 削除された要素の次を指すイテレータが返される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // 見つかって消せた場合は true<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++ite; // 次の要素へイテレータを進める<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 見つからずに消せなかった場合は false<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() = 0; // 純粋仮想関数 = 0 にすると【絶対 Update()関数はoverrideしなきゃいけない義務を付与できる 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() = 0; // 純粋仮想関数 = 0 にすると【絶対 Draw()関数はoverrideしなきゃいけない義務を継承先クラスに付与 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 衝突開始したときの関数 overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
        &nbsp;&nbsp;&nbsp; virtual void OnCollisionEnter(std::shared_ptr&lt;Collision&gt; pCollision)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして衝突開始したときの処理などをオブジェクトの種類ごとに実装する<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 衝突したときの関数 overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
        &nbsp;&nbsp;&nbsp; virtual void OnCollision(std::shared_ptr&lt;Collision&gt; pCollision)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
        &nbsp;&nbsp;&nbsp; };<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 衝突終了したときの関数 overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
        &nbsp;&nbsp;&nbsp; virtual void OnCollisionExit(std::shared_ptr&lt;Collision&gt; pCollision)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして衝突終了したときの処理などをオブジェクトの種類ごとに実装する<br>
        &nbsp;&nbsp;&nbsp; };</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // ジャンプ開始した直後に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnStartJump()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideしてジャンプした瞬間に音を鳴らしたりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 空中でジャンプの上昇中に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnJumping()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中でジャンプの上昇中にエフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 空中で落ちている最中に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnFalling()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中で落ちている最中に音を鳴らしたり、エフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>World.hを変更</code>して、makeGridで世界にグリッド分割情報を持たせられるようにしましょう(<b>デフォルト設定で128×128×128の大きさのグリッドにする</b>)。</p>
    <p class="source">#ifndef WORLD_H_<br>
      #define WORLD_H_<br>
      <br>
      #include &lt;list&gt;<br>
      #include &lt;memory&gt;<br>
      #include &lt;unordered_map&gt;<br>
      #include &lt;functional&gt; // std::functionのラムダ式 で 関数を Draw関数の引数にして、カメラすべてに対して描画処理を発動させる <br>
      <br>
      #include "MyHash.h" // ワールドのタグをhash32型で管理する<br>
      <br>
      <br>
      // [前方宣言] 宣言だけして、#includeはしてないので、ポインタだけはこのファイル内でつかえる<br>
      // #includeはしてないので、hpなどの変数には#include "～.h"しないとアクセスできないので循環インクルード防止のため.cppでインクルードしてください<br>
      class GameScene;<br>
      class Player;<br>
      class PlayerBullet;<br>
      class Enemy;<br>
      class Camera;<br>
      <em>class Grid;</em><br>
      <br>
      // プレイヤや敵や弾などの共有ポインタを管理し、EraseRemoveIfで消して参照カウンタが0になったらそれらを消滅させるクラス(C#のガベージコレクタの代わり)<br>
      class World<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline World(GameScene* pScene, const std::string&amp; worldTag = "") : m_pScene{ pScene }, tag{ worldTag } {}<br>
      &nbsp;&nbsp;&nbsp; inline ~World() {}<br>
      protected: // public:にすると他で外部で後からタグやシーンを書き換えられると辞書での管理などの前提がおかしくなるのでprotected:する<br>
      &nbsp;&nbsp;&nbsp; hash32 tag{ "" }; // ワールド名のタグ<br>
      &nbsp;&nbsp;&nbsp; GameScene* m_pScene{ nullptr }; // ワールドを所有するシーン<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; hash32 Tag() const { return tag; }<br>
      &nbsp;&nbsp;&nbsp; GameScene* scene() { return m_pScene; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //std::unordered_map&lt;hash32, std::shared_ptr&lt;Player&gt;&gt; players; // プレイヤのタグ辞書<br>
      &nbsp;&nbsp;&nbsp; // ワールドを所有するシーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp; void AddPlayer(const std::string&amp; playerTag, std::shared_ptr&lt;Player&gt; pPlayer);<br>
      &nbsp;&nbsp;&nbsp; // ワールドにいるプレイヤを得る<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;Player&gt;&gt; GetPlayers();<br>
      <br>
      <em>protected:<br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Grid&gt; m_pGrid{ nullptr }; // 当たり判定を高速にするためグリッドで空間分割<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; Grid* grid() { return m_pGrid.get(); } // グリッドを返す<br>
        &nbsp;&nbsp;&nbsp; Grid* makeGrid(int cellWidth = <b>128</b>, int cellHeight = <b>128</b>, int cellDepth = <b>128</b>); // グリッドを生成する</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;Player&gt;&gt; players; // プレイヤのタグ辞書<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト <br>
      <br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 削除処理を共通テンプレート関数にする<br>
      &nbsp;&nbsp;&nbsp; // [共通テンプレート関数]https://programming-place.net/ppp/contents/cpp/language/009.html#function_template<br>
      &nbsp;&nbsp;&nbsp; template &lt;typename TypeT, class T_if&gt;<br>
      &nbsp;&nbsp;&nbsp; void EraseRemoveIf(std::list&lt;TypeT&gt;&amp; v, T_if if_condition)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 特定のタイプT↑&nbsp; ↑配列v&nbsp;&nbsp; ↑条件式if_condition<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; v.erase(<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::remove_if(v.begin(), v.end(), if_condition),<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; v.end() //&nbsp; ↓remove_ifの位置<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; );//例.[生][生][死][死][死]← v.end()の位置<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;Camera&gt;&gt; cameras; // このワールドに存在するカメラの辞書&lt;カメラにつけたタグ, カメラの共有ポインタ&gt;<br>
      &nbsp;&nbsp;&nbsp; // 指定されたタグのカメラへの共有ポインタを得る　カメラ辞書に存在しないタグでアクセスしたときにunordered_mapの特性で勝手に意図しないカメラができるのを防ぐ関数<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Camera&gt; camera(const std::string&amp; cameraTag) { auto itr = cameras.find(cameraTag); return (itr != end(cameras)) ? itr-&gt;second : nullptr; }<br>
      &nbsp;&nbsp;&nbsp; // このワールドに存在するカメラすべてに対して drawFuncで描きたい処理を渡して 全カメラのスクリーンに対して描画処理を走らせる<br>
      &nbsp;&nbsp;&nbsp; void Draw(std::function&lt;void()&gt; drawFunc) noexcept;<br>
      &nbsp;&nbsp;&nbsp; // カメラにタグをつけてワールドに追加 カメラにもワールドへのポインタリンクを張る<br>
      &nbsp;&nbsp;&nbsp; inline bool AddCamera(const std::string&amp; cameraTag, std::shared_ptr&lt;Camera&gt; pCamera);<br>
      &nbsp;&nbsp;&nbsp; // 指定したタグのカメラをこのワールドから削除する カメラ側の worldへのリンクのポインタも nullptr にする<br>
      &nbsp;&nbsp;&nbsp; inline bool EraseCamera(const std::string&amp; cameraTag);<br>
      &nbsp;&nbsp;&nbsp; // カメラを nowWorld から nextWorld に移動させる<br>
      &nbsp;&nbsp;&nbsp; static bool MoveCamera(const std::string&amp; cameraTag, World* nowWorld, World* nextWorld);<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>World.cppを変更</code>して、<b>ワールドごとに</b>makeGrid関数でGridをstd::make_sharedで生成する処理を記述しましょう。</p>
    <p class="source">#include "World.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Camera.h"<br>
      #include "Screen.h"<br>
      <br>
      #include "GameScene.h"<br>
      <br>
      <em>#include "GridObject.h" // Gridをmake_sharedで生成するため<br>
        <br>
        Grid* World::makeGrid(int cellWidth, int cellHeight, int cellDepth)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (this-&gt;m_pGrid == nullptr) // グリッドが未生成の場合は生成<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;m_pGrid = std::make_shared&lt;Grid&gt;(cellWidth, cellHeight, cellDepth);<br>
        &nbsp;&nbsp;&nbsp; return this-&gt;m_pGrid.get();<br>
        }</em><br>
      <br>
      void World::AddPlayer(const std::string&amp; playerTag, std::shared_ptr&lt;Player&gt; pPlayer)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (m_pScene != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_pScene-&gt;players.emplace(playerTag, pPlayer); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // このワールドにいるプレイヤを得る<br>
      std::vector&lt;std::weak_ptr&lt;Player&gt;&gt; World::GetPlayers()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;Player&gt;&gt; players;<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; pPlayer : players)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; players.emplace_back(pPlayer);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; return players;<br>
      }<br>
      <br>
      // カメラにタグをつけてワールドに追加 カメラにもワールドへの生ポインタリンクを渡す<br>
      bool World::AddCamera(const std::string&amp; cameraTag, std::shared_ptr&lt;Camera&gt; pCamera)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (pCamera == nullptr) return false;<br>
      &nbsp;&nbsp;&nbsp; if (cameras.count(cameraTag) &gt; 0) return false; // すでに同じタグのカメラがワールドにあったら false<br>
      &nbsp;&nbsp;&nbsp; if (pCamera-&gt;world() != nullptr) pCamera-&gt;world()-&gt;EraseCamera(cameraTag); // すでにカメラが別ワールドに配置されていたら別ワールドから削除<br>
      &nbsp;&nbsp;&nbsp; cameras.emplace(cameraTag, pCamera); // ワールドにカメラを追加する<br>
      &nbsp;&nbsp;&nbsp; pCamera-&gt;world(this); // カメラにもワールドへのポインタリンクを張る<b>(カメラ側に渡すのは共有ポインタではない生ポインタだから共有デッドロックにはならない)</b><br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      // 指定したタグのカメラをこのワールドから削除する カメラ側の worldへのリンクのポインタも nullptr にする<br>
      bool World::EraseCamera(const std::string&amp; cameraTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; auto itr = cameras.find(cameraTag); // 指定したタグのカメラを探す<br>
      &nbsp;&nbsp;&nbsp; if (itr == end(cameras)) return false; // 指定したタグのカメラがワールドにない<br>
      &nbsp;&nbsp;&nbsp; auto pCamera = itr-&gt;second;<br>
      &nbsp;&nbsp;&nbsp; pCamera-&gt;world(nullptr); // カメラ側の worldへのリンクのポインタも nullptrに<br>
      &nbsp;&nbsp;&nbsp; cameras.erase(cameraTag); // カメラを辞書から削除<br>
      <br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      // カメラを nowWorld から nextWorld に移動させる<br>
      bool World::MoveCamera(const std::string&amp; cameraTag, World* nowWorld, World* nextWorld)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (nowWorld == nullptr) return false;<br>
      &nbsp;&nbsp;&nbsp; auto itr = nowWorld-&gt;cameras.find(cameraTag); // タグでカメラを探す<br>
      &nbsp;&nbsp;&nbsp; if (itr == end(nowWorld-&gt;cameras)) return false; // タグに関連づいたカメラがなかった<br>
      &nbsp;&nbsp;&nbsp; auto targetCamera = itr-&gt;second; // カメラの共有ポインタをキープ(次の行でeraseしてもカメラの共有カウンタは0にはならずこのリンクのおかげでカメラはメモリに残存)<br>
      &nbsp;&nbsp;&nbsp; targetCamera-&gt;world(nullptr); // カメラ側の worldへのリンクのポインタを一旦 nullptrに<br>
      &nbsp;&nbsp;&nbsp; nowWorld-&gt;cameras.erase(cameraTag); // nowWorld からは カメラを消す<br>
      &nbsp;&nbsp;&nbsp; if (nextWorld == nullptr) return false;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return nextWorld-&gt;AddCamera(cameraTag, targetCamera); // 次のワールドにカメラを追加する<br>
      }<br>
      <br>
      // このワールドに存在するカメラすべてに対して funcで描きたい処理を渡して 全カメラのスクリーンに対して描画処理を走らせる<br>
      void World::Draw(std::function&lt;void()&gt; drawFunc) noexcept<br>
      {<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : cameras)&nbsp;&nbsp;&nbsp; // このワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR_D beforeCamPos; // 設定変更前のカメラのパラメータを一旦、保管<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; double beforeVRot, beforeHRot, beforeTRot, beforeNear, beforeFar, beforeFov;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Camera::GetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;beforeFov, &amp;beforeNear, &amp;beforeFar);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //camera-&gt;screenID<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngle(camera-&gt;pos, camera-&gt;rot.V, camera-&gt;rot.H, camera-&gt;rot.T); // 各カメラの位置、回転を設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Screen::Start(camera-&gt;screenHandle, true, camera-&gt;fovAngle); // カメラに関連付けられたスクリーンIDを描画先にする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; drawFunc(); // 渡された描画処理を実行<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Screen::End(true); // 描画先を元に戻す<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラの設定をもとに戻しておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Camera::SetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;beforeFov, &amp;beforeNear, &amp;beforeFar);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    <p><code>Player.hを変更</code>して、球体のコライダとグリッドのコンポーネントと押し返す力の設定を追加しましょう。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Resource.h"<br>
      #include "GameObject.h"<br>
      #include "PhysicsComponent.h"<br>
      <em>#include "GridCollidersComponent.h"<br>
        #include "Collider.h"</em><br>
      <br>
      class World; // 前方宣言<br>
      class Camera; // 前方宣言<br>
      <br>
      class Player : public GameObject<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるので、Create関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; Player(World* world, Pad pad, Vector3 position, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pad{ pad }, GameObject(world, position, rotation, velocity, force)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "Player"; // タグは個別の"プレイヤ1"などに使い、タイプはtypeTagで判別する形にしてタイプのジャンルを区別<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>this-&gt;baseTag = "Player";<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;pushPower = 5.0f; // コライダで衝突したときに押し返す力</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~Player() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; Pad pad; // 操作するコントローラー番号<br>
      &nbsp;&nbsp;&nbsp; hash32 worldTag{ "" }; // 現在いるワールドのタグ<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeedMax = 6; // 移動速度Max値<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeed = 0;//移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; float moveAngle = 0; // X軸→方向から何度か<br>
      &nbsp;&nbsp;&nbsp; float deltaAngle = 0; // プレイヤの動く角度の変化率、ハンドルを切ったらだんだんもとに戻る<br>
      &nbsp;&nbsp;&nbsp; int animCount = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image; // プレイヤの板ポリゴンで描くタイル分割画像への共有リンク<br>
      <br>
      &nbsp;&nbsp;&nbsp; Camera* camera{ nullptr }; // プレイヤを追随するカメラ<br>
      &nbsp;&nbsp;&nbsp; void SetCamera(Camera* pCamera) { camera = pCamera; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // overrideして物理落下コンポーネントからの重力値を返す<br>
      &nbsp;&nbsp;&nbsp; virtual float gravity() override { auto pGravityPhysics = gravityPhysics.lock(); return (pGravityPhysics != nullptr) ? pGravityPhysics-&gt;gravity() : 0.0f; }<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;JumpComponent&gt; jumpPhysics; // ジャンプの物理処理コンポーネント<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;GravityComponent&gt; gravityPhysics; // 落下の重力の物理処理コンポーネント<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>std::weak_ptr&lt;GridCollidersComponent&gt; gridCollision; // グリッドマス目分割コンポーネント<br>
        &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;SphereCollider&gt; sphereCollider; // 球コライダのコンポーネント</em><br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyJumpSpeed{ 13, 14, 15, 4 }; // ジャンプ開始の初期速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyForceJump{ 0.5f, 0.4f, 0.3f, 0.1f }; // ジャンプ上昇にかかる力の初期値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyGravity{ 0.8f,0.8f,0.8f,0.8f }; // 重力の設定値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyDownSpeedMax{ 16, 16, 16, 8 }; // 降下スピードのリミット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // AddComponent内部でshared_from_this()を必ず渡してセットで初期化して、オーナーがリンク切れのコンポーネントができないように気をつける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jumpPhysics = AddComponent&lt;JumpComponent&gt;(vyJumpSpeed, vyForceJump);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gravityPhysics = AddComponent&lt;GravityComponent&gt;(vyGravity, vyDownSpeedMax);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 半径16(直径32)の球体コライダ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sphereCollider = AddComponent&lt;SphereCollider&gt;(Vector3(0, 0, 0), 16);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision = AddComponent&lt;GridCollidersComponent&gt;("Player"); //とりあえずわかりやすいように"Player"というタグをつけておく(別に何でもいい)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision.lock()-&gt;LinkCollider(sphereCollider); // コライダをリンクする</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理<br>
      &nbsp;&nbsp;&nbsp; virtual void HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ジャンプ開始した直後に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnStartJump() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// コライダの衝突した際に呼ばれるコールバック関数<br>
        &nbsp;&nbsp;&nbsp; virtual void OnCollision(std::shared_ptr&lt;Collision&gt; pCollision) override;</em><br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Player.cppを変更</code>して、OnCollision関数のpCollisionから得た衝突した法線方向を使ってUpdate関数で力を加えましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      void Player::HandleInput()<br>
      {<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_LEFT) <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_A)) )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = - MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += 1; //ハンドルを左に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_RIGHT)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_D)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle -= 1; //ハンドルを右に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_UP)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_W)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = - MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += 0.6f; //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; MoveSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = MoveSpeedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(pad, PAD_INPUT_DOWN)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_S)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed -= 0.6f; //ブレーキを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.9f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = -0.9f;//ちょっとだけバックできるように<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pad == Pad::Key || pad == Pad::One) // コントローラ1またはキーボード操作のプレイヤのときだけ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGUP)) // キーボードのPageUp ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = 2.0f; // テスト用に空中の上方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGDN)) // キーボードのPageDown ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -2.0f; // テスト用に空中の下方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      // ジャンプ開始した直後に呼ばれる関数<br>
      void Player::OnStartJump()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; this-&gt;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      }<br>
      <br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; <em>vxForce *= 0.9f; // かかっている力の減衰率<br>
        &nbsp;&nbsp;&nbsp; vzForce *= 0.9f; // かかっている力の減衰率</em><br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pJumpPhysics = jumpPhysics.lock();<br>
      &nbsp;&nbsp;&nbsp; if (pJumpPhysics != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pad, PAD_INPUT_A) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;JumpStart(); // ジャンプのスタート処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (vy &gt; 0 &amp;&amp; Input::GetButtonUp(pad, PAD_INPUT_A) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonUp(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;JumpCancel(); // ジャンプのキャンセル処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;Update(); // ジャンプのコンポーネントを更新する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; auto pGravityPhysics = gravityPhysics.lock();<br>
      &nbsp;&nbsp;&nbsp; if (pGravityPhysics != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGravityPhysics-&gt;Update(); // 重力落下のコンポーネントを更新する<br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; rotation.SetRotation(VGet(0, (180 - moveAngle) * MyMath::Deg2Rad, 0)); // 前向きの3Dモデルなら180度回転させて奥方向の向きに設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>vx += vxForce; // 力をかけて速度に加算する<br>
        &nbsp;&nbsp;&nbsp; vz += vzForce; // 力をかけて速度に加算する</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp; x += vx;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp; y += vy;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp; z += vz;<br>
      <br>
      &nbsp;&nbsp;&nbsp; vy += vyForce; // 勢い(力・フォースを加算<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (y &lt;= 0.0f) // 0.0fを地面として 0.0f以下になったら地面に着地したと判定する<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f; // 地面に沿わせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -0.01f; // 下方向への速度をほぼ 0 にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGround = true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>if (auto pGridCollision = gridCollision.lock()) // lock()してnullptrじゃなければ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridCollision-&gt;Update(); // 所属するマス目セルを更新する</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; // moveAngleは2D画像のX方向右を0度とするから、-90度回すと画像を正面に捉える位置にカメラを置ける<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      <em>void Player::OnCollision(std::shared_ptr&lt;Collision&gt; pCollision)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (isDead) return; // すでにisDeadなら return<br>
        &nbsp;&nbsp;&nbsp; auto otherCollider = pCollision-&gt;contacts[0].otherCollider.lock(); // コライダの弱共有ポインタをロック<br>
        &nbsp;&nbsp;&nbsp; if (otherCollider == nullptr) return; // すでにコライダが消去済だった<br>
        &nbsp;&nbsp;&nbsp; auto other = otherCollider-&gt;owner();<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (other-&gt;isDead) return; // other側がisDeadだったら処理をスルー<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (other-&gt;baseTag == "Enemy" || other-&gt;baseTag == "Player")<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto norm = pCollision-&gt;contacts[0].normal * other-&gt;<b>pushPower</b>; // <b>pushPowerの力でotherに押し返される</b><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; force += -norm; // <b>衝突法線方向の力</b>を加える<br>
        &nbsp;&nbsp;&nbsp; }<br>
        }</em><br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int animIndex = animCount / 20; // キャラのパラパラアニメの画像番号(最大3)<br>
      &nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp; if (abs_vx &gt; 1.00f || abs_vz &gt; 1.00f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6; // キャラが地面のXとZ方向に少しでもスピードがあったらアニメを走らせる<br>
      &nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // プレイヤのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 9; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // カメラ向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 奥向きの画像<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *image, imgIndex + animIndex, TRUE);<br>
      <br>
      <em>#ifdef _DEBUG // デバッグのときだけ_DEBUGが定義され描かれる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pSphereCollider = sphereCollider.lock()) pSphereCollider-&gt;Draw(); // コライダを描く<br>
        #endif</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    <p><code>GameScene.cppを変更</code>して、プレイヤのコライダと所属するグリッドをデバッグ表示する処理を実装しましょう。<br>
    </p>
    <p class="source">#include "GameScene.h"<br>
      <br>
      #include "Player.h"<br>
      <br>
      GameSceneSetting GameScene::settings{ "Map/GameSceneSetting.csv" }; // ゲームシーンの設定情報<br>
      <br>
      // 指定したゲームシーンのタグに関連づいたファイル名に対応したワールドを初期化する<br>
      bool GameScene::LoadWorlds(const std::string&amp; gameSceneTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (settings.info.count(gameSceneTag) == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto&amp; info = settings[gameSceneTag];<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; tag_mapPath : info)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateWorld(tag_mapPath.second.tag); // ワールドをタグをつけて生成<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      void GameScene::ChangeWorld(const std::string&amp; worldTag, std::shared_ptr&lt;Player&gt; pPlayer)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (pPlayer == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp; if (worlds.count(worldTag) == 0) return; // 存在しないタグだった<br>
      <br>
      &nbsp;&nbsp;&nbsp; pPlayer-&gt;world(worlds[worldTag].get()); // ワールドへのリンクをすげ替える<br>
      }<br>
      <br>
      <br>
      void GameScene::Initialize()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Ｚバッファを有効にする [Zの深度]<br>
      &nbsp;&nbsp;&nbsp; //[参考]https://docs.google.com/presentation/d/1Z23t1yAS7uzPDVakgW_M02p20qt9DeTs4ku4IiMDLco/edit?usp=sharing<br>
      &nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する<br>
      &nbsp;&nbsp;&nbsp; // ( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを2つ生成 画面の全体の縦方向サイズの Height / 2 にして、上下分割で配置できるようにする<br>
      &nbsp;&nbsp;&nbsp; screenHandle0 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      &nbsp;&nbsp;&nbsp; screenHandle1 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath, 8, 8, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath1, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath2, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの生成<br>
      &nbsp;&nbsp;&nbsp; if (pWorld != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pWorld-&gt;AddCamera("カメラ1", Camera::defaultCamera); // カメラ1というタグをデフォルトカメラにつけてワールドにデフォルトカメラを配置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ1", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera1 = pWorld-&gt;camera("カメラ1"); // カメラ1 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera1-&gt;SetScreenHandle(screenHandle0); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer1 = Object::Create&lt;Player&gt;(nullptr, pWorld, Pad::Key, Vector3(90 + 256, 32, 95 + 256));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ1", pPlayer1); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath1]);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;camera = pCamera1.get(); // カメラをプレイヤにリンクする<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ2", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera2 = pWorld-&gt;camera("カメラ2"); // プレイヤ2 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera2-&gt;SetScreenHandle(screenHandle1); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer2 = Object::Create&lt;Player&gt;(nullptr, pWorld, Pad::Two, Vector3(190, 32, 195));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ2", pPlayer2); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath2]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;camera = pCamera2.get(); // カメラをプレイヤにリンクする<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      <br>
      void GameScene::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle0); // 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle1); // 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; player : players)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player.second-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// グリッドを更新して隣接するグリッドに含まれる敵や弾の当たり判定を行う<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; world : worlds)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (world.second-&gt;grid() != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; cell : world.second-&gt;grid()-&gt;cellData)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pGridObject = cell.second;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (pGridObject != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // while文で数珠つなぎのm_pNextを次々とたどって最後にたどり着くと次がなくてnullptrになる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridObject-&gt;checkCell();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridObject = pGridObject-&gt;m_pNext; // リンクリスト構造を次々とたどる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      }<br>
      <br>
      void GameScene::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; player : players)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player.second-&gt;Draw(); // プレイヤの描画【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>auto world = player.second-&gt;world(); // プレイヤのいるワールド</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // プレイヤのいるワールドのカメラのみを描けば、プレイヤのいないワールドは描かずに済む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 複数のカメラを 範囲 for文 で回す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; camera : player.second-&gt;world()-&gt;cameras)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ラムダ式[&amp;](){ ～ }で{}の外側の変数すべてを &amp; キャプチャで&amp;参照として「Draw関数の内側へ引き連れて」処理できる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera.second-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw関数() の 外側にある変数 mapChipPath も[&amp;]効果で { } の内側で問題なくアクセスできている↓<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 70, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 8);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (camera.first == "カメラ1")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらがプレイヤ1", GetColor(255, 0, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (camera.first == "カメラ2")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらはプレイヤ2", GetColor(0, 255, 0));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <em>#ifdef _DEBUG&nbsp; // デバッグのときだけ_DEBUGが定義され描画される<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (world-&gt;grid() != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; cell : world-&gt;grid()-&gt;cellData)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cell.second-&gt;Draw(); // グリッドの描画<br>
        #endif</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーン0の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, 0, screenHandle0, FALSE);<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, 0, Screen::Width, Screen::Height / 2, GetColor(255, 0, 0));<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーン1の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, Screen::Height / 2, screenHandle1, FALSE);<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, Screen::Height / 2, Screen::Width, Screen::Height, GetColor(0, 255, 0));<br>
      <br>
      }<br>
    </p>
    <br>
    いかがでしょう？プレイヤ1とプレイヤ2の球体コライダが表示され、プレイヤ1を操作してプレイヤ2にぶつかると跳ね返りましたでしょうか？<br>
    水色の<b>グリッドは128×128×128</b>で大きめにとってあります。<br>
    なぜなら、グリッドを2つ飛び越えるような大きなコライダだと、<br>
    今のまわりの隣接するグリッドを探す形ではグリッドを飛び越える大きさになると機能しなくなる弱点があるからです。<br>
    具体的に、<b>256の半径</b>のコライダが[●]にいたら[ <b>(</b> ][ &nbsp; ][●][&nbsp;&nbsp; ][ <b>)</b> ] ←コライダの半径 ( ● ) の <b>)</b> は2つ先のグリッドに及ぶので、<br>
    ほんとは2つ先のグリッドにいるキャラのコライダとも当たり判定しなければなりませんが、<br>
    今のグリッドの仕組みでは<b>隣1つまでのグリッドしか調べません</b>。<br>
    なので、ボスなど大きいキャラでも、<b>128+α ぐらいのサイズが今のグリッドの仕組みが正しく機能する限界</b>となります。<br>
    8分木などを使うと、このような制約はなくなるので、<b>8分木のほうが上位互換</b>ではあります。<br>
    <br>
    大変でしたが、これで一通りのゲームエンジンとしての基本機能がそろってきました。<br>
    コライダは最小限、球体とカプセルのみ準備しました。球体の当たり判定はカプセルの芯を点として同じ計算を流用しています。<br>
    これで球とカプセルのみではありますが、ある程度のゲームを作れる土台は整ってきたのではないかと思います。<br>
    <br>
    物理が苦手な人は「位置(position)」「速度(velocity)」「力(force)」の関係について確認が必要です。<br>
    <b>毎秒5メートル進む人</b>がいるとします。<br>
    <b>1秒ごとに 位置position += 5</b>メートル。これはわかりやすいですね。<br>
    では、力(force)とは何なのか。<br>
    自転車を全力でこいで力を入れると、毎秒スピード速度が上がっていきます。<br>
    <b>毎秒 5の力 で自転車をこぐ人</b>がいるとします。<br>
    <b>1秒ごとに 速度velocity += 5</b>。実は<b>「力」とは速度に毎秒(毎フレーム)いくつ足し算されるか</b>なのです。<br>
    物理の色んな公式がわからなくても、これなら少しわかるぞ。と思ってもらえばラッキーです。<br>
    何のことはない、<b>ブランコをこいでる人がいて、もう一人が後ろから来るたびに押すと段々ブランコが高くまで上がる</b>アレと同じです。<br>
    <b>ブランコを押す瞬間に += 5してるから、速度が大きくなって、当然ブランコも上に上がるようになる</b>わけです。<br>
    <b>Unityの AddForce の「force」とは実はこの「力」</b>なのです。<br>
    <br>
    <br>
    <br>
    <br>
    以上が、中二学派(厨二学派)向けの物理学です。<br>
    <br>
    中二学派(厨二学派)の物理学では不安だという方に向けて、<br>
    念のため<a href="https://ja.wikipedia.org/wiki/%E3%83%8B%E3%83%A5%E3%83%BC%E3%83%88%E3%83%B3%E5%8A%9B%E5%AD%A6">ニュートン学派</a>(欧米か)のほうの式も以下に解説しておきましょう。<br>
    <br>
    <b>運動の第2法則 : F = m × v × Δt [つまり Force(力) = m(重さ) × velocitiy(速度) × Δt(時間の変化) ]</b><br>
    <br>
    先ほどの中二学派の式と<b>対応関係を取るために、Δt(時間の変化) = 1(フレーム) に固定</b>しましょう。<br>
    そうすると、 <b>ΔF(力の変化) = m(重さ) × Δv(速度の変化)</b> になりますよね。 今度は、<b>両辺を m(重さ)で割りましょう</b>。<br>
    m(重さ)で割ると <b>ΔF(力の変化) / m(重さ) = Δv(速度の変化)</b>になりました。中二学派と<b>合わせるために右辺と左辺をひっくり返しましょう</b>。<br>
    右辺⇔左辺すると <b>Δv(速度の変化) = ΔF(力の変化) / m(重さ)</b>になりました。これであとは <b>m(重さ) = 1に固定</b>してみましょう。<br>
    m(重さ) = 1なら <b>Δv(速度の変化) = ΔF(力の変化)</b>になりましたね。これで += 5 で中二学派の式と同じにできます。<br>
    <b>ΔF(力の変化) = 5なら、Δv(速度の変化) += 5</b> になりました。<br>
    これで<b>「中二のアイザック・ニュートン」(ニュータイプ)が誕生</b>しましたね。この物理の式なら<a href="https://www.pixiv.net/tags/%E9%80%A3%E9%82%A6%E3%81%AE%E3%83%A2%E3%83%93%E3%83%AB%E3%82%B9%E3%83%BC%E3%83%84%E3%81%AF%E5%8C%96%E3%81%91%E7%89%A9%E3%81%8B/illustrations">ガンダムのモビルスーツ</a>も動かせそうです。<br>
    <br>
    じゃあ、m(重さ) = 1に固定しなかった場合、つまり、マリオカートのドンキーコングやクッパみたいに重いキャラはどうなるのでしょうか？<br>
    <b>m(重さ) = 2</b> にしたとき、<br>
    <b>Δv(速度の変化) = ΔF(力の変化) / m(重さ) なので当然、m(重さ) = 2 なら</b><br>
    <b>Δv(速度の変化) += 5 / 2</b>になりますね。<br>
    つまり、5 / 2 = 2.5 ずつしか速度が加速しないので、当然あんまりふっとばないようになりますね。<br>
    ニュートン風に<b>まじめに計算したい人は、変数 m(質量) を定義して、v(速度) += 5 / m(重さ) で計算すればいい</b>ですし、<br>
    中二風に<b>シンプルに 計算したい人は、v(速度) += 2 とかにして F = 5 を 2 に変えてキャラをふっとばないようにしてもいい</b>わけです。<br>
    <br>
    <br>
    <br>
    <br>
    さらについでに、ニュートンの上位互換の<a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%83%AA%E3%83%BC%E3%83%89%E3%83%AA%E3%83%92%E3%83%BB%E3%83%8F%E3%83%BC%E3%82%BC%E3%83%8E%E3%83%BC%E3%83%AB">アインシュタインっぽいユダヤ物理学の式の解説</a>にも踏み込んでおきましょう。<br>
    時は19世紀、パリ万国博覧会に渋沢栄一と徳川昭武公が送られ、<a href="https://www.youtube.com/watch?v=aUVafZzLCHY">ブルーウォーターとピカチュウをめぐって抗争</a>が繰り広げられていた頃、<br>
    「<a href="https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%A4%E3%82%B1%E3%83%AB%E3%82%BD%E3%83%B3%E3%83%BB%E3%83%A2%E3%83%BC%E3%83%AA%E3%83%BC%E3%81%AE%E5%AE%9F%E9%A8%93">光は粒なのか？波なのか？</a>」という「水は個体なのか？液体なのか？」「<a

      href="https://ja.wikipedia.org/wiki/%E7%8C%AB%E3%81%AF%E6%B6%B2%E4%BD%93#:%7E:text=%E7%8C%AB%E3%81%8C%E5%9B%BA%E4%BD%93%E3%81%A7%E3%81%82%E3%82%8B,%E9%AB%98%E3%81%84%E3%81%93%E3%81%A8%E3%82%92%E7%99%BA%E8%A6%8B%E3%81%97%E3%81%9F%E3%80%82">ネコは液体なのか？</a>」という人類にとって重要な実験が行われ、<br>
    <b>宇宙空間全体を満たす「エーテルの風」など吹いていない</b>ことが証明されてしまったため、<br>
    <b>超高速で加速した状態で悟空がレーザーを宇宙空間に放った場合</b>でも、<br>
    そのレーザー(光)が加速することはなく「<b>光は完全固定速度</b>」(定額料金制)であることを認めざる負えなくなってしまったため、<br>
    物理学者は従来の法則とつじつまを合わせるためには「光の代わりに<a href="https://ja.wikipedia.org/wiki/%E9%95%B7%E3%81%95%E3%81%AE%E5%8F%8E%E7%B8%AE">物体のほうが収縮してないとつじつまがあわん</a>」状態に追い込まれていた。<br>
    <br>
    <b>ローレンツ因子の式: L = L0 × √(1 - vの2乗 / cの2乗)</b> ↓<br>
    <b>ローレンツ因子の式: L(縮んだ長さ) = L0(縮む前の長さ) × √(1 - 悟空の速度vの2乗 / 光速cの2乗)</b> が苦肉の式として爆誕してしまった。<br>
    <br>
    この式に沿ってしまうと、悟空が地球を1秒間に7.5周する光の速度に近づいたときに、<br>
    地上から見た悟空は進行方向の長さLがほぼ0になってバグった長さになるという式である。<br>
    <b>光の1/2 つまり0.5倍の速度の場合</b>は√(1 - 0.5×0.5 / 1×1) = √(1 - 0.25) = √( 0.75 ) = √( 75 / 100 ) = √( 3×5×5 / 100 ) = 5√3 / 10 = √3 / 2<br>
    つまり、<b>L(縮んだ長さ) = L0 × √3 / 2倍 、√3 / 2 = 1.73 / 2 = 0.86倍に縮んでしまうという式</b>になるということです。 われわれが<b>普段使っている<a

        href="https://global.canon/ja/technology/kids/mystery/m_01_03.html#:%7E:text=%E7%A7%92%E9%80%9F29%E4%B8%879792.458%E3%82%AD%E3%83%AD%E3%83%A1%E3%83%BC%E3%83%88%E3%83%AB%E3%81%AF%E3%80%81%E5%9C%B0%E7%90%83%E3%82%921%E7%A7%92%E9%96%93,7.5%E5%91%A8%E3%81%99%E3%82%8B%E9%80%9F%E3%81%95%E3%80%82">メートル自体、光の速度を基準に逆算して「1メートル＝光が真空中を2億9979万2458分の1秒の間に進む距離」</a>決められています</b>。<br>
    ああ、仕方ない、じゃあおとなしく縮むしかないか..とあきらめムードのなか、<br>
    しかし、<b><a href="https://ja.wikipedia.org/wiki/%E3%83%AD%E3%83%BC%E3%83%AC%E3%83%B3%E3%83%84%E5%A4%89%E6%8F%9B">ローレンツ収縮は実験結果と矛盾</a>してしまった</b>、、つまりわれわれは高速でも縮むことはないらしいのだ。<br>
    では、どうやってつじつまを合わせればいいのか、、<br>
    そこにアインシュタインは<b>「悟空自身はゆがんでいるつもりはない、他人(他の速度の観測者)から見ると縮んで見えてるだけ」</b>という「相対性でつじつまをあわせた」。<br>
    そうなのです、<b>結局「他の人から見て超高速で動いている人は縮んで見えてる」というバグっぽい見え方はホント</b>なのであった。<br>
    そして、中二学派、ニュートン学派の F = m × v × Δt にもつじつま合わせの影響はおよぶ。<br>
    「相対性」ではつじつま合わせとして、<b>他人から見て「長さだけじゃなく、時間をゆがませてつじつま合わせるのもアリ」</b>なのだ。<br>
    じゃあ時間をゆがませず、ニュートンのときのように「時間を1に固定」してしまうとどうなるか？を見てみよう。<br>
    <br>
    <b><a href="https://ja.wikipedia.org/wiki/%E7%89%B9%E6%AE%8A%E7%9B%B8%E5%AF%BE%E6%80%A7%E7%90%86%E8%AB%96#4%E5%85%83%E9%81%8B%E5%8B%95%E9%87%8F%E3%81%AE%E7%A9%BA%E9%96%93%E6%88%90%E5%88%86">相対性理論の力の式</a> : F(力) = m(重さ) × v(速度) / √(1 - vの2乗 / cの2乗)</b><br>
    <br>
    さあ、上の式で<b>「長さも固定=ゆがませない」→速度は長さ、どれだかの距離進むか に関係してるから、<br>
      v(速度)もゆがませられない</b>とすると..<br>
    もう、<b>m(重さ)がいけにえとしてゆがんで √(1 - vの2乗 / cの2乗) で割り算されるしかない</b>ことになってしまう。<br>
    そうすると、<b>光速に近づいている人の「自称の体重はそのままだが、他人から見た見かけ上の体重は∞になっていく」</b>ということなのだろうか。<br>
    あ、ブラックホールって他人から見た見かけ上の体重が∞にみえるんじゃ、、という感覚？。<br>
    太陽は動いてるようには見えず <a href="https://eman-physics.net/relativity/increase.html">v(速度固定) だけど、内部で超重いものが超高速に行ったり来たり震えることで、力→エネルギーを発している</a>という感覚だろうか。<br>
    <br>
    <br>
    「時間をいけにえにして時間がゆがむのを許すとどうなるか」<br>
    t(自分時間)の代わりに、<b>τ(タウ)を絶対時間とすると、(絶対時間とはどんな人からも光速のように、共通の不変の時間)</b><br>
    <b>速度の変化 Δv = Δx(位置の変化) / Δτ(絶対時間)</b> →この式を t(自分時間) にするために、<b>分子と分母でつじつまをあわせる</b>と<br>
    速度の変化 Δv = Δx(位置の変化) / Δt(分母) × <b>Δt(分子) / Δτ(絶対時間)</b> －①<br>
    <br>
    <b>Δt(分子) / Δτ(絶対時間) = 1 / √(1 - vの2乗 / cの2乗)</b> －② ←時間の伸縮の式<br>
    ①と②の式を 速度の変化 Δv = v(速度) ×Δtとして ニュートンの F(力) = m(重さ) × v(速度) × Δtに入れると<br>
    <br>
    相対性理論の力の式 : F(力) = m(重さ) × Δx(位置の変化) / Δt(分母) × <b>Δt(分子) / Δτ(絶対時間)</b><br>
    相対性理論の力の式 : F(力) = m(重さ) × v(速度) × <b>1 / √(1 - vの2乗 / cの2乗)</b> －③<br>
    <br>
    はい、「時間をいけにえ」にしたら、先ほどの「相対性理論の力の式」になりましたね。<br>
    <br>
    そして、有名なE = mc2 [E(エネルギー) = m(重さ) × 光速c の2乗] の式も実は上の式からできあがります。<br>
    <br>
    実は、前提として、<b>E(エネルギー) = F(力) × (速度)</b> です。<br>
    これは、雑巾で床を強く押しながら走ると、エネルギーを消耗するので実感できますよね(車を相撲力士が押して動かすのも同じ)。<br>
    なので、光速c を③の式の両辺に掛け算して速度も v(速度) = c(光速)にします。<br>
    <br>
    <br>
    F(力) <b>× c(光速)</b> = m(重さ) × <b>c</b>(速度) <b>× c(光速)</b> × 1 / √(1 - vの2乗 / cの2乗) －③<br>
    <b>E(エネルギー) = m(重さ) × c(光速)の2乗</b> / √(1 - vの2乗 / cの2乗)<br>
    <br>
    でてきましたね、これで <b>v = 0 にして、分母を√1 = 1にすれば、E = mc2</b>になります。 <br>
    つまり、<b>速度がゼロでも E(エネルギー) = m(体重) × c(光速)の2乗 のエネルギーを皆さんは持っている</b>わけです。<br>
    そう、<b>体重が光速の2乗倍のエネルギーに変えられる</b>という「ライザップの減量の法則」が爆誕したわけですね。<br>
    つまり、<b>脂肪を燃焼して体重を 1kg 減量するためには、光速の2乗倍のエネルギーぶんの努力が必要</b>だということです。<br>
    <br>
    ということは、本来、プレイヤが光るエネルギー弾を撃つためには、MP ではなく 体重を減らさなきゃ物理的にはおかしいわけですね。<br>
    その証拠にサイヤ人の悟空は大量のメシを喰ってますよね。<br>
    一方、幽遊白書は霊力というおかしい概念がでてきますので「幽遊白書の<a href="https://youtu.be/q7UR5BXaBI8?t=550">霊丸(れいがん)</a>は物理的におかしい」という結論になります。<br>
    前提として、幽霊には体重がない、霊の質量 = 0 ゼロなわけですからエネルギーが発生するはずがないのです。<br>
    <br>
    [エネルギーと時間スケールを実感するには]<br>
    植物の人生観からしたら、人間は超高速で動いて見えるわけで、<br>
    ノコギリでギコギコ木を切っている時間は、植物の時間感覚からすると超高速な振動(波の震え)に見えてるわけだし、<br>
    人間の時間のスケールから見ると電子レンジのマイクロ波の波もノコギリのように水分子を押したり引いたりしてお弁当を温めているのは見えない。<br>
    直感的に体重とその内部の超高速な分子レベルの震えの速度とエネルギー(太陽のように一見止まって見えるけど内部で重いものが超高速で震えている)は関係しているのです。<br>
    <br>
    一応、これで基本的な物理の、<br>
    <b>位置(x,y,z)、速度(vx,vy,vz)、力(F:vxForce,vyForce,vzForce)、エネルギー(E = F × [速度] = m×c2乗)</b><br>
    を押さえることができたかと思います。<br>
    位置がエネルギーまでつながる実感がない人は水力発電のダムをイメージしてください。<br>
    湯気が冬に山に雪として降り、重たい位置エネルギーに変わりダムの放水で発電で電気エネルギーの振動(震え)に変わります。<br>
    雪国で雪かきしている人は雪をスコップで持ち上げながら実感しているはずです。「何と無益な位置エネルギーの移動作業なのだ」と。<br>
    体重がエネルギーに変わる実感がない人は、体温計で自分の体温を測ってみましょう。<br>
    あなたの身体の体温の源はどこにあるのでしょう？体内で細胞などが分子レベルの化学反応で震えて熱エネルギーに変わっているのです。<br>
    <br>
    <br>
    <br>
    <b>【練習物理実験1】</b>プレイヤ1とプレイヤ2でぶつかったときの force += 5 をいじって、衝突の物理現象をカスタマイズする。<br>
    <p><code>GameScene.cppを変更</code>して、<b>プレイヤ1とプレイヤ2に質量 mass (重さ)を設定</b>しましょう。<br>
    </p>
    <p class="source">#include "GameScene.h"<br>
      <br>
      #include "Player.h"<br>
      <br>
      (中略).........<br>
      <br>
      void GameScene::Initialize()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Ｚバッファを有効にする [Zの深度]<br>
      &nbsp;&nbsp;&nbsp; //[参考]https://docs.google.com/presentation/d/1Z23t1yAS7uzPDVakgW_M02p20qt9DeTs4ku4IiMDLco/edit?usp=sharing<br>
      &nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する<br>
      &nbsp;&nbsp;&nbsp; // ( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを2つ生成 画面の全体の縦方向サイズの Height / 2 にして、上下分割で配置できるようにする<br>
      &nbsp;&nbsp;&nbsp; screenHandle0 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      &nbsp;&nbsp;&nbsp; screenHandle1 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath, 8, 8, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath1, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath2, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの生成<br>
      &nbsp;&nbsp;&nbsp; if (pWorld != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pWorld-&gt;AddCamera("カメラ1", Camera::defaultCamera); // カメラ1というタグをデフォルトカメラにつけてワールドにデフォルトカメラを配置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ1", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera1 = pWorld-&gt;camera("カメラ1"); // カメラ1 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera1-&gt;SetScreenHandle(screenHandle0); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer1 = Object::Create&lt;Player&gt;(nullptr, pWorld, Pad::Key, Vector3(90 + 256, 32, 95 + 256));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ1", pPlayer1); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath1]);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;camera = pCamera1.get(); // カメラをプレイヤにリンクする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>pPlayer1-&gt;mass = 100.0f; // 体重を100にして衝突されてもびくともしないようにする</em><br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ2", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera2 = pWorld-&gt;camera("カメラ2"); // プレイヤ2 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera2-&gt;SetScreenHandle(screenHandle1); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer2 = Object::Create&lt;Player&gt;(nullptr, pWorld, Pad::Two, Vector3(190, 32, 195));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ2", pPlayer2); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath2]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;camera = pCamera2.get(); // カメラをプレイヤにリンクする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>pPlayer2-&gt;mass = 1.0f; // 体重を1にして普通にふっとぶようにする</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      (以下略)....<br>
    </p>
    <br>
    <p><code>Player.cppを変更</code>して、<b>力 force の計算式を体重 mass で割り算してぶつかったときのふっとび具合</b>に差をつけてみましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      (中略)........................<br>
      <br>
      void Player::OnCollision(std::shared_ptr&lt;Collision&gt; pCollision)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (isDead) return; // すでにisDeadなら return<br>
      &nbsp;&nbsp;&nbsp; auto otherCollider = pCollision-&gt;contacts[0].otherCollider.lock(); // コライダの弱共有ポインタをロック<br>
      &nbsp;&nbsp;&nbsp; if (otherCollider == nullptr) return; // すでにコライダが消去済だった<br>
      &nbsp;&nbsp;&nbsp; auto other = otherCollider-&gt;owner();<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (other-&gt;isDead) return; // other側がisDeadだったら処理をスルー<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (other-&gt;baseTag == "Enemy" || other-&gt;baseTag == "Player")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto norm = pCollision-&gt;contacts[0].normal* other-&gt;pushPower; // pushPowerの力でotherに押し返される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; force += -norm<em> / mass</em>; // 衝突法線方向の力を加える<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      (以下略).............<br>
    </p>
    <br>
    いかがでしょう？操作してプレイヤ1とプレイヤ2をぶつけると、<b>プレイヤ2を操作してプレイヤ1にぶつけてもほぼ動じない</b>ようになりましたか？<br>
    ちょっと<b> forceの式を mass (体重) で割り算しただけなのに、キャラの重たさ(強さ)を表現</b>できるようになりました。<br>
    <b>難しい式を使わなくても、物理の仕組みの割り算と掛け算、つまり分母と分子がわかれば、ゲームのキャラの表現につながる</b>実感がわきましたか？<br>
    <b>デフォルトのpushPower = 5 と キャラごとの体重 mass の割り算だけの「なんちゃって中二物理学」でも十分にゲームとして遊べる衝突は表現可能</b>なのです。<br>
    <br>
    <br>
    <br>
    <br>
    <b>【練習物理実験2】超本格派の物理計算式「離散要素法(Discrete Element Method :DEM)」</b>を使って本格的な物理衝突計算をしてみる。<br>
    <br>
    <p><code>Player.cppを変更</code>して、<b>力 force の計算式を「離散要素法:DEM」の計算式に変えて</b>みましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      (中略)........................<br>
      <br>
      void Player::OnCollision(std::shared_ptr&lt;Collision&gt; pCollision)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (isDead) return; // すでにisDeadなら return<br>
      &nbsp;&nbsp;&nbsp; auto otherCollider = pCollision-&gt;contacts[0].otherCollider.lock(); // コライダの弱共有ポインタをロック<br>
      &nbsp;&nbsp;&nbsp; if (otherCollider == nullptr) return; // すでにコライダが消去済だった<br>
      &nbsp;&nbsp;&nbsp; auto other = otherCollider-&gt;owner();<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (other-&gt;isDead) return; // other側がisDeadだったら処理をスルー<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (other-&gt;baseTag == "Enemy" || other-&gt;baseTag == "Player")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>//[離散要素法:DEM] https://qiita.com/konbraphat51/items/157e5803c514c60264d2<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float k = 1.0f; // バネ係数(めり込みに対するバネ反発の掛け率)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float e = 0.1f; // はね返り係数(直前と比べどれくらいの速さで離れるか0.5だと半分の速さではね返る)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float log_e = std::log(e); // はね返り係数の自然対数log<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float pi_2 = DX_PI_F * DX_PI_F; // πの2乗<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float eta = -2.0f * log_e * std::sqrt(k * mass / (log_e * log_e + pi_2)); // 粘性係数η(イータ)</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto norm = pCollision-&gt;contacts[0].normal<em>; // 衝突の法線</em> <u>* other-&gt;pushPower; // pushPowerの力でotherに押し返される</u><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>auto v_norm = dot(other-&gt;velocity - velocity, norm) * norm; // [相対速度v] 法線norm方向のv = (v1 - v0)・norm [ドット積]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto sep = pCollision-&gt;contacts[0].separation; // 衝突点どうしの距離(めりこみ距離)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto F = -k * sep * norm - eta * v_norm; // <b>F (法線方向の力) = -k × sep - η × v</b> (相対速度:自分から見た相手otherの速度)</em><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; force += <em>F</em> / mass; // 衝突法線方向の力を加える<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      (以下略).............<br>
    </p>
    <br>
    いかがでしょう？プレイヤ1とプレイヤ2を衝突させたら「<b>助走つけて加速してぶつかるとよりふっとぶ</b>」ようになりましたか？<br>
    たったこれだけのコードの追加で「工業のシュミーションにつかわれるプロ仕様の物理計算」ができるようになりました。<br>
    「離散要素法:DEM」自体を理解するのは物理学者ではないので必要はありません。<br>
    <b>プログラマの仕事は物理の式のパラメータの掛け算や割り算のからみあい方を把握して動かして計算式に破綻がないようにすること</b>で、<br>
    <b>ゲームの作り手の仕事はパラメータをいじって はね返り係数 eを変えてみたり、バネ係数 kをいじったり「いじってもよい数字を調整」</b>することです。<br>
    <br>
    <br>
    <br>
    <br>
    <b>【パラメーター演習】質量 mass や バネ係数 k や はね返り係数 e をいじって、プレイヤどうしぶつかりながら実験し、パラメータを使いこなせるようになろう</b>。<br>
    いかがでしょう？実際に自分でパラメータを変えて実験しないことにはゲームを作りこむことはできません。<br>
    <br>
    <br>
    特に、<b>反発係数 eを0～0.5～1.0まで変えてはね返り具合を実感</b>してください。<br>
    auto F = -k * sep * norm - eta * v_norm; ← v_norm = dot(<em>other</em>-&gt;velocity - velocity, norm) * norm;<br>
    上記の式を見ればわかるのですが、<br>
    実は<b>「ぶつかった相手のother側の影響は自分との速度の差のみ」</b>になっています。<br>
    そう、<b>どんなに相手の体重が重くても、ぶつかる瞬間の速度の差[相対速度]が大きくなければ、こちら側はふっとびません</b>。<br>
    となると現状のイメージは<b>「ゴムのスーパーボール」のはね返りの感じ</b>がすると思います。<br>
    スーパーボールがはずむのはスーパーボール自身の表面がゴムで伸縮するからです。<br>
    ですから、スーパーボールはぶつかる側など気にせず<b>「自分のゴムパラメータではね返っている感じ」が出ている</b>と感じませんか？<br>
    ただ、相手の<b>other側の影響がないとなると、ぶよぶよのお腹にスーパーボールを落としてもスーパーボールははね返ってしまいます</b>。<br>
    なので、本来は <b>if (otherがおデブキャラ) e = はね返らない数値;</b> のように<br>
    反発係数 e をif文で場合分けする必要がありますし、<b>物理的解釈でも「反発係数e はぶつかったペアにより変わる」</b>とされています。<br>
    <br>
    次に、バネ係数 k の式は : F = <em>-k * sep * norm</em> ...のように<b>「ぶつかる速度と無関係で、めり込み具合と法線に関係する」</b>ようになっています。<br>
    実際のバネを思い浮かべてください<b>「速度ではなく、バネをどれだけ縮めたか、で反発が決まる」イメージ</b>がしませんか？<br>
    ですので、eをはね返らない数値にして、代わりに バネ係数 k の数値の影響を大きくすれば、バネを表現できるはずです。<br>
    例えば、if (sep &gt; 3) k = 大きな数字; にすれば、バネのめり込みが 3を超えると派手にはね返る、という風に<br>
    自分が指でバネを縮めてバウンドの手ごたえが出てくるところを確かめる、みたいな工夫もできるかもしれません。<br>
    <br>
    <br>
    さて、実は現状は縦方向 上下 y 方向の物理の反発処理は封印されています。<br>
    プレイヤ2でジャンプして、プレイヤ1をマリオのように踏みつけてみてください。<br>
    きっと、横方向にしかプレイヤははね返らないはずです。<br>
    <br>
    あえて、縦方向は封印してあります。<br>
    なぜなら、縦方向は、<b>パラシュートなどで感じるような「空気抵抗」の物理式が必要</b>になりますし、<br>
    現状 <b>y方向は、JumpComponentとGravityComponentに処理を任せている</b>から一緒にするとややこしいからです。<br>
    <code>PhysicsComponent.hを開いてみて</code>ください。<br>
    <p class="source">#ifndef PHYSICS_COMPONENT_H_<br>
      #define PHYSICS_COMPONENT_H_<br>
      <br>
      (中略)..................<br>
      <br>
      class GravityComponent <b>: </b>public PhysicsComponent<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; (中略)..................<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (中略)..................<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;isGround == false &amp;&amp; pOwner-&gt;vy &lt;= 0) // 下落開始(vyが 0以上 のときはまだジャンプ中なので上昇を邪魔しないようにする)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>pOwner-&gt;vyForce = -gravity()</b>; // ジャンプ上昇力が0になって以降に初めて重力をオンにする(ジャンプの加速を邪魔しない工夫)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;OnFalling(); // 下落中の処理のコールバック関数を呼び返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;vy &lt;= -downSpeedMax()) // 無限に落下速度が加速しないようにリミットを働かせる(空気抵抗みたいなもの)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;vy = -downSpeedMax(); // downSpeedMax()以上の落下速度にならないようにする<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
    </p>
    見てください、致命的なのが、<b>pOwner-&gt;vyForce = -gravity()</b>;の部分です。<br>
    せっかく先ほどの「離散要素法:DEM」で<b>force += F / mass;</b> して加えたforceの力の数値が <b>vyForce = -gravity();</b> の <b>= イコールで上書きされて無効化</b>されています。<br>
    ですので、現状の設計のままだと「離散要素法:DEM」のforce と 重力 gravityの vyForce の<b>共存が難しい状況</b>になっています。<br>
    この状況を打開する方法は1つ<b>「コンポーネントごとに別管理の個別の vyForce を持てるようにすればいい」</b>です。<br>
    別管理の<b>個別の vyForce を持てるように設計</b>しなおせば、DEMのほうで<b>頑張った forceを上書きせずに済みます</b>。<br>
    個別にコンポーネントごとに分離してforceを管理して、<br>
    <b>あとから Player.cppで vy += vyForce + vyJumpForce + vyGravityForce;のようにまとめて合算して速度に影響を与えればいい</b>のです。<br>
    <br>
    <p><code>PhysicsComponent.hを変更</code>して、変数m_vyForceと関数vyForce()を定義してコンポーネントごとに力を分離管理できるようにしましょう。</p>
    <p class="source">#ifndef PHYSICS_COMPONENT_H_<br>
      #define PHYSICS_COMPONENT_H_<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      #include "Component.h"<br>
      #include "GameObject.h"<br>
      <br>
      // 物理系のコンポーネントはこのクラスを継承して実装する<br>
      class PhysicsComponent <b>: </b>public Component<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; inline PhysicsComponent(std::shared_ptr&lt;GameObject&gt; pOwner) : Component(pOwner)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;baseTag = "PhysicsComponent"; // 大まかなカテゴリーとしては物理系コンポーネント<br>
      &nbsp;&nbsp;&nbsp; };<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual ~PhysicsComponent() {};<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // なにか物理系のコンポーネントで共通して更新したいことがあればここに実装<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Draw(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // なにか物理系のコンポーネントで共通して描画したいことがあればここに実装<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      class GravityComponent <b>: </b>public PhysicsComponent<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline GravityComponent(std::shared_ptr&lt;GameObject&gt; pOwner, const std::vector&lt;float&gt;&amp; vyGravity, const std::vector&lt;float&gt;&amp; vyDownSpeedMax)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : PhysicsComponent(pOwner), m_vyGravity{ vyGravity }, m_vyDownSpeedMax{ vyDownSpeedMax }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;typeID = typeid(GravityComponent); //[環境によって差が出るので↓が無難か] https://qiita.com/nil_gawa/items/1fece3eee7ca1f88c71d<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;typeTag = "GravityComponent"; // 個別のカテゴリーとしては重力落下コンポーネント<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; virtual ~GravityComponent() {}<br>
      <em>protected:<br>
        &nbsp;&nbsp;&nbsp; float m_vyForce{ 0.0f }; // オーナーのvyForceとは独立した「このコンポーネントのy方向の力」<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; float vyForce() { return m_vyForce; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; size_t m_idx{ 0 }; // 適用する設定配列の番号<br>
      &nbsp;&nbsp;&nbsp; void SetIndex(size_t idx) { m_idx = idx; }<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; m_vyGravity; // 重力の設定値<br>
      &nbsp;&nbsp;&nbsp; float gravity() { return (m_idx &lt; m_vyGravity.size()) ? m_vyGravity[m_idx] : 0.0f; }<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; m_vyDownSpeedMax; // 降下スピードのリミット<br>
      &nbsp;&nbsp;&nbsp; float downSpeedMax() { return (m_idx &lt; m_vyDownSpeedMax.size()) ? m_vyDownSpeedMax[m_idx] : 0.0f; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isEnabled) return; // コンポーネントが有効状態じゃないときは何もせずreturn<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタをロックして得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;isGround == false &amp;&amp; pOwner-&gt;vy &lt;= 0<u>) </u>// 下落開始(vyが 0以上 のときはまだジャンプ中なので上昇を邪魔しないようにする)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<em>|| pOwner-&gt;isJumping == false &amp;&amp; pOwner-&gt;vy &gt; 0)// 上方向にぶっ飛ばされたとき</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>float vyMax_2 = downSpeedMax() * downSpeedMax(); // 最大スピードの2乗 を空気抵抗 kに使う<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //[空気抵抗の物理] https://hunikablog.com/2020/02/02/equation-of-motion-resistance-proportional-to-the-square-of-speed/<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 空気抵抗係数 k https://www.natural-science.or.jp/article/20100829232938.php<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>float k = pOwner-&gt;mass * gravity() / vyMax_2; // k = m * g / vmaxの2乗 にすれば vmaxが収束速度</b>になる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;vy &lt;= 0) k = <b>-k</b>; // <b>下方向への空気抵抗は逆</b>になる</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ジャンプ上昇力が0になって以降に初めて重力をオンにする(ジャンプの加速を邪魔しない工夫)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>m_vyForce</em> = -gravity()<em> <b>- k / pOwner-&gt;mass * pOwner-&gt;vy * pOwner-&gt;vy</b>; // 空気抵抗は - k / m * vyの2乗<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;vy &gt; 0) pOwner-&gt;isGround = false; // ふっ飛ばされた場合はisGroundがtrueなのにvy &gt; 0の状態になったりするから</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;OnFalling(); // 下落中の処理のコールバック関数を呼び返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>if (pOwner-&gt;isGround)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_vyForce = 0.0f; // 着地したらm_vyForceを0にリセットしないと次回ジャンプ時にJump側と重力がダブっちゃう</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <u>if (pOwner-&gt;vy &lt;= -downSpeedMax()) // 無限に落下速度が加速しないようにリミットを働かせる(空気抵抗みたいなもの)<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;vy = -downSpeedMax(); // downSpeedMax()以上の落下速度にならないようにする</u><br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      class JumpComponent : public PhysicsComponent<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline JumpComponent(std::shared_ptr&lt;GameObject&gt; pOwner, const std::vector&lt;float&gt;&amp; vyJumpSpeed, const std::vector&lt;float&gt;&amp; vyForceJump)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : PhysicsComponent(pOwner), m_vyJumpSpeed{ vyJumpSpeed }, m_vyForceJump{ vyForceJump }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;typeID = typeid(JumpComponent); //[環境によって差が出るので↓が無難か] https://qiita.com/nil_gawa/items/1fece3eee7ca1f88c71d<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;typeTag = "JumpComponent"; // 個別のカテゴリーとしてはジャンプ上昇コンポーネント<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; virtual ~JumpComponent() {}<br>
      <em>protected:<br>
        &nbsp;&nbsp;&nbsp; float m_vyForce{ 0.0f }; // オーナーのvyForceとは独立したこのコンポーネントのy方向の力<br>
        public:<br>
        &nbsp;&nbsp;&nbsp; float vyForce() { return m_vyForce; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; size_t m_idx{ 0 }; // 適用する設定配列の番号<br>
      &nbsp;&nbsp;&nbsp; void SetIndex(size_t idx) { m_idx = idx; }<br>
      &nbsp;&nbsp;&nbsp; float yJumpStart{ 0 }; // ジャンプした瞬間のyの位置<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; m_vyJumpSpeed; // ジャンプの上昇スピードのリミット<br>
      &nbsp;&nbsp;&nbsp; float jumpSpeed() { return (m_idx &lt; m_vyJumpSpeed.size()) ? m_vyJumpSpeed[m_idx] : 0.0f; }<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; m_vyForceJump; // ジャンプ中の下方向の勢いの減速する力<br>
      &nbsp;&nbsp;&nbsp; float forceJump() { return (m_idx &lt; m_vyForceJump.size()) ? m_vyForceJump[m_idx] : 0.0f; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isEnabled) return; // コンポーネントが有効状態じゃないときは何もせずreturn<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (<em>pOwner-&gt;isJumping &amp;&amp; pOwner-&gt;vy &lt;= jumpSpeed() // jumpSpeedを超える場合はふっとばされている状態<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &amp;&amp; </em><u>pOwner-&gt;isGround == false &amp;&amp;</u> pOwner-&gt;vy &gt; 0) // vyが0以上のときはまだジャンプ中<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;OnJumping(); // 空中でジャンプの上昇中に呼ばれるコールバック関数を呼び返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>// ジャンプ上昇中にも空気抵抗を効かせるとき<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float vyMax_2 = jumpSpeed() * jumpSpeed(); // jumpSpeed()の2乗を収束速度にする<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; float vyGravity = forceJump(); // ジャンプ中はforceJump()のゆるい重力でジャンプにふわっと感を出す<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>float k = pOwner-&gt;mass * vyGravity / vyMax_2; // k = m * g / vmaxの2乗 にすれば vmaxが収束速度</b>になる<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>// 空気抵抗は - k / m * vyの2乗</b><br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>m_vyForce = -vyGravity - k / pOwner-&gt;mass * pOwner-&gt;vy * pOwner-&gt;vy;</b></em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>else // vy &lt; 0になってジャンプ中じゃなくなり、落下状況になった<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_vyForce = 0.0f;<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;isJumping = false; // ジャンプ状態フラグをfalseにする<br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void JumpStart(GameObject* obj = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isEnabled) return; // コンポーネントが有効状態じゃないときは何もせずreturn<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;isGround)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;vy = jumpSpeed(); // ジャンプ方向はY上方向<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>m_vyForce</em> = -forceJump(); // ジャンプの勢いが弱まる力<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; yJumpStart = pOwner-&gt;y;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>pOwner-&gt;isJumping = true; // isJumpingフラグがtrueになるのはJumpStart()関数経由が正規ルート</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pOwner-&gt;OnStartJump(); // ジャンプスタート時の処理をコールバックで呼び返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void JumpCancel(GameObject* obj = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isEnabled) return; // コンポーネントが有効状態じゃないときは何もせずreturn<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!pOwner-&gt;isGround &amp;&amp; pOwner-&gt;vy &gt;= 0) // vyが0以上のときはまだジャンプ上昇中<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pOwner-&gt;y - yJumpStart &gt;= 1) // ジャンプ位置から1ピクセルを超えないタイミングでボタンを離しても重力はかけ始めない<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>m_vyForce</em> = -pOwner-&gt;gravity(); // ジャンプボタンを離したときには重力をかけ始める<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>pOwner-&gt;isJumping = false; // falseにしてジャンプ状態フラグをオフにする</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    物理の<a href="https://hunikablog.com/2020/02/02/equation-of-motion-resistance-proportional-to-the-square-of-speed/">落下の数式</a>を読み解くと <b>空気抵抗の係数 k = m(体重) * g(重力加速度) / v_max(落下の限界速度)</b> にすれば、<br>
    少し時間が経つと<b>「落下の速度は空気の抵抗と均衡収束して v_maxに落ち着く」</b>ようにうまく意図的に設定できます。<br>
    <a href="https://ushitora.net/archives/5656">空中の空気の抵抗</a>は「チャリのように<b>低速では速度の1乗倍</b>になり、飛行機のように<b>超高速では乱気流が発生し速度の2乗倍</b>」に比例します。<br>
    <b>float k = pOwner-&gt;mass * vyGravity / vyMax_2; // k = m * g / vmaxの2乗<br>
      m_vyForce = -gravity()- k / pOwner-&gt;mass * pOwner-&gt;vy * pOwner-&gt;vy; // 空気抵抗は - k / m * vyの2乗</b><br>
    大事な式です↑y方向だけでなく、x,z方向にも空気抵抗をいれることもできます。<b>1乗倍にして特定の方向だけ抵抗を入れればチャリにのって風の抵抗を表現</b>することもできます。<br>
    <br>
    <p><code>Player.cppを変更</code>して、OnCollision関数のpCollisionから得た衝突した法線方向を使ってUpdate関数で力を加えましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      (中略).......................<br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; vxForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp; <em>vyForce *= 0.9f; // かかっている力の減衰率</em><br>
      &nbsp;&nbsp;&nbsp; vzForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pJumpPhysics = jumpPhysics.lock();<br>
      &nbsp;&nbsp;&nbsp; if (pJumpPhysics != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pad, PAD_INPUT_A) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;JumpStart(); // ジャンプのスタート処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (vy &gt; 0 &amp;&amp; Input::GetButtonUp(pad, PAD_INPUT_A) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonUp(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;JumpCancel(); // ジャンプのキャンセル処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;Update(); // ジャンプのコンポーネントを更新する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; auto pGravityPhysics = gravityPhysics.lock();<br>
      &nbsp;&nbsp;&nbsp; if (pGravityPhysics != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGravityPhysics-&gt;Update(); // 重力落下のコンポーネントを更新する<br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; rotation.SetRotation(VGet(0, (180 - moveAngle) * MyMath::Deg2Rad, 0)); // 前向きの3Dモデルなら180度回転させて奥方向の向きに設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>float vyForceJump = (pJumpPhysics != nullptr) ? pJumpPhysics-&gt;vyForce() : 0.0f;<br>
        &nbsp;&nbsp;&nbsp; float vyForceGravity = (pGravityPhysics != nullptr) ? pGravityPhysics-&gt;vyForce() : 0.0f;</em><br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; vx += vxForce; // 力をかけて速度に加算する<br>
      &nbsp;&nbsp;&nbsp; <em>vy += vyForce + vyForceJump + vyForceGravity; // 勢い(力・フォースを加算</em><br>
      &nbsp;&nbsp;&nbsp; vz += vzForce; // 力をかけて速度に加算する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp; x += vx;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp; y += vy;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp; z += vz;<br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>vy += vyForce; // 勢い(力・フォースを加算</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; if (y &lt;= 0.0f) // 0.0fを地面として 0.0f以下になったら地面に着地したと判定する<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f; // 地面に沿わせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -0.01f; // 下方向への速度をほぼ 0 にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGround = true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (auto pGridCollision = gridCollision.lock()) // lock()してnullptrじゃなければ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridCollision-&gt;Update(); // 所属するマス目セルを更新する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; // moveAngleは2D画像のX方向右を0度とするから、-90度回すと画像を正面に捉える位置にカメラを置ける<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      (中略).......................<br>
      <br>
    </p>
    <br>
    いかがでしょう？<b>体重の軽いプレイヤ2がジャンプして、プレイヤ1をマリオのように上から踏みつけると、反発で大ジャンプ</b>できたでしょうか？<br>
    このように、数式単位で意味をわかれば、Unityのデフォルトの物理現象以外に、自作の物理現象をAddForceでできる可能性もでてきます。<br>
    これが、<b>現代ゲームプログラマの仕事「<a href="https://www.portal.e2r.jp/fixurl/nintendo_career_job/id/4/2?ki=job00149">グラフィック、フレームワーク、AI、ダイナミクス</a>..」</b>などの一角<b>「ダイナミクス=物理プログラミング」の仕事の実例</b>です。<br>
    <br>
    <br>
    <a id="mozTocId0010" class="mozTocH1">
      <h1>タイル情報を.tsxや.jsonや.csvから読み取りタイルマップを表示する</h1>
    </a> まず読み取るデータとして<a href="https://www.mapeditor.org/">タイルマップエディタ</a>で生成された下記データを「Mapフォルダに保管」してください。<br>
    <p><code>マップに並べられる「タイル側の情報」を持つ.tsx形式のファイル→</code><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/tile3d/data/mapchip.tsx">mapchip.tsx</a></p>
    <p><code>マップにタイルやオブジェクトを並べた「マップ側のステージ情報」を持つ.json形式のファイル→</code><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/tile3d/data/stage1.json">stage1.json</a></p>
    <p><code>マップに関して色々「エクセルで設定したい追加情報」を持つ.csv形式のファイル→</code><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/tile3d/data/MapSetting.csv">MapSetting.csv</a></p>
    <br>
    さてダウンロードしたファイルはすべて「Mapフォルダ内」に置いて、互いにリンク切れにならないように注意してください。<br>
    <br>
    続いて、マップに出したいアイテムや敵の画像をダウンロードして「Imageフォルダに保管」してください。<br>
    <p><code>敵(Zako0)の画像.png形式のファイル→</code><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/tile3d/data/zako0.png">zako0.png</a> (<a

        href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/tile3d/data/zako0.xcf">GIMPの書き出し元データzako0.xcf</a>)</p>
    <p><code>敵(CharaMELで制作)の分割画像.png形式のファイル→</code><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/tile3d/data/skullman.png">skullman.png</a></p>
    <p><code>アイテム(エネルギー弾)の画像.png形式のファイル→</code><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/tile3d/data/bullet.png">bullet.png</a> (<a

        href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/tile3d/data/bullet.xcf">GIMPの書き出し元データbullet.xcf</a>)</p>
    <p><code>アイテム(お金:1円)の画像.png形式のファイル→</code><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/tile3d/data/yen1.png">yen1.png</a></p>
    <p><code>アイテム(お金:10円)の画像.png形式のファイル→</code><a href="https://yonezawashin.github.io/yonezawashin.github.io-2020c/tile3d/data/yen10.png">yen10.png</a></p>
    <br>
    さてダウンロードしたファイルはすべて「Imageフォルダ内」に置いて、リンク切れにならないように注意してください。<br>
    <br>
    <br>
    さて、まずは.tsx形式について<b>[右クリックでメモ帳やVisualStudioで開く]</b>して中身に目を通してみましょう。<br>
    まず、最初の行に着目してください→ <b>xml version="1.0" ...</b> とありますね。<br>
    .tsx形式は「<a href="https://ja.wikipedia.org/wiki/Extensible_Markup_Language">.xml形式</a>をベース」としたファイル形式であることがわかります。<br>
    XML形式はIT企業でもよくつかわれるフォーマットで、<b>基本は&lt; ～ &gt;の三角カッコ内にデータの詳細</b>があり、<br>
    <b>&lt; ～ &gt;データ中身&lt;/ ～ &gt;</b>のように<b>三角カッコ同士でデータの中身を囲ってデータの構造を表現</b>する形式です。<br>
    <br>
    一般に流通するフォーマットの形式なので、自分で中身を見れば、<b>tilewidth="32"...←つまりタイルの幅が32</b>、理解できる範囲です。<br>
    C++であれば色々なXML形式を読み取るオープンソースのコードがありますが、<br>
    今回はシンプルな「<a href="https://lapis0896.hatenadiary.org/entry/20120929/1348929023">tinyxml2 (GPLライセンス)</a>」を使って読み取ってみましょう。<br>
    導入方法は <b>tinyxml2.h と tinyxml2.cpp を自分のプロジェクトに新規作成</b>して、下記サイトのコードを書き入れます。<br>
    <a href="https://github.com/leethomason/tinyxml2/blob/master/tinyxml2.h">tinyxml2.h</a><br>
    <a href="https://github.com/leethomason/tinyxml2/blob/master/tinyxml2.cpp">tinyxml2.cpp</a><br>
    <br>
    <br>
    つぎに、ステージの.json形式について<b>[右クリックでVisualStudioで開く]</b>して中身に目を通してみましょう。<br>
    XMLより量は多いですが、<br>
    基本構造は { ～ } で囲まれた中に "height":400, ..などの情報や<br>
    や "data":[1, 1, 1, ..............] のように[ , , ...]四角カッコ[]と ,カンマで配列のデータ構造が保管されています。<br>
    なので基本は[ 1, 1, 1, ... ] の []四角カッコの中身はエクセルで吐き出すcsv形式と同じような保管形態になっているのが読み取れます。<br>
    <br>
    <a href="https://qiita.com/skm_bnn/items/ecf3d0fe1188e666d079">jsonも一般に流通するフォーマットの形式</a>なので、<br>
    タイルエディタから<b>[ファイル]→[名前をつけてエクスポート]→[保存形式を.json形式に]して保存</b>すれば自分で読み解くことが可能です。<br>
    C++であれば色々なXML形式を読み取るオープンソースのコードはありますが、<br>
    使うなら<a href="https://qiita.com/yohm/items/0f389ba5c5de4e2df9cf">nloman-jsonが決定版</a>です。<br>
    導入方法は <b>json.hpp を新規作成</b>して、下記サイトのコードを書き入れます。<br>
    <a href="https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp">json.hpp</a><br>
    <br>
    <br>
    <br>
    <br>
    さて実際に上記のtinyxmlを#includeして、基底ベースとなるDataXMLクラスを継承overrideしてデータを読み取る処理を作成していきましょう。<br>
    <p><code>DataXML.hを新規作成</code>して、基底ベースとなるDataXMLクラスを作成します。</p>
    <p class="source">#ifndef DATA_XML_H_<br>
      <br>
      #include &lt;string&gt;<br>
      #include &lt;sstream&gt; // std::istringstream で &gt;&gt;で 文字列を数値に変換する<br>
      #include "tinyxml2.h" //[軽量シンプルなXML読込パーサー] https://github.com/leethomason/tinyxml2<br>
      <br>
      struct DataXML<br>
      {<br>
      &nbsp;&nbsp;&nbsp; enum class XMLType<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; XML,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; TSX,<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; XMLType type;<br>
      &nbsp;&nbsp;&nbsp; bool isInitialized = false; //[継承2重ロード対策]ベース基底でロードしたらtrueに<br>
      &nbsp;&nbsp;&nbsp; // 読込んだデータファイルの情報<br>
      &nbsp;&nbsp;&nbsp; std::string FilePath{ "" }; // ファイルの保存パス<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <b>tinyxml2::XMLDocument Data; // XMLのデータ本体</b><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化コンストラクタでファイル名を指定して初期化と同時にファイル読込<br>
      &nbsp;&nbsp;&nbsp; DataXML(const std::string&amp; FilePath = "", XMLType xmlType = XMLType::XML) : type{ xmlType } {}<br>
      &nbsp;&nbsp;&nbsp; virtual ~DataXML() { clear(); } // 仮想デストラクタ <br>
      <br>
      &nbsp;&nbsp;&nbsp; // データをクリアしてメモリを節約する<br>
      &nbsp;&nbsp;&nbsp; virtual void clear()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Data.Clear(); // データ本体をクリア<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitialized = false; //ロード済みフラグをOFF<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Load(const std::string&amp; filePath, XMLType xmlType = XMLType::XML)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ここには未実装 継承overrideして個別の読み取り処理を実装してください<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif DATA_XML_H_<br>
    </p>
    <br>
    <br>
    <br>
    そして、このDataXML.hを継承overrideして.tsx形式のファイルを読み取るDataTsxクラスで読み取る処理を作成していきましょう。<br>
    <p><code>DataTsx.hを新規作成</code>して、基底ベースとなるDataXMLクラスを継承overrideして.tsx形式を読み取る処理を作成します。</p>
    <p class="source">#ifndef DATA_TSX_H_<br>
      #define DATA_TSX_H_<br>
      <br>
      #include "DataXML.h"<br>
      #include "MyHash.h" // hash32でタグの高速化<br>
      #include "Resource.h" // タイルのテクスチャ画像ファイル読込み<br>
      <br>
      #include "json.hpp" // jsonを使用<br>
      using json = nlohmann::json;<br>
      <br>
      // .tsxファイルの情報<br>
      struct TsxInfo<br>
      {<br>
      &nbsp;&nbsp;&nbsp; static std::vector&lt;std::pair&lt;int, std::weak_ptr&lt;Texture&gt;&gt;&gt; id_images; // タイルのgid → タイルの&lt;id,画像の弱リンク&gt; への辞書<br>
      &nbsp;&nbsp;&nbsp; // tilewidth:幅, tileheight:高さ, tilecount:タイルの数, columns:1列のタイルの数<br>
      &nbsp;&nbsp;&nbsp; int tilewidth{ 32 }, tileheight{ 32 }, tilecount{ 64 }, columns{ 8 };<br>
      &nbsp;&nbsp;&nbsp; int imageWidth{ 256 }, imageHeight{ 256 }; // 画像ファイルの imageWidth:幅 imageHeight:高さ<br>
      &nbsp;&nbsp;&nbsp; std::string name{ "" }; // タイルの管理名<br>
      &nbsp;&nbsp;&nbsp; std::string imagePath{ "" }; // タイルの画像ファイルパス<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;unsigned int&gt; gid; // タイルのID → gid の配列辞書<br>
      };<br>
      <br>
      // TSXファイルを読込むデータ型<br>
      struct DataTsx : public DataXML<br>
      {<br>
      &nbsp;&nbsp;&nbsp; TsxInfo tsxInfo; //.tsxファイルの情報<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初期化コンストラクタでファイル名を指定して初期化と同時にファイル読込<br>
      &nbsp;&nbsp;&nbsp; DataTsx(const std::string&amp; FilePath = "") : DataXML(FilePath, XMLType::TSX)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (FilePath != "") // .tsxファイルの読込み<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Load(FilePath); // ファイル読込み<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual ~DataTsx() { clear(); } // 仮想デストラクタ <br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Load(const std::string&amp; filePath, XMLType xmlType = XMLType::TSX) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (filePath == "" || isInitialized) return; //ファイル名がないもしくはロード済<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;FilePath = filePath; // ファイル名を保管<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Data.Clear();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (Data.LoadFile(FilePath.c_str()) != 0) return; // ファイルパスからデータ読み込み<br>
      <br>
      #if 0&nbsp;&nbsp;&nbsp; // TSX形式のXMLのフォーマット例<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt; tileset version = "1.10" tiledversion = "1.10.2" name = "mapchip" tilewidth = "32" tileheight = "32" tilecount = "64" columns = "8" &gt;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;image source = "mapchip.png" width = "256" height = "256" / &gt;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt; / tileset&gt;<br>
      #endif<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //[tinyXMLの使い方] https://w.atwiki.jp/bokuyo/pages/186.html<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; tinyxml2::XMLElement * tileset = Data.FirstChildElement("tileset"); // 最初の要素を得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (tileset == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const char* pName = tileset-&gt;Attribute("name"); // 名前<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (nullptr != pName) tsxInfo.name = std::string(pName);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const char* pTilewidth = tileset-&gt;Attribute("tilewidth"); // 幅<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (nullptr != pTilewidth) { std::istringstream ss(pTilewidth); ss &gt;&gt; tsxInfo.tilewidth; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const char* pTileheight = tileset-&gt;Attribute("tileheight"); // 高さ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (nullptr != pTileheight) { std::istringstream ss(pTileheight); ss &gt;&gt; tsxInfo.tileheight; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const char* pTilecount = tileset-&gt;Attribute("tilecount"); // タイル総数<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (nullptr != pTilecount) { std::istringstream ss(pTilecount); ss &gt;&gt; tsxInfo.tilecount; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const char* pColumns = tileset-&gt;Attribute("columns"); // 1列のタイル数<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (nullptr != pColumns) { std::istringstream ss(pColumns); ss &gt;&gt; tsxInfo.columns; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; tinyxml2::XMLElement* image = tileset-&gt;FirstChildElement("image"); // "tileset"内の"image"要素を得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (image != nullptr)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const char* pImagePath = image-&gt;Attribute("source"); // タイル画像パス<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (nullptr != pImagePath) tsxInfo.imagePath = std::string(pImagePath);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const char* pImageWidth = image-&gt;Attribute("width"); // タイル画像の幅<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (nullptr != pImageWidth) { std::istringstream ss(pImageWidth); ss &gt;&gt; tsxInfo.imageWidth; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const char* pImageHeight = image-&gt;Attribute("height"); // タイル画像の高さ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (nullptr != pImageHeight) { std::istringstream ss(pImageHeight); ss &gt;&gt; tsxInfo.imageHeight; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isInitialized = true; //ロード済みフラグをON<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      <br>
      <br>
      <br>
      #if 0<br>
      struct Tileset // 塗りのパレットとなっている画像ファイルなどのタイル情報<br>
      {&nbsp;&nbsp; // 各パレットの0から始まるが他パレットとかぶるとどっちの番号か確定しないので<br>
      &nbsp;&nbsp;&nbsp; int firstgid = -1; // 各パレットのfirstgid=最初の0にあたる番号<br>
      &nbsp;&nbsp;&nbsp; std::string source{ "" }; // 塗りのパレットとなっている"mapchip.tsx"など<br>
      &nbsp;&nbsp;&nbsp; Tileset(int firstgid, std::string source) : firstgid{ firstgid }, source{ source } {};<br>
      &nbsp;&nbsp;&nbsp; ~Tileset() {};<br>
      };<br>
      #endif<br>
      <br>
      // あるgidに対して log N の速度で その firstgid や そのgidを含むタイルファイル名を 計算できる<br>
      struct Tilesets : std::map&lt;unsigned int, std::string&gt;<br>
      {<br>
      &nbsp;&nbsp;&nbsp; static std::unordered_map&lt;hash32, TsxInfo&gt; umTsxInfo; // &lt;ファイルパス, .tsxの情報&gt; の static 辞書<br>
      &nbsp;&nbsp;&nbsp; static std::vector&lt;unsigned int&gt; firstgidLog; // 過去に一度計算したfirstgid→1回計算済のfirstgid の static 配列<br>
      <br>
      &nbsp;&nbsp;&nbsp; Tilesets() = default;<br>
      &nbsp;&nbsp;&nbsp; inline ~Tilesets() { clear(); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; void LoadTsx(json* pData, std::string* jsonFolderPath)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // データの中身を事前処理する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert((*pData).count("tilesets") != 0 &amp;&amp; "jsonにtileset情報が見つからない");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int i = 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (auto&amp; tileset : (*pData)["tilesets"]) {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string tsxPath = tileset["source"];<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (jsonFolderPath != nullptr) tsxPath = *jsonFolderPath + tsxPath;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //auto pos = tileName.find(".", 0);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //if (pos != std::string::npos) tileName = tileName.substr(0, pos); // mapchip.tsxのドット.までの文字列mapchip<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int firstgid = tileset["firstgid"]; // .tsxファイルの最初のタイルのgid番号<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;emplace(firstgid, tsxPath); // this すなわち std::mapの辞書 にfirstgid と タイルのパス を登録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (umTsxInfo.count(tsxPath) == 0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DataTsx tsxData{ tsxPath }; // .tsxからタイルに関する情報をロード<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::string mapChipPath = tsxData.tsxInfo.imagePath; // マップチップのパス<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (jsonFolderPath != nullptr) // jsonファイルと同一フォルダを探す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mapChipPath = *jsonFolderPath + tsxData.tsxInfo.imagePath;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // .tsxファイルの情報をもとにテクスチャファイルをロード<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(mapChipPath, tsxData.tsxInfo.columns, <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; tsxData.tsxInfo.tilecount / tsxData.tsxInfo.columns, <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; tsxData.tsxInfo.tilewidth, tsxData.tsxInfo.tileheight)-&gt;Load();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //[辞書]TsxInfo::id_imagesのタイルのgidぶんのページ数が足りなければresizeでページを増やしておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (firstgid + tsxData.tsxInfo.tilecount &gt;= TsxInfo::id_images.size())<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; TsxInfo::id_images.resize(firstgid + tsxData.tsxInfo.tilecount + 1);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; tsxData.tsxInfo.gid.resize(tsxData.tsxInfo.tilecount);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pMapChip = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (int id = 0, iSize = pMapChip-&gt;m_handles.size(); id &lt; iSize; ++id)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; TsxInfo::id_images[firstgid + id] = { id, pMapChip }; // TsxInfoの辞書にロードしたidと画像の弱リンクを登録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; tsxData.tsxInfo.gid[id] = firstgid + id; // gidを辞書に登録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //umTsxInfo.erase(tilePath); // すでに辞書に読込み済データが有ったら削除<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; umTsxInfo.emplace(tsxPath, tsxData.tsxInfo); // DataTsx::umTsxInfoの辞書に登録<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; void clear() { std::map&lt;unsigned int, std::string&gt;().swap(*this); }<br>
      #if 0<br>
      &nbsp;&nbsp;&nbsp; Tileset* operator[] (std::string tsxFilename) { // []オペレータで["mapchip"]タイル名でアクセス<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (listDic.count(tsxFilename) == 0) return nullptr;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return &amp;list[listDic[tsxFilename]]; // 書き込み<br>
      &nbsp;&nbsp;&nbsp; }<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; // 例.入力gid:129 ファイル:mapchip1.tsx(0～128番) mapchip2.tsx(0～128番)ならば<br>
      &nbsp;&nbsp;&nbsp; // gid=129なら id は 129 - 128 = 1で mapchip2 の1番のタイルだと求めるために firstgidは128を返したい<br>
      &nbsp;&nbsp;&nbsp; inline unsigned int firstgid(unsigned int gid)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (gid &gt;= firstgidLog.size()) { firstgidLog.resize(gid + 1, -1); }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // すでに1回計算済のfirstgidがあればログ辞書↓からその計算済のログを返せば高速<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (firstgidLog[gid] != -1) return firstgidLog[gid]; // std::vectorなら O( 1 )の計算速度<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // lower_boundで2分探索すれば、std::map&lt;int,string&gt;のsize()に対して ★log N の速度で探索できる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto it = std::prev(this-&gt;lower_bound(gid + 1)); // [参考] https://rsk0315.hatenablog.com/?page=1604038627<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (it == this-&gt;end() || it-&gt;first == 0) return firstgidLog[gid] = 1; // 範囲例外のfirstgidは 1<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return firstgidLog[gid] = it-&gt;first;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // gid から ローカルな id に変換する<br>
      &nbsp;&nbsp;&nbsp; inline int id(unsigned int gid) { return gid - firstgid(gid); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // gidの最大値(最後尾のfirstgidに.tsxファイルのtilecountを足す)を求める<br>
      &nbsp;&nbsp;&nbsp; inline unsigned int gidMax()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (this-&gt;size() == 0) return 1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pair = this-&gt;end(); //辞書の最後から一つ後 end()を得る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; --pair;// end()からひとつ前<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (umTsxInfo.count(pair-&gt;second) == 0) return 1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return pair-&gt;first + umTsxInfo[pair-&gt;second].tilecount; // gidの最大値を求める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline std::string tilepath(unsigned int gid) const<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // lower_boundで2分探索すれば、std::map&lt;int,string&gt;のsize()に対して log N の速度で探索できる<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto it = std::prev(this-&gt;lower_bound(gid + 1)); // [参考] https://rsk0315.hatenablog.com/?page=1604038627<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (it == this-&gt;end() || it-&gt;first == 0) return "";<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return it-&gt;second;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      #if 0<br>
      &nbsp;&nbsp;&nbsp; int operator()(std::string gid) const { // ★()読み取りの処理を定義<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; priQue;// 昇順 (デフォルトはstd::less&lt;TypeT&gt;)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (auto&amp; tileset : list)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; priQue.push(tileset.firstgid);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int firstgid = 1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (!priQue.empty())<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int topId = priQue.top();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; priQue.pop(); // 一番トップを削除する(取り出す) 計算速度 log N<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (gid &lt; topId) { break; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; firstgid = topId;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return firstgid;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      #endif<br>
      };<br>
      <br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>DataTsx.cppを新規作成</code>して.hのstatic関係の定義を作成します。</p>
    <p class="source">#include "DataTsx.h"<br>
      <br>
      std::vector&lt;std::pair&lt;int, std::weak_ptr&lt;Texture&gt;&gt;&gt; TsxInfo::id_images; // タイルのgid → タイルの&lt;id,画像の弱リンク&gt; への辞書<br>
      <br>
      std::unordered_map&lt;hash32, TsxInfo&gt; Tilesets::umTsxInfo; // &lt;ファイルパス, tsxの情報&gt; の static 辞書<br>
      std::vector&lt;unsigned int&gt; Tilesets::firstgidLog; // &lt;過去に一度計算したfirstgid, 1回計算済のfirstgid&gt; の static 辞書<br>
    </p>
    <br>
    <br>
    さて.tsx形式の次は<b>ステージの.json形式のファイルを読み取るためのクラス</b>を作っていきましょう。<br>
    まずは.json形式をnloman-jsonで読み取るための基底ベースクラスDataJsonを定義して、<br>
    これを継承overrideしてタイルマップエディタのステージの.tmx形式由来の.jsonファイルを読み取るための準備をします。<br>
    <br>
    <p><code>DataJson.hを新規作成</code>して.json形式をnloman-jsonで読み取るための基底ベースクラスDataJsonを作成します。</p>
    <p class="source">#ifndef DATAJSON_H_<br>
      #define DATAJSON_H_<br>
      <br>
      #include &lt;fstream&gt; // ファイル読み出しifstreamに必要<br>
      #include &lt;string&gt; //文字列に必要<br>
      #include &lt;sstream&gt; // 文字列ストリームに必要<br>
      <br>
      #include "json.hpp" // jsonを使用<br>
      using json = nlohmann::json;<br>
      <br>
      // .json形式のファイルをnlohman::jsonで読み取るための基底ベースクラス<br>
      // このクラスを継承overrideして個別のフォーマットに合わせたファイルの読み取りを実装する<br>
      class DataJson<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; bool isInitialized = false; //[継承2重ロード対策]ベース基底でロードしたらtrueに<br>
      &nbsp;&nbsp;&nbsp; // 読込んだデータファイルの情報<br>
      &nbsp;&nbsp;&nbsp; std::string FilePath{ "" };<br>
      &nbsp;&nbsp;&nbsp; json Data;// jsonデータ<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual std::size_t size()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Data.size();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // 初期化コンストラクタでファイル名を指定して初期化と同時にファイル読込<br>
      &nbsp;&nbsp;&nbsp; DataJson(const std::string&amp; FilePath = "") :FilePath{ FilePath }<br>
      &nbsp;&nbsp;&nbsp; {// jsonファイルの読込み<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FilePath != "") Load(FilePath); // ファイル読込み<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; virtual ~DataJson()<br>
      &nbsp;&nbsp;&nbsp; {// 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data.clear();// 2次元配列データのお掃除<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = false; //ロード済みフラグをOFF<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // データをクリアしてメモリを節約する<br>
      &nbsp;&nbsp;&nbsp; virtual void clear()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // データをクリアしてメモリを節約する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data.clear();// 2次元配列データのお掃除<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // jsonファイルの読み込み<br>
      &nbsp;&nbsp;&nbsp; virtual void Load(const std::string&amp; filePath)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (filePath == "" || isInitialized) return; //ファイル名がないもしくはロード済<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FilePath = filePath; // ファイル名を保管<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data.clear(); //データを一旦クリア<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::ifstream loadStream(FilePath); // ファイルをロード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loadStream &gt;&gt; Data; // jsonデータ型に変換<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // コンストラクタの初期化でロードの場合とLoad関数経由で読む経路があるから<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = true; // 読込み初期化済みフラグをON<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // jsonファイルのセーブ<br>
      &nbsp;&nbsp;&nbsp; virtual void Save(const std::string&amp; filePath = "")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string savePath = (filePath != "") ? filePath : this-&gt;FilePath;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (savePath == "") return; // セーブするファイル名指定が空の場合<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::ofstream saveStream(FilePath); // ファイルの書き込みストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; saveStream &lt;&lt; Data; // jsonデータをセーブ<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <b>タイルマップエディタ(.tmx形式)のステージ</b>は大元の<b>マップのサイズなどのレイヤーをまたぐ共通情報</b>を持ちます。<br>
    まずは、この共通情報を定義するTMXInfoクラスを定義しましょう。<br>
    <p><code>TMXInfo.hを新規作成</code>してタイルマップエディタ(.tmx形式)の<b>レイヤーをまたぐ共通情報を読み取る</b>処理を準備します。</p>
    <p class="source">#ifndef TMXINFO_H_<br>
      #define TMXINFO_H_<br>
      <br>
      #include &lt;string&gt;<br>
      #include &lt;assert.h&gt; // データ読込み失敗表示用<br>
      <br>
      #include "json.hpp" // jsonを使用<br>
      using json = nlohmann::json;<br>
      <br>
      struct TMXInfo // TMX形式から書き出されたjsonの持つ基本情報<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int width{ 0 }, height{ 0 }, tilewidth{ 0 }, tileheight{ 0 };<br>
      &nbsp;&nbsp;&nbsp; int nextlayerid{ 1 }, nextobjectid{ 1 }, compressionlevel{ -1 };<br>
      &nbsp;&nbsp;&nbsp; bool infinite{ false };<br>
      &nbsp;&nbsp;&nbsp; json* pJson{ nullptr };<br>
      &nbsp;&nbsp;&nbsp; std::string version{ "1.10" }, tiledversion{ "1.10.2" };<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline TMXInfo(json* pJson = nullptr) : pJson{ pJson }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pJson == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *this &lt;&lt; *pJson; // jsonからデータをロード<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; ~TMXInfo() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline void operator &lt;&lt; (const json&amp; Data)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // TMX形式から出力されたjsonデータの中身を読み取る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(Data.count("width") != 0 &amp;&amp; "jsonに width が見つからない");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width = Data["width"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(Data.count("height") != 0 &amp;&amp; "jsonに height が見つからない");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height = Data["height"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(Data.count("tilewidth") != 0 &amp;&amp; "jsonに tilewidth が見つからない");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tilewidth = Data["tilewidth"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(Data.count("tileheight") != 0 &amp;&amp; "jsonに tileheight が見つからない");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tileheight = Data["tileheight"];<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextlayerid = Data["nextlayerid"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextobjectid = Data["nextobjectid"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compressionlevel = Data["compressionlevel"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; infinite = Data["infinite"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; version = Data["version"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tiledversion = Data["tiledversion"];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      struct TMXLayerInfo<br>
      {<br>
      &nbsp;&nbsp;&nbsp; enum class Type : short { None, TMXLayer, ObjectGroup, Group };<br>
      &nbsp;&nbsp;&nbsp; int x{ 0 }, y{ 0 }, Width{ 0 }, Height{ 0 }, gid{ 0 };<br>
      &nbsp;&nbsp;&nbsp; float opecity = 1.0f;<br>
      &nbsp;&nbsp;&nbsp; Type type{ Type::None };<br>
      &nbsp;&nbsp;&nbsp; bool visible{ true };<br>
      &nbsp;&nbsp;&nbsp; json* pLayer{ nullptr };<br>
      &nbsp;&nbsp;&nbsp; std::string name{ "" }; // レイヤの名前<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline TMXLayerInfo(json* pLayer = nullptr) : pLayer{ pLayer }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pLayer == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *this &lt;&lt; *pLayer;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; ~TMXLayerInfo() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline void operator &lt;&lt; (const json&amp; layerData)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (layerData["type"] == "tilelayer") type = Type::TMXLayer;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (layerData["type"] == "objectgroup") type = Type::ObjectGroup;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (layerData["type"] == "group") type = Type::Group;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (layerData.count("x") &gt; 0) x = layerData["x"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (layerData.count("y") &gt; 0) y = layerData["y"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (layerData.count("width") &gt; 0) Width = layerData["width"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (layerData.count("height") &gt; 0) Height = layerData["height"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (layerData.count("opecity") &gt; 0) opecity = layerData["opecity"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (layerData.count("visible") &gt; 0) visible = layerData["visible"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gid = layerData["id"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name = layerData["name"];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    さて、ステージの.json形式を読み取る前に、ステージには出現する敵がいますので<br>
    .json形式を読み取る際にその敵の出現するスポーン半径の定義も必要ですので、<br>
    先に出現レンジを表すMapRangeクラスとグリッドから敵を出現スポーンさせるMapSpawnGridクラスを準備します。<br>
    <p><code>MapRange.hを新規作成</code>して、出現レンジを表すクラスを作成します。</p>
    <p class="source">#ifndef MAP_RANGE_H_<br>
      #define MAP_RANGE_H_<br>
      <br>
      #include &lt;vector&gt;<br>
      #include &lt;map&gt;<br>
      #include &lt;unordered_map&gt;<br>
      <br>
      #include "CellXYZ.h" // マス目XYZを辞書配列のキーとするためのクラス<br>
      <br>
      // 敵を出現(スポーン)させるかを判定するマス目処理クラス<br>
      class MapRange<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 敵の出現などの射程のレンジ【注意！単位はマス目1マス】<br>
      &nbsp;&nbsp;&nbsp; int CellRangeX{ 30 }, CellRangeY{ 30 }, CellRangeZ{ 0 };<br>
      <br>
      &nbsp;&nbsp;&nbsp; enum class Type : unsigned char { // 敵の新規出現レンジのタイプ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rect,&nbsp;&nbsp; // 四角の出現レンジ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ellipse, // 楕円の出現レンジ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Ellipsoid, // 3D楕円体の出現レンジ https://ja.wikipedia.org/wiki/%E6%A5%95%E5%86%86%E4%BD%93<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; Type type = Type::Rect;<br>
      &nbsp;&nbsp;&nbsp; bool isFirstAccess = true; // 初期位置のときにはレンジ内の敵を全部出す<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;CellXYZ, bool, CellXYZ::Hash&gt; umRange; // 辞書:umRangeOpened[{10,5}]==trueなら出現範囲 <br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; MapRange() = default;<br>
      &nbsp;&nbsp;&nbsp; MapRange(int SpawnRangeX, int SpawnRangeY, Type type = Type::Rect)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : CellRangeX{ SpawnRangeX }, CellRangeY{ SpawnRangeY }, type{ type }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitRange(type, SpawnRangeX, SpawnRangeY);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // 3D版のコンストラクタ<br>
      &nbsp;&nbsp;&nbsp; MapRange(int SpawnRangeX, int SpawnRangeY, int SpawnRangeZ, Type type = Type::Rect)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : CellRangeX{ SpawnRangeX }, CellRangeY{ SpawnRangeY }, CellRangeZ{ SpawnRangeZ }, type{ type }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitRange(type, SpawnRangeX, SpawnRangeY);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual ~MapRange() {} // 仮想デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 敵出現射程の辞書初期化【先に計算して辞書化】すると計算が必要なくなり【高速化する】<br>
      &nbsp;&nbsp;&nbsp; //【注意！XとYの単位はマス目】<br>
      &nbsp;&nbsp;&nbsp; virtual void InitRange(Type type, int rangeCellX, int rangeCellY, int rangeCellZ = 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;CellRangeX = rangeCellX; this-&gt;CellRangeY = rangeCellY; this-&gt;CellRangeZ = rangeCellZ; this-&gt;type = type;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umRange.clear();//一旦辞書をクリアするのでゲーム中の再設定も可(だが処理時間はかかる)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (type == Type::Ellipse || type == Type::Rect)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 敵出現射程の辞書初期化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★ X = A cosθ Y = B sinθ(←楕円の方程式)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★ 楕円の半径 r = √(A×A×cosθ×cosθ + B×B×sinθ×sinθ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★ xの2乗 + yの2乗 &lt; rならば楕円の内側<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float A2 = (float)(rangeCellX * rangeCellX); // 2乗<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float B2 = (float)(rangeCellY * rangeCellY); // 2乗<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int x = -rangeCellX; x &lt;= rangeCellX; ++x)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int y = -rangeCellY; y &lt;= rangeCellY; ++y)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[逆三角関数] https://cpprefjp.github.io/reference/cmath/atan2.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (type == Type::Ellipse)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 楕円の出現レンジにしたいときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float theta = (float)std::atan2(y, x); // ★[逆三角関数]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float cos_t = std::cos(theta), sin_t = std::sin(theta);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float r2 = A2 * cos_t * cos_t + B2 * sin_t * sin_t;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (x * x + y * y &lt;= r2) // ★ xの2乗 + yの2乗 &lt; rならば楕円の内側<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //楕円の内側なら辞書SpawnDic[{ x,y }] = true;として登録<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rangeCellZ == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umRange[CellXYZ(x, y)] = true; //【例】SpawnDic[{ 3,2 }] = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int z = -rangeCellZ; z &lt; rangeCellZ; ++z)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umRange[CellXYZ(x, y, z)] = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (type == Type::Rect)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //【★四角形の出現レンジにしたいときはこちら】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rangeCellZ == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umRange[CellXYZ(x, y)] = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int z = -rangeCellZ; z &lt; rangeCellZ; ++z)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umRange[CellXYZ(x, y, z)] = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual std::vector&lt;CellXYZ&gt; Spawn(int deltaCellX, int deltaCellY, int deltaCellZ = 0)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;CellXYZ&gt; spawnCells; // 新しく開くマス目(敵を新規生成するマス目)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto iter = umRange.begin(); iter != umRange.end(); iter++)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★例 iter-&gt;firstが"3,1" iter-&gt;secondが[trueかfalse]の射程マスかどうかのペア<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (iter-&gt;second == true)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 例.(3,1)のマス目が出現射程マスか[trueかfalse]か？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ xyz = iter-&gt;first; // iter-&gt;firstに(x,y)=(3,1)が入っている時<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 例.↑(3,1)のマス目xy.X = 3, xy.Y = 1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 例.deltaCellX = 1 deltaCellY = 2のとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int searchX = xyz.X + deltaCellX; //例. 3+1 = 4 移動先は4<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int searchY = xyz.Y + deltaCellY; //例. 1+2 = 3 移動先は3<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int searchZ = xyz.Z + deltaCellZ;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //例.↓もし(4,3)が未登録もしくはfalseなら【新規出現マス！】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ searchXYZ(searchX, searchY, searchZ);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isFirstAccess)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnCells.emplace_back(searchXYZ); // 初回アクセスのときはレンジ内の範囲は全部返す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (umRange.count(searchXYZ) == 1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 例.辞書に↑(4,3)登録があるならcount( (4,3) )は 1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★例.(4,3)がtrueなら↓【被りマス】移動前にすでに敵の出現判定【済】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (umRange[searchXYZ] == true) continue; // 敵を出現させず別マスの判定を続ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnCells.emplace_back(searchXYZ); // 新しく開くマス目(敵を新規生成するマス目)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isFirstAccess) isFirstAccess = false; // 初回アクセスフラグをオフに<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return spawnCells;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>MapSpawnGrid.hを新規作成</code>して、マップをScroll関数でスクロールさせたときに敵を出現スポーンさせるため、スクロールで新たに開かれたグリッドを配列で返すクラスを作成します。</p>
    <p class="source">#ifndef MAP_SPAWN_GRID_H_<br>
      #define MAP_SPAWN_GRID_H_<br>
      <br>
      #include &lt;functional&gt; // スポーン処理をラムダ式で Scroll関数の引数にできるように<br>
      <br>
      #include "MapRange.h"<br>
      #include "Vector3.h"<br>
      #include "GridObject.h"<br>
      <br>
      class MapSpawnGrid : public Grid<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline MapSpawnGrid(int cellWidth = 64, int cellHeight = 64, int cellDepth = 64)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Grid( cellWidth, cellHeight, cellDepth )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual ~MapSpawnGrid() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; // グリッドをスクロールして敵などのオブジェクトをスポーンさせる<br>
      &nbsp;&nbsp;&nbsp; virtual void Scroll(Vector3 prevPos, Vector3 delta, MapRange&amp; spawnRange, std::function&lt;void(int,int,int)&gt; spawnFunc)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マス目を求める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nextCellX = cellX(prevPos.x + delta.x);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int prevCellX = cellX(prevPos.x);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nextCellZ = cellY(prevPos.y + delta.y); // マス目なので Z と Y 入れ替え<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int prevCellZ = cellY(prevPos.y);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nextCellY = cellZ(prevPos.z + delta.z); // マス目なので Z と Y 入れ替え<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int prevCellY = cellZ(prevPos.z);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isMoveCell = false; // マス目移動が発生するか？発生しないならオブジェクト出現検索処理を回避したい<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nextCellX != prevCellX || nextCellY != prevCellY || nextCellZ != prevCellZ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isMoveCell = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マス目移動以外のときはオブジェクト出現検索処理を省いて高速化<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isMoveCell)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 移動が1マス幅を超えればオブジェクト新規出現判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int deltaCellX = nextCellX - prevCellX; // セル(マス目)単位での移動数(マス数)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int deltaCellY = nextCellY - prevCellY; // セル(マス目)単位での移動数(マス数)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int deltaCellZ = nextCellZ - prevCellZ; // セル(マス目)単位での移動数(マス数)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printfDx("\n%d %d", deltaCellX, deltaCellY);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;CellXYZ&gt; spawnCells = spawnRange.Spawn(deltaCellX, deltaCellY, deltaCellZ);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; spawnCell : spawnCells)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int gridX = 0, gridY = 0, gridZ = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 現状ポジションを基準に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridX = spawnCell.X + prevCellX; // セル(マス目)単位でのX位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridY = spawnCell.Y + prevCellY; // セル(マス目)単位でのY位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridZ = spawnCell.Z + prevCellZ;// セル(マス目)単位でのZ位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnFunc(gridX, gridY, gridZ); // スポーン処理の関数を呼び出し<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    さて、いよいよ本題のタイルマップエディタ(.tmx形式)の.json形式からステージのタイル番号(gid)と敵などのオブジェクトを読み出す準備に入ります。<br>
    まず、事前説明として、ステージにはタイル画像:<b>mapchip.png、mapchip1.png..など「複数のタイルが塗れる必要」</b>があります。<br>
    この複数タイルがやっかいです。<br>
    なぜなら、タイル番号がかぶる可能性が出るからです。<br>
    タイル画像:mapchip.png → 画像の左上のタイル番号 2 番<br>
    タイル画像:mapchip1.png → 画像の左上のタイル番号 2 番<br>
    上記2つのタイルは全く別物になってほしいですが id = 2 として管理すると<br>
    id番号 = 2 のデータはmapchip.pngの2番タイルかmapchip1.pngの2番タイルかごっちゃでわからなくなってしまう、からです。<br>
    この「タイル画像が複数あるとidがごっちゃになる問題」の解決策として、タイルマップエディタでは<br>
    id ではなく <b>gid(通し番号) として保存</b>しています。<br>
    mapchip.pngの中にタイルが64個あるときに<br>
    タイル画像:mapchip.png → 画像の左上のタイル番号 2 番 → gid = 2 + 1 = 3<br>
    タイル画像:mapchip1.png → 画像の左上のタイル番号 2 番 → gid = 64 + 1 + 2 = 67番<br>
    このように gid で管理すれば、複数のタイル画像があっても gid がかぶってごっちゃになることはありません。<br>
    +1 しているのはなぜ？と思う人もいるでしょうが、<b>gid = 0 番は特別に「 = 0 タイルがない状態」を意味</b>していますので<br>
    その<b>タイルがない状態ぶんの　+1つぶんの番号を ずらすため +1</b> しています。<br>
    ですので「gid(通し番号) 」から 「タイル画像ごとの個別の id 」に戻す際には<br>
    <b>id = gid - 64 - 1 = 67 - 64 - 1 = 67 - 65 = 2</b> で元の id に戻すことができます。 なので、<b>id と gid を変換</b>するには <b>最低限 64+1 = 65 などのタイルの最初の番号「firstgid」も必要</b>になることがわかると思います。<br>
    実際、stage1.jsonのファイルをテキストで開いて、ファイルの最後のほうを見ると<br>
    "tilesets":[ &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"firstgid":1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"source":"mapchip.tsx" &nbsp;&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"firstgid":65, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"source":"mapchip1.tsx" &nbsp;&nbsp;&nbsp;}], 上記のようにちゃんとmapchip1.tsxのタイルの"firstgid":65 のようにタイルの最初の番号「firstgid」も記録されていることがわかります。<br>
    "mapchip.tsx " : id は -1, 0 ～ 63番 gidは 0, 1 ～ 64<br>
    "mapchip1.tsx" : id は -1, 0 ～ 63番 gidは 0, 65 ～ 128 → 例.gid:64 - 65 = -1(id) 例.gid:128 - 65 = 63(id) <br>
    このように<b>何もない id:-1 gid:0 も</b>含めて <b>firstgid を引き算すれば id と gidの変換のつじつまがあっている</b>ことがわかります。<br>
    これが複数タイルの番号を数値で分別して記録するカラクリとなっています。<br>
    <br>
    よって、id と gidを区別するために、int型(マイナスあり)、unsigned int型(マイナスのない型)をつかいわけます。<br>
    int id;<br>
    unsigned int gid;<br>
    このように型でマイナスのある無しで数字の形式を区別すれば、変数がgidなのかidなのかをマイナスのある無しを手掛かりに勘違い防止できます。<br>
    <br>
    <br>
    では、いよいよ gid 以外にも色んなステージのデータを含むタイルマップエディタのデータを読み取るTMXJsonクラスを準備しましょう。<br>
    色んなデータを含むということは当然、コード量もとてつもなくデカくなるになることを覚悟してください。<br>
    <p><code>TMXJson.hを新規作成</code>して、タイルマップエディタのステージデータを読み取る「クラス群」を作成します。</p>
    <p class="source">#ifndef TMX_JSON_H_<br>
      #define TMX_JSON_H_<br>
      <br>
      #include &lt;memory&gt;<br>
      #include &lt;vector&gt;<br>
      #include &lt;assert.h&gt; // マップ読込み失敗表示用<br>
      <br>
      #include "DataJson.h"<br>
      #include "DataTsx.h"<br>
      #include "DataCsv.h"<br>
      #include "CellXYZ.h" // 敵の配置など、地面のタイルと違って隙間なく埋まっていないタイプのデータはstd::unordered_mapで扱いデータ量を減らす<br>
      <br>
      #include "TMXInfo.h" // .tmx形式の基本データ構造<br>
      #include "MyHash.h"<br>
      <br>
      #include "MapSpawnGrid.h"<br>
      #include "GridObject.h"<br>
      <br>
      // タイルマップエディタのTMX形式に由来するマップのタイルデータの番号 gid を表すクラス<br>
      // ただの数字だけじゃなく、数字を書き換えたときにおおもとのjsonのデータも連動して書き換えるためjson*のリンクも保持できる<br>
      class TMX_gid<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int gid = 0; // 例.129 のとき Tilesetsで求めるfirstgidが128なら ローカルなidは1番<br>
      &nbsp;&nbsp;&nbsp; unsigned int firstgid = 1; // gid =0 firstgid = 1ならば 0 - 1 = -1でデフォルトは-1になる<br>
      &nbsp;&nbsp;&nbsp; json* pJsonTarget; // 元データのjsonを直で書き換えるためのポインタ参照<br>
      &nbsp;&nbsp;&nbsp; Tilesets*&amp; tilesets; // firstgidを求めるのに必要<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; inline TMX_gid(int gid, json* pJsonTarget, Tilesets*&amp; tilesets)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : gid{ gid }, pJsonTarget{ pJsonTarget }, tilesets{ tilesets }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tilesets != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;firstgid = tilesets-&gt;firstgid(gid); // TMXのjsonはタイルごとに最初のgidもマス目ごとに保管しないとidかぶって保存されるとjsonとしてセーブするときに困る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline ~TMX_gid() {}; // デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; void operator=(const int&amp; intValue) // int型の id の代入演算子<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (intValue &lt;= -1) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pJsonTarget != nullptr) *pJsonTarget = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;gid = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pJsonTarget != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pJsonTarget = intValue + firstgid;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;gid = intValue + firstgid;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; void operator=(const unsigned int&amp; uintValue) // unsigned int つまり gidの 代入演算子<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pJsonTarget != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pJsonTarget = uintValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tilesets != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstgid = tilesets-&gt;firstgid((int)uintValue);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;gid = uintValue;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; inline void copy(const TMX_gid&amp; value)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;tilesets = value.tilesets;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;pJsonTarget = value.pJsonTarget;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;gid = value.gid;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;firstgid = value.firstgid;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; inline void operator=(const TMX_gid&amp; value) { copy(value); } // 代入演算子<br>
      &nbsp;&nbsp;&nbsp; // コピーコンストラクタ<br>
      &nbsp;&nbsp;&nbsp; inline TMX_gid(const TMX_gid&amp; other)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pJsonTarget{ other.pJsonTarget }, gid{ other.gid }, firstgid{ other.firstgid }, tilesets{ other.tilesets }<br>
      &nbsp;&nbsp;&nbsp; { }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline operator int() // int型 つまり id の変換オペレータ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★gidを引くことでjsonの保存形式の数字からcsvの0から始まる出力に合わせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (gid == 0) ? -1 : gid - firstgid;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline operator unsigned int() // unsigned int つまり gidの 変換オペレータ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return gid;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline operator json* () const // おおもとのjsonへのリンクを得る<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pJsonTarget;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      // タイルの縦×横のCSV形式のデータの1行を表すためにstd::vector形式を継承したLineを定義<br>
      // []オペレータで配列サイズが足りないとき = マップの範囲外に新たにタイル設置した際に配列サイズを増やす機能を持つ<br>
      struct TMXLine_gid : public std::vector&lt;TMX_gid&gt;<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Tilesets*&amp; tilesets; // firstgidのためにTilesetsのリンクが必要だからTMX_gidに引き渡すための変数定義<br>
      &nbsp;&nbsp;&nbsp; inline TMXLine_gid(Tilesets*&amp; tilesets) : tilesets{ tilesets } {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline TMX_gid&amp; operator[] (size_t x) // 書き込み<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (x &gt;= size()) // ★xが範囲外のときは拡張(注意:でかい数字を入れるとメモリパニック:使う側の性善説に基づく)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;resize(x + 1, { 0, nullptr, tilesets });<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this-&gt;at(x);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      <br>
      struct TMXCsv; // 前方宣言<br>
      <br>
      // タイルマップ辞書構造(3D:z方向あり)何もない空中をデータとしてあらかじめ敷き詰めるのはメモリのムダなので辞書構造に<br>
      struct TMXterrains : public std::unordered_map&lt;int, std::shared_ptr&lt;TMXCsv&gt;&gt;<br>
      {<br>
      &nbsp;&nbsp;&nbsp; TMXCsv&amp; operator[](int z)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;count(z) == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;emplace(z, std::make_shared&lt;TMXCsv&gt;());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this-&gt;at(z); // 読取り<br>
      &nbsp;&nbsp;&nbsp; }<br>
      #if 0<br>
      &nbsp;&nbsp;&nbsp; inline json&amp; operator() (int x, int y, int z)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;count(z) == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;emplace(z, std::make_shared&lt;TMXCsv&gt;());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (*this-&gt;at(z))(x, y); // 読取り<br>
      &nbsp;&nbsp;&nbsp; }<br>
      #endif<br>
      };<br>
      <br>
      // TMX由来の.jsonファイルのオブジェクトごとに設定されているプロパティ<br>
      struct TMXProperty<br>
      {<br>
      &nbsp;&nbsp;&nbsp; enum class Type : unsigned char { Float, Int, String };<br>
      &nbsp;&nbsp;&nbsp; Type type = Type::Int;<br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int intValue{ 0 };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float floatValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string stringValue;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; std::string name{ "" };<br>
      &nbsp;&nbsp;&nbsp; TMXProperty() = default;<br>
      &nbsp;&nbsp;&nbsp; TMXProperty(const std::string&amp; name, int value) : name{ name }, intValue{ value }, type{ Type::Int } {}<br>
      &nbsp;&nbsp;&nbsp; TMXProperty(const std::string&amp; name, float value) : name{ name }, floatValue{ value }, type{ Type::Float } {}<br>
      &nbsp;&nbsp;&nbsp; TMXProperty(const std::string&amp; name, const std::string&amp; value) : name{ name }, stringValue{ value }, type{ Type::String } {}<br>
      &nbsp;&nbsp;&nbsp; ~TMXProperty() {}<br>
      &nbsp;&nbsp;&nbsp; inline operator int() { return intValue; }<br>
      &nbsp;&nbsp;&nbsp; inline operator float() { return floatValue; }<br>
      &nbsp;&nbsp;&nbsp; inline operator std::string() { return stringValue; }<br>
      &nbsp;&nbsp;&nbsp; inline operator Type() { return type; }<br>
      };<br>
      <br>
      // Objectクラスを継承overrideしたGameObjectでTMXのjsonからプロパティデータを受け取って<br>
      // 各GameObjectのInit関数での初期化処理を行う<br>
      struct InitTMXProperty : public InitParams<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // Initが終わったら破棄される一時的な変数なので 生ポインタで tmxのプロパティデータを受け取る<br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, TMXProperty&gt;* properties;<br>
      &nbsp;&nbsp;&nbsp; inline InitTMXProperty(std::unordered_map&lt;hash32, TMXProperty&gt;* tmxProperties = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : properties{ tmxProperties }, InitParams() {}<br>
      &nbsp;&nbsp;&nbsp; virtual ~InitTMXProperty() {}<br>
      };<br>
      <br>
      // TMXのオブジェクトレイヤの敵やライトやアイテムデータをグリッドで出現スポーンするためGridObjectを継承<br>
      struct TMXobject : public GridObject<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 出現させるスポーンのタイプ<br>
      &nbsp;&nbsp;&nbsp; enum class SpawnType : unsigned char { Light, Enemy, Item, Object };<br>
      &nbsp;&nbsp;&nbsp; inline TMXobject(Grid* pGrid = nullptr, SpawnType spawnType = SpawnType::Object) : spawnType{ spawnType }, GridObject(pGrid) {};<br>
      &nbsp;&nbsp;&nbsp; virtual ~TMXobject() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; float x{ 0 }, y{ 0 }, z{ 0 };<br>
      &nbsp;&nbsp;&nbsp; float rotation{ 0 };<br>
      &nbsp;&nbsp;&nbsp; SpawnType spawnType = SpawnType::Object;<br>
      &nbsp;&nbsp;&nbsp; bool visible{ true };<br>
      &nbsp;&nbsp;&nbsp; bool point{ true };<br>
      &nbsp;&nbsp;&nbsp; //int spawnID{ -1 }; // 敵の種類ID や オブジェクトの種類IDなど<br>
      &nbsp;&nbsp;&nbsp; std::string objectName{ "" };<br>
      &nbsp;&nbsp;&nbsp; std::string baseType{ "" }; // Factory.cppで生成する際に使う「基底ベースクラス名」<br>
      &nbsp;&nbsp;&nbsp; std::string type{ "" }; // Factory.cppで生成する際に使う「クラス名」<br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, TMXProperty&gt; properties;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // TMX形式のjsonから読み取ったプロパティの辞書を<br>
      &nbsp;&nbsp;&nbsp; // Object.hのInitParamsをoverride継承したInitTMXProperty型として返す<br>
      &nbsp;&nbsp;&nbsp; // これをFactory.h の MakeSharedObject関数に渡せれば、<br>
      &nbsp;&nbsp;&nbsp; // ★各GameObjectのInit関数の初期化にjsonから読み取ったデータを渡せる<br>
      &nbsp;&nbsp;&nbsp; inline std::shared_ptr&lt;InitTMXProperty&gt; GetInitProperty()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::make_shared&lt;InitTMXProperty&gt;(&amp;properties);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // jsonから &lt;&lt; オペレータでデータを読み取り<br>
      &nbsp;&nbsp;&nbsp; inline void operator &lt;&lt; (json&amp; objectData)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objectName = objectData["name"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type = objectData["type"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visible = objectData["visible"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; point = objectData["point"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rotation = objectData["rotation"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = objectData["x"], y = objectData["y"], z = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; propertyData : objectData["properties"])<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string propertyName = propertyData["name"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string propertyType = propertyData["type"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (propertyName == "Z" &amp;&amp; propertyType == "float") z = propertyData["value"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (propertyName == "z" &amp;&amp; propertyType == "float") z = propertyData["value"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //else if (propertyName == "spawnID") spawnID = propertyData["value"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (propertyType == "float")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float value = propertyData["value"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; properties.emplace(std::piecewise_construct, std::forward_as_tuple(propertyName), std::forward_as_tuple(propertyName, value));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (propertyType == "int")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value = (int)propertyData["value"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; properties.emplace(std::piecewise_construct, std::forward_as_tuple(propertyName), std::forward_as_tuple(propertyName, value));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string value = propertyData["value"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; properties.emplace(std::piecewise_construct, std::forward_as_tuple(propertyName), std::forward_as_tuple(propertyName, value));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      <br>
      <br>
      // 敵の出現のタイルマップのようにほとんどのデータが空白(-1)なのに<br>
      // -1でデータを埋めるのはメモリの無駄なのでstd::unordered_mapを内部に持つCellGridを継承して[{0,4,5}] X=0,y=4,Z=5 の辞書配列でデータを保管できる<br>
      struct TMXobjects : public MapSpawnGrid<br>
      {<br>
      &nbsp;&nbsp;&nbsp; TMXobjects(int cellWidth = 64, int cellHeight = 64, int cellDepth = 64)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : MapSpawnGrid(cellWidth, cellHeight, cellDepth) {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual ~TMXobjects() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; TMXobject::SpawnType spawnType = TMXobject::SpawnType::Object;<br>
      &nbsp;&nbsp;&nbsp; std::string GroupName{ "" }; // レイヤ名(例."Object0") 複数レイヤz=0～... を一つのCellGrid上のデータCellGrid.dataのunordered_mapで管理する<br>
      &nbsp;&nbsp;&nbsp; std::string BaseName{ "" }; // レイヤ名の先頭(例."Object0"のObject) ★Factory.cppの基底ベースクラスの判定にも使う<br>
      &nbsp;&nbsp;&nbsp; //std::unordered_map&lt;int, int&gt; umObjectsCount; // &lt;レイヤ番号, そのレイヤ階層にあるオブジェクト数&gt;<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;MapRange&gt; pSpawnRange{ nullptr };<br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, TMXProperty&gt; properties; // ユーザの定義した追加プロパティ<br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;TMXobject&gt;&gt; data; // オブジェクトのデータの実体をキープする共有リスト<br>
      &nbsp;&nbsp;&nbsp; // データを消す<br>
      &nbsp;&nbsp;&nbsp; void Erase(TMXobject* targetObj)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto it = data.begin();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (it != data.end()) // リストを回している途中でデータを消すには https://qiita.com/satoruhiga/items/fa6eae09c9d89bd48b5d<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (it-&gt;get() == targetObj)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it = data.erase(it);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else ++it;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //int Width{ 0 }, Height{ 0 };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プロパティを読み取り、グリッドのセルのサイズやスポーンのレンジ設定を読み取る<br>
      &nbsp;&nbsp;&nbsp; inline void LoadProperty(json&amp; objectsData)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(objectsData.count("objects") != 0 &amp;&amp; "jsonの objectgroup に objects が見つからない");<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (objectsData.count("properties") == 0) return; // ユーザーの追加定義したプロパティがなければ終了<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ユーザーの追加定義したプロパティがあれば読み取る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; propertyData : objectsData["properties"])<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string propertyName = propertyData["name"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string propertyType = propertyData["type"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (propertyType == "float")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float value = propertyData["value"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; properties.emplace(std::piecewise_construct, std::forward_as_tuple(propertyName), std::forward_as_tuple(propertyName, value));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (propertyType == "int")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value = propertyData["value"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; properties.emplace(std::piecewise_construct, std::forward_as_tuple(propertyName), std::forward_as_tuple(propertyName, value));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string value = propertyData["value"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; properties.emplace(std::piecewise_construct, std::forward_as_tuple(propertyName), std::forward_as_tuple(propertyName, value));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // グリッドのサイズの設定が追加プロパティにユーザが定義していたら読み取る なければMapSetting.csvの設定が優先される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (properties.count("CellSizeX") &gt; 0) this-&gt;cellWidth = properties["CellSizeX"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (properties.count("CellSizeY") &gt; 0) this-&gt;cellHeight = properties["CellSizeY"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (properties.count("CellSizeZ") &gt; 0) this-&gt;cellDepth = properties["CellSizeZ"];<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // スポーンのレンジ設定がプロパティに追加ユーザが定義していたら読み取る なければMapSetting.csvの設定が優先される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (properties.count("SpawnRangeX") &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int SpawnRangeX{ 10 }, SpawnRangeY{ 10 }, SpawnRangeZ{ 1 };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapRange::Type spawnType = MapRange::Type::Ellipse;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (properties.count("SpawnType") &gt; 0) { std::string str = properties["SpawnType"]; spawnType = (str == "Ellipse") ? MapRange::Type::Ellipse : MapRange::Type::Rect; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (properties.count("SpawnRangeX") &gt; 0) SpawnRangeX = properties["SpawnRangeX"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (properties.count("SpawnRangeY") &gt; 0) SpawnRangeY = properties["SpawnRangeY"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (properties.count("SpawnRangeZ") &gt; 0) SpawnRangeZ = properties["SpawnRangeZ"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pSpawnRange = std::make_shared&lt;MapRange&gt;(SpawnRangeX, SpawnRangeY, SpawnRangeZ, spawnType);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pSpawnRange-&gt;InitRange(spawnType, SpawnRangeX, SpawnRangeY, SpawnRangeZ); // 各マップごとに違うスポーンのレンジ設定があればInitしておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // jsonのオブジェクトレイヤからデータを &lt;&lt; オペレータで読み取り<br>
      &nbsp;&nbsp;&nbsp; inline void operator &lt;&lt; (json&amp; objectsData)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //assert(GroupName != "" &amp;&amp; "レイヤをフィルタするグループ名:GroupNameを設定してから &lt;&lt; 読込してください。");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(objectsData.count("objects") != 0 &amp;&amp; "jsonの objectgroup に objects が見つからない");<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // プロパティを読み取り、グリッドのセルのサイズやスポーンのレンジ設定を読み取る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadProperty(objectsData); // グリッドのセルのサイズによっては下で使う cellX() cellY() cellZ() 関数の結果が変わってくるので先に "properties"を読み取り<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; object : objectsData["objects"])<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;TMXobject&gt; pTmxObject = std::make_shared&lt;TMXobject&gt;(this, spawnType); // this は Grid* 型 のリンクでオブジェクトからグリッドへのリンクを張る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pTmxObject &lt;&lt; object; // jsonから &lt;&lt; でデータを読み取り<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data.emplace_back(pTmxObject); // データのキープはこちらの data で行う<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // baseClassName : Factory.cppで生成するときの「基底ベースクラス名」を設定する<br>
      &nbsp;&nbsp;&nbsp; // タイルマップエディタとのスケールの違いの比率を計算して補正した位置のグリッドへ data から objectをaddする<br>
      &nbsp;&nbsp;&nbsp; inline void InitObjects(const std::string&amp; baseClassName, int tilewidth, int tileheight)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float ratioX = (float)cellWidth / tilewidth;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float ratioY = (float)cellHeight / tileheight; // タイルマップエディタとのスケールの違いの比率を計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float ratioZ = (float)cellDepth / tilewidth;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; pTmxObject : data)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTmxObject-&gt;baseType = baseClassName; // Factory.cppで生成するときの「基底ベースクラス名」を設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CellXYZ gridPos{ cellX(pTmxObject-&gt;x * ratioX),cellY(pTmxObject-&gt;y * ratioY),cellZ(pTmxObject-&gt;z * ratioZ) };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTmxObject-&gt;add(&amp;gridPos); // グリッドのgridPosのマス目位置に オブジェクトへのリンクを追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      class TMXJson; // 前方宣言<br>
      <br>
      // タイルマップのステージの.json形式のdata:[1,1,1, ....]部分からマップのタイル番号を読み取りgid_Dataに保持するクラス<br>
      struct TMXCsv : public DataCsv<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Tilesets* tilesets{ nullptr };<br>
      &nbsp;&nbsp;&nbsp; size_t Width{ 0 }, Height{ 0 };<br>
      &nbsp;&nbsp;&nbsp; int z{ 0 }; // z方向(マップ上の上y方向)<br>
      &nbsp;&nbsp;&nbsp; inline std::size_t size() { return Height; }<br>
      &nbsp;&nbsp;&nbsp; json* pData{ nullptr }; // jsonのおおもとデータへのリンク<br>
      &nbsp;&nbsp;&nbsp; //TMXCsvLine tmxCsvLine{ Width, pData, tilesets };<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;TMXLine_gid&gt; gid_Data; // タイルのデータはこの配列に保持される<br>
      &nbsp;&nbsp;&nbsp; std::string LayerName{ "" };<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline TMXCsv(const std::string&amp; FilePath = "")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : DataCsv() { if (FilePath != "") this-&gt;FilePath = FilePath; }<br>
      &nbsp;&nbsp;&nbsp; virtual ~TMXCsv() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline TMXLine_gid&amp; operator[] (size_t y)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (y &gt;= gid_Data.size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gid_Data.resize(y + 1, tilesets); // yが範囲外のときは拡張(使う側の性善説に基づく)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return gid_Data[y];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // jsonのレイヤからデータを読み取る<br>
      &nbsp;&nbsp;&nbsp; inline void operator &lt;&lt; (json&amp; layerData)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(tilesets != nullptr &amp;&amp; "tilesetsがnullptrです。tilesetsに=でタイルセットへのリンクを張ってから &lt;&lt; 読込してください。");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(layerData.count("data") != 0 &amp;&amp; "jsonのレイヤーにdataが見つからない");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(layerData.count("width") != 0 &amp;&amp; "jsonのレイヤーにwidthが見つからない");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(layerData.count("height") != 0 &amp;&amp; "jsonのレイヤーにheightが見つからない");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //int dataWidth = layerData["width"], dataHeight = layerData["height"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Width = layerData["width"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Height = layerData["height"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(Width &gt; 0 &amp;&amp; "jsonのレイヤーのwidthが0以下、データがおかしい");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(Height &gt; 0 &amp;&amp; "jsonのレイヤーのheightが0以下、データがおかしい");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int commaCount = 0; //カンマの数をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int widthCount = 0; //行の数字の数をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int readHeight = 0; //行数をカウント<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData = &amp;layerData["data"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TMXLine_gid valuelist{ tilesets }; // tilesetsへの参照を渡す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; gid : *pData)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //幅をカウントアップしlineWidthと一致したら1行ぶんemplace_backする方法で1行区切る(layerのdataには改行がないので)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++widthCount;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++commaCount;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //int firstgid = tilesets-&gt;firstgid((int)gid);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; valuelist.emplace_back(TMX_gid((int)gid, &amp;gid, tilesets)); // 数字をリスト(1行リスト)に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (widthCount &gt;= Width)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1行分をvectorに追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (valuelist.size() != 0) gid_Data.emplace_back(valuelist);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; valuelist.clear();//1行push_backできたら次の行読みの為クリア<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++readHeight; //マップの高さをカウントアップ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; widthCount = 0;//次の行のカウントを再び始めるのでカウント幅を0に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;LayerName = layerData["name"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;isInitialized = true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline json&amp; operator () (int x, int y)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(0 &lt;= x &amp;&amp; x &lt; Width &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; Height &amp;&amp; "x y のアクセス位置が範囲外です。");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (*pData)[x + y * Width];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      // タイルマップエディタに特化したJSON読み書きクラス<br>
      class TMXJson : public DataJson<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 初期化コンストラクタでファイル名を指定して初期化と同時にファイル読込<br>
      &nbsp;&nbsp;&nbsp; TMXJson(const std::string&amp; FilePath = "") :DataJson(FilePath)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // jsonファイルの読込みは継承もとのDataJsonで終わっている前提でデータの中身を事前処理する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FilePath == "") return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;Load(FilePath);<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual ~TMXJson() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; TMXInfo tmxInfo; // .tmx形式の基本データ<br>
      &nbsp;&nbsp;&nbsp; std::string folderPath{ "" }; // jsonの入っているフォルダ<br>
      &nbsp;&nbsp;&nbsp; Tilesets tilesets; // 塗りのパレットタイル情報のリスト<br>
      <br>
      &nbsp;&nbsp;&nbsp; struct Group : std::list&lt;int&gt;<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int gid;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::list&lt;Group&gt; children;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline Group(int _id = 0) : gid{ _id } {}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline ~Group() {}<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; Group groups; // 複数のレイヤを子に持てるフォルダの gid の 親子構造を保持する<br>
      <br>
      &nbsp;&nbsp;&nbsp; TMXterrains terrains; // z方向にも複数タイルを保管できる辞書<br>
      &nbsp;&nbsp;&nbsp; TMXobjects lights; //[光源のスポーン] CellGridを継承して辞書配列ベースで 空白 -1 を保管せずにデータを管理<br>
      &nbsp;&nbsp;&nbsp; TMXobjects enemies; //[敵のスポーン] CellGridを継承して辞書配列ベースで 空白 -1 を保管せずにデータを管理<br>
      &nbsp;&nbsp;&nbsp; TMXobjects items; //[アイテムのスポーン] CellGridを継承して辞書配列ベースで 空白 -1 を保管せずにデータを管理<br>
      &nbsp;&nbsp;&nbsp; TMXobjects objects; //[その他のスポーン] CellGridを継承して辞書配列ベースで 空白 -1 を保管せずにデータを管理<br>
      &nbsp;&nbsp;&nbsp; void SetGridSize(Vector3 gridSize)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lights.cellWidth = gridSize.x; lights.cellHeight = gridSize.y; lights.cellDepth = gridSize.z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enemies.cellWidth = gridSize.x; enemies.cellHeight = gridSize.y; enemies.cellDepth = gridSize.z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; items.cellWidth = gridSize.x; items.cellHeight = gridSize.y; items.cellDepth = gridSize.z;;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objects.cellWidth = gridSize.x; objects.cellHeight = gridSize.y; objects.cellDepth = gridSize.z;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; std::size_t size() { return terrains.size(); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // [] オペレータでアクセスされたらterrainsを返す<br>
      &nbsp;&nbsp;&nbsp; inline TMXCsv&amp; operator[] (int z)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return terrains[z];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // filePathにあるjson形式のファイルをタイルマップのTMXの形式として読み取る<br>
      &nbsp;&nbsp;&nbsp; virtual void Load(const std::string&amp; filePath)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (filePath == "") return; //ファイル名がない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;FilePath = filePath;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [親フォルダを抽出] https://qiita.com/takano_tak/items/acf34b4a30cb974bab65<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t path_i = FilePath.find_last_of("\\/");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; folderPath = FilePath.substr(0, path_i + 1);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataJson::Load(FilePath); // 基底クラスDataJsonでjsonをロード<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(Data.count("type") != 0 &amp;&amp; "jsonファイルの中身が空かタイルマップの.tmx由来じゃないかも");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(Data["type"] == "map" &amp;&amp; "jsonファイルがタイルマップの.tmx由来じゃないかも");<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tilesets.LoadTsx(&amp;Data, &amp;folderPath); // .tsxからタイル情報を取得<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmxInfo &lt;&lt; Data; // データの中身を事前読み取り<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetGridSize({ (float)tmxInfo.tilewidth,(float)tmxInfo.tileheight,(float)tmxInfo.tilewidth });<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(Data.count("layers") != 0 &amp;&amp; "jsonにlayers情報が見つからない");<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadTMXLayer(filePath, Data, groups);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; void LoadTMXLayer(const std::string&amp; filePath, json&amp; layerData, Group&amp; groupNode, int terrainNum = 0, int objectsNum = 0, int AStarNum = 0)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 各レイヤをループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; layer : layerData["layers"])<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (layer["type"] == "tilelayer" || layer["type"] == "objectgroup" || layer["type"] == "group")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (layer["type"] == "tilelayer")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[文字列発見] https://cpprefjp.github.io/reference/string/basic_string/find.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string layerName = layer["name"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (layerName.find("AStar") != std::string::npos)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // "AStar..."てレイヤーなので強制的にAStarNumで0123..と番号をつけなおす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; layer["name"] = "AStar" + std::to_string(AStarNum++);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert("対応していない形式(tilelayer,objectgroup,group以外)のレイヤーが見つかりました(タイルエディタで未対応形式のレイヤー作ってない？)" == "");<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (layer["type"] == "group") // レイヤのタイプが groupのとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; groupNode.children.emplace_back((int)layer["id"]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadTMXLayer(filePath, layer, groupNode.children.back(), terrainNum, objectsNum, AStarNum);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (layer["type"] == "objectgroup") // レイヤのタイプが objectgroupのとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; groupNode.emplace_back((int)layer["id"]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //bool isTerrain = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objects.GroupName = layer["name"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (objects.GroupName.find("Enemy") != std::string::npos)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enemies.spawnType = TMXobject::SpawnType::Enemy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enemies &lt;&lt; layer; // 敵のスポーンデータを読み取り<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enemies.InitObjects("Enemy", tmxInfo.tilewidth, tmxInfo.tileheight);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (objects.GroupName.find("Light") != std::string::npos)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lights.spawnType = TMXobject::SpawnType::Light;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lights &lt;&lt; layer; // 光源のデータを読み取り<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lights.InitObjects("Light", tmxInfo.tilewidth, tmxInfo.tileheight);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (objects.GroupName.find("Item") != std::string::npos)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; items.spawnType = TMXobject::SpawnType::Item;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; items &lt;&lt; layer; // アイテムのデータを読み取り<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; items.InitObjects("Item", tmxInfo.tilewidth, tmxInfo.tileheight);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objects.spawnType = TMXobject::SpawnType::Object;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objects &lt;&lt; layer; // その他オブジェクトのデータを読み取り<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objects.InitObjects("Object", tmxInfo.tilewidth, tmxInfo.tileheight);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (layer["type"] == "tilelayer")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(layer.count("width") != 0 &amp;&amp; layer.count("height") != 0 &amp;&amp; "json(TMX)のレイヤーのwidthかheightの情報がない？？");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; groupNode.emplace_back((int)layer["id"]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isTerrain = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string layerName = layer["name"];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pos = layerName.find("terrain");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pos != std::string::npos)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t endPos = std::string("terrain").size();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string numStr = layerName.substr(pos + endPos, layerName.size() - 1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::istringstream ss(numStr); //文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int numZ; ss &gt;&gt; numZ;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pos != std::string::npos)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; terrainZ = terrains[numZ];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainZ.tilesets = &amp;(this-&gt;tilesets);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainZ.FilePath = this-&gt;FilePath;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainZ.z = numZ;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainZ &lt;&lt; layer; // layer["data"]を &lt;&lt;で読み取る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isTerrain = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>CollisionParams.hを新規作成</code>して、jsonから衝突関連のパラメータを読み取れるようにしましょう。</p>
    <p class="source">#ifndef COLLISIONPARAMS_H_<br>
      #define COLLISIONPARAMS_H_<br>
      <br>
      #include "TMXJson.h"<br>
      #include "Object.h"<br>
      <br>
      struct CollisionParams : public InitParams<br>
      {&nbsp;&nbsp;&nbsp; //[離散要素法] https://qiita.com/konbraphat51/items/157e5803c514c60264d2<br>
      &nbsp;&nbsp;&nbsp; float k = 10.0f; // バネ係数(めり込みに対するバネ反発の掛け率)<br>
      &nbsp;&nbsp;&nbsp; float e = 0.3f; // 跳ね返り係数(直前と比べどれくらいの速さで離れるか 0)<br>
      &nbsp;&nbsp;&nbsp; inline float log_e() { return std::log(e); };<br>
      &nbsp;&nbsp;&nbsp; const float pi_2 = DX_PI_F * DX_PI_F;<br>
      &nbsp;&nbsp;&nbsp; // 粘性係数<br>
      &nbsp;&nbsp;&nbsp; inline float eta(float mass) { return -2.0f * log_e() * std::sqrt(k * mass / (log_e() * log_e() + pi_2)); }<br>
      <br>
      &nbsp;&nbsp;&nbsp; float pushPower{ 5.0f }; // kやeの設定がなかった場合はデフォルトのpushPowerで法線方向に押し返す<br>
      &nbsp;&nbsp;&nbsp; bool isDEMcollision = false; //[離散要素法:DEM]のパラメータを使用するか(falseのときはpushPowerで単純な押し戻し) <br>
      <br>
      &nbsp;&nbsp;&nbsp; inline CollisionParams(std::shared_ptr&lt;InitParams&gt; initParams = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (initParams == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto tmxParams = std::static_pointer_cast&lt;InitTMXProperty&gt;(initParams);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (tmxParams-&gt;properties == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto tmxProperties = tmxParams-&gt;properties;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // tmxのjsonの追加プロパティからデータを読み取る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto itr = tmxProperties-&gt;find("collision_e");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Float &amp;&amp; "json の collision_e のタイプが Floatでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; e = itr-&gt;second.floatValue;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isDEMcollision = true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("collision_k");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Float &amp;&amp; "json の collision_k のタイプが Floatでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; k = itr-&gt;second.floatValue;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isDEMcollision = true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("pushPower");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Float &amp;&amp; "json の pushPower のタイプが Floatでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pushPower = itr-&gt;second.floatValue;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; ~CollisionParams() {}<br>
      };<br>
      <br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    いかがでしょう？ここまでで、一旦ビルドしてエラーがでないか確かめておきましょう。<br>
    コード量が多いのでここまでで一旦エラー原因を絞り込むためです。<br>
    タイルの世界を表示させるにはまだまだ必要なものが沢山あります。<br>
    タイル世界だけでなく、普通の3Dの世界も「jsonの"objectgroup"レイヤに色んな3Dファイルを配置」すれば作成できます。<br>
    本来2Dのタイルゲーム向けのエディタのjson構造を自分で解析して、Z方向に積み上げたり、<br>
    "objectgroup"レイヤを応用して3Dのゲームのデータにも拡張できるように対応しているのです。<br>
    jsonやxmlなどのよく知られたフォーマットを知っていれば、<br>
    ツールのデータ構造を調査して、自分のゲーム向けにデータ構造を工夫すれば「2Dツールなのに3Dゲームを作る」ことに応用できてしまうのです。<br>
    つまり、大事なのは<b>「誰かが決めた仕様のツールを使える」ことではなく「自分のデータを作るためにツールを自分の用途向けに応用できる」こと</b>なのです。<br>
    <b>「ツールに振り回される」のではなく「自分の必要なデータ目的のためにツールを振り回す」ためには「世界共通のフォーマットを勉強して知っている」ほうが重要</b>なのです。<br>
    <b>「タイルマップエディタが使えること」には大した意味などありません。<br>
      ひるがえって「Unityを使えること」にも「かつてのAdobeのFlashのオワコン化」のように意味がなくなる時代が来るかもしれません</b>。<br>
    ほんとうに応用の効く重要なことは「ツールよりデータ構造」なのです。<br>
    「XML」「JSON」などを読み取れるスキルは応用が効きます。しっかり勉強する意味があります。<br>
    <br>
    <br>
    <br>
    <br>
    <br>
    つづいて<b>タイルの当たり判定などの「タイル自体の持つ特性の情報の定義」</b>に移ります。<br>
    jsonのステージには「タイルの番号」は保持されていますが、<br>
    それは<b>あくまでもタイル番号にすぎないわけで「そのタイル番号が壁なのか床なのか壊せるのか」などの情報はまた別物</b>です。<br>
    <br>
    まずは、タイルにどの箇所から当たったかを表すヒット箇所 HitPartをビットとして表すデータ定義をしておきます。<br>
    <p><code>HitPart.hを新規作成</code>して、タイルなどに当たった箇所を表すデータ定義を作成します。</p>
    <p class="source">#ifndef HIT_PART_H_<br>
      #define HIT_PART_H_<br>
      <br>
      #include &lt;string&gt;<br>
      <br>
      // タイルなどに当たった箇所を表すenum と Bit演算 HitBit型(int)を使う<br>
      <br>
      typedef int HitBit; // 当たった箇所を表すビット特性 Left | Top なら 左上部分が当たった の特性を表す<br>
      <br>
      enum class HitPart : HitBit // 当たった箇所を表すビット<br>
      {<br>
      &nbsp;&nbsp;&nbsp; None = 0,<br>
      &nbsp;&nbsp;&nbsp; Left&nbsp;&nbsp;&nbsp;&nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp; Right&nbsp;&nbsp;&nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0010,<br>
      &nbsp;&nbsp;&nbsp; Top&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'0100,<br>
      &nbsp;&nbsp;&nbsp; Bottom&nbsp; = 0b0000'0000'0000'0000'0000'0000'0000'1000,<br>
      &nbsp;&nbsp;&nbsp; XMiddle = 0b0000'0000'0000'0000'0000'0000'0001'0000,<br>
      &nbsp;&nbsp;&nbsp; YMiddle = 0b0000'0000'0000'0000'0000'0000'0010'0000,<br>
      &nbsp;&nbsp;&nbsp; Forward = 0b0000'0000'0000'0000'0000'0000'0100'0000,<br>
      &nbsp;&nbsp;&nbsp; Back&nbsp;&nbsp;&nbsp; = 0b0000'0000'0000'0000'0000'0000'1000'0000,<br>
      &nbsp;&nbsp;&nbsp; ZMiddle = 0b0000'0000'0000'0000'0000'0001'0000'0000,<br>
      };<br>
      <br>
      <br>
      <br>
      // 文字列 stringType から HitPart型に変換する<br>
      inline HitPart enumHitPart(const std::string&amp; stringType)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "Left") ? HitPart::Left :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "Right") ? HitPart::Right :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "Top") ? HitPart::Top :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "Bottom") ? HitPart::Bottom :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "XMiddle") ? HitPart::XMiddle :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "YMiddle") ? HitPart::YMiddle :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "Forward") ? HitPart::Forward :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "Back") ? HitPart::Back :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "ZMiddle") ? HitPart::ZMiddle :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HitPart::None;<br>
      }<br>
      <br>
      <br>
      // [ビット論理和 演算子 | のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr HitBit operator | (HitPart left, HitPart right) { return static_cast&lt;HitBit&gt;(left) | static_cast&lt;HitBit&gt;(right); }<br>
      // [ビット論理和 演算子 | のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr HitBit operator | (HitBit left, HitPart right) { return left | static_cast&lt;HitBit&gt;(right); }<br>
      // [ビット論理和 演算子 | のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr HitBit operator | (HitPart left, HitBit right) { return static_cast&lt;HitBit&gt;(left) | right; }<br>
      <br>
      // [ビット論理積 演算子 &amp; のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr HitBit operator &amp; (HitPart left, HitPart right) { return static_cast&lt;HitBit&gt;(left) &amp; static_cast&lt;HitBit&gt;(right); }<br>
      // [ビット論理積 演算子 &amp; のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr HitBit operator &amp; (HitBit left, HitPart right) { return left &amp; static_cast&lt;HitBit&gt;(right); }<br>
      // [ビット論理積 演算子 &amp; のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr HitBit operator &amp; (HitPart left, HitBit right) { return static_cast&lt;HitBit&gt;(left) &amp; right; }<br>
      <br>
      // [ビット排他的論理和 演算子 ^ のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr HitBit operator ^ (HitPart left, HitPart right) { return static_cast&lt;HitBit&gt;(left) ^ static_cast&lt;HitBit&gt;(right); }<br>
      // [ビット排他的論理和 演算子 ^ のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr HitBit operator ^ (HitBit left, HitPart right) { return left ^ static_cast&lt;HitBit&gt;(right); }<br>
      // [ビット排他的論理和 演算子 ^ のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr HitBit operator ^ (HitPart left, HitBit right) { return static_cast&lt;HitBit&gt;(left) ^ right; }<br>
      <br>
      // [一致演算子 == ]のオーバーロード HitPart型を HitBit型に変換して比較<br>
      inline constexpr bool operator == (HitPart left, HitBit right) { return static_cast&lt;HitBit&gt;(left) == right; }<br>
      // [一致演算子 == ]のオーバーロード HitPart型を HitBit型に変換して比較<br>
      inline constexpr bool operator == (HitBit left, HitPart right) { return left == static_cast&lt;HitBit&gt;(right); }<br>
      <br>
      // [不一致演算子 != ]のオーバーロード HitPart型を HitBit型に変換して比較<br>
      inline constexpr bool operator != (HitPart left, HitBit right) { return !(left == right); }<br>
      // [不一致演算子 != ]のオーバーロード HitPart型を HitBit型に変換して比較<br>
      inline constexpr bool operator != (HitBit left, HitPart right) { return !(left == right); }<br>
      <br>
      #endif<br>
    </p>
    <br>
    つづいて、壁や床や壊せるブロックなどタイルの特性をビットとして取り扱えるようにするTileクラスを準備します。<br>
    <p><code>Tile.hを新規作成</code>して、壁、床、壊せるなどのビット特性を表現する定義と<b>設定を「Map/MapSetting.csv」から読み出す</b>クラスを作成します。</p>
    <p class="source">#ifndef TILE_H_<br>
      #define TILE_H_<br>
      <br>
      #include &lt;string&gt; //文字列に必要<br>
      #include &lt;unordered_map&gt;<br>
      #include &lt;vector&gt;<br>
      <br>
      #include "DataCsv.h"<br>
      #include "DataTsx.h"<br>
      #include "MyDraw.h"<br>
      #include "MyHash.h" // hash32でタグを高速化<br>
      <br>
      #include "HitPart.h" // タイルに当たった箇所を表すenum と Bit演算 HitBit型(int)を使う<br>
      <br>
      typedef int TileBit; // タイルのビット特性 Wall | Bounce なら はずむ壁 の特性を持つ<br>
      <br>
      enum class TileType : TileBit //★ブロックの特性を32桁のビットで表現<br>
      {<br>
      &nbsp;&nbsp;&nbsp; None = 0,<br>
      &nbsp;&nbsp;&nbsp; Wall =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0b0000'0000'0000'0000'0000'0000'0000'0001,<br>
      &nbsp;&nbsp;&nbsp; Damage = 0b0000'0000'0000'0000'0000'0000'0000'0010,<br>
      &nbsp;&nbsp;&nbsp; Bounce = 0b0000'0000'0000'0000'0000'0000'0000'0100, // 叩くと弾むブロック<br>
      &nbsp;&nbsp;&nbsp; Change = 0b0000'0000'0000'0000'0000'0000'0000'1000, // 叩くとブロックの種類が変わる<br>
      &nbsp;&nbsp;&nbsp; Switch =&nbsp; 0b0000'0000'0000'0000'0000'0000'0001'0000, // スイッチを叩くと赤ブロックや青ブロックの無効⇔有効が切り替え<br>
      &nbsp;&nbsp;&nbsp; Goal =&nbsp;&nbsp;&nbsp;&nbsp; 0b0000'0000'0000'0000'0000'0000'0010'0000,<br>
      &nbsp;&nbsp;&nbsp; Floor =&nbsp;&nbsp;&nbsp; 0b0000'0000'0000'0000'0000'0000'0100'0000,<br>
      };<br>
      <br>
      // 文字列 stringType から TileType型に変換する<br>
      inline TileType enumTileBit(const std::string&amp; stringType)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "Wall") ? TileType::Wall :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "Damage") ? TileType::Damage :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "Bounce") ? TileType::Bounce :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "Change") ? TileType::Change :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "Switch") ? TileType::Switch :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "Goal") ? TileType::Goal :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (stringType == "Floor") ? TileType::Floor :<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TileType::None;<br>
      }<br>
      <br>
      <br>
      // [ビット論理和 演算子 | のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr TileBit operator | (TileType left, TileType right) { return static_cast&lt;TileBit&gt;(left) | static_cast&lt;TileBit&gt;(right); }<br>
      // [ビット論理和 演算子 | のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr TileBit operator | (TileBit left, TileType right) { return left | static_cast&lt;TileBit&gt;(right); }<br>
      // [ビット論理和 演算子 | のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr TileBit operator | (TileType left, TileBit right) { return static_cast&lt;TileBit&gt;(left) | right; }<br>
      <br>
      // [ビット論理積 演算子 &amp; のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr TileBit operator &amp; (TileType left, TileType right) { return static_cast&lt;TileBit&gt;(left) &amp; static_cast&lt;TileBit&gt;(right); }<br>
      // [ビット論理積 演算子 &amp; のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr TileBit operator &amp; (TileBit left, TileType right) { return left &amp; static_cast&lt;TileBit&gt;(right); }<br>
      // [ビット論理積 演算子 &amp; のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr TileBit operator &amp; (TileType left, TileBit right) { return static_cast&lt;TileBit&gt;(left) &amp; right; }<br>
      <br>
      // [ビット排他的論理和 演算子 ^ のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr TileBit operator ^ (TileType left, TileType right) { return static_cast&lt;TileBit&gt;(left) ^ static_cast&lt;TileBit&gt;(right); }<br>
      // [ビット排他的論理和 演算子 ^ のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr TileBit operator ^ (TileBit left, TileType right) { return left ^ static_cast&lt;TileBit&gt;(right); }<br>
      // [ビット排他的論理和 演算子 ^ のオーバーロードでenum型を暗黙変換] https://marycore.jp/prog/cpp/enum-bitmask-bitwise-operation/<br>
      inline constexpr TileBit operator ^ (TileType left, TileBit right) { return static_cast&lt;TileBit&gt;(left) ^ right; }<br>
      <br>
      // [一致演算子 == ]のオーバーロード HitPart型を HitBit型に変換して比較<br>
      inline constexpr bool operator == (TileType left, TileBit right) { return static_cast&lt;TileBit&gt;(left) == right; }<br>
      // [一致演算子 == ]のオーバーロード HitPart型を HitBit型に変換して比較<br>
      inline constexpr bool operator == (TileBit left, TileType right) { return left == static_cast&lt;TileBit&gt;(right); }<br>
      <br>
      // [不一致演算子 != ]のオーバーロード HitPart型を HitBit型に変換して比較<br>
      inline constexpr bool operator != (TileType left, TileBit right) { return !(left == right); }<br>
      // [不一致演算子 != ]のオーバーロード HitPart型を HitBit型に変換して比較<br>
      inline constexpr bool operator != (TileBit left, TileType right) { return !(left == right); }<br>
      <br>
      <br>
      struct Tile // タイル情報<br>
      {<br>
      &nbsp;&nbsp;&nbsp; static constexpr unsigned int None = 0; // 何もないことを表す gid <br>
      <br>
      &nbsp;&nbsp;&nbsp; Tile() = default;<br>
      &nbsp;&nbsp;&nbsp; inline Tile(int id, float cost = 1.0f, TileBit typeBit = (TileBit)TileType::None, const std::string&amp; typeTag = "", const CsvValue&amp; value = CsvValue())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : id{ id }, cost{ cost }, typeBit{ typeBit }, typeTag{ typeTag }, value{ value } {};<br>
      &nbsp;&nbsp;&nbsp; ~Tile() {};// デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; int id = -1; // タイルid<br>
      &nbsp;&nbsp;&nbsp; float cost = 1; // AIの経路判定で使う移動コスト<br>
      &nbsp;&nbsp;&nbsp; TileBit typeBit = (TileBit)TileType::None; // タイルのタイプ<br>
      &nbsp;&nbsp;&nbsp; int changeID{ 0 }; // 変化先ID<br>
      &nbsp;&nbsp;&nbsp; hash32 typeTag{ "" }; // タイルのタグ<br>
      &nbsp;&nbsp;&nbsp; CsvValue value{ "" }; // 値(ダメージ値など 文字列も使用できる)<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; syncIDs; // 連動するID (sync:シンクロ)ブロックを叩いたら連動して他も変わるなどに使う<br>
      };<br>
      <br>
      // "Map/MapSettings.csv"から読み出すタイルの情報<br>
      struct TileInfo<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; TileBit noneBit{ 0 }; // id = -1 のときのBit<br>
      &nbsp;&nbsp;&nbsp; // &lt;gid→idに対応したタイプのbit&gt; へ変換するvector型の辞書<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;TileBit&gt; idTypeBits;<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;int, Tile&gt; tiles; // タイル情報<br>
      &nbsp;&nbsp;&nbsp; inline Tile&amp; operator[](int id) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tiles[id]; // &amp;参照で読み書き<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline TileBit&amp; idTypeBit(int id)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (id &gt;= (int)idTypeBits.size()) idTypeBits.resize(id + 1, 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (id &lt; 0) ? noneBit : idTypeBits[id];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // id→ビットのタイプ の辞書に |= でbitTypeをビット論理和して、Wall:壁 や Bounce:はずむ などの特性を追加する<br>
      &nbsp;&nbsp;&nbsp; TileBit SetTypeBit(int id, TileBit bitType) { return idTypeBit(id) |= bitType; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // id→ビットのタイプ の辞書で &amp; ビット論理積で 指定したidが Wall:壁 や Bounce:はずむ などの特性を持つかを判定する<br>
      &nbsp;&nbsp;&nbsp; inline bool isType(int id, TileType bitType) { return idTypeBit(id) &amp; bitType; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // id→ビットのタイプ の辞書で &amp; ビット論理積で 指定したidが Wall:壁 や Bounce:はずむ などの特性を持つかを判定し一致したBitを返す(複数が1のビットもありうる)<br>
      &nbsp;&nbsp;&nbsp; inline TileBit matchTypes(int id, TileBit bitType) { return idTypeBit(id) &amp; bitType; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline bool IsWall(int id) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return isType(id, TileType::Wall);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      // "Map/MapSettings.csv"からタイルの設定情報を読み出すクラス<br>
      struct TileSetting<br>
      {<br>
      &nbsp;&nbsp;&nbsp; TileSetting(const std::string&amp; csvFileName = "")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (csvFileName != "") Load(csvFileName);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; ~TileSetting() {} //デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; //[辞書].tsxファイル名→タイル情報<br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;TileInfo&gt;&gt; info;<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline std::shared_ptr&lt;TileInfo&gt; operator[](const std::string&amp; tsxPath) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return info[tsxPath]; // 読み書き<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; bool isInitialized = false; //[継承2重ロード対策]<br>
      &nbsp;&nbsp;&nbsp; std::string FilePath{ "" }; // csvのファイルパス<br>
      &nbsp;&nbsp;&nbsp; DataCsv Data; // マップ情報一覧のデータ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 例.csvのセルに"Wall | Bounce | Change"と書かれたいたら TileType::Wall Bounce Changeが1となったビットを返す <br>
      &nbsp;&nbsp;&nbsp; TileBit bitFromCsvCell(const std::string&amp; csvCellString)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TileBit returnBit = (TileBit)TileType::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (csvCellString == "") return returnBit;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::istringstream ss(csvCellString); // 文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string typeString; // | での分割文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (std::getline(ss, typeString, { '|' }))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // [std::isspaceで空白除去] https://b.0218.jp/20150625194056.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typeString.erase(std::remove_if(typeString.begin(), typeString.end(), std::isspace), typeString.end());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; returnBit |= (TileBit)enumTileBit(typeString); // ビット論理和でタイルのビット特性を付加していく 例. Wall | Bounce はずむ壁<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return returnBit;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 例..csvのセルに"12 | 13 | 15"と書かれていたら配列に[12][13][15]を入れて返す<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; intFromCsvCell(const std::string&amp; csvCellString)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; returnInts;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (csvCellString == "") return returnInts;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::istringstream ss(csvCellString); // 文字列ストリーム<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string intString; // | での分割文字列<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (std::getline(ss, intString, { '|' }))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // [std::isspaceで空白除去] https://b.0218.jp/20150625194056.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intString.erase(std::remove_if(intString.begin(), intString.end(), std::isspace), intString.end());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; returnInts.emplace_back((int)std::stol(intString)); // stolで文字列→数値に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return returnInts;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; void Load(const std::string&amp; csvFileName = "")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isInitialized) return; // 2重ロード対策<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (csvFileName != "") this-&gt;FilePath = csvFileName;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;FilePath == "") return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data.Load(this-&gt;FilePath, DataCsv::CsvType::CsvValue);// CSVファイルからデータをロード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string tsxFile; //tsxファイル名<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; Data.size(); ++j)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //std::string test = (std::string)Data[j][0];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((std::string)Data[j][0] == "//") continue; // 一番左の列が//なら読み飛ばしのコメント行<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((std::string)Data[j][0] == "TsxFile")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tsxFile = Data[j][1]; //tsxファイル名<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info.emplace(tsxFile, std::make_shared&lt;TileInfo&gt;());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tsxFile == "") continue; //ステージファイル名が未確定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (Data[j].size() &gt; 1 &amp;&amp; (std::string)Data[j][1] != "")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tileID = Data[j][1]; // タイルID<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info[tsxFile]-&gt;tiles[tileID].id = tileID; // タイルIDを辞書登録<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((std::string)Data[j][2] != "")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info[tsxFile]-&gt;tiles[tileID].cost = Data[j][2]; //コスト登録<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info[tsxFile]-&gt;tiles[tileID].typeTag = (std::string)Data[j][3]; //タグ登録<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((std::string)Data[j][4] != "") // タイプ登録 None,Wall,Floor..など<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info[tsxFile]-&gt;tiles[tileID].typeBit = info[tsxFile]-&gt;SetTypeBit(tileID, bitFromCsvCell(Data[j][4]));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Data[j].size() &gt; 5) // 値(ダメージ値など)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info[tsxFile]-&gt;tiles[tileID].value = Data[j][5];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Data[j].size() &gt; 6) // 変化先ID<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info[tsxFile]-&gt;tiles[tileID].changeID = Data[j][6];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Data[j].size() &gt; 7) // 連動ID<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info[tsxFile]-&gt;tiles[tileID].syncIDs = std::move(intFromCsvCell(Data[j][7]));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isInitialized = true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    さてここでいよいよマップを表すMap.hを定義しましょう。<br>
    <p><code>Map.hを新規作成</code>して、タイルマップエディタで作成したステージを表現するMapクラスを作成してタイルマップを3D表示させます(<b>現状当たり判定と敵の出現はまだない</b>)。</p>
    <p class="source">#ifndef MAP_H_<br>
      #define MAP_H_<br>
      <br>
      #include &lt;vector&gt; // C#におけるListリストの機能<br>
      #include &lt;unordered_map&gt;&nbsp;&nbsp;&nbsp; // 辞書型連想配列に必要<br>
      #include &lt;memory&gt; // メモリを扱う【共有ポインタに必要】<br>
      #include &lt;limits&gt; //intやfloatなどの無限大∞に使う&nbsp; https://cpprefjp.github.io/reference/limits/numeric_limits/max.html<br>
      <br>
      #include &lt;fstream&gt; // ファイル読み出しifstreamに必要<br>
      #include &lt;string&gt; //文字列に必要<br>
      #include &lt;sstream&gt; // 文字列ストリームに必要<br>
      <br>
      #include &lt;assert.h&gt; // マップ読込み失敗表示用<br>
      <br>
      #include "Screen.h"<br>
      #include "MyMath.h"<br>
      #include "MyHash.h"<br>
      #include "MyDraw.h"<br>
      #include "DataCsv.h"<br>
      #include "TMXJson.h"<br>
      <br>
      #include "Singleton.h"<br>
      #include "GameObject.h"<br>
      #include "World.h"<br>
      #include "Camera.h"<br>
      <br>
      #include "MapRange.h" // マス目のレンジ表現するクラス<br>
      <br>
      #include "Tile.h"<br>
      <br>
      #include "Vector3.h"<br>
      <br>
      class AI_Map; // 前方宣言<br>
      <br>
      // csvから読み取るマップの基本情報<br>
      struct MapInfo<br>
      {<br>
      &nbsp;&nbsp;&nbsp; MapInfo() = default;<br>
      &nbsp;&nbsp;&nbsp; inline MapInfo(unsigned int CellSize, int SpawnRangeX, int SpawnRangeY, MapRange::Type type = MapRange::Type::Rect)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : CellSize{ CellSize }, spawnRange{ MapRange(SpawnRangeX,SpawnRangeY,type) } {};<br>
      &nbsp;&nbsp;&nbsp; ~MapInfo() {};<br>
      <br>
      &nbsp;&nbsp;&nbsp; unsigned int CellSize{ 1 }; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;&nbsp; MapRange spawnRange; // 敵の新規出現レンジ<br>
      };<br>
      <br>
      struct MapSetting // マップ情報をMapSetting.csvなどから読みだす<br>
      {<br>
      &nbsp;&nbsp;&nbsp; MapSetting(const std::string&amp; csvFileName = "")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (csvFileName != "")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Load(csvFileName);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; ~MapSetting() {}; //デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::string FilePath{ "" }; // csvのファイルパス<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;MapInfo&gt;&gt; info; //[辞書]stageファイル名→マップ情報<br>
      <br>
      &nbsp;&nbsp;&nbsp; MapInfo&amp; operator[](const std::string&amp; stageFilePath) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(info.count(stageFilePath) != 0 &amp;&amp; "マップのステージ情報が読み取れていません Map/MapSettings.csv にステージ情報があるか確認！");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *info[stageFilePath]; // 読み書き<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; void Load(const std::string&amp; csvFileName = "")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (csvFileName != "") this-&gt;FilePath = csvFileName;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;FilePath == "") return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マップ情報のデータ CSVファイルからデータをロード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataCsv Data{ this-&gt;FilePath, DataCsv::CsvType::CsvValue };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string stageFile; //ステージファイル名<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; Data.size(); ++j)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((std::string)Data[j][0] == "//")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue; // 一番左の列が//なら読み飛ばしのコメント行<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((std::string)Data[j][0] == "File")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stageFile = Data[j][1]; //ステージファイル名<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info.emplace(stageFile, std::make_shared&lt;MapInfo&gt;());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (stageFile == "") continue; //ステージファイル名が未確定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((std::string)Data[j][0] == "CellSize")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info[stageFile]-&gt;CellSize = (int)Data[j][1]; //マス目サイズ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((std::string)Data[j][0] == "SpawnRange")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 敵出現レンジ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapRange::Type rangeType = ((std::string)Data[j][3] == "Ellipse") ? MapRange::Type::Ellipse : MapRange::Type::Rect; //敵出現のタイプ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info[stageFile]-&gt;spawnRange.InitRange(rangeType, Data[j][1].intFromString(), Data[j][2].intFromString()); //敵出現のタイプを初期化設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      // ステージのタイルマップのクラス<br>
      class Map<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Map(World* world, const std::string&amp; filePath = "")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : m_world{ world }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (filePath == "") return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Load(filePath);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // デストラクタ<br>
      &nbsp;&nbsp;&nbsp; ~Map()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // マップデータのお掃除<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enemyData.clear();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //terrains.clear(); //★地形のお掃除<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; static MapSetting settings; // マップに関する設定 Map.cpp で初期読込み デフォルトは"Map/MapSetting.csv" を読み込む<br>
      &nbsp;&nbsp;&nbsp; static TileSetting tileSettings; // タイルに関する設定 Map.cpp で初期読込み デフォルトは"Map/MapSetting.csv" を読み込む<br>
      &nbsp;&nbsp;&nbsp; // タイルのチップ画像のパスとidからTileの情報とタイルのgid情報を得る<br>
      &nbsp;&nbsp;&nbsp; static Tile GetTile(const std::string&amp; mapChipPath, int id, unsigned int&amp; gid)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pos = mapChipPath.find(".", 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string tsxPath{ "" };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pos != std::string::npos) tsxPath = mapChipPath.substr(0, pos) + ".tsx";<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto found = Tilesets::umTsxInfo.find(tsxPath);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (found != end(Tilesets::umTsxInfo) &amp;&amp; found-&gt;second.gid.size() &gt; id)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gid = found-&gt;second.gid[id]; // 辞書で id から gidに変換しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else return Tile(); // id が-1のときは見つからなかったとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = tsxPath.find("/", 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pos != std::string::npos) tsxPath = tsxPath.substr(pos + 1, tsxPath.size() - 1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Map::tileSettings.info[tsxPath]-&gt;tiles[id];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; World* m_world{ nullptr }; // マップに配置する敵などのポインタを保持するワールド<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; World* world() { return m_world; }<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
      &nbsp;&nbsp;&nbsp; void world(World* changeWorld) { m_world = changeWorld; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;AI_Map&gt; aiMap{ nullptr }; // AIの経路探索に使うAIマップ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 読込んだデータファイルの情報<br>
      &nbsp;&nbsp;&nbsp; std::string FilePath{ "" };<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; unsigned int m_CellSize{ 1 }; // マップの1マスのピクセル数 1のときはtmxに設定されたサイズが採用される<br>
      &nbsp;&nbsp;&nbsp; unsigned int m_HalfCellSize{ 1 }; // マス目サイズの 1/2<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline unsigned int CellSize() { return m_CellSize; }<br>
      &nbsp;&nbsp;&nbsp; inline unsigned int HalfCellSize() { return m_HalfCellSize; }<br>
      &nbsp;&nbsp;&nbsp; inline void SetCellSize(unsigned int cellSize) { m_CellSize = cellSize; m_HalfCellSize = m_CellSize / 2; }<br>
      &nbsp;&nbsp;&nbsp; MapRange spawnRange; // 敵の新規出現レンジをプレイヤから半径X,Yの楕円にする<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline float centerX(int cellX) const { return (cellX &gt;= 0) ? (float)((cellX * m_CellSize) + m_HalfCellSize) : (float)((cellX + 1) * m_CellSize) - m_HalfCellSize; } //マス目サイズ/2ずらし<br>
      &nbsp;&nbsp;&nbsp; inline float centerY(int cellY) const { return (cellY &gt;= 0) ? (float)((cellY * m_CellSize) + m_HalfCellSize) : (float)((cellY + 1) * m_CellSize) - m_HalfCellSize; } //マス目サイズ/2ずらし<br>
      &nbsp;&nbsp;&nbsp; inline float centerZ(int cellZ) const { return (cellZ &gt;= 0) ? (float)((cellZ * m_CellSize) + m_HalfCellSize) : (float)((cellZ + 1) * m_CellSize) - m_HalfCellSize; } //マス目サイズ/2ずらし<br>
      &nbsp;&nbsp;&nbsp; inline int cellX(float worldX) const { return (worldX &gt;= 0) ? (int)worldX / m_CellSize : (int)worldX / m_CellSize - 1; } // マイナス方向にも対応<br>
      &nbsp;&nbsp;&nbsp; inline int cellY(float worldY) const { return (worldY &gt;= 0) ? (int)worldY / m_CellSize : (int)worldY / m_CellSize - 1; } // マイナス方向にも対応<br>
      &nbsp;&nbsp;&nbsp; inline int cellZ(float worldZ) const { return (worldZ &gt;= 0) ? (int)worldZ / m_CellSize : (int)worldZ / m_CellSize - 1; } // マイナス方向にも対応<br>
      <br>
      &nbsp;&nbsp;&nbsp; TMXCsv enemyData;// 敵配置データ<br>
      &nbsp;&nbsp;&nbsp; TMXJson tmxData; // タイルマップエディタのjsonデータ<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // &lt;gid→idに対応したタイプのbit&gt; へ変換するvector型の辞書<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;TileBit&gt; gidTypeBits{ 0 };<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline TileBit&amp; gidTypeBit(unsigned int gid)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (gid &gt;= (int)gidTypeBits.size()) gidTypeBits.resize(gid + 1, 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (gid &lt; 0) ? gidTypeBits[0] : gidTypeBits[gid];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // id→ビットのタイプ の辞書に |= でbitTypeをビット論理和して、Wall:壁 や Bounce:はずむ などの特性を追加する<br>
      &nbsp;&nbsp;&nbsp; TileBit SetTypeBit(unsigned int gid, TileBit bitType) { return gidTypeBit(gid) |= bitType; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // id→ビットのタイプ の辞書で &amp; ビット論理積で 指定したidが Wall:壁 や Bounce:はずむ などの特性を持つかを判定する<br>
      &nbsp;&nbsp;&nbsp; inline bool isType(unsigned int gid, TileType bitType) { return gidTypeBit(gid) &amp; bitType; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // id→ビットのタイプ の辞書で &amp; ビット論理積で 指定したidが Wall:壁 や Bounce:はずむ などの特性を持つかを判定し一致したBitを返す(複数が1のビットもありうる)<br>
      &nbsp;&nbsp;&nbsp; inline TileBit matchTypes(unsigned int gid, TileBit bitType) { return gidTypeBit(gid) &amp; bitType; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // tilesetsの.tsxのfirstgidをたどって、SetTypeBitでビット辞書に<br>
      &nbsp;&nbsp;&nbsp; // csvのtileSettingsから読み取っておいたビット設定を登録<br>
      &nbsp;&nbsp;&nbsp; bool InitTypeBit(const Tilesets&amp; tilesets)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(tilesets.size() &gt; 0 &amp;&amp; "ステージのjsonファイルにタイルセット設定が一つもありません");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tilesets.size() == 0) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; pair : tilesets)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto firstgid = pair.first;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; tsxFilePath = pair.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; tsxInfo = tilesets.umTsxInfo.at(tsxFilePath);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [親フォルダを抽出] https://qiita.com/takano_tak/items/acf34b4a30cb974bab65<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t path_i = tsxFilePath.find_last_of("\\/");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (path_i + 1 &gt;= tsxFilePath.size()) continue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto tsxFile = tsxFilePath.substr(path_i + 1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto csvInfo = tileSettings.info.find(tsxFile);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (csvInfo == end(tileSettings.info)) continue; // csv側にタイルの情報がなかった<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // gidが0 idが-1 のデフォルトのタイルのビット特性を設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetTypeBit(0, csvInfo-&gt;second-&gt;idTypeBit(-1));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id = 0; // gidじゃなく0から始まるローカルなid<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto gid = firstgid, iEnd = firstgid + tsxInfo.tilecount; gid &lt; iEnd; ++gid)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // このMapのgidのビット辞書にcsvのtileSettingsから読み取っておいたビット設定を登録<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetTypeBit(gid, csvInfo-&gt;second-&gt;idTypeBit(id));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++id; // ローカルなidも次に進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // マップファイルのロード<br>
      &nbsp;&nbsp;&nbsp; void Load(const std::string&amp; filePath)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;FilePath = filePath;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★jsonファイルの読み込み<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmxData.Load(filePath);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // tilesetsの.tsxのfirstgidをたどって、SetTypeBitでビット辞書に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // csvのtileSettingsから読み取っておいたビット設定を登録<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitTypeBit(tmxData.tilesets);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto info = settings[filePath];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (info.spawnRange.umRange.size() != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnRange = info.spawnRange;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnRange.InitRange(MapRange::Type::Ellipse, 10, 10);// 敵の新規出現レンジをプレイヤから半径X,Yの楕円にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (info.CellSize != 1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetCellSize(info.CellSize); // csvに書かれているCellSizeを設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmxData.SetGridSize({(float)info.CellSize ,(float)info.CellSize ,(float)info.CellSize });<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // if (info.CellSize == 1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetCellSize(tmxData.tmxInfo.tilewidth); // tmxのタイルの幅を取得<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // 指定された座標（ワールド座標）の地形データを取得する<br>
      &nbsp;&nbsp;&nbsp; unsigned int GetTerrain(float worldX, float worldY, float worldZ = (std::numeric_limits&lt;float&gt;::min)())<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (worldZ != (std::numeric_limits&lt;float&gt;::min)())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float tmpY = worldY;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worldY = worldZ; //【YとZを変換】Zの入力があるときはZをYとして扱う<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worldZ = tmpY; //【YとZを変換】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 負の座標が指定された場合は、何も無いものとして扱う<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (worldX &lt; 0 || worldY &lt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Tile::None;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapX = (int)(worldX / m_CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapY = (int)(worldY / m_CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapZ = (int)(worldZ / m_CellSize);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tmxData.terrains.count(mapZ) == 0) // zの階層がまだなかったとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Tile::None; // 配列の範囲外は、何も無いものとして扱う<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; terrainZ = tmxData.terrains[mapZ]; // 辞書からZに対応するデータへの参照を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mapY &gt;= terrainZ.size() || mapX &gt;= terrainZ[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Tile::None; // 配列の範囲外は、何も無いものとして扱う<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return terrainZ[mapY][mapX]; // 二次元配列から地形IDを取り出して返却する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 指定された座標（ワールド座標）の地形データを書き換える return には書き換える前のgidが返る<br>
      &nbsp;&nbsp;&nbsp; bool SetTerrain(unsigned int gid, float worldX, float worldY, float worldZ = (std::numeric_limits&lt;float&gt;::min)())<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (worldZ != (std::numeric_limits&lt;float&gt;::min)())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float tmpY = worldY;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worldY = worldZ; //【YとZを変換】Zの入力があるときはZをYとして扱う<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worldZ = tmpY; //【YとZを変換】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 負の座標が指定された場合は、書き換えられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (worldX &lt; 0 || worldY &lt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapX = (int)(worldX / m_CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapY = (int)(worldY / m_CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapZ = (int)(worldZ / m_CellSize);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 二次元配列の範囲外は、書き換えられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (mapY &gt;= terrain.size() || mapX &gt;= terrain[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isNewZ = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tmxData.terrains.count(mapZ) == 0) isNewZ = true; // 新しい z の階層の場合<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; terrainZ = tmxData.terrains[mapZ]; // 辞書からZに対応するデータへの参照を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isNewZ) // 新しい z の階層の場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainZ.z = mapZ;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainZ.tilesets = &amp;(tmxData.tilesets); //&nbsp; 新しい z の階層のtilesetsを設定する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainZ.Width = tmxData.tmxInfo.width; terrainZ.Height = tmxData.tmxInfo.height;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; terrinZYX = terrainZ[mapY][mapX];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrinZYX.tilesets = &amp;(tmxData.tilesets);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrinZYX = gid; // 地形データ書き換え<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainZ[mapY][mapX] = gid; // 地形データ書き換え<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // gidに応じてタイルを描き分ける<br>
      &nbsp;&nbsp;&nbsp; void DrawTile(unsigned int gid, float worldX, float worldY, float worldZ, float ExRate)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto texture = TsxInfo::id_images[gid].second.lock();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id = TsxInfo::id_images[gid].first;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isType(gid, TileType::Floor)) // 板ポリゴンで床を描く <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaFloorF3D(MyDraw::Plane::Y, worldX, worldY, worldZ, ExRate, 0, *texture, id);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isType(gid, TileType::Wall)) //壁のときはボックスを描く <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(worldX, worldY, worldZ, ExRate, *texture, id);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 地形をタイルで描く<br>
      &nbsp;&nbsp;&nbsp; void DrawTerrain()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; terrainN : tmxData.terrains)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; terrainZ = *terrainN.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cellZ = terrainN.first;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int cellY = 0, ySize = terrainZ.size(); cellY &lt; ySize; cellY++)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int cellX = 0, xSize = terrainZ[cellY].size(); cellX &lt; ySize; cellX++)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x = centerX(cellX); //マス目サイズ/2ずらし<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float y = centerY(cellY); //マス目サイズ/2ずらし<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float z = centerZ(cellZ); //マス目サイズ/2ずらし<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id = -1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int gid = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cellY &lt; terrainZ.size() &amp;&amp; cellX &lt; terrainZ[cellY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gid = terrainZ[cellY][cellX];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0 &lt;= gid &amp;&amp; gid &lt; TsxInfo::id_images.size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pTileImage = TsxInfo::id_images[gid].second.lock();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pTileImage == nullptr) continue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // ワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //auto stepXYZs = MyMath::CrossGridVec(camera-&gt;pos - camera-&gt;m_targetXYZ, Vector3{ CellSize, CellSize, CellSize });<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float ExRate = (float)m_CellSize / (float)pTileImage-&gt;m_XSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawTile(gid, x, z, y, ExRate); // idに応じてタイルを描き分ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 指定された座標（ワールド座標）の地形が壁か調べる<br>
      &nbsp;&nbsp;&nbsp; inline bool IsWall(float worldX, float worldY, float worldZ = (std::numeric_limits&lt;float&gt;::min)())<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto terrainID = GetTerrain(worldX, worldY, worldZ); // 指定された座標の地形のIDを取得<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return IsWall(terrainID);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //あるIDが壁かどうかだけ調べる<br>
      &nbsp;&nbsp;&nbsp; inline bool IsWall(unsigned int gid)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 地形が壁ならtrue、違うならfalseを返却する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return isType(gid, TileType::Wall);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 指定された座標worldPosの地形が 壁 や ダメージブロックかなどをチェックする関数<br>
      &nbsp;&nbsp;&nbsp; bool checkID(TileBit checkBit, float worldX, float worldY, float worldZ,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, unsigned int* pTerrainID = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int terrainID; // 指定された座標の地形のID<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (worldZ != (std::numeric_limits&lt;float&gt;::min)())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //【YとZを変換】Zの入力があるときはZをYとして扱う タイルマップの X,Yは3DではYがZ:奥行に対応するから<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float tmpY = worldY;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worldY = worldZ;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worldZ = tmpY; //【YとZを変換】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (worldX &lt; 0 || worldY &lt; 0) return false; // 負の座標が指定された場合<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapX = cellX(worldX), mapY = cellY(worldY), mapZ = cellZ(worldZ);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tmxData.terrains.count(mapZ) == 0) // zの階層がまだなかったときは 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainID = 0; // 範囲外のときは 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // zの階層がすでにあったとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 二次元配列の範囲内か判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; terrainZ = tmxData.terrains[mapZ];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mapY &gt;= terrainZ.size() || mapX &gt;= terrainZ[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainID = 0; // 範囲外のときは 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainID = terrainZ[mapY][mapX]; // 配列から地形IDを取り出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pTerrainID != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pTerrainID = terrainID;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TileBit matchBits = matchTypes(terrainID, checkBit); // ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCheckBit = matchBits != (TileBit)TileType::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCheckBit &amp;&amp; pMapX != nullptr &amp;&amp; pMapY != nullptr &amp;&amp; pMapZ != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pMapX = mapX, * pMapY = mapY, * pMapZ = mapZ; // ブロックのマス目のセル番号をポインタに記録(nullptrの場合は記録しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMatchBits != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pMatchBits = matchBits; // マッチしたビットをポインタ先に代入して返す<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return isCheckBit;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Map.cppを新規作成</code>して、static変数の初期化でcsvなどをロードしましょう。</p>
    <p class="source">#include "Map.h"<br>
      <br>
      MapSetting Map::settings{ "Map/MapSetting.csv" }; // マップ一覧情報<br>
      <br>
      TileSetting Map::tileSettings{ "Map/MapSetting.csv" }; // タイル情報<br>
    </p>
    <br>
    <br>
    <p><code>World.hを変更</code>して、Mapの前方宣言と共有ポインタとマップをロードする関数を宣言しましょう。</p>
    <p class="source">#ifndef WORLD_H_<br>
      #define WORLD_H_<br>
      <br>
      #include &lt;list&gt;<br>
      #include &lt;memory&gt;<br>
      #include &lt;unordered_map&gt;<br>
      #include &lt;functional&gt; // std::functionのラムダ式 で 関数を Draw関数の引数にして、カメラすべてに対して描画処理を発動させる <br>
      <br>
      #include "MyHash.h" // ワールドのタグをhash32型で管理する<br>
      <br>
      <br>
      // [前方宣言] 宣言だけして、#includeはしてないので、ポインタだけはこのファイル内でつかえる<br>
      // #includeはしてないので、hpなどの変数には#include "～.h"しないとアクセスできないので循環インクルード防止のため.cppでインクルードしてください<br>
      class GameScene;<br>
      class Player;<br>
      class PlayerBullet;<br>
      class Enemy;<br>
      class Camera;<br>
      class Grid;<br>
      <em>class Map;</em><br>
      <br>
      // プレイヤや敵や弾などの共有ポインタを管理し、EraseRemoveIfで消して参照カウンタが0になったらそれらを消滅させるクラス(C#のガベージコレクタの代わり)<br>
      class World<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline World(GameScene* pScene, const std::string&amp; worldTag = "") : m_pScene{ pScene }, tag{ worldTag } {}<br>
      &nbsp;&nbsp;&nbsp; inline ~World() {}<br>
      protected: // public:にすると他で外部で後からタグやシーンを書き換えられると辞書での管理などの前提がおかしくなるのでprotected:する<br>
      &nbsp;&nbsp;&nbsp; hash32 tag{ "" }; // ワールド名のタグ<br>
      &nbsp;&nbsp;&nbsp; GameScene* m_pScene{ nullptr }; // ワールドを所有するシーン<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; hash32 Tag() const { return tag; }<br>
      &nbsp;&nbsp;&nbsp; GameScene* scene() { return m_pScene; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //std::unordered_map&lt;hash32, std::shared_ptr&lt;Player&gt;&gt; players; // プレイヤのタグ辞書<br>
      &nbsp;&nbsp;&nbsp; // ワールドを所有するシーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp; void AddPlayer(const std::string&amp; playerTag, std::shared_ptr&lt;Player&gt; pPlayer);<br>
      &nbsp;&nbsp;&nbsp; // ワールドにいるプレイヤを得る<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;Player&gt;&gt; GetPlayers();<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>bool LoadMap(const std::string&amp; mapFilePath); // ワールドのマップをロード<br>
        <br>
        &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Map&gt; map{ nullptr }; // マップ(共有ポインタ) マップのメモリ解放は World と運命をともにして消える<br>
      </em><br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Grid&gt; m_pGrid{ nullptr }; // 当たり判定を高速にするためグリッドで空間分割<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; Grid* grid() { return m_pGrid.get(); } // グリッドを返す<br>
      &nbsp;&nbsp;&nbsp; Grid* makeGrid(int cellWidth = 128, int cellHeight = 128, int cellDepth = 128); // グリッドを生成する<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;Player&gt;&gt; players; // プレイヤのタグ辞書<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;PlayerBullet&gt;&gt; playerBullets; // 自機弾のリスト <br>
      <br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 削除処理を共通テンプレート関数にする<br>
      &nbsp;&nbsp;&nbsp; // [共通テンプレート関数]https://programming-place.net/ppp/contents/cpp/language/009.html#function_template<br>
      &nbsp;&nbsp;&nbsp; template &lt;typename TypeT, class T_if&gt;<br>
      &nbsp;&nbsp;&nbsp; void EraseRemoveIf(std::list&lt;TypeT&gt;&amp; v, T_if if_condition)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 特定のタイプT↑&nbsp; ↑配列v&nbsp;&nbsp; ↑条件式if_condition<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; v.erase(<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::remove_if(v.begin(), v.end(), if_condition),<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; v.end() //&nbsp; ↓remove_ifの位置<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; );//例.[生][生][死][死][死]← v.end()の位置<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;Camera&gt;&gt; cameras; // このワールドに存在するカメラの辞書&lt;カメラにつけたタグ, カメラの共有ポインタ&gt;<br>
      &nbsp;&nbsp;&nbsp; // 指定されたタグのカメラへの共有ポインタを得る　カメラ辞書に存在しないタグでアクセスしたときにunordered_mapの特性で勝手に意図しないカメラができるのを防ぐ関数<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Camera&gt; camera(const std::string&amp; cameraTag) { auto itr = cameras.find(cameraTag); return (itr != end(cameras)) ? itr-&gt;second : nullptr; }<br>
      &nbsp;&nbsp;&nbsp; // このワールドに存在するカメラすべてに対して drawFuncで描きたい処理を渡して 全カメラのスクリーンに対して描画処理を走らせる<br>
      &nbsp;&nbsp;&nbsp; void Draw(std::function&lt;void()&gt; drawFunc) noexcept;<br>
      &nbsp;&nbsp;&nbsp; // カメラにタグをつけてワールドに追加 カメラにもワールドへのポインタリンクを張る<br>
      &nbsp;&nbsp;&nbsp; inline bool AddCamera(const std::string&amp; cameraTag, std::shared_ptr&lt;Camera&gt; pCamera);<br>
      &nbsp;&nbsp;&nbsp; // 指定したタグのカメラをこのワールドから削除する カメラ側の worldへのリンクのポインタも nullptr にする<br>
      &nbsp;&nbsp;&nbsp; inline bool EraseCamera(const std::string&amp; cameraTag);<br>
      &nbsp;&nbsp;&nbsp; // カメラを nowWorld から nextWorld に移動させる<br>
      &nbsp;&nbsp;&nbsp; static bool MoveCamera(const std::string&amp; cameraTag, World* nowWorld, World* nextWorld);<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>World.cppを変更</code>して、Mapをstd::make_sharedで生成する処理を記述しましょう。</p>
    <p class="source">#include "World.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Camera.h"<br>
      #include "Screen.h"<br>
      <br>
      #include "GameScene.h"<br>
      <br>
      #include "GridObject.h" // Gridをmake_sharedで生成するため<br>
      <em>#include "Map.h" // Mapをmake_sharedで生成するため</em><br>
      <br>
      Grid* World::makeGrid(int cellWidth, int cellHeight, int cellDepth)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (this-&gt;m_pGrid == nullptr) // グリッドが未生成の場合は生成<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;m_pGrid = std::make_shared&lt;Grid&gt;(cellWidth, cellHeight, cellDepth);<br>
      &nbsp;&nbsp;&nbsp; return this-&gt;m_pGrid.get();<br>
      }<br>
      <br>
      void World::AddPlayer(const std::string&amp; playerTag, std::shared_ptr&lt;Player&gt; pPlayer)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (m_pScene != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_pScene-&gt;players.emplace(playerTag, pPlayer); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // このワールドにいるプレイヤを得る<br>
      std::vector&lt;std::weak_ptr&lt;Player&gt;&gt; World::GetPlayers()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;Player&gt;&gt; players;<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; pPlayer : players)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; players.emplace_back(pPlayer);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; return players;<br>
      }<br>
      <br>
      <em>// ワールドのマップをロード<br>
        bool World::LoadMap(const std::string&amp; mapFilePath)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; map = std::make_shared&lt;Map&gt;(this, mapFilePath); // マップをファイルから読み込む<br>
        &nbsp;&nbsp;&nbsp; return map-&gt;tmxData.isInitialized; // 読込に成功したかを返す<br>
        }</em><br>
      <br>
      // カメラにタグをつけてワールドに追加 カメラにもワールドへの生ポインタリンクを渡す<br>
      bool World::AddCamera(const std::string&amp; cameraTag, std::shared_ptr&lt;Camera&gt; pCamera)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (pCamera == nullptr) return false;<br>
      &nbsp;&nbsp;&nbsp; if (cameras.count(cameraTag) &gt; 0) return false; // すでに同じタグのカメラがワールドにあったら false<br>
      &nbsp;&nbsp;&nbsp; if (pCamera-&gt;world() != nullptr) pCamera-&gt;world()-&gt;EraseCamera(cameraTag); // すでにカメラが別ワールドに配置されていたら別ワールドから削除<br>
      &nbsp;&nbsp;&nbsp; cameras.emplace(cameraTag, pCamera); // ワールドにカメラを追加する<br>
      &nbsp;&nbsp;&nbsp; pCamera-&gt;world(this); // カメラにもワールドへのポインタリンクを張る<b>(カメラ側に渡すのは共有ポインタではない生ポインタだから共有デッドロックにはならない)</b><br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      // 指定したタグのカメラをこのワールドから削除する カメラ側の worldへのリンクのポインタも nullptr にする<br>
      bool World::EraseCamera(const std::string&amp; cameraTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; auto itr = cameras.find(cameraTag); // 指定したタグのカメラを探す<br>
      &nbsp;&nbsp;&nbsp; if (itr == end(cameras)) return false; // 指定したタグのカメラがワールドにない<br>
      &nbsp;&nbsp;&nbsp; auto pCamera = itr-&gt;second;<br>
      &nbsp;&nbsp;&nbsp; pCamera-&gt;world(nullptr); // カメラ側の worldへのリンクのポインタも nullptrに<br>
      &nbsp;&nbsp;&nbsp; cameras.erase(cameraTag); // カメラを辞書から削除<br>
      <br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      // カメラを nowWorld から nextWorld に移動させる<br>
      bool World::MoveCamera(const std::string&amp; cameraTag, World* nowWorld, World* nextWorld)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (nowWorld == nullptr) return false;<br>
      &nbsp;&nbsp;&nbsp; auto itr = nowWorld-&gt;cameras.find(cameraTag); // タグでカメラを探す<br>
      &nbsp;&nbsp;&nbsp; if (itr == end(nowWorld-&gt;cameras)) return false; // タグに関連づいたカメラがなかった<br>
      &nbsp;&nbsp;&nbsp; auto targetCamera = itr-&gt;second; // カメラの共有ポインタをキープ(次の行でeraseしてもカメラの共有カウンタは0にはならずこのリンクのおかげでカメラはメモリに残存)<br>
      &nbsp;&nbsp;&nbsp; targetCamera-&gt;world(nullptr); // カメラ側の worldへのリンクのポインタを一旦 nullptrに<br>
      &nbsp;&nbsp;&nbsp; nowWorld-&gt;cameras.erase(cameraTag); // nowWorld からは カメラを消す<br>
      &nbsp;&nbsp;&nbsp; if (nextWorld == nullptr) return false;<br>
      <br>
      &nbsp;&nbsp;&nbsp; return nextWorld-&gt;AddCamera(cameraTag, targetCamera); // 次のワールドにカメラを追加する<br>
      }<br>
      <br>
      // このワールドに存在するカメラすべてに対して funcで描きたい処理を渡して 全カメラのスクリーンに対して描画処理を走らせる<br>
      void World::Draw(std::function&lt;void()&gt; drawFunc) noexcept<br>
      {<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : cameras)&nbsp;&nbsp;&nbsp; // このワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; VECTOR_D beforeCamPos; // 設定変更前のカメラのパラメータを一旦、保管<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; double beforeVRot, beforeHRot, beforeTRot, beforeNear, beforeFar, beforeFov;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Camera::GetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;beforeFov, &amp;beforeNear, &amp;beforeFar);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //camera-&gt;screenID<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DxLib::SetCameraPositionAndAngle(camera-&gt;pos, camera-&gt;rot.V, camera-&gt;rot.H, camera-&gt;rot.T); // 各カメラの位置、回転を設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Screen::Start(camera-&gt;screenHandle, true, camera-&gt;fovAngle); // カメラに関連付けられたスクリーンIDを描画先にする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; drawFunc(); // 渡された描画処理を実行<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Screen::End(true); // 描画先を元に戻す<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // カメラの設定をもとに戻しておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Camera::SetCameraSettings(&amp;beforeCamPos, &amp;beforeVRot, &amp;beforeHRot, &amp;beforeTRot, &amp;beforeFov, &amp;beforeNear, &amp;beforeFar);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    <p><code>GameScene.cppを変更</code>して、タイルマップ読み込む処理と3D表示で描く処理を実装しましょう。<br>
    </p>
    <p class="source">#include "GameScene.h"<br>
      <br>
      #include "Player.h"<br>
      <em>#include "Map.h"</em><br>
      <br>
      GameSceneSetting GameScene::settings{ "Map/GameSceneSetting.csv" }; // ゲームシーンの設定情報<br>
      <br>
      // 指定したゲームシーンのタグに関連づいたファイル名に対応したワールドを初期化する<br>
      bool GameScene::LoadWorlds(const std::string&amp; gameSceneTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (settings.info.count(gameSceneTag) == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto&amp; info = settings[gameSceneTag];<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; tag_mapPath : info)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateWorld(tag_mapPath.second.tag); // ワールドをタグをつけて生成<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// ワールドのマップをロード<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worlds[tag_mapPath.second.tag]-&gt;LoadMap(tag_mapPath.second.mapFilePath);</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      void GameScene::ChangeWorld(const std::string&amp; worldTag, std::shared_ptr&lt;Player&gt; pPlayer)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (pPlayer == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp; if (worlds.count(worldTag) == 0) return; // 存在しないタグだった<br>
      <br>
      &nbsp;&nbsp;&nbsp; pPlayer-&gt;world(worlds[worldTag].get()); // ワールドへのリンクをすげ替える<br>
      }<br>
      <br>
      <br>
      void GameScene::Initialize()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Ｚバッファを有効にする [Zの深度]<br>
      &nbsp;&nbsp;&nbsp; //[参考]https://docs.google.com/presentation/d/1Z23t1yAS7uzPDVakgW_M02p20qt9DeTs4ku4IiMDLco/edit?usp=sharing<br>
      &nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する<br>
      &nbsp;&nbsp;&nbsp; // ( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを2つ生成 画面の全体の縦方向サイズの Height / 2 にして、上下分割で配置できるようにする<br>
      &nbsp;&nbsp;&nbsp; screenHandle0 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      &nbsp;&nbsp;&nbsp; screenHandle1 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>Resource::MakeShared&lt;Texture&gt;(mapChipPath, 8, 8, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする</u><br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath1, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath2, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの生成<br>
      &nbsp;&nbsp;&nbsp; if (pWorld != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pWorld-&gt;AddCamera("カメラ1", Camera::defaultCamera); // カメラ1というタグをデフォルトカメラにつけてワールドにデフォルトカメラを配置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ1", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera1 = pWorld-&gt;camera("カメラ1"); // カメラ1 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera1-&gt;SetScreenHandle(screenHandle0); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer1 = Object::Create&lt;Player&gt;(nullptr, pWorld, Pad::Key, Vector3(90 + 256, 32, 95 + 256));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ1", pPlayer1); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath1]);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;camera = pCamera1.get(); // カメラをプレイヤにリンクする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;mass = 100.0f; // 体重を100にして衝突されてもびくともしないようにする<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ2", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera2 = pWorld-&gt;camera("カメラ2"); // プレイヤ2 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera2-&gt;SetScreenHandle(screenHandle1); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer2 = Object::Create&lt;Player&gt;(nullptr, pWorld, Pad::Two, Vector3(190, 32, 195));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ2", pPlayer2); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath2]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;camera = pCamera2.get(); // カメラをプレイヤにリンクする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;mass = 1.0f; // 体重を1にして普通にふっとぶようにする<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      <br>
      void GameScene::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle0); // 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle1); // 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; player : players)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player.second-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // グリッドを更新して隣接するグリッドに含まれる敵や弾の当たり判定を行う<br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; world : worlds)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (world.second-&gt;grid() != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; cell : world.second-&gt;grid()-&gt;cellData)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pGridObject = cell.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (pGridObject != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // while文で数珠つなぎのm_pNextを次々とたどって最後にたどり着くと次がなくてnullptrになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridObject-&gt;checkCell();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridObject = pGridObject-&gt;m_pNext; // リンクリスト構造を次々とたどる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      void GameScene::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>std::unordered_set&lt;World*&gt; drawEndSet; // すでに描いたWorldをポインタの<b>setでかぶらないように判定</b>する</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; player : players)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player.second-&gt;Draw(); // プレイヤの描画【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto world = player.second-&gt;world(); // プレイヤのいるワールド<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if (drawEndSet.count(world) &gt; 0) continue; // すでに描いたWorldは描かずスキップする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawEndSet.emplace(world); // 描いたWorldの<b>ポインタ住所をsetに登録</b>する<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; world-&gt;map-&gt;DrawTerrain(); // マップの描画</em><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>// プレイヤのいるワールドのカメラのみを描けば、プレイヤのいないワールドは描かずに済む<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 複数のカメラを 範囲 for文 で回す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; camera : player.second-&gt;world()-&gt;cameras)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ラムダ式[&amp;](){ ～ }で{}の外側の変数すべてを &amp; キャプチャで&amp;参照として「Draw関数の内側へ引き連れて」処理できる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera.second-&gt;Draw([&amp;]()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw関数() の 外側にある変数 mapChipPath も[&amp;]効果で { } の内側で問題なくアクセスできている↓<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(40, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 2);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 40, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 0);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3Dで6枚のタイル(12ポリゴン)でボックスを描く<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(0, 70, 40, 1.0, *std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[mapChipPath]), 8);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (camera.first == "カメラ1")<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらがプレイヤ1", GetColor(255, 0, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (camera.first == "カメラ2")<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, "こちらはプレイヤ2", GetColor(0, 255, 0));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</u><br>
      #ifdef _DEBUG&nbsp; // デバッグのときだけ_DEBUGが定義され描画される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (world-&gt;grid() != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; cell : world-&gt;grid()-&gt;cellData)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cell.second-&gt;Draw(); // グリッドの描画<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーン0の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, 0, screenHandle0, FALSE);<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, 0, Screen::Width, Screen::Height / 2, GetColor(255, 0, 0));<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーン1の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, Screen::Height / 2, screenHandle1, FALSE);<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, Screen::Height / 2, Screen::Width, Screen::Height, GetColor(0, 255, 0));<br>
      <br>
      }<br>
    </p>
    <br>
    いかがでしょう？マップにめり込む形ですが、タイルマップが3D表示で描かれたでしょうか?<br>
    <b>現状マップに当たり判定はないので、地面の代わりに 0 の位置までプレイヤはめり込みます</b>。<br>
    では次の章では、マップの当たり判定を作成していきましょう。<br>
    <br>
    <br>
    <a id="mozTocId0011" class="mozTocH1">
      <h1>Map/MapSetting.csvの設定に合わせてタイルとの当たり判定をする</h1>
    </a> <br>
    では次は、タイルと当たり判定する処理をコンポーネントにして、タイルの上を歩けるようにしてゆきましょう。<br>
    <p><code>HitBoxComponent.hを新規作成</code>して、コンポーネントのオーナーの当たり判定のボックスの上下左右奥手前を取得できる機能を実装しましょう。<br>
    </p>
    <p class="source">#ifndef HITBOX_COMPONENT_H_<br>
      #define HITBOX_COMPONENT_H_<br>
      <br>
      #include "Component.h"<br>
      #include "GameObject.h"<br>
      #include "Vector3.h"<br>
      #include "MyDraw.h"<br>
      <br>
      class HitBoxComponent : public Component<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; HitBoxComponent(std::shared_ptr&lt;GameObject&gt; pOwner, Vector3 boxSize, Vector3 offsetLeftBottomBack, Vector3 offsetRightTopForward)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Component(pOwner), m_BoxSize{ boxSize }, m_OffsetLeftBottomBack{ offsetLeftBottomBack }, m_OffsetRightTopForward{ offsetRightTopForward }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StorePostionAndHitBox(); // ヒットボックスの現在の境界を一旦 prev に 初期保管<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual ~HitBoxComponent() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; Vector3 m_BoxSize; // ボックスの幅X、高さY、奥行Z<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 m_OffsetLeftBottomBack; // ヒットボックスのオフセット(X左、Y底、Z手前)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float hitboxOffsetLeft, hitboxOffsetBottom, hitboxOffsetBack; };<br>
      &nbsp;&nbsp;&nbsp; };<br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 m_OffsetRightTopForward; // ヒットボックスのオフセット(X右、Y上、Z奥)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float hitboxOffsetRight, hitboxOffsetTop, hitboxOffsetForward; };<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; Vector3 m_PrevPos; // 1フレーム前の位置 (動く雲に乗るなどに使う)<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 m_PrevLeftBottomBack; // 1フレーム前のボックスの境目位置 (動く雲に乗るなどに使う)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float prevLeft, prevBottom, prevBack; };<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 m_PrevRightTopForward; // 1フレーム前のボックスの境目位置 (動く雲に乗るなどに使う)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float prevRight, prevTop, prevForward; };<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 当たり判定の左端を取得<br>
      &nbsp;&nbsp;&nbsp; virtual inline float GetLeft()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (owner()-&gt;x - m_BoxSize.x / 2) + hitboxOffsetLeft;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 左端を指定することにより位置を設定する<br>
      &nbsp;&nbsp;&nbsp; virtual inline void SetLeft(float left)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owner()-&gt;x = left - hitboxOffsetLeft + m_BoxSize.x / 2;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 右端を取得<br>
      &nbsp;&nbsp;&nbsp; virtual inline float GetRight()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (owner()-&gt;x - m_BoxSize.x / 2) + m_BoxSize.x - hitboxOffsetRight;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 右端を指定することにより位置を設定する<br>
      &nbsp;&nbsp;&nbsp; virtual inline void SetRight(float right)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owner()-&gt;x = right + hitboxOffsetRight - m_BoxSize.x + m_BoxSize.x / 2;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 上端を取得<br>
      &nbsp;&nbsp;&nbsp; virtual inline float GetTop()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (owner()-&gt;y - m_BoxSize.y / 2) + m_BoxSize.y - hitboxOffsetTop;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 上端を指定することにより位置を設定する<br>
      &nbsp;&nbsp;&nbsp; virtual inline void SetTop(float top)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owner()-&gt;y = top + hitboxOffsetTop - m_BoxSize.y + m_BoxSize.y / 2;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 下端を取得する<br>
      &nbsp;&nbsp;&nbsp; virtual inline float GetBottom()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (owner()-&gt;y - m_BoxSize.y / 2) + hitboxOffsetBottom;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 下端を指定することにより位置を設定する<br>
      &nbsp;&nbsp;&nbsp; virtual inline void SetBottom(float bottom)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owner()-&gt;y = bottom - hitboxOffsetBottom + m_BoxSize.y / 2;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 当たり判定のZ手前側を取得<br>
      &nbsp;&nbsp;&nbsp; virtual inline float GetBack()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (owner()-&gt;z - m_BoxSize.z / 2) + hitboxOffsetBack;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Z手前側を指定することにより位置を設定する<br>
      &nbsp;&nbsp;&nbsp; virtual inline void SetBack(float back)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owner()-&gt;z = back - hitboxOffsetBack + m_BoxSize.z / 2;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Z奥行き方向位置を取得<br>
      &nbsp;&nbsp;&nbsp; virtual inline float GetForward()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (owner()-&gt;z - m_BoxSize.z / 2) + m_BoxSize.z - hitboxOffsetForward;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Z奥行き方向位置を指定することにより位置を設定する<br>
      &nbsp;&nbsp;&nbsp; virtual inline void SetForward(float forward)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owner()-&gt;z = forward + hitboxOffsetForward - m_BoxSize.z + m_BoxSize.z / 2;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 雲に乗る系のための1フレーム前処理関数群<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // 1フレーム前からの移動量（x方向）<br>
      &nbsp;&nbsp;&nbsp; virtual inline float GetDeltaX()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return owner()-&gt;x - m_PrevPos.x;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 1フレーム前からの移動量（y方向）<br>
      &nbsp;&nbsp;&nbsp; virtual inline float GetDeltaY()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return owner()-&gt;y - m_PrevPos.y;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 1フレーム前からの移動量（z方向）<br>
      &nbsp;&nbsp;&nbsp; virtual inline float GetDeltaZ()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return owner()-&gt;z - m_PrevPos.z;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // 1フレーム前の X 左端を取得する<br>
      &nbsp;&nbsp;&nbsp; virtual inline float GetPrevLeft()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return prevLeft;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 1フレーム前の X 右端を取得する<br>
      &nbsp;&nbsp;&nbsp; virtual inline float GetPrevRight()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return prevRight;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 1フレーム前の Y 上端を取得する<br>
      &nbsp;&nbsp;&nbsp; virtual inline float GetPrevTop()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return prevTop;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 1フレーム前の Y 下端を取得する<br>
      &nbsp;&nbsp;&nbsp; virtual inline float GetPrevBottom()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return prevBottom;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 1フレーム前の Z 前方を取得する<br>
      &nbsp;&nbsp;&nbsp; virtual inline float GetPrevForward()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return prevForward;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 1フレーム前の Z 後方を取得する<br>
      &nbsp;&nbsp;&nbsp; virtual inline float GetPrevBack()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return prevBack;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 1フレーム前の場所と当たり判定を記憶する<br>
      &nbsp;&nbsp;&nbsp; virtual inline void StorePostionAndHitBox()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_PrevPos = pOwner-&gt;position;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevLeft = GetLeft();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevRight = GetRight();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevTop = GetTop();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevBottom = GetBottom();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevForward = GetForward();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevBack = GetBack();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 当たり判定を描画（デバッグ用）<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 赤で当たり判定の四角Boxを描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawLineBox(Vector3(GetLeft(), GetBottom(), GetBack()), Vector3(GetRight(), GetTop(), GetForward()), GetColor(255, 0, 0));<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    HitBoxComponentを継承overrideしてMapと当たり判定するコンポーネントを作成しましょう。<br>
    <p><code>MapHitBoxComponent.hを新規作成</code>して、マップのタイルから壁や床などのビットを取得して当たり判定と押し戻しする機能を実装しましょう。<br>
    </p>
    <p class="source">#ifndef MAP_HITBOX_COMPONENT_H_<br>
      #define MAP_HITBOX_COMPONENT_H_<br>
      <br>
      #include "HitBoxComponent.h"<br>
      <br>
      #include "Tile.h" // Tile::isType(terrainID, checkBit)関数を使って ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      #include "Map.h"<br>
      <br>
      class MapHitBoxComponent : public HitBoxComponent<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; MapHitBoxComponent(std::shared_ptr&lt;GameObject&gt; pOwner, Vector3 boxSize, Vector3 offsetLeftBottomBack, Vector3 offsetRightTopForward)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : HitBoxComponent(pOwner, boxSize, offsetLeftBottomBack, offsetRightTopForward) {}<br>
      &nbsp;&nbsp;&nbsp; virtual ~MapHitBoxComponent() {}<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp; // デバッグ用に最後に当たったXYZの位置などを記録する<br>
      &nbsp;&nbsp;&nbsp; float debugHitX = 0.0f, debugHitY = 0.0f, debugHitZ = 0.0f;<br>
      &nbsp;&nbsp;&nbsp; HitBit debugHitPart = (HitBit)HitPart::None;<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; // 当たり判定を描画（デバッグ用）<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HitBoxComponent::Draw(obj); // 継承もとのDrawも呼び出す<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ヒットしたパートを青四角で描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (debugHitPart &amp; HitPart::Left || debugHitPart &amp; HitPart::Right)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawLineBox(Vector3(debugHitX - 1, debugHitY - m_BoxSize.y / 2, debugHitZ - m_BoxSize.z / 2),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3(debugHitX + 1, debugHitY + m_BoxSize.y / 2, debugHitZ + m_BoxSize.z / 2), GetColor(0, 0, 255));<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (debugHitPart &amp; HitPart::Bottom || debugHitPart &amp; HitPart::Top)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawLineBox(Vector3(debugHitX - m_BoxSize.x / 2, debugHitY - 1, debugHitZ - m_BoxSize.z / 2),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3(debugHitX + m_BoxSize.x / 2, debugHitY + 1, debugHitZ + m_BoxSize.z / 2), GetColor(0, 0, 255));<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (debugHitPart &amp; HitPart::Back || debugHitPart &amp; HitPart::Forward)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawLineBox(Vector3(debugHitX - m_BoxSize.x / 2, debugHitY - m_BoxSize.y / 2, debugHitZ - 1),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3(debugHitX + m_BoxSize.x / 2, debugHitY + m_BoxSize.y / 2, debugHitZ + 1), GetColor(0, 0, 255));<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ヒットボックスの当たり判定の隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp; virtual inline bool GetHitBorder(float* pXLeft, float* pXMiddle, float* pXRight, float* pYBottom, float* pYMiddle, float* pYTop, float* pZBack, float* pZMiddle, float* pZForward)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return false; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 当たり判定の隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xLeft = GetLeft();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xRight = GetRight();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pXLeft != nullptr) *pXLeft = xLeft + 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pXMiddle != nullptr) *pXMiddle = xLeft + (xRight - xLeft) / 2; // xの中間点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pXRight != nullptr) *pXRight = xRight - 0.01f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yBottom = GetBottom();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yTop = GetTop();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pYBottom != nullptr) *pYBottom = yBottom; // 底はisGround状態を維持するため +0.01fしない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pYMiddle != nullptr) *pYMiddle = yBottom + (yTop - yBottom) / 2; // yの中間点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pYTop != nullptr) *pYTop = yTop - 0.01f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float zBack = GetBack();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float zForward = GetForward();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pZBack != nullptr) *pZBack = zBack + 0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pZMiddle != nullptr) *pZMiddle = zBack + (zForward - zBack) / 2; // zの中間点<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pZForward != nullptr) *pZForward = zForward - 0.01f;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void OnHitLeft(HitBit hitPartBitX, TileBit checkBit, float xLeft, float xMiddle, float xRight, float yBottom, float yMiddle, float yTop, float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;OnHitTile(HitPart::Left, hitPartBitX, checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★[C++は小数点の % 余り演算がない!] https://marycore.jp/prog/c-lang/modulo-floating-point-number/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float wallRight = xLeft - (float)std::fmod(xLeft, pOwner-&gt;map()-&gt;CellSize()) + pOwner-&gt;map()-&gt;CellSize(); // 壁の右端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetLeft(wallRight); // キャラの左端を壁の右端に沿わす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;vx = 0;<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; debugHitPart = (HitBit)HitPart::Left; debugHitX = xLeft; debugHitY = yMiddle; debugHitZ = zMiddle;<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void OnHitRight(HitBit hitPartBitX, TileBit checkBit, float xLeft, float xMiddle, float xRight, float yBottom, float yMiddle, float yTop, float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;OnHitTile(HitPart::Right, hitPartBitX, checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float wallLeft = xRight - (float)std::fmod(xRight, pOwner-&gt;map()-&gt;CellSize()); // 壁の左端<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetRight(wallLeft); // キャラの右端を壁の左端に沿わす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;vx = 0;<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; debugHitPart = (HitBit)HitPart::Right; debugHitX = xRight; debugHitY = yMiddle; debugHitZ = zMiddle;<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // X方向[左端、右端]が checkBit かどうかのビット論理積 &amp; をとり、OnHitLeft か OnHitRight をコールバックする<br>
      &nbsp;&nbsp;&nbsp; inline HitBit hitCheckX(TileBit checkBit, unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return (HitBit)HitPart::None; // オーナーがすでにメモリから解放済のときは return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner-&gt;map() == nullptr) return (HitBit)HitPart::None;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 当たり判定の隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetHitBorder(&amp;xLeft, &amp;xMiddle, &amp;xRight, &amp;yBottom, &amp;yMiddle, &amp;yTop, &amp;zBack, &amp;zMiddle, &amp;zForward);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HitBit hitPartBitX = hitcheckX(checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★ 左端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (HitPart::Left &amp; hitPartBitX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 左端がぶつかったときのコールバック関数を呼ぶ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnHitLeft(hitPartBitX, checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右端が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (HitPart::Right &amp; hitPartBitX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 左端がぶつかったときのコールバック関数を呼ぶ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnHitRight(hitPartBitX, checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitPartBitX;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void OnHitBottom(HitBit hitPartBitY, TileBit checkBit, float xLeft, float xMiddle, float xRight, float yBottom, float yMiddle, float yTop, float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;OnHitTile(HitPart::Bottom, hitPartBitY, checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yBottomHit = yBottom; // めり込んだy位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float pushUpY = pOwner-&gt;map()-&gt;CellSize(); // Y方向押し上げ高さ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMatchBits != nullptr &amp;&amp; (*pMatchBits) &amp; (TileBit)TileType::Floor) // 床にめり込んだ場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yBottomHit = yBottom + pOwner-&gt;map()-&gt;CellSize();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushUpY = 0; // 床の場合はマス目サイズCellSizeぶん上にはあげない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float wallTop = yBottomHit - (float)std::fmod(yBottomHit, pOwner-&gt;map()-&gt;CellSize()) + pushUpY; // 壁や床の上側<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetBottom(wallTop); // キャラの足元を壁のトップや床に沿わす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;vy = -0.01f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;isGround = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;isFlying = false;<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; debugHitPart = (HitBit)HitPart::Bottom; debugHitY = yBottom; debugHitX = xMiddle; debugHitZ = zMiddle;<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void OnHitTop(HitBit hitPartBitY, TileBit checkBit, float xLeft, float xMiddle, float xRight, float yBottom, float yMiddle, float yTop, float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr); // オーナーがすでにメモリから解放済のときは return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;OnHitTile(HitPart::Top, hitPartBitY, checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float wallBottom = yTop - (float)std::fmod(yTop, pOwner-&gt;map()-&gt;CellSize()); // 壁の下側<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetTop(wallBottom); // キャラのトップを壁の下側に沿わす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;vy = 0;<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; debugHitPart = (HitBit)HitPart::Top; debugHitY = yTop; debugHitX = xMiddle; debugHitZ = zMiddle;<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 空中にいるときのコールバック<br>
      &nbsp;&nbsp;&nbsp; virtual void OnAir(HitBit hitPartBitY, TileBit checkBit, float xLeft, float xMiddle, float xRight, float yBottom, float yMiddle, float yTop, float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;isGround = false; // 空中にいるので isGround を false に<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Y方向[下端、上端]が checkBit かどうかのビット論理積 &amp; をとり、OnHitBottom か OnHitTop をコールバックする<br>
      &nbsp;&nbsp;&nbsp; inline HitBit hitCheckY(TileBit checkBit, unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return (HitBit)HitPart::None; // オーナーがすでにメモリから解放済のときは return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner-&gt;map() == nullptr) return (HitBit)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pMap = pOwner-&gt;map();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 当たり判定の隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetHitBorder(&amp;xLeft, &amp;xMiddle, &amp;xRight, &amp;yBottom, &amp;yMiddle, &amp;yTop, &amp;zBack, &amp;zMiddle, &amp;zForward);<br>
      #if 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkBit &amp; (TileBit)TileType::Floor)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 床かをチェックする場合は現在より一つ上のCellSizeぶん上のタイルが床なら一つ下に壁があるときに上方向に押し戻したのと同じような形になる<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((int)HitPart::Bottom &amp; hitPartFloorBitY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 下端がぶつかったときのコールバック関数を呼ぶ 床の場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnHitBottom(hitPartFloorBitY, checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, &amp;matchFloorBit); // matchFloorBitには TileType::Floor のビットだけが1になったビットが渡される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMatchBits != nullptr) *pMatchBits = (TileBit)TileType::Floor; // ずらしてヒット判定したのであてになるのは TileType::Floor のビットのみなのでそれを |= ビット論理和する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitPartFloorBitY;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TileBit matchFloorBit = (TileBit)TileType::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 床にめりこんでいるか(床は特殊で一つ上のマス目が床であれば キャラが床より下にめりこんでいるということなので、CellSizeぶん↓上のマス目が床か調べ、下のマス目のTopに沿わせる)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HitBit hitPartFloorBitY = hitcheckBottomY((TileBit)TileType::Floor, xLeft, xMiddle, xRight, yBottom + pMap-&gt;CellSize(), yMiddle + pMap-&gt;CellSize(), yTop + pMap-&gt;CellSize(),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, &amp;matchFloorBit); // matchFloorBit は床にめり込んでいたらTileBit::Floorの 1の部分が1になっている<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 下側が床にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (HitPart::Bottom &amp; hitPartFloorBitY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnHitBottom(hitPartFloorBitY, checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, &amp;matchFloorBit); // ←matchFloorBit経由でFloorの 1の部分を床の押し戻しかの判定用に渡す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMatchBits != nullptr) *pMatchBits |= (TileBit)TileType::Floor; // ずらしてヒット判定したのであてになるのは TileType::Floor のビットのみなのでそれを |= ビット論理和する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitPartFloorBitY;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 下側が「床以外」にめりこんでいるか★↓ ^ 排他的論理和をFloorに対してとると、checkBitのFloorのビットが1だったら打ち消すことができる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HitBit hitPartBitY = hitcheckY(checkBit ^ (TileBit)TileType::Floor, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 下側が床以外にめり込んでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (HitPart::Bottom &amp; hitPartBitY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 下端がぶつかったときのコールバック関数を呼ぶ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnHitBottom(hitPartBitY, checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上側が床以外にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (HitPart::Top &amp; hitPartBitY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 上端がぶつかったときのコールバック関数を呼ぶ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnHitTop(hitPartBitY, checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // 空中にいるときのコールバック関数をよぶ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnAir(hitPartBitY, checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitPartBitY;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void OnHitBack(HitBit hitPartBitZ, TileBit checkBit, float xLeft, float xMiddle, float xRight, float yBottom, float yMiddle, float yTop, float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner-&gt;map() == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pMap = pOwner-&gt;map();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;OnHitTile(HitPart::Back, hitPartBitZ, checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float wallForward = zBack - (float)std::fmod(zBack, pMap-&gt;CellSize()) + pMap-&gt;CellSize(); // 壁の奥行き方向<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetBack(wallForward); // キャラの背中を壁のフォワードに沿わす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;vz = 0;<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; debugHitPart = (HitBit)HitPart::Back; debugHitZ = zBack; debugHitX = xMiddle; debugHitY = yMiddle;<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void OnHitForward(HitBit hitPartBitZ, TileBit checkBit, float xLeft, float xMiddle, float xRight, float yBottom, float yMiddle, float yTop, float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return; // オーナーがすでにメモリから解放済のときは return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner-&gt;map() == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pMap = pOwner-&gt;map();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;OnHitTile(HitPart::Forward, hitPartBitZ, checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float wallBack = zForward - (float)std::fmod(zForward, pMap-&gt;CellSize()); // 壁の手前側<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetForward(wallBack); // キャラのおでこを壁のバックに沿わす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pOwner-&gt;vz = 0;<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; debugHitPart = (HitBit)HitPart::Forward; debugHitZ = zForward; debugHitX = xMiddle; debugHitY = yMiddle;<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Z方向[z手前、Z奥]が checkBit かどうかのビット論理積 &amp; をとり、OnHitBack か OnHitForward をコールバックする<br>
      &nbsp;&nbsp;&nbsp; inline HitBit hitCheckZ(TileBit checkBit, unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return (HitBit)HitPart::None; // オーナーがすでにメモリから解放済のときは return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (pOwner-&gt;map() == nullptr) return (HitBit)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //auto pMap = pOwner-&gt;map();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 当たり判定の隅の座標(±0.01fで1ピクセル隣)を取得<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetHitBorder(&amp;xLeft, &amp;xMiddle, &amp;xRight, &amp;yBottom, &amp;yMiddle, &amp;yTop, &amp;zBack, &amp;zMiddle, &amp;zForward);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HitBit hitPartBitZ = hitcheckZ(checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 手前側が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (HitPart::Back &amp; hitPartBitZ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // Z手前 がぶつかったときのコールバック関数を呼ぶ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnHitBack(hitPartBitZ, checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 奥行き側が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (HitPart::Forward &amp; hitPartBitZ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // Z奥 がぶつかったときのコールバック関数を呼ぶ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnHitForward(hitPartBitZ, checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitPartBitZ;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 指定された座標worldPosの地形が 壁 や ダメージブロックかなどをチェックする関数<br>
      &nbsp;&nbsp;&nbsp; inline bool checkID(TileBit checkBit, float worldX, float worldY, float worldZ,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int terrain_gid; // 指定された座標の地形のID<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (worldZ != (std::numeric_limits&lt;float&gt;::min)())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //【YとZを変換】Zの入力があるときはZをYとして扱う タイルマップの X,Yは3DではYがZ:奥行に対応するから<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float tmpY = worldY;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worldY = worldZ;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worldZ = tmpY; //【YとZを変換】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (worldX &lt; 0 || worldY &lt; 0) return false; // 負の座標が指定された場合<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner(); // コンポーネントを所有するオーナーへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return false; // オーナーがすでにメモリから解放済のときは return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner-&gt;map() == nullptr) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Map* map = pOwner-&gt;map();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapX = map-&gt;cellX(worldX), mapY = map-&gt;cellY(worldY), mapZ = map-&gt;cellZ(worldZ);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (map-&gt;tmxData.terrains.count(mapZ) == 0) // zの階層がまだなかったときは 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrain_gid = 0; // 範囲外のときは0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // zの階層がすでにあったとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 二次元配列の範囲内か判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; terrainZ = map-&gt;tmxData.terrains[mapZ];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mapY &gt;= terrainZ.size() || mapX &gt;= terrainZ[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrain_gid = 0; // 範囲外のときは0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrain_gid = terrainZ[mapY][mapX]; // 配列から地形IDを取り出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TileBit matchBits = map-&gt;matchTypes(terrain_gid, checkBit); // ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCheckBit = matchBits != TileType::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCheckBit &amp;&amp; pMapX != nullptr &amp;&amp; pMapY != nullptr &amp;&amp; pMapZ != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pMapX = mapX, * pMapY = mapY, * pMapZ = mapZ; // ブロックのマス目のセル番号をポインタに記録(nullptrの場合は記録しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCheckBit &amp;&amp; pMatchBits != nullptr &amp;&amp; matchBits &amp; (TileBit)TileType::Floor)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pMatchBits |= matchBits; // マッチしたビットをポインタにビット論理和して返す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCheckBit &amp;&amp; pTerrainID != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pTerrainID = terrain_gid; // チェックビット条件に当てはまったらその地形IDを返す<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return isCheckBit;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // [X方向左]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      &nbsp;&nbsp;&nbsp; inline HitBit hitcheckLeftX(TileBit checkBit,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xLeft, float xMiddle, float xRight,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yBottom, float yMiddle, float yTop,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yTop, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Top | HitPart::Back; // 左上手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yTop, zMiddle, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Top | HitPart::ZMiddle; // 左上中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yTop, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Top | HitPart::Forward; // 左上奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yMiddle, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::YMiddle | HitPart::Back; // 左中手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yMiddle, zMiddle, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::YMiddle | HitPart::ZMiddle; // 左中中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::YMiddle | HitPart::Forward; // 左中奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yBottom, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Bottom | HitPart::Back; // 左下手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yBottom, zMiddle, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Bottom | HitPart::ZMiddle; // 左下中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yBottom, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Bottom | HitPart::Forward; // 左下奥がめりこんでいる<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (HitBit)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // [X方向右]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      &nbsp;&nbsp;&nbsp; inline HitBit hitcheckRightX(TileBit checkBit,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xLeft, float xMiddle, float xRight,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yBottom, float yMiddle, float yTop,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yTop, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Top | HitPart::Back; // 右上手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yTop, zMiddle, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Top | HitPart::ZMiddle; // 右上中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yTop, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Top | HitPart::Forward; // 右上奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yMiddle, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::YMiddle | HitPart::Back; // 右中手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yMiddle, zMiddle, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::YMiddle | HitPart::ZMiddle; // 右中中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::YMiddle | HitPart::Forward; // 右中奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yBottom, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Bottom | HitPart::Back; // 右下手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yBottom, zMiddle, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Bottom | HitPart::ZMiddle; // 右下中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yBottom, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Bottom | HitPart::Forward; // 右下奥がめりこんでいる<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (HitBit)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // [X方向左右]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      &nbsp;&nbsp;&nbsp; inline HitBit hitcheckX(TileType checkBit, float xLeft, float xMiddle, float xRight, float yBottom, float yMiddle, float yTop, float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 下の関数にTileBit型をキャスト変換して取次ぎ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitcheckX((TileBit)checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // [X方向左右]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      &nbsp;&nbsp;&nbsp; inline HitBit hitcheckX(TileBit checkBit,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xLeft, float xMiddle, float xRight,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yBottom, float yMiddle, float yTop,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HitBit hitPartLeftBit = hitcheckLeftX(checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hitPartLeftBit != HitPart::None)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitPartLeftBit;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 右端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HitBit hitPartRightBit = hitcheckRightX(checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hitPartRightBit != HitPart::None)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitPartRightBit;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (HitBit)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // [Y方向下]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      &nbsp;&nbsp;&nbsp; inline HitBit hitcheckBottomY(TileBit checkBit,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xLeft, float xMiddle, float xRight,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yBottom, float yMiddle, float yTop,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 足元が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yBottom, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Bottom | HitPart::Back; // 左下手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yBottom, zMiddle, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Bottom | HitPart::ZMiddle; // 左下中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yBottom, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Bottom | HitPart::Forward; // 左下奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xMiddle, yBottom, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::XMiddle | HitPart::Bottom | HitPart::Back; // 中下手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xMiddle, yBottom, zMiddle, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::XMiddle | HitPart::Bottom | HitPart::ZMiddle; // 中下中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xMiddle, yBottom, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::XMiddle | HitPart::Bottom | HitPart::Forward; // 中下奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yBottom, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Bottom | HitPart::Back; // 右下手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yBottom, zMiddle, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Bottom | HitPart::ZMiddle; // 右下中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yBottom, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Bottom | HitPart::Forward; // 右下奥がめりこんでいる<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (HitBit)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // [Y方向下]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      &nbsp;&nbsp;&nbsp; inline HitBit hitcheckTopY(TileBit checkBit,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xLeft, float xMiddle, float xRight,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yBottom, float yMiddle, float yTop,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 頭の部分がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yTop, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Top | HitPart::Back; // 左上手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yTop, zMiddle, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Top | HitPart::ZMiddle; // 左上中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yTop, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Top | HitPart::Forward; // 左上奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xMiddle, yTop, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::XMiddle | HitPart::Top | HitPart::Back; // 中上手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xMiddle, yTop, zMiddle, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::XMiddle | HitPart::Top | HitPart::ZMiddle; // 中上中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xMiddle, yTop, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::XMiddle | HitPart::Top | HitPart::Forward; // 中上奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yTop, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Top | HitPart::Back; // 右上手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yTop, zMiddle, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Top | HitPart::ZMiddle; // 右上中がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yTop, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Top | HitPart::Forward; // 右上奥がめりこんでいる<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (HitBit)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // [Y方向上下]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      &nbsp;&nbsp;&nbsp; inline HitBit hitcheckY(TileType checkBit, float xLeft, float xMiddle, float xRight, float yBottom, float yMiddle, float yTop, float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 下の関数にTileBit型をキャスト変換して取次ぎ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitcheckY((TileBit)checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // [Y方向上下]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      &nbsp;&nbsp;&nbsp; HitBit hitcheckY(TileBit checkBit,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xLeft, float xMiddle, float xRight,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yBottom, float yMiddle, float yTop,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 下端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HitBit hitPartBottomBit = hitcheckBottomY(checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hitPartBottomBit != HitPart::None)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitPartBottomBit;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 上端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HitBit hitPartTopBit = hitcheckTopY(checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hitPartTopBit != HitPart::None)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitPartTopBit;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (HitBit)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      #if 0<br>
      &nbsp;&nbsp;&nbsp; // [Y方向フロア床]地形の Floor:床にぶつかったかをチェックする関数(一つ上のタイルが床:Floorならtrue)<br>
      &nbsp;&nbsp;&nbsp; HitBit hitcheckFloorY(//Tile::Bit checkBit,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xLeft, float xMiddle, float xRight,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yBottom, float yMiddle, float yTop,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 一つ上のタイルが Floor:床 で 下端がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HitBit hitPartBottomBit = hitcheckBottomY((int)TileType::Floor, xLeft, xMiddle, xRight, yBottom + CellSize, yMiddle + CellSize, yTop + CellSize, zBack, zMiddle, zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hitPartBottomBit != HitPart::None)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitPartBottomBit;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (HitBit)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; // [Z方向手前]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      &nbsp;&nbsp;&nbsp; inline HitBit hitcheckBackZ(TileBit checkBit,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xLeft, float xMiddle, float xRight,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yBottom, float yMiddle, float yTop,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 手前の部分がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yTop, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Top | HitPart::Back; // 左上手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xMiddle, yTop, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::XMiddle | HitPart::Top | HitPart::Back; // 中上手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yTop, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Top | HitPart::Back; // 右上手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yMiddle, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::YMiddle | HitPart::Back; // 左中手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xMiddle, yMiddle, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::XMiddle | HitPart::YMiddle | HitPart::Back; // 中中手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yMiddle, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::YMiddle | HitPart::Back; // 右中手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yBottom, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Bottom | HitPart::Back; // 左下手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xMiddle, yBottom, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::XMiddle | HitPart::Bottom | HitPart::Back; // 中下手前がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yBottom, zBack, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Bottom | HitPart::Back; // 右下手前がめりこんでいる<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (HitBit)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // [Z方向奥]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      &nbsp;&nbsp;&nbsp; inline HitBit hitcheckForwardZ(TileBit checkBit,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xLeft, float xMiddle, float xRight,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yBottom, float yMiddle, float yTop,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 奥が壁にめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yTop, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Top | HitPart::Forward; // 左上奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xMiddle, yTop, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::XMiddle | HitPart::Top | HitPart::Forward; // 中上奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yTop, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Top | HitPart::Forward; // 右上奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::YMiddle | HitPart::Forward; // 左中奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xMiddle, yMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::XMiddle | HitPart::YMiddle | HitPart::Forward; // 中中奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::YMiddle | HitPart::Forward; // 右中奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xLeft, yBottom, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Left | HitPart::Bottom | HitPart::Forward; // 左下奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xMiddle, yBottom, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::XMiddle | HitPart::Bottom | HitPart::Forward; // 中下奥がめりこんでいる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (checkID(checkBit, xRight, yBottom, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HitPart::Right | HitPart::Bottom | HitPart::Forward; // 右下奥がめりこんでいる<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (HitBit)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // [Z方向手前奥]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      &nbsp;&nbsp;&nbsp; inline HitBit hitcheckZ(TileType checkBit, float xLeft, float xMiddle, float xRight, float yBottom, float yMiddle, float yTop, float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 下の関数にTileBit型をキャスト変換して取次ぎ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitcheckZ((TileBit)checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // [Z方向手前奥]地形の ダメージブロックなどにぶつかったかをチェックする関数<br>
      &nbsp;&nbsp;&nbsp; HitBit hitcheckZ(TileBit checkBit,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xLeft, float xMiddle, float xRight,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yBottom, float yMiddle, float yTop,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 手前がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HitBit hitPartBackBit = hitcheckBackZ(checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hitPartBackBit != HitPart::None)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitPartBackBit;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 奥がめりこんでいるか？<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HitBit hitPartForwardBit = hitcheckForwardZ(checkBit, xLeft, xMiddle, xRight, yBottom, yMiddle, yTop, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hitPartForwardBit != HitPart::None)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitPartForwardBit;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (HitBit)HitPart::None;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 地形の ダメージブロックなどにぶつかったかをチェックする一時関数<br>
      &nbsp;&nbsp;&nbsp; HitBit hitcheck(TileBit checkBit,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xLeft, float xMiddle, float xRight,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yTop, float yMiddle, float yBottom,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hitcheckX(checkBit, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | hitcheckY(checkBit, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | hitcheckZ(checkBit, xLeft, xMiddle, xRight, yTop, yMiddle, yBottom, zBack, zMiddle, zForward, pTerrainID, pMapX, pMapY, pMapZ, pMatchBits);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    地獄のようなコード量になりましたが仕方ありません。上下左右奥手前がめり込んでいるかをifで判定するので条件判定式がかさむからです。<br>
    沢山処理があるように見えてますが、<b>実はほぼ全部checkID関数に上下左右奥手前の色んなバリエーションを渡して当たっているか判定している</b>だけです。<br>
    縦一列に「checkID 関数が並ぶ様子はまさに圧巻」です。この一つバグがありでもしたら...ゾッとします。教育教育教育教育教育教育...修正修正修正修正修正修正...<br>
    上下左右手前奥の色んな組み合わせがあるから、当然 if判定のコードが増える、というわけです。<br>
    なので、むしろ注目してほしいのは<b>OnHitLeft や OnHitBottomなどのOnHit系の当たった時の押し戻し関数やOnAir関数などの当たっていない関数</b>です。<br>
    足元がタイルに当たったら、オーナーのvy = 0;にして速度を0にして、めり込みぶんを押し戻しています。これで地面に立てるのです。<br>
    <br>
    では、今度はGameObject側にもOnHitTile関数を追加して、map()関数でMapHitBoxComponent側がオーナーのいるマップにアクセスできるようにしましょう。<br>
    <br>
    <p><code>GameObject.hを変更</code>して、OnCollisionなどの衝突判定のコールバック関数を準備しましょう。</p>
    <p class="source">#ifndef GAMEOBJECT_H_<br>
      #define GAMEOBJECT_H_<br>
      <br>
      #include &lt;memory&gt; // 共有ポインタの定義のため<br>
      <br>
      #include "Vector3.h"<br>
      #include "Quaternion.h"<br>
      <em>#include "Tile.h" // OnHitTileのコールバックに必要</em><br>
      <br>
      #include "Object.h" // インスタンスIDや検索タグを持ち、shared_from_this_as&lt;継承先クラス名&gt;などができる<br>
      <em>#include "World.h"</em><br>
      <br>
      <u>class World; // 前方宣言</u><br>
      <em>class Map; // 前方宣言</em><br>
      class Component; // 前方宣言<br>
      class Collision; // 前方宣言<br>
      <br>
      // ゲーム上に表示される物体の基底クラス。<br>
      // プレイヤーや敵、アイテムなどはこのクラスを継承して作る。<br>
      class GameObject : public Object<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるのでCreate関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; GameObject(World* world = nullptr, Vector3 position = { 0,0,0 }, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Object(), m_world{ world }, position{ position }, rotation{ rotation }, velocity{ velocity }, force{ force }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~GameObject() {}<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★下記3つはメモリ上で共用状態になる(position、x,y,z、xyzどの名前から数値を変えたり読出してもメモリ上は同じ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 同じデータに3種類の名前を付けたイメージ、しかもVector3の機能や配列としてのアクセスの仕方もできて便利<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // XYZ座標&nbsp; [匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 position; // XYZ座標<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp;&nbsp; }; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
      <br>
      &nbsp;&nbsp;&nbsp; Quaternion rotation; // 回転クオータニオン<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vx, vy, vz; }; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 velocity; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyz;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vxForce, vyForce, vzForce; }; // XYZ方向にかかる力(Unityでいうと AddForce関数 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 force; // XYZ方向の力(物理的には加速度:1フレームごとにvelocityの増える=加速する量)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyzForce;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 重力を返す、重力を変えたいときはoverrideして処理を変えてください、重力を変えてない場合は 0.0f<br>
      &nbsp;&nbsp;&nbsp; virtual inline float gravity() { return 0.0f; }<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; World* m_world; // GameObjectが配置されたワールドへのリンク<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; virtual World* world() { return m_world; }<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
      &nbsp;&nbsp;&nbsp; virtual void world(World* changeWorld) { m_world = changeWorld; }<br>
      &nbsp;&nbsp;&nbsp; <em>// GameObjectが現在いるマップへのポインタを返す<br>
        &nbsp;&nbsp;&nbsp; Map* map() { return m_world-&gt;map.get(); }</em><br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; bool isDead{ false }; // 死んだ（削除対象）フラグ<br>
      &nbsp;&nbsp;&nbsp; bool isStatic{ false }; // 動かない(静的オブジェクトか?)<br>
      &nbsp;&nbsp;&nbsp; bool isGround{ false }; // 地面についているか<br>
      &nbsp;&nbsp;&nbsp; bool isJumping{ false }; // ジャンプ中か<br>
      &nbsp;&nbsp;&nbsp; bool isFlying{ false }; // 空をとんでいるか<br>
      <br>
      &nbsp;&nbsp;&nbsp; float pushPower{ 5.0f }; // コライダで接触したときに押し返す力(相手側が強いと押される)<br>
      &nbsp;&nbsp;&nbsp; float mass{ 1.0f }; // 質量(重さ)コライダで接触したときに重さでforceを割り算すると動きにくくなる<br>
      <br>
      &nbsp;&nbsp;&nbsp; hash32 typeTag{ "" }; // 小カテゴリ Zako0など個別のタイプ<br>
      &nbsp;&nbsp;&nbsp; hash32 baseTag{ "" }; // 大カテゴリ Enemyなど大まかなベースジャンル<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンポーネントの&lt;ハッシュID, 共有所有ポインタ&gt; の辞書でコンポーネントの共有カウンタ+1を保持する<br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;size_t, std::shared_ptr&lt;Component&gt;&gt; components;<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // コンポーネントを得る 例えば GetComponent&lt;BoxCollider&gt;でBoxColliderという名前のコンポーネントをcomponents辞書から得る<br>
      &nbsp;&nbsp;&nbsp; template&lt;class ComponentT&gt;<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;ComponentT&gt;&gt; GetComponents()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // equal_range 関数を使って、指定したキーの最初と終端の位置を示すイテレータを std::pair&lt;&gt; で取得します。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto range = components.equal_range(hashID); //https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;ComponentT&gt;&gt; returnList; // "ComponentT" 例."CircleCollider"など をキーとするコンポーネント一覧<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto ite = range.first; ite != range.second; ++ite)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; returnList.emplace_back(ite-&gt;second); // 辞書で見つかったコンポーネントを返すリストに追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return returnList;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンポーネントを追加する .AddComponent&lt;BoxCollider&gt;(...)で追加できる<br>
      &nbsp;&nbsp;&nbsp; template&lt;class ComponentT, typename ...ArgsT&gt;<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;ComponentT&gt; AddComponent(ArgsT&amp;&amp;...args)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // shared_from_this()を必ず渡してセットで初期化して、オーナーがリンク切れのコンポーネントができないように気をつける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ComponentT&gt; newComponent = std::make_shared&lt;ComponentT&gt;(shared_from_this_as&lt;GameObject&gt;(), std::forward&lt;ArgsT&gt;(args)<b>...</b>);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // std::unrodered_multimap&lt;&gt; と同型の値を取る std::pair&lt;&gt; を作って insert 関数でcomponents辞書に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; components.insert(std::pair&lt;size_t, std::shared_ptr&lt;ComponentT&gt;&gt;(hashID, newComponent));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return newComponent;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンポーネントを削除する<br>
      &nbsp;&nbsp;&nbsp; template&lt;typename ComponentT&gt;<br>
      &nbsp;&nbsp;&nbsp; bool RemoveComponent(std::shared_ptr&lt;ComponentT&gt; removeComponent)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // equal_range 関数を使って、指定したキーの最初と終端の位置を示すイテレータを std::pair&lt;&gt; で取得します。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto range = components.equal_range(hashID); //https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[イテレート中に探しながら消す] https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/erase.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto ite = range.first; ite != range.second;)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ite-&gt;second == removeComponent)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; components.erase(ite); // 削除された要素の次を指すイテレータが返される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // 見つかって消せた場合は true<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++ite; // 次の要素へイテレータを進める<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 見つからずに消せなかった場合は false<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() = 0; // 純粋仮想関数 = 0 にすると【絶対 Update()関数はoverrideしなきゃいけない義務を付与できる 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() = 0; // 純粋仮想関数 = 0 にすると【絶対 Draw()関数はoverrideしなきゃいけない義務を継承先クラスに付与 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 衝突開始したときの関数 overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollisionEnter(std::shared_ptr&lt;Collision&gt; pCollision)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして衝突開始したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 衝突したときの関数 overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollision(std::shared_ptr&lt;Collision&gt; pCollision)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 衝突終了したときの関数 overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollisionExit(std::shared_ptr&lt;Collision&gt; pCollision)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして衝突終了したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ジャンプ開始した直後に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnStartJump()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideしてジャンプした瞬間に音を鳴らしたりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 空中でジャンプの上昇中に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnJumping()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中でジャンプの上昇中にエフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 空中で落ちている最中に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnFalling()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中で落ちている最中に音を鳴らしたり、エフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// タイルに当たったときのコールバック<br>
        &nbsp;&nbsp;&nbsp; virtual void OnHitTile(HitPart hitPart, HitBit hitPartBit, TileBit checkBit, float xLeft, float xMiddle, float xRight,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yBottom, float yMiddle, float yTop, float zBack, float zMiddle, float zForward,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 継承 overrideしてタイルに当たったときの処理を実装する<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Player.hを変更</code>して、タイルマップと当たり判定をするコンポーネントの初期 Init 設定を追加しましょう。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Resource.h"<br>
      #include "GameObject.h"<br>
      #include "PhysicsComponent.h"<br>
      <em>#include "MapHitBoxComponent.h"</em><br>
      #include "GridCollidersComponent.h"<br>
      #include "Collider.h"<br>
      <br>
      class World; // 前方宣言<br>
      class Camera; // 前方宣言<br>
      <br>
      class Player : public GameObject<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるので、Create関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; Player(World* world, Pad pad, Vector3 position, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pad{ pad }, GameObject(world, position, rotation, velocity, force)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "Player"; // タグは個別の"プレイヤ1"などに使い、タイプはtypeTagで判別する形にしてタイプのジャンルを区別<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;baseTag = "Player";<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;pushPower = 5.0f; // コライダで衝突したときに押し返す力<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~Player() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; Pad pad; // 操作するコントローラー番号<br>
      &nbsp;&nbsp;&nbsp; hash32 worldTag{ "" }; // 現在いるワールドのタグ<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeedMax = 6; // 移動速度Max値<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeed = 0;//移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; float moveAngle = 0; // X軸→方向から何度か<br>
      &nbsp;&nbsp;&nbsp; float deltaAngle = 0; // プレイヤの動く角度の変化率、ハンドルを切ったらだんだんもとに戻る<br>
      &nbsp;&nbsp;&nbsp; int animCount = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image; // プレイヤの板ポリゴンで描くタイル分割画像への共有リンク<br>
      <br>
      &nbsp;&nbsp;&nbsp; Camera* camera{ nullptr }; // プレイヤを追随するカメラ<br>
      &nbsp;&nbsp;&nbsp; void SetCamera(Camera* pCamera) { camera = pCamera; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // overrideして物理落下コンポーネントからの重力値を返す<br>
      &nbsp;&nbsp;&nbsp; virtual float gravity() override { auto pGravityPhysics = gravityPhysics.lock(); return (pGravityPhysics != nullptr) ? pGravityPhysics-&gt;gravity() : 0.0f; }<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;JumpComponent&gt; jumpPhysics; // ジャンプの物理処理コンポーネント<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;GravityComponent&gt; gravityPhysics; // 落下の重力の物理処理コンポーネント<br>
      &nbsp;&nbsp;&nbsp; <em>// マップ地形に対するヒットボックスの当たり判定と押し戻しをするコンポーネント<br>
        &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;MapHitBoxComponent&gt; mapHitBox;</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;GridCollidersComponent&gt; gridCollision; // グリッドマス目分割コンポーネント<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;SphereCollider&gt; sphereCollider; // 球コライダのコンポーネント<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyJumpSpeed{ 13, 14, 15, 4 }; // ジャンプ開始の初期速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyForceJump{ 0.5f, 0.4f, 0.3f, 0.1f }; // ジャンプ上昇にかかる力の初期値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyGravity{ 0.8f,0.8f,0.8f,0.8f }; // 重力の設定値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyDownSpeedMax{ 16, 16, 16, 8 }; // 降下スピードのリミット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // AddComponent内部でshared_from_this()を必ず渡してセットで初期化して、オーナーがリンク切れのコンポーネントができないように気をつける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jumpPhysics = AddComponent&lt;JumpComponent&gt;(vyJumpSpeed, vyForceJump);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gravityPhysics = AddComponent&lt;GravityComponent&gt;(vyGravity, vyDownSpeedMax);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 半径16(直径32)の球体コライダ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sphereCollider = AddComponent&lt;SphereCollider&gt;(Vector3(0, 0, 0), 16);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision = AddComponent&lt;GridCollidersComponent&gt;("Player"); //とりあえずわかりやすいように"Player"というタグをつけておく(別に何でもいい)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision.lock()-&gt;LinkCollider(sphereCollider); // コライダをリンクする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>float mapHitBoxSize = sphereCollider.lock()-&gt;m_radius * 2.0f; // 球体コライダの直径に合わす<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 boxSize{ mapHitBoxSize,mapHitBoxSize,mapHitBoxSize };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 offsetLeftBottomBack{ 3, 0, 3 }; // ボックスの端を内側にどれだけ削るか(キャラの画像に合わせて小さくできる)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 offsetRightTopForward{ 3, 8, 3 }; // ボックスの端を内側にどれだけ削るか(頭を8削る)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mapHitBox = AddComponent&lt;MapHitBoxComponent&gt;(boxSize, offsetLeftBottomBack, offsetRightTopForward);</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理<br>
      &nbsp;&nbsp;&nbsp; virtual void HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ジャンプ開始した直後に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnStartJump() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コライダの衝突した際に呼ばれるコールバック関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollision(std::shared_ptr&lt;Collision&gt; pCollision) override;<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Player.cppを変更</code>して、コンポーネントを使ってタイルマップと当たり判定をしましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      void Player::HandleInput()<br>
      {<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_LEFT) <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_A)) )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = - MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += 1; //ハンドルを左に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_RIGHT)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_D)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle -= 1; //ハンドルを右に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_UP)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_W)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = - MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += 0.6f; //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; MoveSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = MoveSpeedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(pad, PAD_INPUT_DOWN)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_S)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed -= 0.6f; //ブレーキを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.9f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = -0.9f;//ちょっとだけバックできるように<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pad == Pad::Key || pad == Pad::One) // コントローラ1またはキーボード操作のプレイヤのときだけ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGUP)) // キーボードのPageUp ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = 2.0f; // テスト用に空中の上方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGDN)) // キーボードのPageDown ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -2.0f; // テスト用に空中の下方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      // ジャンプ開始した直後に呼ばれる関数<br>
      void Player::OnStartJump()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; this-&gt;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      }<br>
      <br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; vxForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp; vyForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp; vzForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pJumpPhysics = jumpPhysics.lock();<br>
      &nbsp;&nbsp;&nbsp; if (pJumpPhysics != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pad, PAD_INPUT_A) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;JumpStart(); // ジャンプのスタート処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (vy &gt; 0 &amp;&amp; Input::GetButtonUp(pad, PAD_INPUT_A) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonUp(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;JumpCancel(); // ジャンプのキャンセル処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;Update(); // ジャンプのコンポーネントを更新する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; auto pGravityPhysics = gravityPhysics.lock();<br>
      &nbsp;&nbsp;&nbsp; if (pGravityPhysics != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGravityPhysics-&gt;Update(); // 重力落下のコンポーネントを更新する<br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; rotation.SetRotation(VGet(0, (180 - moveAngle) * MyMath::Deg2Rad, 0)); // 前向きの3Dモデルなら180度回転させて奥方向の向きに設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; float vyForceJump = (pJumpPhysics != nullptr) ? pJumpPhysics-&gt;vyForce() : 0.0f;<br>
      &nbsp;&nbsp;&nbsp; float vyForceGravity = (pGravityPhysics != nullptr) ? pGravityPhysics-&gt;vyForce() : 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp; vx += vxForce; // 力をかけて速度に加算する<br>
      &nbsp;&nbsp;&nbsp; vy += vyForce + vyForceJump + vyForceGravity; // 勢い(力・フォースを加算<br>
      &nbsp;&nbsp;&nbsp; vz += vzForce; // 力をかけて速度に加算する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>auto pMapHitBox = mapHitBox.lock();</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp; x += vx;<br>
      &nbsp;&nbsp;&nbsp; <em>if (pMapHitBox != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMapHitBox-&gt;hitCheckX((TileBit)TileType::Wall);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp; y += vy;<br>
      &nbsp;&nbsp;&nbsp; <em>if (pMapHitBox != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMapHitBox-&gt;hitCheckY((TileBit)TileType::Wall | (TileBit)TileType::Floor);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp; z += vz;<br>
      &nbsp;&nbsp;&nbsp; <em>if (pMapHitBox != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMapHitBox-&gt;hitCheckZ((TileBit)TileType::Wall);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>if (y &lt;= 0.0f) // 0.0fを地面として 0.0f以下になったら地面に着地したと判定する<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 0.0f; // 地面に沿わせる<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -0.01f; // 下方向への速度をほぼ 0 にする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isGround = true;<br>
        &nbsp;&nbsp;&nbsp; }</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; if (auto pGridCollision = gridCollision.lock()) // lock()してnullptrじゃなければ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridCollision-&gt;Update(); // 所属するマス目セルを更新する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; // moveAngleは2D画像のX方向右を0度とするから、-90度回すと画像を正面に捉える位置にカメラを置ける<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      void Player::OnCollision(std::shared_ptr&lt;Collision&gt; pCollision)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (isDead) return; // すでにisDeadなら return<br>
      &nbsp;&nbsp;&nbsp; auto otherCollider = pCollision-&gt;contacts[0].otherCollider.lock(); // コライダの弱共有ポインタをロック<br>
      &nbsp;&nbsp;&nbsp; if (otherCollider == nullptr) return; // すでにコライダが消去済だった<br>
      &nbsp;&nbsp;&nbsp; auto other = otherCollider-&gt;owner();<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (other-&gt;isDead) return; // other側がisDeadだったら処理をスルー<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (other-&gt;baseTag == "Enemy" || other-&gt;baseTag == "Player")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[離散要素法:DEM] https://qiita.com/konbraphat51/items/157e5803c514c60264d2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float k = 1.0f; // バネ係数(めり込みに対するバネ反発の掛け率)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float e = 0.1f; // はね返り係数(直前と比べどれくらいの速さで離れるか0.5だと半分の速さではね返る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float log_e = std::log(e); // はね返り係数の自然対数log<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float pi_2 = DX_PI_F * DX_PI_F; // πの2乗<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float eta = -2.0f * log_e * std::sqrt(k * mass / (log_e * log_e + pi_2)); // 粘性係数η(イータ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto norm = pCollision-&gt;contacts[0].normal; // 衝突の法線 * other-&gt;pushPower; // pushPowerの力でotherに押し返される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto v_norm = dot(other-&gt;velocity - velocity, norm) * norm; // [相対速度v] 法線norm方向のv = (v1 - v0)・norm [ドット積]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto sep = pCollision-&gt;contacts[0].separation; // 衝突点どうしの距離(めりこみ距離)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto F = -k * sep * norm - eta * v_norm; // F (法線方向の力) = -k × sep - η × v (相対速度:自分から見た相手otherの速度)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; force += F / mass; // 衝突法線方向の力を加える<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int animIndex = animCount / 20; // キャラのパラパラアニメの画像番号(最大3)<br>
      &nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp; if (abs_vx &gt; 1.00f || abs_vz &gt; 1.00f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6; // キャラが地面のXとZ方向に少しでもスピードがあったらアニメを走らせる<br>
      &nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // プレイヤのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 9; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // カメラ向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 奥向きの画像<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *image, imgIndex + animIndex, TRUE);<br>
      <br>
      #ifdef _DEBUG // デバッグのときだけ_DEBUGが定義され描かれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pSphereCollider = sphereCollider.lock()) pSphereCollider-&gt;Draw(); // コライダを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>if (auto pMapHitBox = mapHitBox.lock()) pMapHitBox-&gt;Draw(); // ヒットボックスを描く</em><br>
      #endif<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    いかがでしょう？Debugビルドで当たり判定のボックスが表示され、タイルの上を歩くことができるようになりましたか？<br>
    ただし、現状では<b>高速でタイルと当たり判定するときは、<br>
      当然 vx などが タイルのサイズ 32 を超える35などで動けば隣の隣のタイルと当たり判定することになりすり抜けてしまいます</b>。<br>
    実験として、プレイヤ1を勢いよくプレイヤ2にぶつけてみてください。タイルのブロックをすり抜ける現象が発生するはずです。<br>
    この現象は当然、球体同士のコライダでも起こりえます。<br>
    ではどうすればすり抜けないようにできるでしょうか？<br>
    <b>すり抜け現象が起こってしまうのは タイルの大きさ 32 に対して速度 vx が 35になり超えてしまっているから</b>です。<br>
    では、32以下の 30 などのスピードならすり抜けは起こらないのでしょうか？<br>
    いいえ、<b>実はめり込み具合が 32の半分の 16 を超えてしまうとめり込みの 小さい壁の向こう側に向けて押し返されてしまう</b>のです。<br>
    <br>
    ですので、vx や vz などを<b>16以下の細切れにして少しづつ移動</b>させながら当たり判定をループさせて<br>
    <b>最終的に 16 + 16 + 3 = 35のように35移動</b>すればすり抜けずに止まるか、壁がなければ +35 まで動くことができます。<br>
    <b>斜め方向の移動の場合</b>はどうしましょうか？<br>
    <b>vx が 35で vz が 70 の速さだとしましょう。<br>
      この場合は、70のほうに合わせて細切れにすればいい</b>のです。<br>
    <b>vz を 16ずつ動かす場合には vx を 16 × 35 / 70 = 8 ずつ動かせば斜めの方向の比率としては同じ</b>になるはずです。<br>
    <br>
    <br>
    <p><code>GridSteps.hを新規作成</code>して、当たり判定がすり抜けないように<b>細切れのグリッド</b>の数値を計算する機能を準備しましょう。</p>
    <p class="source">#ifndef GRID_STEPS_H_<br>
      #define GRID_STEPS_H_<br>
      <br>
      #include "Vector3.h"<br>
      <br>
      // 超高速すぎて当たり判定をすり抜けないように gridSize で分割して<br>
      // グリッドを飛び越えずに1つ1つ 細かい step で進んですり抜けないように div 回分進んで、<br>
      // 最後に余りの mod ぶん進む と vec と同じぶん、進んだことになり、当たり判定もすり抜けずにすむ<br>
      struct GridSteps<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int div; // stepを何回ぶん繰り返すと vec と等しくなるか<br>
      &nbsp;&nbsp;&nbsp; Vector3 step; //[ステップ] vec = step * div + mod で細かく div 回進むようにする<br>
      &nbsp;&nbsp;&nbsp; Vector3 mod; //[余り] vec = step * div + mod で細かく div 回進んで最後に 余りmodぶん進む<br>
      &nbsp;&nbsp;&nbsp; inline GridSteps(const Vector3&amp; vec, const Vector3&amp; gridSize, int divLimit = 1000)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float vx = vec.x, vy = vec.y, vz = vec.z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xGridSize = gridSize.x, yGridSize = gridSize.y, zGridSize = gridSize.z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ブロックなどのグリッドを貫通するほどの速さのvxがあるとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // グリッドを1つ1つまたぐ分割されたスピートを vx の割り算とその余りで求める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float vxAbs = (vx &lt; 0) ? -vx : vx, vyAbs = (vy &lt; 0) ? -vy : vy, vzAbs = (vz &lt; 0) ? -vz : vz;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float signX = (vx &lt; 0) ? -1 : +1, signY = (vy &lt; 0) ? -1 : +1, signZ = (vz &lt; 0) ? -1 : +1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float vxDiv = vxAbs / xGridSize; // vxから±を消した絶対値 を グリッドのサイズで割ると必要ステップ数<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float vyDiv = (yGridSize == 0) ? 1.0f : vyAbs / yGridSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float vzDiv = (zGridSize == 0) ? 1.0f : vzAbs / zGridSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (vxDiv &lt;= 1.0f &amp;&amp; vyDiv &lt;= 1.0f &amp;&amp; vzDiv &lt;= 1.0f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;div = 1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;step = vec; // 1マスしか進まない場合は速度をそのまま返す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (vxDiv &gt; divLimit) vxDiv = divLimit;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (vyDiv &gt; divLimit) vyDiv = divLimit; // divが大きくなりすぎるとStepが∞に近づくのでリミットをかける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (vzDiv &gt; divLimit) vzDiv = divLimit;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float vxMod = std::fmod(vxAbs, xGridSize); // グリッドのサイズで速度を割った余りmod<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float vyMod = (yGridSize == 0) ? 0 : std::fmod(vyAbs, yGridSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float vzMod = (zGridSize == 0) ? 0 : std::fmod(vzAbs, zGridSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <b>∞=infや計算不能 nan を !isfiniteで 検出</b>したら 0 にする https://qiita.com/N700A/items/36b9383eaf923f4bf6ae<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (vxMod &gt; xGridSize || <b>!isfinite</b>(vxMod)) vxMod = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (vyMod &gt; yGridSize || <b>!isfinite</b>(vyMod)) vyMod = 0; // 速度が∞に近づくと余りも∞になるので 0 にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (vzMod &gt; zGridSize || <b>!isfinite</b>(vzMod)) vzMod = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int maxDiv; // 通過する区切りの回数が一番多いもの(= maxDiv)に合わせて進むx,y,zの1回のステップを決める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float xStep = xGridSize, yStep = yGridSize, zStep = zGridSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (vxDiv &gt;= vyDiv &amp;&amp; vxDiv &gt;= vzDiv) // 1番割り算したDivの区切りの多いものにあわせて他はその区切りで割るので<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxDiv = (int)vxDiv, yStep = vyAbs / maxDiv, zStep = vzAbs / maxDiv, vyMod = 0, vzMod = 0; // 他の余りは 0 にする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (vyDiv &gt;= vzDiv &amp;&amp; vyDiv &gt;= vxDiv)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxDiv = (int)vyDiv, xStep = vxAbs / maxDiv, zStep = vzAbs / maxDiv, vxMod = 0, vzMod = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxDiv = (int)vzDiv, xStep = vxAbs / maxDiv, yStep = vyAbs / maxDiv, vxMod = 0, vyMod = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ステップの回数 div,1回のステップ step, 最後のステップのつじつまを合わせる余り mod を返す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;div = maxDiv;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;step = Vector3{ signX * xStep, signY * yStep, signZ * zStep };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;mod = Vector3{ signX * vxMod, signY * vyMod, signZ * vzMod };<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Player.cppを変更</code>して、GridStepsで細切れに移動してすり抜けないように当たり判定をしましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      <em>#include "GridSteps.h"</em><br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      void Player::HandleInput()<br>
      {<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_LEFT) <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_A)) )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = - MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += 1; //ハンドルを左に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_RIGHT)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_D)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle -= 1; //ハンドルを右に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_UP)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_W)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = - MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += 0.6f; //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; MoveSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = MoveSpeedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(pad, PAD_INPUT_DOWN)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_S)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed -= 0.6f; //ブレーキを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.9f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = -0.9f;//ちょっとだけバックできるように<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pad == Pad::Key || pad == Pad::One) // コントローラ1またはキーボード操作のプレイヤのときだけ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGUP)) // キーボードのPageUp ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = 2.0f; // テスト用に空中の上方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGDN)) // キーボードのPageDown ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -2.0f; // テスト用に空中の下方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      // ジャンプ開始した直後に呼ばれる関数<br>
      void Player::OnStartJump()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; this-&gt;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      }<br>
      <br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; vxForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp; vyForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp; vzForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pJumpPhysics = jumpPhysics.lock();<br>
      &nbsp;&nbsp;&nbsp; if (pJumpPhysics != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pad, PAD_INPUT_A) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;JumpStart(); // ジャンプのスタート処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (vy &gt; 0 &amp;&amp; Input::GetButtonUp(pad, PAD_INPUT_A) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonUp(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;JumpCancel(); // ジャンプのキャンセル処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;Update(); // ジャンプのコンポーネントを更新する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; auto pGravityPhysics = gravityPhysics.lock();<br>
      &nbsp;&nbsp;&nbsp; if (pGravityPhysics != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGravityPhysics-&gt;Update(); // 重力落下のコンポーネントを更新する<br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; rotation.SetRotation(VGet(0, (180 - moveAngle) * MyMath::Deg2Rad, 0)); // 前向きの3Dモデルなら180度回転させて奥方向の向きに設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; float vyForceJump = (pJumpPhysics != nullptr) ? pJumpPhysics-&gt;vyForce() : 0.0f;<br>
      &nbsp;&nbsp;&nbsp; float vyForceGravity = (pGravityPhysics != nullptr) ? pGravityPhysics-&gt;vyForce() : 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp; vx += vxForce; // 力をかけて速度に加算する<br>
      &nbsp;&nbsp;&nbsp; vy += vyForce + vyForceJump + vyForceGravity; // 勢い(力・フォースを加算<br>
      &nbsp;&nbsp;&nbsp; vz += vzForce; // 力をかけて速度に加算する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pMapHitBox = mapHitBox.lock();<br>
      &nbsp;&nbsp;&nbsp; <em>float cellHalf = (map() != nullptr) ? (float)map()-&gt;CellSize() / 2.0f : 16.0f; // マップのセルのサイズの半分<br>
        &nbsp;&nbsp;&nbsp; // 速すぎて当たり判定がすり抜けないように細切れのステップのグリッドで移動させつつ当たり判定する<br>
        &nbsp;&nbsp;&nbsp; Vector3 gridStepSize = (pMapHitBox == nullptr) ? Vector3{ cellHalf, cellHalf, cellHalf } : pMapHitBox-&gt;m_BoxSize / 2;<br>
        &nbsp;&nbsp;&nbsp; GridSteps vSteps{ velocity, gridStepSize }; // 細切れのステップの数値を計算<br>
        #ifdef _DEBUG<br>
        &nbsp;&nbsp;&nbsp; if (vSteps.div &gt;= 1000) // <b>分割が1000を超える場合は物理式かどこかで∞=inf や 計算不可能数=nanが発生してそう</b><br>
        &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // vx,vy,vzに原因がありそうなのでデバッグ表示<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isfinite(vx)) printfDx(("vx:∞かnan x:" + std::to_string(x) + "\n").c_str());<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isfinite(vy)) printfDx(("vy:∞かnan y:" + std::to_string(y) + "\n").c_str());<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isfinite(vz)) printfDx(("vz:∞かnan z:" + std::to_string(z) + "\n").c_str());<br>
        &nbsp;&nbsp;&nbsp; }<br>
        #endif<br>
        <br>
        &nbsp;&nbsp;&nbsp; bool isCollisionX{ false }, isCollisionY{ false }, isCollisionZ{ false }, isCollisionCollider{ false };<br>
        &nbsp;&nbsp;&nbsp; for (int i = 1, iSize = vSteps.div + 1; i &lt;= iSize; ++i)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; vStep = (i &lt; iSize) ? vSteps.step : vSteps.mod;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // まず横に移動する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMapHitBox == nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += vx;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionX == false) // まだ前のステップでX方向の衝突がないなら<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += vStep.x;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionX = pMapHitBox-&gt;hitCheckX((TileBit)TileType::Wall);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMapHitBox == nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += vy;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionY == false) // まだ前のステップでY方向の衝突がないなら<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += vStep.y;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionY = pMapHitBox-&gt;hitCheckY((TileBit)TileType::Wall | (TileBit)TileType::Floor);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMapHitBox == nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z += vz;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionZ == false) // まだ前のステップでZ方向の衝突がないなら<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z += vStep.z;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionZ = pMapHitBox-&gt;hitCheckZ((TileBit)TileType::Wall);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pGridCollision = gridCollision.lock())<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridCollision-&gt;Update(); // 所属するマス目セルを更新する<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; collider : *pGridCollision-&gt;colliders())<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionCollider |= collider.lock()-&gt;IsCollision();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 衝突があったら、速すぎてすり抜けちゃう前に今のステップでbreakで抜ける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollisionCollider)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; // ぶつかっているのにさらに次のステップの速度も足すとすり抜けちゃう<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; <u>// まず横に移動する<br>
        &nbsp;&nbsp;&nbsp; x += vx;<br>
        &nbsp;&nbsp;&nbsp; if (pMapHitBox != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMapHitBox-&gt;hitCheckX((TileBit)TileType::Wall);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
        &nbsp;&nbsp;&nbsp; y += vy;<br>
        &nbsp;&nbsp;&nbsp; if (pMapHitBox != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMapHitBox-&gt;hitCheckY((TileBit)TileType::Wall | (TileBit)TileType::Floor);<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
        &nbsp;&nbsp;&nbsp; z += vz;<br>
        &nbsp;&nbsp;&nbsp; if (pMapHitBox != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMapHitBox-&gt;hitCheckZ((TileBit)TileType::Wall);<br>
        <br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; if (auto pGridCollision = gridCollision.lock()) // lock()してnullptrじゃなければ<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridCollision-&gt;Update(); // 所属するマス目セルを更新する</u><br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; // moveAngleは2D画像のX方向右を0度とするから、-90度回すと画像を正面に捉える位置にカメラを置ける<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      void Player::OnCollision(std::shared_ptr&lt;Collision&gt; pCollision)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (isDead) return; // すでにisDeadなら return<br>
      &nbsp;&nbsp;&nbsp; auto otherCollider = pCollision-&gt;contacts[0].otherCollider.lock(); // コライダの弱共有ポインタをロック<br>
      &nbsp;&nbsp;&nbsp; if (otherCollider == nullptr) return; // すでにコライダが消去済だった<br>
      &nbsp;&nbsp;&nbsp; auto other = otherCollider-&gt;owner();<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (other-&gt;isDead) return; // other側がisDeadだったら処理をスルー<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (other-&gt;baseTag == "Enemy" || other-&gt;baseTag == "Player")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[離散要素法:DEM] https://qiita.com/konbraphat51/items/157e5803c514c60264d2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float k = 1.0f; // バネ係数(めり込みに対するバネ反発の掛け率)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float e = 0.1f; // はね返り係数(直前と比べどれくらいの速さで離れるか0.5だと半分の速さではね返る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float log_e = std::log(e); // はね返り係数の自然対数log<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float pi_2 = DX_PI_F * DX_PI_F; // πの2乗<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float eta = -2.0f * log_e * std::sqrt(k * mass / (log_e * log_e + pi_2)); // 粘性係数η(イータ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto norm = pCollision-&gt;contacts[0].normal; // 衝突の法線 * other-&gt;pushPower; // pushPowerの力でotherに押し返される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto v_norm = dot(other-&gt;velocity - velocity, norm) * norm; // [相対速度v] 法線norm方向のv = (v1 - v0)・norm [ドット積]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto sep = pCollision-&gt;contacts[0].separation; // 衝突点どうしの距離(めりこみ距離)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto F = -k * sep * norm - eta * v_norm; // F (法線方向の力) = -k × sep - η × v (相対速度:自分から見た相手otherの速度)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; force += F / mass; // 衝突法線方向の力を加える<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int animIndex = animCount / 20; // キャラのパラパラアニメの画像番号(最大3)<br>
      &nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp; if (abs_vx &gt; 1.00f || abs_vz &gt; 1.00f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6; // キャラが地面のXとZ方向に少しでもスピードがあったらアニメを走らせる<br>
      &nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // プレイヤのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 9; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // カメラ向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 奥向きの画像<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *image, imgIndex + animIndex, TRUE);<br>
      <br>
      #ifdef _DEBUG // デバッグのときだけ_DEBUGが定義され描かれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pSphereCollider = sphereCollider.lock()) pSphereCollider-&gt;Draw(); // コライダを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pMapHitBox = mapHitBox.lock()) pMapHitBox-&gt;Draw(); // ヒットボックスを描く<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    いかがでしょう？<b>プレイヤ1で助走をつけてプレイヤ2にぶつかってプレイヤ2が高速で壁にぶつかってもすり抜けないようになった</b>でしょうか？<br>
    泥臭いアナログなやり方ではありますが、すり抜け防止の機能は実現できるようになりました。<br>
    Unityなどのゲームエンジンの内部では高速の移動直線と交わるかの難しい数学ですり抜けない当たり判定をしているでしょうが、<br>
    今回のように、タイルの大きさがほぼ固定の 32 、キャラの大きさも だいたい32 という限定的な条件設定であれば、細切れステップのすり抜け防止も有効策となるわけです。<br>
    <br>
    <br>
    <br>
    <a id="mozTocId0012" class="mozTocH1">
      <h1>Factory.cppにZako生成などの#includeを集約(依存性の逆転)させてMapでZakoなどの敵を出現スポーンさせる</h1>
    </a> さて、次はマップの出現レンジをスクロールさせてザコなどの敵を出現スポーンさせましょう。<br>
    ただ、ちゃんと設計しないとザコ0、ザコ1,2,3.... と種類が増えるとZako0.h Zako1.h Zako2.h... とファイルはどんどん増え#includeもどんどん増えます。<br>
    #includeの機会が増えるということは循環インクルードする可能性も増えますし、<br>
    何よりどこで#include してたっけ？とかいちいちあちこちで#include書きたくないよ、とかの問題もでます。<br>
    さらに<b>「あちこちで new や std::make_shared やObject::Create で実体を生成する処理を書くと引数など仕様が変わった際にコードを直す作業がちらばってて苦痛」</b>です。<br>
    ですので、こういった「生成の処理を一括代行する工場(Factory)パターン」がコードのデザインパターンとしてあります。<br>
    <a href="https://blog.ecbeing.tech/entry/2021/01/20/114000">ファクトリーパターン</a>の書き方は人それぞれ違っては来ますが、大事なポイントは「依存性の逆転」です。<br>
    <b>あるコードが別のコードやクラスを#includeして使用するということは「依存している」</b>ということです。<br>
    MapでZako0を生成するということはMapがZako0.hを#include するということなので<b>「MapはZako0.hに依存している」</b>ことになります。<br>
    今回はFactoryクラスを導入して<b>MapクラスではZako0を直接#includeする必要がない形</b>にします。<br>
    そうすると<b>Mapの立場はどうなるか？MapクラスはZako0に「依存する形」からFactoryを「使用する立場」に変わります</b>。<br>
    「立場が[依存者]から[使用者]に逆転して変わります」Mapクラスの#includeはFactoryだけになります。<br>
    Mapクラス以外でも#includeはFactoryだけになり、#includeを書く数は格段に減ります。<br>
    なるほど、#includeがcppに集中するという点では仲介者Managerのパターンと似てはいますね。<br>
    仲介者Managerが「連絡先の窓口」のニュアンスが強いのに対して、ファクトリーパターンは「新規生成工場」のニュアンスが強いです。<br>
    ですので、以前作成したObject.hクラスのCreate関数でいろいろなGameObjectを新規生成するのもファクトリーパターンの一種といえます。<br>
    今回作成するFactoryクラスではそれに加えて、"Zako0"などの文字列からZako0というクラスを新規生成できる機能も追加します。<br>
    文字列"Zako0"からクラスを新規生成できれば、.jsonのステージに配置したオブジェクトのプロパティに"Zako0"などの文字列を指定すれば、<br>
    jsonのファイルの配置内容の文字列"Zako0"を判別してゲーム上に敵キャラを新規スポーン生成で出現させることができるようになります。<br>
    <br>
    文字列"Zako0"からクラスを新規生成するには<b>「文字列 → newやmake_sharedやCreateなどの新規生成手段の辞書があれば可能」</b>です。<br>
    ですが、本来「プログラム上のクラス名はビルドされた後は機械語のビットに変わりプログラム上で見えているクラス名とは別物に翻訳」されてしまいます。<br>
    本来は無理な話のはずなのですよね。<b>ただし、#マクロ を使うとビルド時に プログラム上のクラス名が文字列に変わるマジック</b>があります。<br>
    <p><code>Factory.hを新規作成</code>して、ザコやアイテムなど「生成する処理を集約して呼び出す工場の窓口」を準備しましょう。</p>
    <p class="source">#ifndef FACTORY_H_<br>
      #define FACTORY_H_<br>
      <br>
      #include &lt;string&gt;<br>
      #include &lt;memory&gt; // 共有ポインタを使う<br>
      #include &lt;unordered_map&gt;<br>
      #include "Vector3.h"<br>
      #include "Quaternion.h"<br>
      #include &lt;assert.h&gt;<br>
      #include &lt;list&gt;<br>
      <br>
      #include "Object.h"<br>
      <br>
      class GameObject; // 前方宣言でクラス宣言だけしてインクルードしない(.hではポインタしか使ってないから)<br>
      class World;<br>
      class Enemy;<br>
      class Bullet;<br>
      class Light;<br>
      class Item;<br>
      <br>
      // 無名名前空間で区切ることで関数名など被らないように(★constructorとかよくある関数名で不安なので)<br>
      namespace // 無名名前空間(他ファイルから参照できない変数や関数を宣言) https://marycore.jp/prog/cpp/unnamed-namespace/<br>
      {<br>
      &nbsp;&nbsp;&nbsp; //template &lt;class classT&gt;<br>
      &nbsp;&nbsp;&nbsp; //void* Constructor(World* world, Vector3 position, Quaternion rotation)<br>
      &nbsp;&nbsp;&nbsp; //{&nbsp;&nbsp;&nbsp; // ★classTをZako1とすると new classT(.. は初期化コンストラクタへの住所ポインタ(void*)型を返す<br>
      &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; return (void*) new classT(world, position, rotation); // newの生成コンストラクタへのポインタを辞書に入れる場合<br>
      &nbsp;&nbsp;&nbsp; //}<br>
      <br>
      &nbsp;&nbsp;&nbsp; template &lt;class classT&gt;<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Object&gt; Constructor(std::shared_ptr&lt;InitParams&gt; initParams, World* world, Vector3 position, Quaternion rotation)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Object::Create&lt;classT&gt;(initParams, world, position, rotation);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //return std::make_shared&lt;classT&gt;(world, position, rotation); // make_sharedの生成コンストラクタへのポインタを辞書に入れる場合<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //[関数へのポインタの応用:コンストラクタも関数の一種なので] https://blog.cryolite.net/entry/01000226/p1<br>
      &nbsp;&nbsp;&nbsp; //typedef void* (*constructorT)(World*, Vector3, Quaternion);<br>
      <br>
      &nbsp;&nbsp;&nbsp; typedef std::shared_ptr&lt;Object&gt;(*constructorT)(std::shared_ptr&lt;InitParams&gt;, World*, Vector3, Quaternion);<br>
      &nbsp;&nbsp;&nbsp; typedef std::unordered_map&lt;std::string, constructorT&gt; ConstructorDictionary;//クラス名⇒初期化コンストラクタへの辞書<br>
      <br>
      &nbsp;&nbsp;&nbsp; //★&lt;クラス名→コンストラクタ&gt;を呼び出す辞書★★★★★★★★★★<br>
      &nbsp;&nbsp;&nbsp; ConstructorDictionary g_Constructors; // クラス名⇒コンストラクタへの辞書配列<br>
      &nbsp;&nbsp;&nbsp; //★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★<br>
      <br>
      &nbsp;&nbsp;&nbsp; // クラス辞書に任意のclassTの初期化コンストラクタを登録する<br>
      &nbsp;&nbsp;&nbsp; template &lt;class classT&gt;<br>
      &nbsp;&nbsp;&nbsp; void RegisterConstructor(std::string const&amp; className)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // insertでクラス辞書配列にクラス名とその初期化コンストラクタのアドレスのペアを登録する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; g_Constructors.insert(std::make_pair(className, &amp;Constructor&lt;classT&gt;));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Object&gt; Construct(std::string const&amp; className, std::shared_ptr&lt;InitParams&gt; initParams, World* world, Vector3 position, Quaternion rotation = { 0,0,0,1 })<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // classNameでクラス辞書をfind検索する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ConstructorDictionary::iterator ite = g_Constructors.find(className);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (ite == g_Constructors.end()) // .end()なら辞書の最後なので見つからなかったってこと<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; assert("登録されていないクラスを初期化しようとしました！ちゃんと Factory.cpp で REGISTER_CONSTRUCTORしてください" == "");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return 0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //辞書のsecondには初期化コンストラクタが入っているのでそれを返す⇒returnと同時に初期化コンストラクタが駆動する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return ite-&gt;second(initParams, world, position, rotation); // _VSTD::forward&lt;_Args&gt;(__args)...));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      <br>
      // ★工場ファクトリーパターン(プレイヤーや敵、アイテムなどのメモリ上の実体の初期化コンストラクトやmake_sharedを作成を一手に任せる)<br>
      // 【効果】新規生成処理の経路を共通の窓口にすることで色んなとこに散らばった生成処理の経路を一本にまとめる<br>
      class Factory<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; //friend Object; // フレンド宣言でObjectクラスのprivateな関数にもアクセスできるようにする<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初回だけ Zako0 などのクラスのコンストラクタを辞書に登録を1回だけする<br>
      &nbsp;&nbsp;&nbsp; // class_name に対応するコンストラクタが辞書登録済かもチェック<br>
      &nbsp;&nbsp;&nbsp; static void Init(const std::string&amp; class_name);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // class_nameに応じて敵などのオブジェクトを生成してreturnで返す<br>
      &nbsp;&nbsp;&nbsp; template &lt;typename TypeT&gt; //[templateを.hと.cppに分けて書くのが難しい] https://qiita.com/i153/items/38f9688a9c80b2cb7da7<br>
      &nbsp;&nbsp;&nbsp; static std::shared_ptr&lt;TypeT&gt; <b>ConstructByClassName</b>(const std::string&amp; <b>class_name</b>, std::shared_ptr&lt;InitParams&gt; initParams, World* world, Vector3 position, Quaternion rotation = { 0,0,0,1 });<br>
      <br>
      &nbsp;&nbsp;&nbsp; //IDに応じて作り分ける役目を工場でMapなどの代わりに請け負う<br>
      &nbsp;&nbsp;&nbsp; template&lt;typename TypeT&gt;<br>
      &nbsp;&nbsp;&nbsp; static std::shared_ptr&lt;TypeT&gt; <b>MakeSharedObject</b>(const std::string&amp; <b>class_name</b>, std::shared_ptr&lt;InitParams&gt; initParams, World* world, Vector3 position, Quaternion rotation = { 0,0,0,1 })<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // class_nameの名前のコンストラクタがあるかチェックし、初回だけ Zako0 などのクラスのコンストラクタを辞書に登録を1回だけする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Init(class_name);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // class_name に応じて敵などのオブジェクトを生成してreturnで返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pObject = <b>ConstructByClassName</b>&lt;TypeT&gt;(<b>class_name</b>, initParams, world, position, rotation);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return pObject; // 共有ポインタに変換して回し読み状態で返す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    Factory.hをみればわかるようにZako0.hやItem.hなどの実際のインクルードはなく代わりにclass Zako0; など前方宣言にしてあります。<br>
    そして、<b>MakeSharedObject</b>関数を窓口にして<b>ConstructByClassName</b>で <b>class_name</b>からZako0などをTypeTとして初期生成する処理の窓口が用意されてます。<br>
    実際のZako0などの初期化には#include が必須なので <b>ConstructByClassName関数は.hでは定義だけして.cppに初期生成の処理を逃がせるようにしています。</b><br>
    <br>
    <p><code>Factory.cppを新規作成</code>して、Zako0やItemなどの「文字列 → Zako0などのコンストラクタへの辞書」でZako0などの実体を生成できるようにしましょう。</p>
    <p class="source">#include "Factory.h"<br>
      <br>
      #include &lt;unordered_map&gt; //★ #文字列 マクロで&lt;クラス名→コンストラクタ&gt;をビルドする瞬間に 辞書に登録<br>
      <br>
      // new や std::make_shared1 や Createで初期生成するには<br>
      // #includeしてコンストラクタを呼び出せる必要が出てくる<br>
      #include "Enemy.h"<br>
      #include "Zako0.h"<br>
      //#include "Zako1.h"<br>
      //#include "Zako2.h"<br>
      //#include "Zako3.h"<br>
      //#include "Boss.h"<br>
      <br>
      //#include "Item.h"<br>
      //#include "ItemBlock.h"<br>
      //#include "ItemBullet.h"<br>
      //#include "ItemMoney.h"<br>
      <br>
      //#include "Bullet.h"<br>
      <br>
      #include "World.h"<br>
      <br>
      //【上級1】★以下サイトを参考に【文字列"Zako1"とかからクラスを初期化するテクニック】<br>
      // https://stackoverflow.com/questions/5447675/how-to-convert-a-string-to-a-class-name/5447776<br>
      // <br>
      // 以下のようにクラスの型タイプを書かずに初期化できるので★if else文をいちいちコピーして増やさずに済む<br>
      // 例. いちいち書く例<br>
      // if (gid == 0)&nbsp;&nbsp;&nbsp;&nbsp; return Factory::make_shared&lt;Zako0&gt;(x + 32, y + 32);<br>
      // else if(gid == 1) return Factory::make_shared&lt;Zako1&gt;(x + 32, y + 32);<br>
      //&nbsp; .......(敵の種類が増えるたびにいちいちif elseコピペで書かないと..)<br>
      // ↓<br>
      // ↓★"Zako1"の文字列で初期化できれば1行で書けるようになる余地が出てくる！(CSVのクラス名の文字から初期化も目指せる)<br>
      // ↓<br>
      // 例. 初期化に&lt;Zako1&gt;を使わずに済むようになる "Zako1"で書ける<br>
      // auto enemy = g_ClassFactory.Construct("Zako1", x + 32, y + 32);//←"Zako1"で初期化 &lt;Zako1&gt;だとコードに書くしかない<br>
      <br>
      <br>
      // クラス名 classTypeName 例. Zako0 のコンストラクタを s_umConstructors 辞書に登録するための↓<b>#文字取得マクロ</b><br>
      #define <b>REGISTER_CONSTRUCTOR</b>(classTypeName) RegisterConstructor&lt;classTypeName&gt;( <b>#classTypeName</b> )<br>
      <br>
      // Factoryクラスの「依存性の逆転」を引き起こすには.hでは★#includeしたくない https://blog.ecbeing.tech/entry/2021/01/20/114000<br>
      // だが、テンプレート関数は普通.hに実装までする必要があるが、それを回避する方法もある https://qiita.com/i153/items/38f9688a9c80b2cb7da7<br>
      // .cppでtemplate関数の実体を.hと分けて定義するには「★最小限下記の定義をオブジェクトごとにする必要」がある<br>
      template std::shared_ptr&lt;Object&gt; Factory::ConstructByClassName&lt;Object&gt;(const std::string&amp;, std::shared_ptr&lt;InitParams&gt;, World*, Vector3, Quaternion);<br>
      template std::shared_ptr&lt;Enemy&gt; Factory::ConstructByClassName&lt;Enemy&gt;(const std::string&amp;, std::shared_ptr&lt;InitParams&gt;, World*, Vector3, Quaternion);<br>
      <br>
      <br>
      namespace // 無名名前空間(他ファイルから参照できない変数や関数を宣言)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; bool isConstructorRegistered{ false }; // 初回だけクラスのコンストラクタ登録を1回だけするためのフラグ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初回だけ Zako0 などのクラスのコンストラクタを辞書に登録を1回だけする<br>
      &nbsp;&nbsp;&nbsp; inline void InitConstructors()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isConstructorRegistered) // 初回だけクラスのコンストラクタ登録を1回だけする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //クラス登録されていないなら初回登録して "文字列"→コンストラクタ を呼び出せるようにしておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>REGISTER_CONSTRUCTOR(Zako0); // Zako0のコンストラクタを辞書に登録</b>しておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //REGISTER_CONSTRUCTOR(Zako1);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //REGISTER_CONSTRUCTOR(Zako2);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //REGISTER_CONSTRUCTOR(Zako3);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //REGISTER_CONSTRUCTOR(Boss);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //REGISTER_CONSTRUCTOR(ItemBullet);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //REGISTER_CONSTRUCTOR(ItemBlock);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //REGISTER_CONSTRUCTOR(ItemMoney);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //REGISTER_CONSTRUCTOR(Bullet);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isConstructorRegistered = true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      void Factory::Init(const std::string&amp; class_name)//int id)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 初回だけ Zako0 などのクラスのコンストラクタを辞書に登録を1回だけする<br>
      &nbsp;&nbsp;&nbsp; InitConstructors();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 辞書に class_name が登録されているかチェック<br>
      &nbsp;&nbsp;&nbsp; assert(g_Constructors.count(class_name) != 0 &amp;&amp; "まだ登録してない クラス名 が Factory.cpp にありました。");<br>
      }<br>
      <br>
      // class_name に応じて敵などのオブジェクトを生成してreturnで返す<br>
      template &lt;typename TypeT&gt; //[templateを.hと.cppに分けて書くのが難しい] https://qiita.com/i153/items/38f9688a9c80b2cb7da7<br>
      std::shared_ptr&lt;TypeT&gt; Factory::ConstructByClassName(const std::string&amp; class_name, std::shared_ptr&lt;InitParams&gt; initParams, World* world, Vector3 position, Quaternion rotation)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // class_nameに応じて敵などのオブジェクトを生成してreturnで返す<br>
      &nbsp;&nbsp;&nbsp; // ★Zako1*でもBoss*でもOK、ベース基底のObject型であいまいな状態で受け取る<br>
      &nbsp;&nbsp;&nbsp; auto pObject = Construct(class_name, initParams, world, position, rotation);<br>
      &nbsp;&nbsp;&nbsp; return std::dynamic_pointer_cast&lt;TypeT&gt;(pObject); // タイプをキャストでTypeTで指定した型に変換して返す<br>
      }<br>
    </p>
    <br>
    <p><code>GameObject.hを変更</code>して、OnDamageなどダメージ系の処理のベースを準備しましょう。</p>
    <p class="source">#ifndef GAMEOBJECT_H_<br>
      #define GAMEOBJECT_H_<br>
      <br>
      #include &lt;memory&gt; // 共有ポインタの定義のため<br>
      <br>
      #include "Vector3.h"<br>
      #include "Quaternion.h"<br>
      #include "Tile.h" // OnHitTileのコールバックに必要<br>
      <br>
      #include "Object.h" // インスタンスIDや検索タグを持ち、shared_from_this_as&lt;継承先クラス名&gt;などができる<br>
      #include "World.h"<br>
      <br>
      class Map; // 前方宣言<br>
      class Component; // 前方宣言<br>
      class Collision; // 前方宣言<br>
      <em>class CollisionParams; // 前方宣言</em><br>
      <br>
      // ゲーム上に表示される物体の基底クラス。<br>
      // プレイヤーや敵、アイテムなどはこのクラスを継承して作る。<br>
      class GameObject : public Object<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるのでCreate関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; GameObject(World* world = nullptr, Vector3 position = { 0,0,0 }, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Object(), m_world{ world }, position{ position }, rotation{ rotation }, velocity{ velocity }, force{ force }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~GameObject() {}<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★下記3つはメモリ上で共用状態になる(position、x,y,z、xyzどの名前から数値を変えたり読出してもメモリ上は同じ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 同じデータに3種類の名前を付けたイメージ、しかもVector3の機能や配列としてのアクセスの仕方もできて便利<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // XYZ座標&nbsp; [匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 position; // XYZ座標<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp;&nbsp; }; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
      <br>
      &nbsp;&nbsp;&nbsp; Quaternion rotation; // 回転クオータニオン<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vx, vy, vz; }; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 velocity; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyz;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vxForce, vyForce, vzForce; }; // XYZ方向にかかる力(Unityでいうと AddForce関数 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 force; // XYZ方向の力(物理的には加速度:1フレームごとにvelocityの増える=加速する量)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyzForce;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 重力を返す、重力を変えたいときはoverrideして処理を変えてください、重力を変えてない場合は 0.0f<br>
      &nbsp;&nbsp;&nbsp; virtual inline float gravity() { return 0.0f; }<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; World* m_world; // GameObjectが配置されたワールドへのリンク<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; virtual World* world() { return m_world; }<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
      &nbsp;&nbsp;&nbsp; virtual void world(World* changeWorld) { m_world = changeWorld; }<br>
      &nbsp;&nbsp;&nbsp; // GameObjectが現在いるマップへのポインタを返す<br>
      &nbsp;&nbsp;&nbsp; Map* map() { return m_world-&gt;map.get(); }<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; bool isDead{ false }; // 死んだ（削除対象）フラグ<br>
      &nbsp;&nbsp;&nbsp; bool isStatic{ false }; // 動かない(静的オブジェクトか?)<br>
      &nbsp;&nbsp;&nbsp; bool isGround{ false }; // 地面についているか<br>
      &nbsp;&nbsp;&nbsp; bool isJumping{ false }; // ジャンプ中か<br>
      &nbsp;&nbsp;&nbsp; bool isFlying{ false }; // 空をとんでいるか<br>
      <br>
      &nbsp;&nbsp;&nbsp; float pushPower{ 5.0f }; // コライダで接触したときに押し返す力(相手側が強いと押される)<br>
      &nbsp;&nbsp;&nbsp; float mass{ 1.0f }; // 質量(重さ)コライダで接触したときに重さでforceを割り算すると動きにくくなる<br>
      &nbsp;&nbsp;&nbsp; <em>std::shared_ptr&lt;CollisionParams&gt; collisionParams; // 衝突関係の物理パラメータ<br>
        <br>
      </em> &nbsp;&nbsp;&nbsp; hash32 typeTag{ "" }; // 小カテゴリ Zako0など個別のタイプ<br>
      &nbsp;&nbsp;&nbsp; hash32 baseTag{ "" }; // 大カテゴリ Enemyなど大まかなベースジャンル<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンポーネントの&lt;ハッシュID, 共有所有ポインタ&gt; の辞書でコンポーネントの共有カウンタ+1を保持する<br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;size_t, std::shared_ptr&lt;Component&gt;&gt; components;<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // コンポーネントを得る 例えば GetComponent&lt;BoxCollider&gt;でBoxColliderという名前のコンポーネントをcomponents辞書から得る<br>
      &nbsp;&nbsp;&nbsp; template&lt;class ComponentT&gt;<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;ComponentT&gt;&gt; GetComponents()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // equal_range 関数を使って、指定したキーの最初と終端の位置を示すイテレータを std::pair&lt;&gt; で取得します。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto range = components.equal_range(hashID); //https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;ComponentT&gt;&gt; returnList; // "ComponentT" 例."CircleCollider"など をキーとするコンポーネント一覧<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto ite = range.first; ite != range.second; ++ite)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; returnList.emplace_back(ite-&gt;second); // 辞書で見つかったコンポーネントを返すリストに追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return returnList;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンポーネントを追加する .AddComponent&lt;BoxCollider&gt;(...)で追加できる<br>
      &nbsp;&nbsp;&nbsp; template&lt;class ComponentT, typename ...ArgsT&gt;<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;ComponentT&gt; AddComponent(ArgsT&amp;&amp;...args)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // shared_from_this()を必ず渡してセットで初期化して、オーナーがリンク切れのコンポーネントができないように気をつける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ComponentT&gt; newComponent = std::make_shared&lt;ComponentT&gt;(shared_from_this_as&lt;GameObject&gt;(), std::forward&lt;ArgsT&gt;(args)<b>...</b>);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // std::unrodered_multimap&lt;&gt; と同型の値を取る std::pair&lt;&gt; を作って insert 関数でcomponents辞書に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; components.insert(std::pair&lt;size_t, std::shared_ptr&lt;ComponentT&gt;&gt;(hashID, newComponent));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return newComponent;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンポーネントを削除する<br>
      &nbsp;&nbsp;&nbsp; template&lt;typename ComponentT&gt;<br>
      &nbsp;&nbsp;&nbsp; bool RemoveComponent(std::shared_ptr&lt;ComponentT&gt; removeComponent)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // equal_range 関数を使って、指定したキーの最初と終端の位置を示すイテレータを std::pair&lt;&gt; で取得します。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto range = components.equal_range(hashID); //https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[イテレート中に探しながら消す] https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/erase.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto ite = range.first; ite != range.second;)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ite-&gt;second == removeComponent)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; components.erase(ite); // 削除された要素の次を指すイテレータが返される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // 見つかって消せた場合は true<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++ite; // 次の要素へイテレータを進める<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 見つからずに消せなかった場合は false<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() = 0; // 純粋仮想関数 = 0 にすると【絶対 Update()関数はoverrideしなきゃいけない義務を付与できる 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() = 0; // 純粋仮想関数 = 0 にすると【絶対 Draw()関数はoverrideしなきゃいけない義務を継承先クラスに付与 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 衝突開始したときの関数 overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollisionEnter(std::shared_ptr&lt;Collision&gt; pCollision)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして衝突開始したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 衝突したときの関数 overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollision(std::shared_ptr&lt;Collision&gt; pCollision)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 衝突終了したときの関数 overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollisionExit(std::shared_ptr&lt;Collision&gt; pCollision)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして衝突終了したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ジャンプ開始した直後に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnStartJump()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideしてジャンプした瞬間に音を鳴らしたりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 空中でジャンプの上昇中に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnJumping()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中でジャンプの上昇中にエフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 空中で落ちている最中に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnFalling()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中で落ちている最中に音を鳴らしたり、エフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // タイルに当たったときのコールバック<br>
      &nbsp;&nbsp;&nbsp; virtual void OnHitTile(HitPart hitPart, HitBit hitPartBit, TileBit checkBit, float xLeft, float xMiddle, float xRight,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yBottom, float yMiddle, float yTop, float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 継承 overrideしてタイルに当たったときの処理を実装する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 継承 overrideしてGameObjectのもつ個別のダメージの値を返す( otherの種類などでダメージ計算式をカスタムできる )<br>
        &nbsp;&nbsp;&nbsp; virtual float Damage(std::shared_ptr&lt;GameObject&gt; other) { return 0.0f; }<br>
        &nbsp;&nbsp;&nbsp; // 継承 overrideして個別のダメージの値を返す<br>
        &nbsp;&nbsp;&nbsp; virtual float Damage() { return 0.0f; }<br>
        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; virtual void OnDamage(std::shared_ptr&lt;GameObject&gt; other)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideしてダメージを受けた時の処理を個別に実装<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>Enemy.hを新規作成</code>して、Zako0などの敵を表現するベース基底クラスを準備しましょう。</p>
    <p class="source">#ifndef ENEMY_H_<br>
      #define ENEMY_H_<br>
      <br>
      #include "GameObject.h"<br>
      #include "Collider.h"<br>
      #include "CollisionParams.h"<br>
      <br>
      class World; //前方宣言<br>
      <br>
      // アイテムの情報のベース基底クラス 継承override してアイテム情報をjsonなどから受け取る<br>
      struct EnemyInfo : public InitParams<br>
      {<br>
      &nbsp;&nbsp;&nbsp; float life{ 1.0f }; // HP lifeが0になったらisDeadになる<br>
      &nbsp;&nbsp;&nbsp; float damage{ 0.0f }; // プレイヤが当たったときに受けるダメージ<br>
      &nbsp;&nbsp;&nbsp; float speedMax{ 3.0f }; // 敵の移動スピードのMAX値<br>
      &nbsp;&nbsp;&nbsp; float colliderRadius{ 8.0f }; // アイテムとしてのコライダの半径<br>
      &nbsp;&nbsp;&nbsp; float bulletRadius{ 16.0f }; // 敵が弾を撃つ際の弾としてのコライダの半径<br>
      &nbsp;&nbsp;&nbsp; int bulletCount{ -1 }; // 弾を撃てる数のカウント値( -1のときは無限に撃てるタイプの敵 )<br>
      &nbsp;&nbsp;&nbsp; float bulletDamage{ 1 }; // 弾の与えるダメージ<br>
      &nbsp;&nbsp;&nbsp; float bulletSpeed{ 10.0f }; // 弾のスピード<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;CollisionParams&gt; collisionParams; // 衝突関係の物理パラメータ<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;GameObject&gt; shooter; // 弾を撃った後に弾の撃ち手の弱共有ポインタのリンクをBulletに渡す<br>
      &nbsp;&nbsp;&nbsp; float shooterAngleY{ 0.0f }; // 撃ち手の撃った際の角度<br>
      &nbsp;&nbsp;&nbsp; int imageIndex{ -1 }; // 敵の画像が分割画像だったらどの位置のIDの画像か<br>
      &nbsp;&nbsp;&nbsp; int bulletImageIndex{ -1 }; // 弾の画像が分割画像だったらどの位置のIDの画像か<br>
      &nbsp;&nbsp;&nbsp; std::string imagePath{ "" }; // 敵の画像のパス<br>
      &nbsp;&nbsp;&nbsp; std::string bulletImagePath{ "" }; // 敵の撃つ弾の画像のパス<br>
      &nbsp;&nbsp;&nbsp; inline EnemyInfo(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) : InitParams{}<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto tmxParams = std::static_pointer_cast&lt;InitTMXProperty&gt;(initParams);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tmxParams-&gt;properties == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto tmxProperties = tmxParams-&gt;properties;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // tmxのjsonの追加プロパティからデータを読み取る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tmxProperties-&gt;count("pushPower") &gt; 0 || tmxProperties-&gt;count("collision_e") &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collisionParams = std::make_shared&lt;CollisionParams&gt;(initParams); // 物理パラメータを読み取り<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto itr = tmxProperties-&gt;find("life");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Float &amp;&amp; "json の imagePath のタイプが Floatでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life = itr-&gt;second.floatValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("damage");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Float &amp;&amp; "json の damage のタイプが Floatでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; damage = itr-&gt;second.floatValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("imageIndex");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Int &amp;&amp; "json の imageIndex のタイプが Intでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imageIndex = itr-&gt;second.intValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("imagePath");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::String &amp;&amp; "json の imagePath のタイプが Stringでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imagePath = itr-&gt;second.stringValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("bulletImageIndex");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Int &amp;&amp; "json の bulletImageIndex のタイプが Intでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bulletImageIndex = itr-&gt;second.intValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("bulletImagePath");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::String &amp;&amp; "json の bulletImagePath のタイプが Stringでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bulletImagePath = itr-&gt;second.stringValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("colliderRadius");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Float &amp;&amp; "json の colliderRadius のタイプが Floatでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; colliderRadius = itr-&gt;second.floatValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("bulletRadius");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Float &amp;&amp; "json の bulletRadius のタイプが Floatでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bulletRadius = itr-&gt;second.floatValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("bulletSpeed");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Float &amp;&amp; "json の bulletSpeed のタイプが Floatでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bulletSpeed = itr-&gt;second.floatValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("bulletCount");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Int &amp;&amp; "json の bulletCount のタイプが Intでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bulletCount = itr-&gt;second.intValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("bulletDamage");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Float &amp;&amp; "json の bulletDamage のタイプが Floatでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bulletDamage = itr-&gt;second.floatValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual ~EnemyInfo() {}<br>
      };<br>
      <br>
      <br>
      // 敵の基底クラス。<br>
      // 全ての敵は、このクラスを継承して作る。<br>
      // ★【勉強】abstract型はC++にない!!【純粋仮想関数】=0を使って作る<br>
      class Enemy : public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Enemy(World* world, Vector3 position, Quaternion rotation = { 0,0,0,1 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; Enemy(const Object::ID&amp; stopper, World* world, Vector3 position)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : GameObject(world, position, rotation)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;baseTag = "Enemy";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; float speedMax{ 1.0f };<br>
      &nbsp;&nbsp;&nbsp; float life{ 1.0f }; // 耐久力<br>
      &nbsp;&nbsp;&nbsp; float m_Damage{ 0 }; // 敵に当たった時に与えるダメージ<br>
      &nbsp;&nbsp;&nbsp; float Damage() override { return m_Damage; }<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Resource&gt; m_pImage; // 画像や3Dモデルなどのパス<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;EnemyInfo&gt; m_enemyInfo; // 敵のjsonから読み取った情報<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (initParams == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_enemyInfo = std::make_shared&lt;EnemyInfo&gt;(initParams); // アイテム情報を受け取る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collisionParams = m_enemyInfo-&gt;collisionParams; // 物理衝突パラメータを受け取る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (Resource::TypeByExt(params-&gt;imagePath) == Resource::Type::Texture)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_enemyInfo-&gt;imagePath != "")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pImage = Resource::MakeShared&lt;Texture&gt;(m_enemyInfo-&gt;imagePath);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Damage = m_enemyInfo-&gt;damage;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life = m_enemyInfo-&gt;life;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; speedMax = m_enemyInfo-&gt;speedMax;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual ~Enemy() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() = 0;//virtual ～ = 0;で【純粋仮想関数に】これで【C#のabstract型に】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理。派生クラスでオーバーライドして使う<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() = 0; //virtual ～ = 0;で【純粋仮想関数に】【関数 = 0で未定義状態を表現】<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollision(std::shared_ptr&lt;Collision&gt; pCollision) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isDead) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto otherCollider = pCollision-&gt;contacts[0].otherCollider.lock();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (otherCollider == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto other = otherCollider-&gt;owner();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (other-&gt;isDead) return; // other側がisDeadだったら処理をスルー<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (other-&gt;typeTag == "PlayerBullet" || other-&gt;baseTag == "Enemy" || other-&gt;baseTag == "Player")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 相手方がPlayerBulletの場合は相手側の物理パラメータを使用する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto colObj = (other-&gt;typeTag == "PlayerBullet") ? other : shared_from_this_as&lt;GameObject&gt;();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float objPushPower = (colObj-&gt;collisionParams != nullptr) ? colObj-&gt;collisionParams-&gt;pushPower : other-&gt;pushPower;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (colObj-&gt;collisionParams != nullptr &amp;&amp; colObj-&gt;collisionParams-&gt;isDEMcollision)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //[離散要素法] https://qiita.com/konbraphat51/items/157e5803c514c60264d2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float k = colObj-&gt;collisionParams-&gt;k; // バネ係数(めり込みに対するバネ反発の掛け率)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float e = colObj-&gt;collisionParams-&gt;e; // 跳ね返り係数(直前と比べどれくらいの速さで離れるか 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float log_e = colObj-&gt;collisionParams-&gt;log_e();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float eta = colObj-&gt;collisionParams-&gt;eta(mass); // 粘性係数 の mass は自分側を使う?<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto norm = pCollision-&gt;contacts[0].normal;// *other-&gt;pushPower; // pushPowerの力でotherに押し返される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto v_norm = dot(other-&gt;velocity - velocity, norm) * norm; // 法線norm方向のv = (v1 - v0)・norm [ドット積]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto sep = pCollision-&gt;contacts[0].separation; // 衝突点どうしのはなれ具合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto F = -k * sep * norm - eta * v_norm;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; force += F / mass; // 衝突法線方向の力を加える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto norm = pCollision-&gt;contacts[0].normal * objPushPower;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; force += -norm;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 継承overrideしてダメージ計算式で値を返す<br>
      &nbsp;&nbsp;&nbsp; virtual float Damage(std::shared_ptr&lt;GameObject&gt; other) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return other-&gt;Damage(); // 弾の側のダメージ値をそのまま採用(防御力とかで式をカスタムもできる)<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void OnDamage(std::shared_ptr&lt;GameObject&gt; other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (other-&gt;baseTag == "Bullet")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; life -= Damage(other); // ライフを減らす&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ライフが無くなったら、死亡<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (life &lt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isDead = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Zako0.hを新規作成</code>して、Enemyを継承overrideして敵の実体を定義しましょう。</p>
    <p class="source">#ifndef ZAKO_0_H_<br>
      #define ZAKO_0_H_<br>
      <br>
      #include "Enemy.h"<br>
      <br>
      #include "MyRandom.h"<br>
      #include "Resource.h"<br>
      <br>
      #include "MapHitBoxComponent.h"<br>
      <br>
      #include "Collider.h"<br>
      #include "GridCollidersComponent.h"<br>
      #include "GridSteps.h"<br>
      <br>
      #include "PhysicsComponent.h" // 重力落下などの物理処理コンポーネントを使う<br>
      <br>
      class World; // 前方宣言<br>
      <br>
      // ザコ0クラス<br>
      class Zako0 : public Enemy<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; Image()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::static_pointer_cast&lt;Texture&gt;(m_pImage);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeed = 0;//移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; float moveAngle = 0; // X軸→方向から何度か<br>
      &nbsp;&nbsp;&nbsp; float deltaAngle = 0; // 動く角度の変化率、ハンドルを切ったらだんだんもとに戻る<br>
      &nbsp;&nbsp;&nbsp; int animCount = 0;<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;GravityComponent&gt; gravityPhysics; // 落下の重力の物理処理コンポーネント<br>
      &nbsp;&nbsp;&nbsp; // マップ地形に対するヒットボックスの当たり判定と押し戻しをするコンポーネント<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;MapHitBoxComponent&gt; mapHitBox;<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;GridCollidersComponent&gt; gridCollision;<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;SphereCollider&gt; sphereCollider;<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Enemy::Init(initParams); // 基底ベースで共通パラメータを読み取り<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_enemyInfo-&gt;imagePath == "" &amp;&amp; m_pImage == nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pImage = Resource::MakeShared&lt;Texture&gt;("Image/zako0.png");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyGravity{ 0.8f,0.8f,0.8f,0.8f }; // 重力の設定値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyDownSpeedMax{ 16, 16, 16, 8 }; // 降下スピードのリミット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // AddComponent内部でshared_from_this()を必ず渡してセットで初期化して、オーナーがリンク切れのコンポーネントができないように気をつける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gravityPhysics = AddComponent&lt;GravityComponent&gt;(vyGravity, vyDownSpeedMax);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 半径16(直径32)の球体コライダ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sphereCollider = AddComponent&lt;SphereCollider&gt;(Vector3(0, 0, 0), 16);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision = AddComponent&lt;GridCollidersComponent&gt;("Enemy");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision.lock()-&gt;LinkCollider(sphereCollider); // コライダをリンクする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float mapHitBoxSize = sphereCollider.lock()-&gt;m_radius * 2.0f; // 球体コライダの直径に合わす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 boxSize{ mapHitBoxSize,mapHitBoxSize,mapHitBoxSize };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 offsetLeftBottomBack{ 3, 0, 3 }; // ボックスの端を内側にどれだけ削るか(キャラの画像に合わせて小さくできる)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 offsetRightTopForward{ 3, 4, 3 }; // ボックスの端を内側にどれだけ削るか(頭を4削る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mapHitBox = AddComponent&lt;MapHitBoxComponent&gt;(boxSize, offsetLeftBottomBack, offsetRightTopForward);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // overrideして物理落下コンポーネントからの重力値を返す<br>
      &nbsp;&nbsp;&nbsp; virtual float gravity() override { auto pGravityPhysics = gravityPhysics.lock(); return (pGravityPhysics != nullptr) ? pGravityPhysics-&gt;gravity() : 0.0f; }<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Zako0(World* world, Vector3 position, Quaternion rotation = { 0,0,0,1 }) : Enemy(world, position, rotation)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "Zako0";<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;pushPower = 5.0f;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vxForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vyForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vzForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += MyRandom::Range(-0.07f, 0.1f); //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; speedMax) MoveSpeed = speedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.7f) MoveSpeed = -0.7f;//ちょっとだけバックできるように<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ランダムAI動作処理<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += MyRandom::PlusMinus(0.3f); // プレイヤがみつからないときはランダム(同じフロアにいないとき)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pGravityPhysics = gravityPhysics.lock();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pGravityPhysics != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGravityPhysics-&gt;Update(); // 重力落下のコンポーネントを更新する<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vx = (float)std::cos(moveAngle) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vz = (float)std::sin(moveAngle) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float vyForceGravity = (pGravityPhysics != nullptr) ? pGravityPhysics-&gt;vyForce() : 0.0f;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vx += vxForce;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy += vyForce + vyForceGravity; // 勢い(力・フォースを加算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vz += vzForce;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy += vyForce; // 勢い(力・フォースを加算<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pMapHitBox = mapHitBox.lock();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float cellHalf = (map() != nullptr) ? (float)map()-&gt;CellSize() / 2.0f : 16.0f; // マップのセルのサイズの半分<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 速すぎて当たり判定がすり抜けないように細切れのステップのグリッドで移動させつつ当たり判定する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 gridStepSize = (pMapHitBox == nullptr) ? Vector3{ cellHalf, cellHalf, cellHalf } : pMapHitBox-&gt;m_BoxSize / 2;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GridSteps vSteps{ velocity, gridStepSize }; // 細切れのステップの数値を計算<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCollisionX{ false }, isCollisionY{ false }, isCollisionZ{ false }, isCollisionCollider{ false };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 1, iSize = vSteps.div + 1; i &lt;= iSize; ++i)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; vStep = (i &lt; iSize) ? vSteps.step : vSteps.mod;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMapHitBox == nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += vx;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionX == false) // まだ前のステップでX方向の衝突がないなら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += vStep.x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionX = pMapHitBox-&gt;hitCheckX((TileBit)TileType::Wall);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMapHitBox == nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionY == false) // まだ前のステップでY方向の衝突がないなら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += vStep.y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionY = pMapHitBox-&gt;hitCheckY((TileBit)TileType::Wall | (TileBit)TileType::Floor);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMapHitBox == nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z += vz;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionZ == false) // まだ前のステップでZ方向の衝突がないなら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z += vStep.z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionZ = pMapHitBox-&gt;hitCheckZ((TileBit)TileType::Wall);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pGridCollision = gridCollision.lock())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridCollision-&gt;Update(); // 所属するマス目セルを更新する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; collider : *pGridCollision-&gt;colliders())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionCollider |= collider.lock()-&gt;IsCollision();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 衝突があったら、速すぎてすり抜けちゃう前に今のステップでbreakで抜ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollisionCollider)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; // ぶつかっているのにさらに次のステップの速度も足すとすり抜けちゃう<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (world() == nullptr) return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto image = Image();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int animIndex = animCount / 20;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (image-&gt;m_handles.size() &gt; 8)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (abs_vx &gt; 0.01f || abs_vz &gt; 0.01f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // GameObjectのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 0; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (image-&gt;m_handles.size() &gt; 8)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // 奥向きの画僧<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 前向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0 &lt;= imgIndex &amp;&amp; imgIndex &lt; image-&gt;m_handles.size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int handleWidth, handleHeight; // 描画するサイズを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::GetGraphSize(image-&gt;m_handles[imgIndex], &amp;handleWidth, &amp;handleHeight);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float ExRate = 32.0f / handleWidth;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, ExRate, angle, *image, imgIndex + animIndex, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pSphereCollider = sphereCollider.lock()) pSphereCollider-&gt;Draw(); // コライダを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pMapHitBox = mapHitBox.lock()) pMapHitBox-&gt;Draw(); // ヒットボックスを描く<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>GameScene.cppを変更</code>して、敵を更新する処理と描く処理を実装しましょう。<br>
    </p>
    <p class="source">#include "GameScene.h"<br>
      <br>
      #include "Player.h"<br>
      <em>#include "Enemy.h"</em><br>
      #include "Map.h"<br>
      <br>
      GameSceneSetting GameScene::settings{ "Map/GameSceneSetting.csv" }; // ゲームシーンの設定情報<br>
      <br>
      // 指定したゲームシーンのタグに関連づいたファイル名に対応したワールドを初期化する<br>
      bool GameScene::LoadWorlds(const std::string&amp; gameSceneTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (settings.info.count(gameSceneTag) == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto&amp; info = settings[gameSceneTag];<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; tag_mapPath : info)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateWorld(tag_mapPath.second.tag); // ワールドをタグをつけて生成<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ワールドのマップをロード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worlds[tag_mapPath.second.tag]-&gt;LoadMap(tag_mapPath.second.mapFilePath);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      void GameScene::ChangeWorld(const std::string&amp; worldTag, std::shared_ptr&lt;Player&gt; pPlayer)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (pPlayer == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp; if (worlds.count(worldTag) == 0) return; // 存在しないタグだった<br>
      <br>
      &nbsp;&nbsp;&nbsp; pPlayer-&gt;world(worlds[worldTag].get()); // ワールドへのリンクをすげ替える<br>
      }<br>
      <br>
      <br>
      void GameScene::Initialize()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Ｚバッファを有効にする [Zの深度]<br>
      &nbsp;&nbsp;&nbsp; //[参考]https://docs.google.com/presentation/d/1Z23t1yAS7uzPDVakgW_M02p20qt9DeTs4ku4IiMDLco/edit?usp=sharing<br>
      &nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する<br>
      &nbsp;&nbsp;&nbsp; // ( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを2つ生成 画面の全体の縦方向サイズの Height / 2 にして、上下分割で配置できるようにする<br>
      &nbsp;&nbsp;&nbsp; screenHandle0 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      &nbsp;&nbsp;&nbsp; screenHandle1 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath1, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath2, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>Resource::MakeShared&lt;Texture&gt;("Image/zako0.png")-&gt;Load(); // 敵画像を読込<br>
        &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;("Image/skullman.png", 3, 4, 32, 32)-&gt;LoadDivGraph(); // 敵画像を読込</em><br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの生成<br>
      &nbsp;&nbsp;&nbsp; if (pWorld != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pWorld-&gt;AddCamera("カメラ1", Camera::defaultCamera); // カメラ1というタグをデフォルトカメラにつけてワールドにデフォルトカメラを配置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ1", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera1 = pWorld-&gt;camera("カメラ1"); // カメラ1 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera1-&gt;SetScreenHandle(screenHandle0); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer1 = Object::Create&lt;Player&gt;(nullptr, pWorld, Pad::Key, Vector3(90 + 256, 32, 95 + 256));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ1", pPlayer1); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath1]);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;camera = pCamera1.get(); // カメラをプレイヤにリンクする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;mass = 100.0f; // 体重を100にして衝突されてもびくともしないようにする<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ2", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera2 = pWorld-&gt;camera("カメラ2"); // プレイヤ2 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera2-&gt;SetScreenHandle(screenHandle1); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer2 = Object::Create&lt;Player&gt;(nullptr, pWorld, Pad::Two, Vector3(190, 32, 195));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ2", pPlayer2); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath2]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;camera = pCamera2.get(); // カメラをプレイヤにリンクする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;mass = 1.0f; // 体重を1にして普通にふっとぶようにする<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      <br>
      void GameScene::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle0); // 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle1); // 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; player : players)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player.second-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 敵の更新処理<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; world : worlds)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; e : world.second-&gt;enemies)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e-&gt;Update();</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // グリッドを更新して隣接するグリッドに含まれる敵や弾の当たり判定を行う<br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; world : worlds)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (world.second-&gt;grid() != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; cell : world.second-&gt;grid()-&gt;cellData)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pGridObject = cell.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (pGridObject != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // while文で数珠つなぎのm_pNextを次々とたどって最後にたどり着くと次がなくてnullptrになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridObject-&gt;checkCell();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridObject = pGridObject-&gt;m_pNext; // リンクリスト構造を次々とたどる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      void GameScene::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_set&lt;World*&gt; drawEndSet; // すでに描いたWorldをポインタのsetでかぶらないように判定する<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; player : players)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player.second-&gt;Draw(); // プレイヤの描画【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto world = player.second-&gt;world(); // プレイヤのいるワールド<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (drawEndSet.count(world) &gt; 0) continue; // すでに描いたWorldは描かずスキップする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawEndSet.emplace(world); // 描いたWorldのポインタ住所をsetに登録する<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; world-&gt;map-&gt;DrawTerrain(); // マップの描画<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 敵の描画<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; enemy : world-&gt;enemies)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enemy-&gt;Draw();<br>
        #ifdef _DEBUG<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //enemy-&gt;DrawHitBox(); // 当たり判定の描画<br>
        #endif<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      #ifdef _DEBUG&nbsp; // デバッグのときだけ_DEBUGが定義され描画される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (world-&gt;grid() != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; cell : world-&gt;grid()-&gt;cellData)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cell.second-&gt;Draw(); // グリッドの描画<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーン0の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, 0, screenHandle0, FALSE);<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, 0, Screen::Width, Screen::Height / 2, GetColor(255, 0, 0));<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーン1の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, Screen::Height / 2, screenHandle1, FALSE);<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, Screen::Height / 2, Screen::Width, Screen::Height, GetColor(0, 255, 0));<br>
      <br>
      }<br>
    </p>
    <br>
    <br>
    <br>
    <p><code>Map.hを変更</code>して、Factoryから敵を生成する処理を追加します。</p>
    <p class="source">#ifndef MAP_H_<br>
      #define MAP_H_<br>
      <br>
      #include &lt;vector&gt; // C#におけるListリストの機能<br>
      #include &lt;unordered_map&gt;&nbsp;&nbsp;&nbsp; // 辞書型連想配列に必要<br>
      #include &lt;memory&gt; // メモリを扱う【共有ポインタに必要】<br>
      #include &lt;limits&gt; //intやfloatなどの無限大∞に使う&nbsp; https://cpprefjp.github.io/reference/limits/numeric_limits/max.html<br>
      <br>
      #include &lt;fstream&gt; // ファイル読み出しifstreamに必要<br>
      #include &lt;string&gt; //文字列に必要<br>
      #include &lt;sstream&gt; // 文字列ストリームに必要<br>
      <br>
      #include &lt;assert.h&gt; // マップ読込み失敗表示用<br>
      <br>
      #include "Screen.h"<br>
      #include "MyMath.h"<br>
      #include "MyHash.h"<br>
      #include "MyDraw.h"<br>
      #include "DataCsv.h"<br>
      #include "TMXJson.h"<br>
      <br>
      #include "Singleton.h"<br>
      #include "GameObject.h"<br>
      #include "World.h"<br>
      #include "Camera.h"<br>
      <em>#include "Factory.h"</em><br>
      <br>
      #include "MapRange.h" // マス目のレンジ表現するクラス<br>
      <br>
      #include "Tile.h"<br>
      <br>
      #include "Vector3.h"<br>
      <br>
      class AI_Map; // 前方宣言<br>
      <br>
      // csvから読み取るマップの基本情報<br>
      struct MapInfo<br>
      {<br>
      &nbsp;&nbsp;&nbsp; MapInfo() = default;<br>
      &nbsp;&nbsp;&nbsp; inline MapInfo(unsigned int CellSize, int SpawnRangeX, int SpawnRangeY, MapRange::Type type = MapRange::Type::Rect)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : CellSize{ CellSize }, spawnRange{ MapRange(SpawnRangeX,SpawnRangeY,type) } {};<br>
      &nbsp;&nbsp;&nbsp; ~MapInfo() {};<br>
      <br>
      &nbsp;&nbsp;&nbsp; unsigned int CellSize{ 1 }; // マップの1マスのピクセル数<br>
      &nbsp;&nbsp;&nbsp; MapRange spawnRange; // 敵の新規出現レンジ<br>
      };<br>
      <br>
      struct MapSetting // マップ情報をMapSetting.csvなどから読みだす<br>
      {<br>
      &nbsp;&nbsp;&nbsp; MapSetting(const std::string&amp; csvFileName = "")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (csvFileName != "")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Load(csvFileName);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; ~MapSetting() {}; //デストラクタ<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::string FilePath{ "" }; // csvのファイルパス<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;MapInfo&gt;&gt; info; //[辞書]stageファイル名→マップ情報<br>
      <br>
      &nbsp;&nbsp;&nbsp; MapInfo&amp; operator[](const std::string&amp; stageFilePath) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(info.count(stageFilePath) != 0 &amp;&amp; "マップのステージ情報が読み取れていません Map/MapSettings.csv にステージ情報があるか確認！");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *info[stageFilePath]; // 読み書き<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; void Load(const std::string&amp; csvFileName = "")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (csvFileName != "") this-&gt;FilePath = csvFileName;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this-&gt;FilePath == "") return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マップ情報のデータ CSVファイルからデータをロード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataCsv Data{ this-&gt;FilePath, DataCsv::CsvType::CsvValue };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string stageFile; //ステージファイル名<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; Data.size(); ++j)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((std::string)Data[j][0] == "//")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue; // 一番左の列が//なら読み飛ばしのコメント行<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((std::string)Data[j][0] == "File")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stageFile = Data[j][1]; //ステージファイル名<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info.emplace(stageFile, std::make_shared&lt;MapInfo&gt;());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (stageFile == "") continue; //ステージファイル名が未確定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((std::string)Data[j][0] == "CellSize")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info[stageFile]-&gt;CellSize = (int)Data[j][1]; //マス目サイズ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ((std::string)Data[j][0] == "SpawnRange")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 敵出現レンジ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapRange::Type rangeType = ((std::string)Data[j][3] == "Ellipse") ? MapRange::Type::Ellipse : MapRange::Type::Rect; //敵出現のタイプ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info[stageFile]-&gt;spawnRange.InitRange(rangeType, Data[j][1].intFromString(), Data[j][2].intFromString()); //敵出現のタイプを初期化設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      // ステージのタイルマップのクラス<br>
      class Map<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Map(World* world, const std::string&amp; filePath = "")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : m_world{ world }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (filePath == "") return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Load(filePath);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // デストラクタ<br>
      &nbsp;&nbsp;&nbsp; ~Map()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // マップデータのお掃除<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enemyData.clear();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //terrains.clear(); //★地形のお掃除<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; static MapSetting settings; // マップに関する設定 Map.cpp で初期読込み デフォルトは"Map/MapSetting.csv" を読み込む<br>
      &nbsp;&nbsp;&nbsp; static TileSetting tileSettings; // タイルに関する設定 Map.cpp で初期読込み デフォルトは"Map/MapSetting.csv" を読み込む<br>
      &nbsp;&nbsp;&nbsp; // タイルのチップ画像のパスとidからTileの情報とタイルのgid情報を得る<br>
      &nbsp;&nbsp;&nbsp; static Tile GetTile(const std::string&amp; mapChipPath, int id, unsigned int&amp; gid)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pos = mapChipPath.find(".", 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string tsxPath{ "" };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pos != std::string::npos) tsxPath = mapChipPath.substr(0, pos) + ".tsx";<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto found = Tilesets::umTsxInfo.find(tsxPath);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (found != end(Tilesets::umTsxInfo) &amp;&amp; found-&gt;second.gid.size() &gt; id)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gid = found-&gt;second.gid[id]; // 辞書で id から gidに変換しておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else return Tile(); // id が-1のときは見つからなかったとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = tsxPath.find("/", 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pos != std::string::npos) tsxPath = tsxPath.substr(pos + 1, tsxPath.size() - 1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Map::tileSettings.info[tsxPath]-&gt;tiles[id];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; World* m_world{ nullptr }; // マップに配置する敵などのポインタを保持するワールド<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; World* world() { return m_world; }<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
      &nbsp;&nbsp;&nbsp; void world(World* changeWorld) { m_world = changeWorld; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;AI_Map&gt; aiMap{ nullptr }; // AIの経路探索に使うAIマップ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 読込んだデータファイルの情報<br>
      &nbsp;&nbsp;&nbsp; std::string FilePath{ "" };<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; unsigned int m_CellSize{ 1 }; // マップの1マスのピクセル数 1のときはtmxに設定されたサイズが採用される<br>
      &nbsp;&nbsp;&nbsp; unsigned int m_HalfCellSize{ 1 }; // マス目サイズの 1/2<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline unsigned int CellSize() { return m_CellSize; }<br>
      &nbsp;&nbsp;&nbsp; inline unsigned int HalfCellSize() { return m_HalfCellSize; }<br>
      &nbsp;&nbsp;&nbsp; inline void SetCellSize(unsigned int cellSize) { m_CellSize = cellSize; m_HalfCellSize = m_CellSize / 2; }<br>
      &nbsp;&nbsp;&nbsp; MapRange spawnRange; // 敵の新規出現レンジをプレイヤから半径X,Yの楕円にする<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline float centerX(int cellX) const { return (cellX &gt;= 0) ? (float)((cellX * m_CellSize) + m_HalfCellSize) : (float)((cellX + 1) * m_CellSize) - m_HalfCellSize; } //マス目サイズ/2ずらし<br>
      &nbsp;&nbsp;&nbsp; inline float centerY(int cellY) const { return (cellY &gt;= 0) ? (float)((cellY * m_CellSize) + m_HalfCellSize) : (float)((cellY + 1) * m_CellSize) - m_HalfCellSize; } //マス目サイズ/2ずらし<br>
      &nbsp;&nbsp;&nbsp; inline float centerZ(int cellZ) const { return (cellZ &gt;= 0) ? (float)((cellZ * m_CellSize) + m_HalfCellSize) : (float)((cellZ + 1) * m_CellSize) - m_HalfCellSize; } //マス目サイズ/2ずらし<br>
      &nbsp;&nbsp;&nbsp; inline int cellX(float worldX) const { return (worldX &gt;= 0) ? (int)worldX / m_CellSize : (int)worldX / m_CellSize - 1; } // マイナス方向にも対応<br>
      &nbsp;&nbsp;&nbsp; inline int cellY(float worldY) const { return (worldY &gt;= 0) ? (int)worldY / m_CellSize : (int)worldY / m_CellSize - 1; } // マイナス方向にも対応<br>
      &nbsp;&nbsp;&nbsp; inline int cellZ(float worldZ) const { return (worldZ &gt;= 0) ? (int)worldZ / m_CellSize : (int)worldZ / m_CellSize - 1; } // マイナス方向にも対応<br>
      <br>
      &nbsp;&nbsp;&nbsp; TMXCsv enemyData;// 敵配置データ<br>
      &nbsp;&nbsp;&nbsp; TMXJson tmxData; // タイルマップエディタのjsonデータ<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // &lt;gid→idに対応したタイプのbit&gt; へ変換するvector型の辞書<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;TileBit&gt; gidTypeBits{ 0 };<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline TileBit&amp; gidTypeBit(unsigned int gid)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (gid &gt;= (int)gidTypeBits.size()) gidTypeBits.resize(gid + 1, 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (gid &lt; 0) ? gidTypeBits[0] : gidTypeBits[gid];<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // id→ビットのタイプ の辞書に |= でbitTypeをビット論理和して、Wall:壁 や Bounce:はずむ などの特性を追加する<br>
      &nbsp;&nbsp;&nbsp; TileBit SetTypeBit(unsigned int gid, TileBit bitType) { return gidTypeBit(gid) |= bitType; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // id→ビットのタイプ の辞書で &amp; ビット論理積で 指定したidが Wall:壁 や Bounce:はずむ などの特性を持つかを判定する<br>
      &nbsp;&nbsp;&nbsp; inline bool isType(unsigned int gid, TileType bitType) { return gidTypeBit(gid) &amp; bitType; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // id→ビットのタイプ の辞書で &amp; ビット論理積で 指定したidが Wall:壁 や Bounce:はずむ などの特性を持つかを判定し一致したBitを返す(複数が1のビットもありうる)<br>
      &nbsp;&nbsp;&nbsp; inline TileBit matchTypes(unsigned int gid, TileBit bitType) { return gidTypeBit(gid) &amp; bitType; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // tilesetsの.tsxのfirstgidをたどって、SetTypeBitでビット辞書に<br>
      &nbsp;&nbsp;&nbsp; // csvのtileSettingsから読み取っておいたビット設定を登録<br>
      &nbsp;&nbsp;&nbsp; bool InitTypeBit(const Tilesets&amp; tilesets)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(tilesets.size() &gt; 0 &amp;&amp; "ステージのjsonファイルにタイルセット設定が一つもありません");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tilesets.size() == 0) return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; pair : tilesets)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto firstgid = pair.first;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; tsxFilePath = pair.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; tsxInfo = tilesets.umTsxInfo.at(tsxFilePath);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // [親フォルダを抽出] https://qiita.com/takano_tak/items/acf34b4a30cb974bab65<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t path_i = tsxFilePath.find_last_of("\\/");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (path_i + 1 &gt;= tsxFilePath.size()) continue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto tsxFile = tsxFilePath.substr(path_i + 1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto csvInfo = tileSettings.info.find(tsxFile);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (csvInfo == end(tileSettings.info)) continue; // csv側にタイルの情報がなかった<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // gidが0 idが-1 のデフォルトのタイルのビット特性を設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetTypeBit(0, csvInfo-&gt;second-&gt;idTypeBit(-1));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id = 0; // gidじゃなく0から始まるローカルなid<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto gid = firstgid, iEnd = firstgid + tsxInfo.tilecount; gid &lt; iEnd; ++gid)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // このMapのgidのビット辞書にcsvのtileSettingsから読み取っておいたビット設定を登録<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetTypeBit(gid, csvInfo-&gt;second-&gt;idTypeBit(id));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++id; // ローカルなidも次に進める<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // マップファイルのロード<br>
      &nbsp;&nbsp;&nbsp; void Load(const std::string&amp; filePath)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;FilePath = filePath;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ★jsonファイルの読み込み<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmxData.Load(filePath);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // tilesetsの.tsxのfirstgidをたどって、SetTypeBitでビット辞書に<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // csvのtileSettingsから読み取っておいたビット設定を登録<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitTypeBit(tmxData.tilesets);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto info = settings[filePath];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (info.spawnRange.umRange.size() != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnRange = info.spawnRange;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnRange.InitRange(MapRange::Type::Ellipse, 10, 10);// 敵の新規出現レンジをプレイヤから半径X,Yの楕円にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (info.CellSize != 1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetCellSize(info.CellSize); // csvに書かれているCellSizeを設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmxData.SetGridSize({(float)info.CellSize ,(float)info.CellSize ,(float)info.CellSize });<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // if (info.CellSize == 1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetCellSize(tmxData.tmxInfo.tilewidth); // tmxのタイルの幅を取得<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// オブジェクトを Factoryクラスで className に応じて見きわめて 生成・配置する<br>
        &nbsp;&nbsp;&nbsp; template&lt;typename TypeT&gt;<br>
        &nbsp;&nbsp;&nbsp; inline std::shared_ptr&lt;TypeT&gt; SpawnTmxObject(const std::string&amp; className, std::shared_ptr&lt;InitParams&gt; initParams, Vector3 spawnPos, Quaternion rotation = { 0,0,0,1 })<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //IDに応じてFactory工場で作り分ける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Factory::MakeSharedObject&lt;TypeT&gt;(className, initParams, m_world, spawnPos);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 画面スクロール（位置の更新）<br>
        &nbsp;&nbsp;&nbsp; void Scroll3D(Vector3 prevPos, Vector3 delta, MapRange* pSpawnRange = nullptr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;TMXobjects*&gt; tmxObjectsList{ &amp;tmxData.enemies,&amp;tmxData.lights,&amp;tmxData.items,&amp;tmxData.objects };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; tmxObjects : tmxObjectsList)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tmxObjects-&gt;data.size() == 0) continue; // リストにデータが一つもなければスクロールせず次へ<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmxObjects-&gt;Scroll(prevPos, delta, (pSpawnRange != nullptr) ? *pSpawnRange : (tmxObjects-&gt;pSpawnRange != nullptr) ? *(tmxObjects-&gt;pSpawnRange) : spawnRange,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [&amp;](int gridX, int gridY, int gridZ)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pObject = tmxObjects-&gt;top(gridX, gridY, gridZ); // グリッドからオブジェクトを取り出す<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (pObject != nullptr)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pObj = (TMXobject*)pObject;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //int spawnID = pObj-&gt;spawnID; // 生成する敵のID情報をTMXの jsonファイルのデータから読み取る<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float ratioX = (float)tmxObjects-&gt;cellWidth / tmxData.tmxInfo.tilewidth;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float ratioY = (float)tmxObjects-&gt;cellHeight / tmxData.tmxInfo.tileheight; // タイルマップエディタとのスケールの違いの比率を計算<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float ratioZ = (float)tmxObjects-&gt;cellDepth / tmxData.tmxInfo.tilewidth;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //クラス名とベースクラス名に応じて工場で作り分ける<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pObj-&gt;baseType == "Enemy")<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_world-&gt;enemies.emplace_back(SpawnTmxObject&lt;Enemy&gt;(pObj-&gt;type, pObj-&gt;GetInitProperty(), Vector3(pObj-&gt;x * ratioX, pObj-&gt;z * ratioZ, pObj-&gt;y * ratioY)));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (pObj-&gt;baseType == "Light")<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; m_world-&gt;lights.emplace_back(SpawnTmxObject&lt;Light&gt;(pObj-&gt;type, Vector3(pObj-&gt;x * ratioX, pObj-&gt;z * ratioZ, pObj-&gt;y * ratioY)));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (pObj-&gt;baseType == "Item")<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; m_world-&gt;items.emplace_back(SpawnTmxObject&lt;Item&gt;(pObj-&gt;type, pObj-&gt;GetInitProperty(), Vector3(pObj-&gt;x * ratioX, pObj-&gt;z * ratioZ, pObj-&gt;y * ratioY)));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (pObj-&gt;baseType == "Object")<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; m_world-&gt;objects.emplace_back(SpawnTmxObject&lt;Object&gt;(pObj-&gt;type, Vector3(pObj-&gt;x * ratioX, pObj-&gt;z * ratioZ, pObj-&gt;y * ratioY)));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //m_world-&gt;enemies.emplace_back(Factory::MakeSharedTmxObject(spawnID,m_world, Vector3(pEnemy-&gt;x * ratioX, pEnemy-&gt;z * ratioZ, pEnemy-&gt;y * ratioY)));<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pObject = pObject-&gt;m_pNext; // 同じグリッドの次のオブジェクトへ<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmxObjects-&gt;Erase(pObj); // tmxObjectsのdataとグリッドからデータを消して再びスポーンしないようにする<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // このグリッドには何もいなくなるのでマス目自体eraseして高速化<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmxObjects-&gt;cellData.erase(CellXYZ(gridX, gridY, gridZ));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 指定された座標（ワールド座標）の地形データを取得する<br>
      &nbsp;&nbsp;&nbsp; unsigned int GetTerrain(float worldX, float worldY, float worldZ = (std::numeric_limits&lt;float&gt;::min)())<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (worldZ != (std::numeric_limits&lt;float&gt;::min)())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float tmpY = worldY;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worldY = worldZ; //【YとZを変換】Zの入力があるときはZをYとして扱う<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worldZ = tmpY; //【YとZを変換】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 負の座標が指定された場合は、何も無いものとして扱う<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (worldX &lt; 0 || worldY &lt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Tile::None;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapX = (int)(worldX / m_CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapY = (int)(worldY / m_CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapZ = (int)(worldZ / m_CellSize);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tmxData.terrains.count(mapZ) == 0) // zの階層がまだなかったとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Tile::None; // 配列の範囲外は、何も無いものとして扱う<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; terrainZ = tmxData.terrains[mapZ]; // 辞書からZに対応するデータへの参照を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mapY &gt;= terrainZ.size() || mapX &gt;= terrainZ[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Tile::None; // 配列の範囲外は、何も無いものとして扱う<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return terrainZ[mapY][mapX]; // 二次元配列から地形IDを取り出して返却する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 指定された座標（ワールド座標）の地形データを書き換える return には書き換える前のgidが返る<br>
      &nbsp;&nbsp;&nbsp; bool SetTerrain(unsigned int gid, float worldX, float worldY, float worldZ = (std::numeric_limits&lt;float&gt;::min)())<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (worldZ != (std::numeric_limits&lt;float&gt;::min)())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float tmpY = worldY;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worldY = worldZ; //【YとZを変換】Zの入力があるときはZをYとして扱う<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worldZ = tmpY; //【YとZを変換】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 負の座標が指定された場合は、書き換えられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (worldX &lt; 0 || worldY &lt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapX = (int)(worldX / m_CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapY = (int)(worldY / m_CellSize);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapZ = (int)(worldZ / m_CellSize);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 二次元配列の範囲外は、書き換えられない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (mapY &gt;= terrain.size() || mapX &gt;= terrain[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isNewZ = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tmxData.terrains.count(mapZ) == 0) isNewZ = true; // 新しい z の階層の場合<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; terrainZ = tmxData.terrains[mapZ]; // 辞書からZに対応するデータへの参照を得る<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isNewZ) // 新しい z の階層の場合<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainZ.z = mapZ;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainZ.tilesets = &amp;(tmxData.tilesets); //&nbsp; 新しい z の階層のtilesetsを設定する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainZ.Width = tmxData.tmxInfo.width; terrainZ.Height = tmxData.tmxInfo.height;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; terrinZYX = terrainZ[mapY][mapX];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrinZYX.tilesets = &amp;(tmxData.tilesets);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrinZYX = gid; // 地形データ書き換え<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainZ[mapY][mapX] = gid; // 地形データ書き換え<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // gidに応じてタイルを描き分ける<br>
      &nbsp;&nbsp;&nbsp; void DrawTile(unsigned int gid, float worldX, float worldY, float worldZ, float ExRate)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto texture = TsxInfo::id_images[gid].second.lock();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id = TsxInfo::id_images[gid].first;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isType(gid, TileType::Floor)) // 板ポリゴンで床を描く <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaFloorF3D(MyDraw::Plane::Y, worldX, worldY, worldZ, ExRate, 0, *texture, id);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isType(gid, TileType::Wall)) //壁のときはボックスを描く <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivBoxF3D(worldX, worldY, worldZ, ExRate, *texture, id);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 地形をタイルで描く<br>
      &nbsp;&nbsp;&nbsp; void DrawTerrain()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; terrainN : tmxData.terrains)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; terrainZ = *terrainN.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cellZ = terrainN.first;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int cellY = 0, ySize = terrainZ.size(); cellY &lt; ySize; cellY++)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int cellX = 0, xSize = terrainZ[cellY].size(); cellX &lt; ySize; cellX++)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x = centerX(cellX); //マス目サイズ/2ずらし<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float y = centerY(cellY); //マス目サイズ/2ずらし<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float z = centerZ(cellZ); //マス目サイズ/2ずらし<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id = -1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int gid = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cellY &lt; terrainZ.size() &amp;&amp; cellX &lt; terrainZ[cellY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gid = terrainZ[cellY][cellX];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (0 &lt;= gid &amp;&amp; gid &lt; TsxInfo::id_images.size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pTileImage = TsxInfo::id_images[gid].second.lock();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pTileImage == nullptr) continue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // ワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //auto stepXYZs = MyMath::CrossGridVec(camera-&gt;pos - camera-&gt;m_targetXYZ, Vector3{ CellSize, CellSize, CellSize });<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float ExRate = (float)m_CellSize / (float)pTileImage-&gt;m_XSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawTile(gid, x, z, y, ExRate); // idに応じてタイルを描き分ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 指定された座標（ワールド座標）の地形が壁か調べる<br>
      &nbsp;&nbsp;&nbsp; inline bool IsWall(float worldX, float worldY, float worldZ = (std::numeric_limits&lt;float&gt;::min)())<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto terrainID = GetTerrain(worldX, worldY, worldZ); // 指定された座標の地形のIDを取得<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return IsWall(terrainID);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //あるIDが壁かどうかだけ調べる<br>
      &nbsp;&nbsp;&nbsp; inline bool IsWall(unsigned int gid)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 地形が壁ならtrue、違うならfalseを返却する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return isType(gid, TileType::Wall);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 指定された座標worldPosの地形が 壁 や ダメージブロックかなどをチェックする関数<br>
      &nbsp;&nbsp;&nbsp; bool checkID(TileBit checkBit, float worldX, float worldY, float worldZ,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, unsigned int* pTerrainID = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int terrainID; // 指定された座標の地形のID<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (worldZ != (std::numeric_limits&lt;float&gt;::min)())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //【YとZを変換】Zの入力があるときはZをYとして扱う タイルマップの X,Yは3DではYがZ:奥行に対応するから<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float tmpY = worldY;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worldY = worldZ;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worldZ = tmpY; //【YとZを変換】<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (worldX &lt; 0 || worldY &lt; 0) return false; // 負の座標が指定された場合<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // マップ座標系（二次元配列の行と列）に変換する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapX = cellX(worldX), mapY = cellY(worldY), mapZ = cellZ(worldZ);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tmxData.terrains.count(mapZ) == 0) // zの階層がまだなかったときは 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainID = 0; // 範囲外のときは 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else // zの階層がすでにあったとき<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 二次元配列の範囲内か判定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; terrainZ = tmxData.terrains[mapZ];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mapY &gt;= terrainZ.size() || mapX &gt;= terrainZ[mapY].size())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainID = 0; // 範囲外のときは 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; terrainID = terrainZ[mapY][mapX]; // 配列から地形IDを取り出す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pTerrainID != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pTerrainID = terrainID;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TileBit matchBits = matchTypes(terrainID, checkBit); // ビット論理積 &amp; で地形のchekckBitを確かめる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isCheckBit = matchBits != (TileBit)TileType::None;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCheckBit &amp;&amp; pMapX != nullptr &amp;&amp; pMapY != nullptr &amp;&amp; pMapZ != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pMapX = mapX, * pMapY = mapY, * pMapZ = mapZ; // ブロックのマス目のセル番号をポインタに記録(nullptrの場合は記録しない)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMatchBits != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pMatchBits = matchBits; // マッチしたビットをポインタ先に代入して返す<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return isCheckBit;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Player.cppを変更</code>して、マップをスクロールして敵を出現させましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      #include "GridSteps.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      void Player::HandleInput()<br>
      {<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_LEFT) <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_A)) )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = - MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += 1; //ハンドルを左に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_RIGHT)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_D)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle -= 1; //ハンドルを右に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_UP)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_W)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = - MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += 0.6f; //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; MoveSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = MoveSpeedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(pad, PAD_INPUT_DOWN)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_S)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed -= 0.6f; //ブレーキを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.9f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = -0.9f;//ちょっとだけバックできるように<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pad == Pad::Key || pad == Pad::One) // コントローラ1またはキーボード操作のプレイヤのときだけ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGUP)) // キーボードのPageUp ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = 2.0f; // テスト用に空中の上方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGDN)) // キーボードのPageDown ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -2.0f; // テスト用に空中の下方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      // ジャンプ開始した直後に呼ばれる関数<br>
      void Player::OnStartJump()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; this-&gt;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      }<br>
      <br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; vxForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp; vyForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp; vzForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pJumpPhysics = jumpPhysics.lock();<br>
      &nbsp;&nbsp;&nbsp; if (pJumpPhysics != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pad, PAD_INPUT_A) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;JumpStart(); // ジャンプのスタート処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (vy &gt; 0 &amp;&amp; Input::GetButtonUp(pad, PAD_INPUT_A) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonUp(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;JumpCancel(); // ジャンプのキャンセル処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;Update(); // ジャンプのコンポーネントを更新する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; auto pGravityPhysics = gravityPhysics.lock();<br>
      &nbsp;&nbsp;&nbsp; if (pGravityPhysics != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGravityPhysics-&gt;Update(); // 重力落下のコンポーネントを更新する<br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; rotation.SetRotation(VGet(0, (180 - moveAngle) * MyMath::Deg2Rad, 0)); // 前向きの3Dモデルなら180度回転させて奥方向の向きに設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; float vyForceJump = (pJumpPhysics != nullptr) ? pJumpPhysics-&gt;vyForce() : 0.0f;<br>
      &nbsp;&nbsp;&nbsp; float vyForceGravity = (pGravityPhysics != nullptr) ? pGravityPhysics-&gt;vyForce() : 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp; vx += vxForce; // 力をかけて速度に加算する<br>
      &nbsp;&nbsp;&nbsp; vy += vyForce + vyForceJump + vyForceGravity; // 勢い(力・フォースを加算<br>
      &nbsp;&nbsp;&nbsp; vz += vzForce; // 力をかけて速度に加算する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pMapHitBox = mapHitBox.lock();<br>
      &nbsp;&nbsp;&nbsp; float cellHalf = (map() != nullptr) ? (float)map()-&gt;CellSize() / 2.0f : 16.0f; // マップのセルのサイズの半分<br>
      &nbsp;&nbsp;&nbsp; // 速すぎて当たり判定がすり抜けないように細切れのステップのグリッドで移動させつつ当たり判定する<br>
      &nbsp;&nbsp;&nbsp; Vector3 gridStepSize = (pMapHitBox == nullptr) ? Vector3{ cellHalf, cellHalf, cellHalf } : pMapHitBox-&gt;m_BoxSize / 2;<br>
      &nbsp;&nbsp;&nbsp; GridSteps vSteps{ velocity, gridStepSize }; // 細切れのステップの数値を計算<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp; if (vSteps.div &gt;= 1000) // 分割が1000を超える場合は物理式かどこかで∞=inf や 計算不可能数=nanが発生してそう<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // vx,vy,vzに原因がありそうなのでデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isfinite(vx)) printfDx(("vx:∞かnan x:" + std::to_string(x) + "\n").c_str());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isfinite(vy)) printfDx(("vy:∞かnan y:" + std::to_string(y) + "\n").c_str());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isfinite(vz)) printfDx(("vz:∞かnan z:" + std::to_string(z) + "\n").c_str());<br>
      &nbsp;&nbsp;&nbsp; }<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; bool isCollisionX{ false }, isCollisionY{ false }, isCollisionZ{ false }, isCollisionCollider{ false };<br>
      &nbsp;&nbsp;&nbsp; for (int i = 1, iSize = vSteps.div + 1; i &lt;= iSize; ++i)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; vStep = (i &lt; iSize) ? vSteps.step : vSteps.mod;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMapHitBox == nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += vx;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionX == false) // まだ前のステップでX方向の衝突がないなら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += vStep.x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionX = pMapHitBox-&gt;hitCheckX((TileBit)TileType::Wall);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMapHitBox == nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionY == false) // まだ前のステップでY方向の衝突がないなら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += vStep.y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionY = pMapHitBox-&gt;hitCheckY((TileBit)TileType::Wall | (TileBit)TileType::Floor);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMapHitBox == nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z += vz;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionZ == false) // まだ前のステップでZ方向の衝突がないなら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z += vStep.z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionZ = pMapHitBox-&gt;hitCheckZ((TileBit)TileType::Wall);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pGridCollision = gridCollision.lock())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridCollision-&gt;Update(); // 所属するマス目セルを更新する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; collider : *pGridCollision-&gt;colliders())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionCollider |= collider.lock()-&gt;IsCollision();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 衝突があったら、速すぎてすり抜けちゃう前に今のステップでbreakで抜ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollisionCollider)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; // ぶつかっているのにさらに次のステップの速度も足すとすり抜けちゃう<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>map()-&gt;Scroll3D(position, Vector3(vx, vy, vz)); // マップ（敵）データをスクロール</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; // moveAngleは2D画像のX方向右を0度とするから、-90度回すと画像を正面に捉える位置にカメラを置ける<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      void Player::OnCollision(std::shared_ptr&lt;Collision&gt; pCollision)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (isDead) return; // すでにisDeadなら return<br>
      &nbsp;&nbsp;&nbsp; auto otherCollider = pCollision-&gt;contacts[0].otherCollider.lock(); // コライダの弱共有ポインタをロック<br>
      &nbsp;&nbsp;&nbsp; if (otherCollider == nullptr) return; // すでにコライダが消去済だった<br>
      &nbsp;&nbsp;&nbsp; auto other = otherCollider-&gt;owner();<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (other-&gt;isDead) return; // other側がisDeadだったら処理をスルー<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (other-&gt;baseTag == "Enemy" || other-&gt;baseTag == "Player")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[離散要素法:DEM] https://qiita.com/konbraphat51/items/157e5803c514c60264d2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float k = 1.0f; // バネ係数(めり込みに対するバネ反発の掛け率)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float e = 0.1f; // はね返り係数(直前と比べどれくらいの速さで離れるか0.5だと半分の速さではね返る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float log_e = std::log(e); // はね返り係数の自然対数log<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float pi_2 = DX_PI_F * DX_PI_F; // πの2乗<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float eta = -2.0f * log_e * std::sqrt(k * mass / (log_e * log_e + pi_2)); // 粘性係数η(イータ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto norm = pCollision-&gt;contacts[0].normal; // 衝突の法線 * other-&gt;pushPower; // pushPowerの力でotherに押し返される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto v_norm = dot(other-&gt;velocity - velocity, norm) * norm; // [相対速度v] 法線norm方向のv = (v1 - v0)・norm [ドット積]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto sep = pCollision-&gt;contacts[0].separation; // 衝突点どうしの距離(めりこみ距離)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto F = -k * sep * norm - eta * v_norm; // F (法線方向の力) = -k × sep - η × v (相対速度:自分から見た相手otherの速度)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; force += F / mass; // 衝突法線方向の力を加える<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int animIndex = animCount / 20; // キャラのパラパラアニメの画像番号(最大3)<br>
      &nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp; if (abs_vx &gt; 1.00f || abs_vz &gt; 1.00f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6; // キャラが地面のXとZ方向に少しでもスピードがあったらアニメを走らせる<br>
      &nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // プレイヤのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 9; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // カメラ向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 奥向きの画像<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *image, imgIndex + animIndex, TRUE);<br>
      <br>
      #ifdef _DEBUG // デバッグのときだけ_DEBUGが定義され描かれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pSphereCollider = sphereCollider.lock()) pSphereCollider-&gt;Draw(); // コライダを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pMapHitBox = mapHitBox.lock()) pMapHitBox-&gt;Draw(); // ヒットボックスを描く<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    <br>
    いかがでしょう？敵キャラが表示されたでしょうか？<br>
    敵キャラはあとからAIで賢くすることとして、現在はまだふらふらしているだけです。<br>
    ジャンプして踏みつければ大ジャンプできるか試しておきましょう。<br>
    <br>
    <br>
    <a id="mozTocId0013" class="mozTocH1">
      <h1>ItemクラスとItemActionクラスを作成し継承して弾やブロックなどのアイテムを取って使用できるようにする</h1>
    </a>
    <p><code>Item.hを新規作成</code>して、アイテムのベース基底クラスを定義しましょう。</p>
    <p class="source">#ifndef ITEM_H_<br>
      #define ITEM_H_<br>
      <br>
      #include "GameObject.h"<br>
      #include "Collider.h"<br>
      <br>
      class World; //前方宣言<br>
      <br>
      // アイテムの情報のベース基底クラス 継承override してアイテム情報をjsonなどから受け取る<br>
      struct ItemInfo : public InitParams<br>
      {<br>
      &nbsp;&nbsp;&nbsp; //std::shared_ptr&lt;InitParams&gt; initParams{ nullptr };<br>
      &nbsp;&nbsp;&nbsp; hash32 itemTag{ "" }; // アイテムを区別して、アイコンを区別して辞書に分けていれるためのタグ<br>
      &nbsp;&nbsp;&nbsp; inline ItemInfo(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) : InitParams()<br>
      &nbsp;&nbsp;&nbsp; {}<br>
      &nbsp;&nbsp;&nbsp; virtual ~ItemInfo() {}<br>
      };<br>
      <br>
      // アイテムの基底クラス。<br>
      // 全てのアイテムは、このクラスを継承して作る。<br>
      class Item : public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ItemInfo&gt; m_ItemInfo{ nullptr }; // アイテムに関する情報<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Item(World* world, Vector3 position, Quaternion rotation = { 0,0,0,1 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : GameObject(world, position, rotation)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;baseTag = "Item";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual ~Item() {}<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; // 継承overrideしてアイテムを取った時にアイテム一覧で選択できるアクションを持つかをtrueかfalseで返す<br>
      &nbsp;&nbsp;&nbsp; virtual bool hasAction() { return false; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Initをoverrideしてアイテムの情報をjsonなどから受け取っておく<br>
      &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ItemInfo = std::make_shared&lt;ItemInfo&gt;(initParams); // アイテム情報を持っておく<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollision(std::shared_ptr&lt;Collision&gt; pCollision) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isDead) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto otherCollider = pCollision-&gt;contacts[0].otherCollider.lock();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (otherCollider == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto thisCollider = pCollision-&gt;contacts[0].thisCollider.lock();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (thisCollider == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto other = otherCollider-&gt;owner();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (other-&gt;isDead) return; // other側がisDeadだったら処理をスルー<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (other-&gt;baseTag == "Player")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!thisCollider-&gt;isTrigger)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 跳ね返したいアイテムの場合は forceをかける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto norm = pCollision-&gt;contacts[0].normal * other-&gt;pushPower;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; force += -norm;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; other-&gt;OnItem(shared_from_this_as&lt;Item&gt;()); // プレイヤのときはアイテムの効果を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnItem(shared_from_this_as&lt;Item&gt;()); // 自身のOnItemも呼ぶ(アイテム自身が爆発したりできる)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アイテムを取ったときの共通処理を overrideして実装<br>
      &nbsp;&nbsp;&nbsp; virtual void OnItem(std::shared_ptr&lt;Item&gt; pItem) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pItem == shared_from_this_as&lt;Item&gt;())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 自分自身からOnItemが呼ばれた場合はこちら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (pItem-&gt;baseTag == "Player")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; //life += 1; // ライフを増やすなど<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      <br>
      #endif<br>
    </p>
    <br>
    ボタンを押して<b>選択中のアイテムを次のアイテムに変えるのに向いているのは「次、前のリンクリスト構造」</b>です。<br>
    <b>各アイテムのアイコンを表すItemActionクラス</b>には<b>前Prev、次Nextのリンクリスト構造</b>を持たせることにしましょう。<br>
    <p><code>ItemAction.hを新規作成</code>して、アイテムを使ったときに起こるアクションのベース基底クラスを定義しましょう。</p>
    <p class="source">#ifndef ITEM_ACTION_H_<br>
      #define ITEM_ACTION_H_<br>
      <br>
      #include "Component.h"<br>
      #include "Vector3.h"<br>
      #include "Resource.h"<br>
      #include "Item.h"<br>
      <br>
      class ItemListComponent; // 前方宣言<br>
      <br>
      // アイテムを使ったときに起きるアクション<br>
      class ItemAction : public Component<br>
      {<br>
      &nbsp;&nbsp;&nbsp; //protected:<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline ItemAction(ItemListComponent* pItemList, std::shared_ptr&lt;GameObject&gt; pOwner)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : m_items{ pItemList }, Component(pOwner)//, m_itemTag{ itemTag }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;baseTag = "ItemAction";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual ~ItemAction() {}<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ItemInfo&gt; m_ItemInfo{ nullptr }; // アイテムに関する情報<br>
      &nbsp;&nbsp;&nbsp; // アイテムを区別して、アイコンを区別して辞書に分けていれるためのタグ<br>
      &nbsp;&nbsp;&nbsp; virtual hash32 ItemTag() { return (m_ItemInfo == nullptr) ? "" : m_ItemInfo-&gt;itemTag; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; ItemListComponent* m_items; // プレイヤの持っているアイテム一覧へのリンク<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;ItemAction&gt; <b>m_prev</b>; // リンクリスト構造の前へのポインタ<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;ItemAction&gt; <b>m_next</b>; // リンクリスト構造の次へのポインタ<br>
      &nbsp;&nbsp;&nbsp; //hash32 m_itemTag{ "" }; // アイテムのタグ<br>
      &nbsp;&nbsp;&nbsp; //int order{ 0 }; // アイテムの並び変え順番の<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ItemAction&gt; <b>Prev()</b> { auto pPrev = m_prev.lock(); return pPrev; }<br>
      &nbsp;&nbsp;&nbsp; void Prev(std::shared_ptr&lt;ItemAction&gt; pPrev) { m_prev = pPrev; }<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ItemAction&gt; <b>Next()</b> { auto pNext = m_next.lock(); return pNext; }<br>
      &nbsp;&nbsp;&nbsp; void Next(std::shared_ptr&lt;ItemAction&gt; pNext) { m_next = pNext; }<br>
      &nbsp;&nbsp;&nbsp; // 一番最初を返す<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ItemAction&gt; Top()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pPrev = Prev();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pPrev == nullptr)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return shared_from_this_as&lt;ItemAction&gt;(); // 前がないならすでに1番最初<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for (;;)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // 前の前がnullptrなら一番最初<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pPrevPrev = pPrev-&gt;Prev();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pPrevPrev == nullptr) return pPrev; // 1番最初<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pPrev = pPrevPrev;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; // <b>次がnullptrのときにも一番最初にループ</b>して次を返す<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ItemAction&gt; <b>LoopNext()</b><br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pNext = Next();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pNext != nullptr) return pNext;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pTop = Top();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pSelf = shared_from_this_as&lt;ItemAction&gt;(); // 自分自身<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pTop == pSelf) return pSelf; // 1番最初が自身になるのは1つしかない場合<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return pTop; // 一番最初へループする<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 例えば、すでに取得したプレイヤの弾と同じ種類の弾のアイテムをゲットしたら、<br>
      &nbsp;&nbsp;&nbsp; // アイテムとしてダブらせるのではなく使用回数を増やす処理をこの関数をoverrideしてやる<br>
      &nbsp;&nbsp;&nbsp; virtual void AddSameItem(std::shared_ptr&lt;InitParams&gt; initParam)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 継承 overrideして、アイテムとしてダブらせるのではなく例えば、弾の使用回数を増やす処理などを実装<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // なにかアイテムのアクション系のコンポーネントで共通して更新したいことがあればここに実装<br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // なにかアイテムのアクション系のコンポーネントで共通して描画したいことがあればここに実装<br>
      &nbsp;&nbsp;&nbsp; virtual inline void Draw(GameObject* obj = nullptr) override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アイコンを描く<br>
      &nbsp;&nbsp;&nbsp; virtual Vector3 DrawIcon(const Vector3&amp; drawPos, const Vector3&amp; limitPos, int nextIntervalX = 30)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // overrideしてアイコンを描く処理を個別実装する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return drawPos;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 次のアイテムのUIを数珠つなぎで描く nextPos に次はどのくらいずらすか指定<br>
      &nbsp;&nbsp;&nbsp; // limitPosを超える位置には描かない、超えない範囲でループしてselectingに戻るまでつぎつぎと描く<br>
      &nbsp;&nbsp;&nbsp; virtual void DrawNextUI(const Vector3&amp; nextPos, const Vector3&amp; limitPos, std::shared_ptr&lt;ItemAction&gt; pSelecting);<br>
      };<br>
      <br>
      <br>
      class Item; // 前方宣言<br>
      <br>
      // 複数のアイテムをリストとして管理するコンポーネント(UIも描画する)<br>
      class ItemListComponent : public Component<br>
      {<br>
      &nbsp;&nbsp;&nbsp; //protected:<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline ItemListComponent(std::shared_ptr&lt;GameObject&gt; pOwner) : Component(pOwner)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this-&gt;baseTag = "ItemListComponent";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual ~ItemListComponent() {}<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; int heightUI{ 32 };<br>
      &nbsp;&nbsp;&nbsp; int frameWidth{ 2 }; // アイテムの枠の幅<br>
      &nbsp;&nbsp;&nbsp; unsigned int frameColor = GetColor(255, 255, 255); // アイテムの枠の色<br>
      &nbsp;&nbsp;&nbsp; Vector3 drawPos{ (float)frameWidth, (float)frameWidth + 20, 0 }; // アイテムを描くUI上の2D位置の起点<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; //std::map&lt;PlayerItemAction, hash32&gt; order; // アイテムの並び順番<br>
      &nbsp;&nbsp;&nbsp; //hash32 m_selectingTag{ "" }; // 取得したアイテムの選択中のアクションのタグ<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;ItemAction&gt; m_selecting;<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;ItemAction&gt; m_topAction;<br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;ItemAction&gt;&gt; m_actions; // 取得したアイテムのアクションのリスト<br>
      public:<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アイテムのアクションを得る 例えば Get&lt;ItemBulletAction&gt;でItemBulletActionという名前のアクションをm_actions辞書から得る<br>
      &nbsp;&nbsp;&nbsp; template&lt;class ActionT&gt;<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ActionT&gt; Get(const std::string&amp; itemTag)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto itr = m_actions.find(itemTag);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (itr == end(m_actions)) return nullptr;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return itr-&gt;second;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アイテムを削除する<br>
      &nbsp;&nbsp;&nbsp; bool RemoveAction(std::shared_ptr&lt;ItemAction&gt; removeAction)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (removeAction == nullptr || removeAction-&gt;ItemTag() == "")<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false; // 見つからずに消せなかった場合は false<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_topAction = removeAction-&gt;LoopNext(); // 消すの前に次をトップにしておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_actions.erase(removeAction-&gt;ItemTag());<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; // アイテムを追加する .Add&lt;ItemBulletAction&gt;(...)で追加できる<br>
      &nbsp;&nbsp;&nbsp; template&lt;class ActionT, typename ...ArgsT&gt;<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ActionT&gt; Add(std::shared_ptr&lt;ItemInfo&gt; initParam, ArgsT&amp;&amp;...args)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //★[ActionTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //size_t hashID = typeid(ActionT).hash_code(); //[まずハッシュでID化]<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto found = m_actions.find(initParam-&gt;itemTag);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (found != end(m_actions))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; // すでに取得済の種類のアイテムだったらAddSameItemで取得済のアイテムの追加処理を呼ぶ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; found-&gt;second-&gt;AddSameItem(initParam);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return found-&gt;second-&gt;shared_from_this_as&lt;ActionT&gt;();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // shared_from_this()を必ず渡してセットで初期化して、オーナーがリンク切れのコンポーネントができないように気をつける<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ActionT&gt; newAction = Create&lt;ActionT&gt;(initParam, std::forward&lt;ArgsT&gt;(args)...);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_actions.emplace(initParam-&gt;itemTag, newAction);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pSelecting = Selecting(); // 現在選択中のアイテムのリンクを取得<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pSelecting == nullptr) // 現在ひとつもアイテムがない場合は先頭Topとして追加する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_topAction = newAction; // Topを newAction に設定する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return newAction;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //↓リンクリスト構造のリストを使ってリンクを相互に張る<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto selectingNext = pSelecting-&gt;Next(); // [今選択中のアイテムの★次]<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pSelecting-&gt;Next(newAction); // 「今選択中のアイテム」の → 次を newActionにする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; newAction-&gt;Prev(pSelecting); // 「今選択中のアイテム」を ← newAction の前 にする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; newAction-&gt;Next(selectingNext); // selecting と selectingのNext の間にはさむ<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (selectingNext)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; selectingNext-&gt;Prev(newAction); // newAction ←[今選択中のアイテムの★次] のリンク<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //↑ここまでの処理で数珠つなぎのリンクリスト構造になる<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return newAction;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ItemAction&gt; Add(std::shared_ptr&lt;Item&gt; pItem);<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual std::shared_ptr&lt;ItemAction&gt; Top()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pTopAction = m_topAction.lock(); // 弱共有ポインタをlock()する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (m_actions.size() == 0 || pTopAction == nullptr)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return nullptr; // リストにひとつもアクションがない場合は nullptr を返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return pTopAction;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual std::shared_ptr&lt;ItemAction&gt; Selecting()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pSelecting = m_selecting.lock(); // 弱共有ポインタをlock()する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pSelecting == nullptr) // なにも選択中のアイテムがない場合は<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return Top(); // リンクリスト構造の一番最初のトップを返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return pSelecting;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; template &lt;typename ActionT&gt;<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ItemAction&gt; Select()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; size_t hashID = typeid(ActionT).hash_code(); //[まずハッシュでID化]<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto found = m_actions.find(hashID);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (found == end(m_actions)) return nullptr; // 見つからなかったら<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return m_selecting = found-&gt;second; // 見つかったアクションをm_selectingに設定してそのアクションを返す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 選択中のアイテムの次のアイテムを返す<br>
      &nbsp;&nbsp;&nbsp; virtual std::shared_ptr&lt;ItemAction&gt; SelectNext()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pSelecting = Selecting();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pSelecting == nullptr) return pSelecting;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pNext = pSelecting-&gt;Next();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pNext == nullptr) pNext = Top(); // リンクリスト構造の次がないときはループして一番最初のTopを返す<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m_selecting = pNext; // 現在選択中のアイテムを更新する<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return pNext;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pTop = Top();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pTop == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pTop-&gt;Update();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pNext = pTop-&gt;Next();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (pNext != nullptr)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pNext-&gt;Update();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pNext = pNext-&gt;Next();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Draw(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pSelecting = Selecting();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pSelecting == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pSelecting-&gt;Draw();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //auto pNext = pSelecting-&gt;Next();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //pNext-&gt;Draw();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      <br>
      // なにかアイテムのアクション系のコンポーネントで共通して描画したいことがあればここに実装<br>
      inline void ItemAction::Draw(GameObject* obj)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Vector3 limitPos{ 400, -1, -1 };<br>
      &nbsp;&nbsp;&nbsp; Vector3 nextIconPos = DrawIcon(m_items-&gt;drawPos, limitPos); // アイコンを描く<br>
      &nbsp;&nbsp;&nbsp; if (nextIconPos == m_items-&gt;drawPos) return; // nextの位置とdrawPosが同じならアイコンを描けなかった<br>
      &nbsp;&nbsp;&nbsp; auto pNext = Next(); // 次のアイテムへのリンクを得る<br>
      &nbsp;&nbsp;&nbsp; auto pSelf = shared_from_this_as&lt;ItemAction&gt;(); // 自分自身<br>
      &nbsp;&nbsp;&nbsp; if (pNext != nullptr)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pNext-&gt;DrawNextUI(nextIconPos, limitPos, pSelf); // 数珠つなぎで次のアイコンを描く<br>
      &nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; auto pLoopNext = LoopNext(); // 次がnullptrでも最初のアイテムへループして描く<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (pLoopNext == pSelf) return; // ループしても自分自身ならアイテムは一つしかないので終了<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pLoopNext-&gt;DrawNextUI(nextIconPos, limitPos, pSelf); // 数珠つなぎで次のアイコンを描く<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // 次のアイテムのUIを数珠つなぎで描く nextPos に次はどのくらいずらすか指定<br>
      // limitPosを超える位置には描かない、超えない範囲でループしてselectingに戻るまでつぎつぎと描く<br>
      inline void ItemAction::DrawNextUI(const Vector3&amp; nextPos, const Vector3&amp; limitPos, std::shared_ptr&lt;ItemAction&gt; pSelecting)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; Vector3 nextIconPos = DrawIcon(nextPos, limitPos); // アイコンを描く<br>
      &nbsp;&nbsp;&nbsp; if (nextIconPos == m_items-&gt;drawPos) return; // nextの位置とdrawPosが同じならアイコンを描けなかった<br>
      &nbsp;&nbsp;&nbsp; auto pLoopNext = LoopNext(); // 次のアイテムへのリンクを得る<br>
      &nbsp;&nbsp;&nbsp; if (pLoopNext == pSelecting) return; // 次が現在選択中アイテムならすべてループしたのでここで終了<br>
      &nbsp;&nbsp;&nbsp; pLoopNext-&gt;DrawNextUI(nextIconPos, limitPos, pSelecting); // 数珠つなぎで次のアイコンを描く<br>
      }<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>ItemAction.cppを新規作成</code>して.cpp側でItemBlock.h(ブロック)やItemBullet.h(弾)などをインクルードすることで、<br>
      アイテムの種類に応じてアイテムを使ったときに起こるアクションをAddでItemListComponent(アイテムのリスト)に追加しましょう。</p>
    <p class="source">#include "ItemAction.h"<br>
      <br>
      #include "Item.h"<br>
      #include "ItemBullet.h"<br>
      #include "ItemBlock.h"<br>
      <br>
      // .cppで各種Itemを継承したクラスとItemActionを継承したクラスを#includeして<br>
      // アイテムの種類に応じてItemからItemActionを初期化する<br>
      <br>
      std::shared_ptr&lt;<b>ItemAction</b>&gt; <b>ItemListComponent::Add</b>(std::shared_ptr&lt;<b>Item</b>&gt; pItem)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (pItem-&gt;typeTag == "") return nullptr;<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pItem-&gt;typeTag == "<b>ItemBullet</b>")<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return this-&gt;Add&lt;<b>ItemBulletAction</b>&gt;(pItem-&gt;m_ItemInfo, this, owner());<br>
      &nbsp;&nbsp;&nbsp; else if (pItem-&gt;typeTag == "<b>ItemBlock</b>")<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return this-&gt;Add&lt;<b>ItemBlockAction</b>&gt;(pItem-&gt;m_ItemInfo, this, owner());<br>
      &nbsp;&nbsp;&nbsp; return nullptr;<br>
      }<br>
    </p>
    この<b>ItemAction.cpp</b>が<u>フィールド上のアイテム</u>(<b>Itemクラス</b>)と<u>取得した画面UIのアイテムのリスト</u>(<b>ItemListComponentクラス</b>)と<br>
    <u>アイコン上の使用するアイテムの動作アクション</u>(<b>ItemActionクラス</b>を継承した<b>ItemBulletAction</b>や<b>ItemBlockAction</b>など)の<br>
    「異なる<b><u>アイテムに関わる3要素</u>をつなぐ一番大事な役割</b>」をこなしています。<br>
    ブロックや弾以外にも<b>後から「剣」「ばくだん」など自作のアイテムを作った場合にはこのItemAction.cppで新アイテムを#includeしてAdd処理を書く必要</b>が出てきます。<br>
    当然、<b>様々な新種類のアイテムのインクルードが、この.cppファイルに集約して集まるように設計してありますので忘れないで</b>ください。<br>
    <br>
    <br>
    <p><code>GameObject.hを変更</code>して、OnItemなどアイテムを取ったときのコールバック関数を準備しましょう。</p>
    <p class="source">#ifndef GAMEOBJECT_H_<br>
      #define GAMEOBJECT_H_<br>
      <br>
      #include &lt;memory&gt; // 共有ポインタの定義のため<br>
      <br>
      #include "Vector3.h"<br>
      #include "Quaternion.h"<br>
      #include "Tile.h" // OnHitTileのコールバックに必要<br>
      <br>
      #include "Object.h" // インスタンスIDや検索タグを持ち、shared_from_this_as&lt;継承先クラス名&gt;などができる<br>
      #include "World.h"<br>
      <br>
      class Map; // 前方宣言<br>
      class Component; // 前方宣言<br>
      class Collision; // 前方宣言<br>
      class CollisionParams; // 前方宣言<br>
      <em>class Item; // 前方宣言</em><br>
      <br>
      // ゲーム上に表示される物体の基底クラス。<br>
      // プレイヤーや敵、アイテムなどはこのクラスを継承して作る。<br>
      class GameObject : public Object<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるのでCreate関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; GameObject(World* world = nullptr, Vector3 position = { 0,0,0 }, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Object(), m_world{ world }, position{ position }, rotation{ rotation }, velocity{ velocity }, force{ force }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~GameObject() {}<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; union { // ★共用体unionテクニック https://inemaru.hatenablog.com/entry/2016/03/02/005408<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //★下記3つはメモリ上で共用状態になる(position、x,y,z、xyzどの名前から数値を変えたり読出してもメモリ上は同じ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 同じデータに3種類の名前を付けたイメージ、しかもVector3の機能や配列としてのアクセスの仕方もできて便利<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float x, y, z; }; // XYZ座標&nbsp; [匿名共用体とは] https://code.i-harness.com/ja-jp/q/4d437c<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 position; // XYZ座標<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; xyz; // float xyz[3];と同じ意味 float 3個ぶんのデータサイズでx,y,z 3個ぶんと一致するので★unionで共用<br>
      &nbsp;&nbsp;&nbsp; }; // unionは異なる複数のものをメモリ上の同一の番地に割り当てられる⇒x,y,z分けて記述するの面倒なとき配列xyz[3]をfor文i=0～3で回せる<br>
      <br>
      &nbsp;&nbsp;&nbsp; Quaternion rotation; // 回転クオータニオン<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vx, vy, vz; }; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 velocity; // XYZ方向の速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyz;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; union {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { float vxForce, vyForce, vzForce; }; // XYZ方向にかかる力(Unityでいうと AddForce関数 )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 force; // XYZ方向の力(物理的には加速度:1フレームごとにvelocityの増える=加速する量)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::array&lt;float, 3&gt; vxyzForce;<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 重力を返す、重力を変えたいときはoverrideして処理を変えてください、重力を変えてない場合は 0.0f<br>
      &nbsp;&nbsp;&nbsp; virtual inline float gravity() { return 0.0f; }<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; World* m_world; // GameObjectが配置されたワールドへのリンク<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドへのポインタを得る<br>
      &nbsp;&nbsp;&nbsp; virtual World* world() { return m_world; }<br>
      &nbsp;&nbsp;&nbsp; // 現在いるワールドのポインタを変更する<br>
      &nbsp;&nbsp;&nbsp; virtual void world(World* changeWorld) { m_world = changeWorld; }<br>
      &nbsp;&nbsp;&nbsp; // GameObjectが現在いるマップへのポインタを返す<br>
      &nbsp;&nbsp;&nbsp; Map* map() { return m_world-&gt;map.get(); }<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; bool isDead{ false }; // 死んだ（削除対象）フラグ<br>
      &nbsp;&nbsp;&nbsp; bool isStatic{ false }; // 動かない(静的オブジェクトか?)<br>
      &nbsp;&nbsp;&nbsp; bool isGround{ false }; // 地面についているか<br>
      &nbsp;&nbsp;&nbsp; bool isJumping{ false }; // ジャンプ中か<br>
      &nbsp;&nbsp;&nbsp; bool isFlying{ false }; // 空をとんでいるか<br>
      <br>
      &nbsp;&nbsp;&nbsp; float pushPower{ 5.0f }; // コライダで接触したときに押し返す力(相手側が強いと押される)<br>
      &nbsp;&nbsp;&nbsp; float mass{ 1.0f }; // 質量(重さ)コライダで接触したときに重さでforceを割り算すると動きにくくなる<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;CollisionParams&gt; collisionParams; // 衝突関係の物理パラメータ<br>
      <br>
      &nbsp;&nbsp;&nbsp; hash32 typeTag{ "" }; // 小カテゴリ Zako0など個別のタイプ<br>
      &nbsp;&nbsp;&nbsp; hash32 baseTag{ "" }; // 大カテゴリ Enemyなど大まかなベースジャンル<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンポーネントの&lt;ハッシュID, 共有所有ポインタ&gt; の辞書でコンポーネントの共有カウンタ+1を保持する<br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;size_t, std::shared_ptr&lt;Component&gt;&gt; components;<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // コンポーネントを得る 例えば GetComponent&lt;BoxCollider&gt;でBoxColliderという名前のコンポーネントをcomponents辞書から得る<br>
      &nbsp;&nbsp;&nbsp; template&lt;class ComponentT&gt;<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;ComponentT&gt;&gt; GetComponents()<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // equal_range 関数を使って、指定したキーの最初と終端の位置を示すイテレータを std::pair&lt;&gt; で取得します。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto range = components.equal_range(hashID); //https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;ComponentT&gt;&gt; returnList; // "ComponentT" 例."CircleCollider"など をキーとするコンポーネント一覧<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto ite = range.first; ite != range.second; ++ite)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; returnList.emplace_back(ite-&gt;second); // 辞書で見つかったコンポーネントを返すリストに追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return returnList;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンポーネントを追加する .AddComponent&lt;BoxCollider&gt;(...)で追加できる<br>
      &nbsp;&nbsp;&nbsp; template&lt;class ComponentT, typename ...ArgsT&gt;<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;ComponentT&gt; AddComponent(ArgsT&amp;&amp;...args)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // shared_from_this()を必ず渡してセットで初期化して、オーナーがリンク切れのコンポーネントができないように気をつける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ComponentT&gt; newComponent = std::make_shared&lt;ComponentT&gt;(shared_from_this_as&lt;GameObject&gt;(), std::forward&lt;ArgsT&gt;(args)<b>...</b>);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // std::unrodered_multimap&lt;&gt; と同型の値を取る std::pair&lt;&gt; を作って insert 関数でcomponents辞書に追加<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; components.insert(std::pair&lt;size_t, std::shared_ptr&lt;ComponentT&gt;&gt;(hashID, newComponent));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return newComponent;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンポーネントを削除する<br>
      &nbsp;&nbsp;&nbsp; template&lt;typename ComponentT&gt;<br>
      &nbsp;&nbsp;&nbsp; bool RemoveComponent(std::shared_ptr&lt;ComponentT&gt; removeComponent)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //★[ComponentTのハッシュコードを得るテク] https://cpprefjp.github.io/reference/typeindex/type_index/hash_code.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t hashID = typeid(ComponentT).hash_code(); //[まずハッシュでID化]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // equal_range 関数を使って、指定したキーの最初と終端の位置を示すイテレータを std::pair&lt;&gt; で取得します。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto range = components.equal_range(hashID); //https://ez-net.jp/article/9E/DFLX8hNG/G5J8DPmsltz4/<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[イテレート中に探しながら消す] https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/erase.html<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto ite = range.first; ite != range.second;)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ite-&gt;second == removeComponent)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; components.erase(ite); // 削除された要素の次を指すイテレータが返される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true; // 見つかって消せた場合は true<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++ite; // 次の要素へイテレータを進める<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; // 見つからずに消せなかった場合は false<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() = 0; // 純粋仮想関数 = 0 にすると【絶対 Update()関数はoverrideしなきゃいけない義務を付与できる 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理[純粋仮想関数 = 0 なのでoverride必須の関数]<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() = 0; // 純粋仮想関数 = 0 にすると【絶対 Draw()関数はoverrideしなきゃいけない義務を継承先クラスに付与 】<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 衝突開始したときの関数 overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollisionEnter(std::shared_ptr&lt;Collision&gt; pCollision)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして衝突開始したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 衝突したときの関数 overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollision(std::shared_ptr&lt;Collision&gt; pCollision)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 衝突終了したときの関数 overrideして衝突したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollisionExit(std::shared_ptr&lt;Collision&gt; pCollision)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして衝突終了したときの処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ジャンプ開始した直後に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnStartJump()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideしてジャンプした瞬間に音を鳴らしたりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 空中でジャンプの上昇中に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnJumping()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中でジャンプの上昇中にエフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 空中で落ちている最中に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnFalling()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideして空中で落ちている最中に音を鳴らしたり、エフェクトを出したりする処理などをオブジェクトの種類ごとに実装する<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; // タイルに当たったときのコールバック<br>
      &nbsp;&nbsp;&nbsp; virtual void OnHitTile(HitPart hitPart, HitBit hitPartBit, TileBit checkBit, float xLeft, float xMiddle, float xRight,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float yBottom, float yMiddle, float yTop, float zBack, float zMiddle, float zForward,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int* pTerrainID = nullptr, int* pMapX = nullptr, int* pMapY = nullptr, int* pMapZ = nullptr, TileBit* pMatchBits = nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 継承 overrideしてタイルに当たったときの処理を実装する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 継承 overrideしてGameObjectのもつ個別のダメージの値を返す( otherの種類などでダメージ計算式をカスタムできる )<br>
      &nbsp;&nbsp;&nbsp; virtual float Damage(std::shared_ptr&lt;GameObject&gt; other) { return 0.0f; }<br>
      &nbsp;&nbsp;&nbsp; // 継承 overrideして個別のダメージの値を返す<br>
      &nbsp;&nbsp;&nbsp; virtual float Damage() { return 0.0f; }<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; virtual void OnDamage(std::shared_ptr&lt;GameObject&gt; other)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideしてダメージを受けた時の処理を個別に実装<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; <em>virtual void OnItem(std::shared_ptr&lt;Item&gt; pItem)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideしてアイテムに触れたときのコールバック処理を個別に実装<br>
        &nbsp;&nbsp;&nbsp; }<br>
        <br>
        <br>
        &nbsp;&nbsp;&nbsp; virtual void OnMoney(int getMoney)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // overrideしてアイテムに触れたときのコールバック処理を個別に実装<br>
        &nbsp;&nbsp;&nbsp; }</em><br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>ItemBullet.hを新規作成</code>して、ステージ上のエネルギー弾などのアイテムとそれを使ったときのアクションを準備しましょう。</p>
    <p class="source">#ifndef ITEM_BULLET_H_<br>
      #define ITEM_BULLET_H_<br>
      <br>
      #include "Item.h"<br>
      #include "ItemAction.h"<br>
      #include "Resource.h"<br>
      #include "DataJson.h"<br>
      #include "GridCollidersComponent.h"<br>
      #include "Factory.h"<br>
      #include "Player.h"<br>
      #include "CollisionParams.h"<br>
      <br>
      // アイテムの情報のクラス 継承override して情報をjsonなどから受け取る<br>
      struct ItemBulletInfo : public ItemInfo<br>
      {<br>
      &nbsp;&nbsp;&nbsp; //int bulletId{ 0 }; // 弾の種類<br>
      &nbsp;&nbsp;&nbsp; int count{ -1 }; // 弾を撃てる数のカウントアップ値( -1のときは一度取得したら無限に撃てるタイプのアイテム )<br>
      &nbsp;&nbsp;&nbsp; float colliderRadius{ 8.0f }; // アイテムとしてのコライダの半径<br>
      &nbsp;&nbsp;&nbsp; float bulletRadius{ 16.0f }; // 撃つ際の弾としてのコライダの半径<br>
      &nbsp;&nbsp;&nbsp; float bulletDamage{ 1 }; // 弾の与えるダメージ<br>
      &nbsp;&nbsp;&nbsp; float bulletSpeed{ 10.0f }; // 弾のスピード<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;CollisionParams&gt; collisionParams; // 衝突関係の物理パラメータ<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;GameObject&gt; shooter; // 弾を撃った後に弾の撃ち手の弱共有ポインタのリンクをBulletに渡す<br>
      &nbsp;&nbsp;&nbsp; float shooterAngleY{ 0.0f }; // 撃ち手の撃った際の角度<br>
      &nbsp;&nbsp;&nbsp; int imageIndex{ -1 }; // 弾の画像が分割画像だったらどの位置のIDの画像か<br>
      &nbsp;&nbsp;&nbsp; int iconImageIndex{ -1 }; // 弾のアイコン画像が分割画像だったらどの位置のIDの画像か<br>
      &nbsp;&nbsp;&nbsp; std::string imagePath{ "" }; // 弾の画像のパス<br>
      &nbsp;&nbsp;&nbsp; std::string iconImagePath{ "" }; // 弾のアイテムのアイコン画像のパス<br>
      &nbsp;&nbsp;&nbsp; inline ItemBulletInfo(std::shared_ptr&lt;InitParams&gt; initParams = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : ItemInfo{ initParams }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto tmxParams = std::static_pointer_cast&lt;InitTMXProperty&gt;(initParams);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tmxParams-&gt;properties == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto tmxProperties = tmxParams-&gt;properties;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // tmxのjsonの追加プロパティからデータを読み取る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tmxProperties-&gt;count("pushPower") &gt; 0 || tmxProperties-&gt;count("collision_e") &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collisionParams = std::make_shared&lt;CollisionParams&gt;(initParams); // 物理パラメータを読み取り<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto itr = tmxProperties-&gt;find("itemTag");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::String &amp;&amp; "json の itemTag のタイプが Stringでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itemTag = itr-&gt;second.stringValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("count");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Int &amp;&amp; "json の count のタイプが Intでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count = itr-&gt;second.intValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("imagePath");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::String &amp;&amp; "json の imagePath のタイプが Stringでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imagePath = itr-&gt;second.stringValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("imageIndex");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Int &amp;&amp; "json の imageIndex のタイプが Intでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imageIndex = itr-&gt;second.intValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("iconImagePath");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::String &amp;&amp; "json の iconImagePath のタイプが Stringでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iconImagePath = itr-&gt;second.stringValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("iconImageIndex");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Int &amp;&amp; "json の iconImageIndex のタイプが Intでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iconImageIndex = itr-&gt;second.intValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("colliderRadius");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Float &amp;&amp; "json の colliderRadius のタイプが Floatでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; colliderRadius = itr-&gt;second.floatValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("bulletRadius");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Float &amp;&amp; "json の bulletRadius のタイプが Floatでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bulletRadius = itr-&gt;second.floatValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("bulletSpeed");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Float &amp;&amp; "json の bulletSpeed のタイプが Floatでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bulletSpeed = itr-&gt;second.floatValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("bulletDamage");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Float &amp;&amp; "json の bulletDamage のタイプが Floatでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bulletDamage = itr-&gt;second.floatValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual ~ItemBulletInfo() {}<br>
      };<br>
      <br>
      <br>
      class ItemBulletAction : public ItemAction<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; inline ItemBulletAction(ItemListComponent* pItemList, std::shared_ptr&lt;GameObject&gt; pOwner)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : ItemAction(pItemList, pOwner)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;baseTag = "ItemBulletAction";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual ~ItemBulletAction() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto bulletInfo = std::static_pointer_cast&lt;ItemBulletInfo&gt;(initParams);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ItemInfo = bulletInfo;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bulletInfo-&gt;iconImagePath != "")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pIconImage = Resource::at&lt;Texture&gt;(bulletInfo-&gt;iconImagePath);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_iconImageIndex = bulletInfo-&gt;iconImageIndex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (bulletInfo-&gt;imagePath != "")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pIconImage = Resource::at&lt;Texture&gt;(bulletInfo-&gt;imagePath);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_iconImageIndex = bulletInfo-&gt;imageIndex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 弾の数を増やす(-1のときは無限撃ち可能、マイナス指定のときは弾の数を減らす)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddBullet(bulletInfo-&gt;count);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 弾の数を増やす(-1のときは無限撃ち可能、マイナス指定のときは弾の数を減らす)<br>
      &nbsp;&nbsp;&nbsp; void AddBullet(int newBulletCount)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_count != -1) // -1のときは無限に撃てる状態だから無理に変えない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (newBulletCount == -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_count = -1; // -1にすると無限に撃てる状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_count += newBulletCount;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_count &lt; 0) m_count = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; int m_count{ 0 }; // 弾の残数<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; m_pIconImage; // アイコン画像への共有ポインタ<br>
      &nbsp;&nbsp;&nbsp; int m_iconImageIndex{ -1 }; // アイコン画像が分割画像だったときの画像位置ID<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 例えば、すでに取得したプレイヤの弾と同じ種類の弾のアイテムをゲットしたら、<br>
      &nbsp;&nbsp;&nbsp; // アイテムとしてダブらせるのではなく使用回数を増やす処理をこの関数をoverrideしてやる<br>
      &nbsp;&nbsp;&nbsp; virtual void AddSameItem(std::shared_ptr&lt;InitParams&gt; initParam)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto params = std::static_pointer_cast&lt;ItemBulletInfo&gt;(initParam);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 弾の数を増やす(-1のときは無限撃ち可能、マイナス指定のときは弾の数を減らす)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddBullet(params-&gt;count);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_count == 0) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto selecting = m_items-&gt;Selecting();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pWorld = pOwner-&gt;world();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner-&gt;baseTag == "Player" &amp;&amp; selecting != nullptr &amp;&amp; selecting == shared_from_this_as&lt;ItemAction&gt;())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer = std::static_pointer_cast&lt;Player&gt;(pOwner);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ボタン押下で自機弾を発射<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pPlayer-&gt;pad, PAD_INPUT_C) // <b>コントローラのCボタン(キーボードのCキー)</b>を押したら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pPlayer-&gt;pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_T))) // <b>プレイヤ2はキーボードのT</b>を押したら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto bulletInfo = std::static_pointer_cast&lt;ItemBulletInfo&gt;(m_ItemInfo);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bulletInfo-&gt;shooter = pPlayer; // 撃ち手の弱共有ポインタをInfoに設定してBulletに渡す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bulletInfo-&gt;shooterAngleY = pPlayer-&gt;moveAngle + 90; // 撃ち手の角度をInfoに渡す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;playerBullets.emplace_back(Factory::MakeSharedObject&lt;Bullet&gt;("Bullet", bulletInfo, pWorld, pPlayer-&gt;position));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_count != -1) // -1のときは∞なので減らさない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --m_count; // 弾の数を減らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_count == 0) // 弾の数が0になったらアイテムのアクションのリストからも削除<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_items-&gt;RemoveAction(shared_from_this_as&lt;ItemAction&gt;());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アイコンを描く<br>
      &nbsp;&nbsp;&nbsp; virtual Vector3 DrawIcon(const Vector3&amp; drawPos, const Vector3&amp; limitPos, int nextIntervalX = 30) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 nextPos{ drawPos };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_pIconImage != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iconWidth = m_pIconImage-&gt;m_XSize, iconHeight = m_pIconImage-&gt;m_YSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int widthUI = m_items-&gt;heightUI * iconWidth / iconHeight;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int heightUI = m_items-&gt;heightUI;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int frameWidth = m_items-&gt;frameWidth;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int frameColor = m_items-&gt;frameColor;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iconIndex = (m_iconImageIndex != -1 &amp;&amp; m_iconImageIndex &lt; m_pIconImage-&gt;m_handles.size()) ? m_iconImageIndex : 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iconHandle = (m_pIconImage-&gt;m_handles.size() &gt; 0) ? m_pIconImage-&gt;m_handles[iconIndex] : -1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (limitPos.x &lt; drawPos.x + widthUI + nextIntervalX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nextPos; // 描いたら limitPosの位置を超えちゃうときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アイテムのアイコンのフレームの枠を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(drawPos.x - frameWidth, drawPos.y - frameWidth, drawPos.x + widthUI + frameWidth, drawPos.y + heightUI + frameWidth, frameColor, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(drawPos.x, drawPos.y, drawPos.x + widthUI, drawPos.y + heightUI, GetColor(0, 0, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アイテムのアイコン画像を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawRotaGraph(drawPos.x + widthUI / 2, drawPos.y + heightUI / 2, 1.0, 0.0, iconHandle, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アイテムの残りの数を表示する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string str{ (m_count == -1) ? "∞" : std::to_string(m_count) };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int fontHeight = DxLib::GetFontSize();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(drawPos.x + widthUI + 2, drawPos.y + heightUI - fontHeight, str.c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextPos = Vector3{ drawPos.x + widthUI + nextIntervalX, drawPos.y, 0 }; // 次のアイコンのずらし位置を計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nextPos;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      <br>
      // プレイヤの撃つ弾のアイテムのクラス<br>
      class ItemBullet : public Item<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; ItemBullet(World* world, Vector3 position, Quaternion rotation = { 0,0,0,1 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Item(world, position, rotation)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "ItemBullet";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual ~ItemBullet() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 継承overrideしてアイテムを取った時にアイテム一覧で選択できるアクションを持つかをtrueかfalseで返す<br>
      &nbsp;&nbsp;&nbsp; virtual bool hasAction() override { return true; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; m_pImage{ nullptr }; // 画像テクスチャへの共有リンク +1<br>
      &nbsp;&nbsp;&nbsp; int m_imageIndex{ -1 }; // 分割画像だったら表示させたい画像番号<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;GridCollidersComponent&gt; gridCollision; // 当たり判定用のグリッドのコンポーネント<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SphereCollider&gt; sphereCollider; // 球体コライダ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Initをoverrideしてアイテムの情報をjsonなどから受け取っておく<br>
      &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto itemBulletInfo = std::make_shared&lt;ItemBulletInfo&gt;(initParams); // アイテム情報を持っておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ItemInfo = itemBulletInfo;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pImage = Resource::MakeShared&lt;Texture&gt;(itemBulletInfo-&gt;imagePath);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 球体コライダ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sphereCollider = std::make_shared&lt;SphereCollider&gt;(shared_from_this_as&lt;ItemBullet&gt;(), Vector3(0, 0, 0), itemBulletInfo-&gt;colliderRadius);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision = std::make_shared&lt;GridCollidersComponent&gt;(shared_from_this_as&lt;ItemBullet&gt;(), "ItemBullet");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision-&gt;LinkCollider(sphereCollider); // コライダをリンクする<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの弾の画像のハンドル を 事前にItemInfo から読み取ったtextureから返す(画像番号があるときはindexで返される)<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image(int&amp; index) { if (m_imageIndex &gt;= 0) index = m_imageIndex; return m_pImage; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理を override<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理を override<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (world() == nullptr) return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; world()-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int index = 0; // 画像番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pImage = image(index); // 画像の共有リンク(indexで画像番号を受け取る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float radius = (sphereCollider != nullptr) ? sphereCollider-&gt;m_radius : 8; // コライダの半径(なかったら8)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float ExRate = radius / pImage-&gt;m_XSize; // 画像の拡大率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, ExRate, angle, *pImage, (index == -1) ? 0 : index, TRUE);<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sphereCollider != nullptr) sphereCollider-&gt;Draw();<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollision(std::shared_ptr&lt;Collision&gt; pCollision) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Item::OnCollision(pCollision); // ベース基底の共通処理のOnCollisionを呼ぶ<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アイテムを取ったときの処理を overrideして実装<br>
      &nbsp;&nbsp;&nbsp; virtual void OnItem(std::shared_ptr&lt;Item&gt; pItem) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pItem == shared_from_this_as&lt;Item&gt;())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 自分自身からOnItemが呼ばれた場合はこちら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isDead = true; // 取られたら消える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>ItemBlock.hを新規作成</code>して、ステージ上のレンガなどブロックのアイテムとそれを使ったときのアクションを準備しましょう。</p>
    <p class="source">#ifndef ITEM_BLOCK_H_<br>
      #define ITEM_BLOCK_H_<br>
      <br>
      #include "Item.h"<br>
      #include "ItemAction.h"<br>
      #include "Resource.h"<br>
      #include "TMXJson.h"<br>
      #include "DataTsx.h"<br>
      #include "GridCollidersComponent.h"<br>
      #include "Factory.h"<br>
      #include "Player.h"<br>
      #include "Map.h"<br>
      <br>
      // アイテムの情報のクラス 継承override して情報をjsonなどから受け取る<br>
      struct ItemBlockInfo : public ItemInfo<br>
      {<br>
      &nbsp;&nbsp;&nbsp; unsigned int gid{ 0 }; // タイルのgid<br>
      &nbsp;&nbsp;&nbsp; int count{ -1 }; // アイテム数のカウントアップ値( -1のときは一度取得したら無限に撃てるタイプのアイテム )<br>
      &nbsp;&nbsp;&nbsp; int cost{ 1 }; // 経路探索のコスト<br>
      &nbsp;&nbsp;&nbsp; float colliderRadius{ 8.0f }; // アイテムとしてのコライダの半径<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;GameObject&gt; shooter; // 撃ち手の弱共有ポインタのリンクをBulletに渡す<br>
      &nbsp;&nbsp;&nbsp; float shooterAngleY{ 0.0f }; // 撃ち手の撃った際の角度<br>
      &nbsp;&nbsp;&nbsp; int imageIndex{ -1 }; // 画像が分割画像だったらどの位置のIDの画像か<br>
      &nbsp;&nbsp;&nbsp; //int iconImageIndex{ -1 }; // アイコン画像が分割画像だったらどの位置のIDの画像か<br>
      &nbsp;&nbsp;&nbsp; std::string imagePath{ "" }; // 画像のパス<br>
      &nbsp;&nbsp;&nbsp; //std::string iconImagePath{ "" }; // アイテムのアイコン画像のパス<br>
      &nbsp;&nbsp;&nbsp; inline ItemBlockInfo(std::shared_ptr&lt;InitParams&gt; initParams = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : ItemInfo{ initParams }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto tmxParams = std::static_pointer_cast&lt;InitTMXProperty&gt;(initParams);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tmxParams-&gt;properties == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto tmxProperties = tmxParams-&gt;properties;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // tmxのjsonの追加プロパティからデータを読み取る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto itr = tmxProperties-&gt;find("itemTag");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::String &amp;&amp; "json の itemTag のタイプが Stringでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itemTag = itr-&gt;second.stringValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("count");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Int &amp;&amp; "json の count のタイプが Intでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count = itr-&gt;second.intValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("imagePath");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::String &amp;&amp; "json の imagePath のタイプが Stringでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imagePath = itr-&gt;second.stringValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("imageIndex");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Int &amp;&amp; "json の imageIndex のタイプが Intでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imageIndex = itr-&gt;second.intValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (imageIndex &gt;= 0) // id が 0以上なら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tile tile = Map::GetTile(imagePath, imageIndex, gid);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cost = tile.cost;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("colliderRadius");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Float &amp;&amp; "json の colliderRadius のタイプが Floatでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; colliderRadius = itr-&gt;second.floatValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual ~ItemBlockInfo() {}<br>
      };<br>
      <br>
      // アイテムでブロックを選択中のアクション<br>
      class ItemBlockAction : public ItemAction<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; inline ItemBlockAction(ItemListComponent* pItemList, std::shared_ptr&lt;GameObject&gt; pOwner)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : ItemAction(pItemList, pOwner)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;baseTag = "ItemBulletAction";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual ~ItemBlockAction() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto blockInfo = std::static_pointer_cast&lt;ItemBlockInfo&gt;(initParams);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ItemInfo = blockInfo;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (blockInfo-&gt;imagePath != "")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pIconImage = Resource::at&lt;Texture&gt;(blockInfo-&gt;imagePath);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_iconImageIndex = blockInfo-&gt;imageIndex;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ブロックの数を増やす(-1のときは無限撃ち可能、マイナス指定のときは弾の数を減らす)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddBlock(blockInfo-&gt;count);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ブロックの数を増やす(-1のときは無限置き可能、マイナス指定のときはブロックの数を減らす)<br>
      &nbsp;&nbsp;&nbsp; void AddBlock(int newBlockCount)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_count != -1) // -1のときは無限に置ける状態だから無理に変えない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (newBlockCount == -1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_count = -1; // -1にすると無限に置ける状態<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_count += newBlockCount;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_count &lt; 0) m_count = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; int m_count{ 0 }; // ブロックの残数<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; m_pIconImage; // アイコン画像への共有ポインタ<br>
      &nbsp;&nbsp;&nbsp; int m_iconImageIndex{ -1 }; // アイコン画像が分割画像だったときの画像位置ID<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 例えば、すでに取得したプレイヤのブロックと同じ種類のブロックのアイテムをゲットしたら、<br>
      &nbsp;&nbsp;&nbsp; // アイテムとしてダブらせるのではなく使用回数を増やす処理をこの関数をoverrideしてやる<br>
      &nbsp;&nbsp;&nbsp; virtual void AddSameItem(std::shared_ptr&lt;InitParams&gt; initParam)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto params = std::static_pointer_cast&lt;ItemBlockInfo&gt;(initParam);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ブロックの数を増やす(-1のときは無限置き可能、マイナス指定のときはブロックの数を減らす)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddBlock(params-&gt;count);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ボタンを押したときにブロックを置く処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_count == 0) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pOwner = owner();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner == nullptr) return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto selecting = m_items-&gt;Selecting();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pWorld = pOwner-&gt;world();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pOwner-&gt;baseTag == "Player" &amp;&amp; selecting != nullptr &amp;&amp; selecting == shared_from_this_as&lt;ItemAction&gt;())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer = std::static_pointer_cast&lt;Player&gt;(pOwner);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ボタン押下でステージにタイルを配置する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pPlayer-&gt;pad, PAD_INPUT_C) // <b>コントローラのCボタン(キーボードのCキー)</b>を押したら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pPlayer-&gt;pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_T))) // <b>プレイヤ2はキーボードのT</b>を押したら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto blockInfo = std::static_pointer_cast&lt;ItemBlockInfo&gt;(m_ItemInfo);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blockInfo-&gt;shooter = pPlayer; // 置き手の弱共有ポインタをInfoに設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blockInfo-&gt;shooterAngleY = pPlayer-&gt;moveAngle + 90; // 置き手の角度をInfoに渡す<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float cellSize = pWorld-&gt;map-&gt;CellSize();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float putX = (float)std::cos((pPlayer-&gt;moveAngle + 90) * MyMath::Deg2Rad) * cellSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float putZ = (float)std::sin((pPlayer-&gt;moveAngle + 90) * MyMath::Deg2Rad) * cellSize;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float writeX = pPlayer-&gt;position.x + putX; // 地形を書き換えるワールド位置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float writeY = pPlayer-&gt;position.y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float writeZ = pPlayer-&gt;position.z + putZ;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int gid = blockInfo-&gt;gid; // 書き換える gid<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isWall = pWorld-&gt;map-&gt;IsWall(writeX, writeY, writeZ); // 書き換え位置が壁か<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mapX, mapY, mapZ; unsigned int gid_now = 0; // checkID関数で読み出す数値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TileBit matchBit;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isMatch = pWorld-&gt;map-&gt;checkID(TileType::Wall | TileType::Floor, writeX, writeY, writeZ, &amp;mapX, &amp;mapY, &amp;mapZ, &amp;gid_now, &amp;matchBit);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (matchBit &amp; TileType::Wall) return; // マッチしたbitが壁か<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (gid_now != 0 &amp;&amp; gid_now == gid) return; // 書き換え先の現在のgidがこれから書き換えるgidと同じならアイテム数は減らさず return<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if ((matchBit &amp; TileType::Floor) &amp;&amp; !(pWorld-&gt;map-&gt;matchTypes(gid, (TileBit)TileType::Floor) &amp; TileType::Floor))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 地形を書き換え<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;map-&gt;SetTerrain(gid, writeX, writeY, writeZ);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_count != -1) // -1のときは∞なので減らさない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --m_count; // ブロックの数を減らす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_count == 0) // ブロックの数が0になったらアイテムのアクションのリストからも削除<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_items-&gt;RemoveAction(shared_from_this_as&lt;ItemAction&gt;());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アイコンを描く<br>
      &nbsp;&nbsp;&nbsp; virtual Vector3 DrawIcon(const Vector3&amp; drawPos, const Vector3&amp; limitPos, int nextIntervalX = 30) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 nextPos{ drawPos };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_pIconImage != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iconWidth = m_pIconImage-&gt;m_XSize, iconHeight = m_pIconImage-&gt;m_YSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int widthUI = m_items-&gt;heightUI * iconWidth / iconHeight; // アイコンの実際の画像サイズの縦横比率×heightUI<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int heightUI = m_items-&gt;heightUI;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int frameWidth = m_items-&gt;frameWidth;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int frameColor = m_items-&gt;frameColor;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iconIndex = (m_iconImageIndex != -1 &amp;&amp; m_iconImageIndex &lt; m_pIconImage-&gt;m_handles.size()) ? m_iconImageIndex : 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iconHandle = (m_pIconImage-&gt;m_handles.size() &gt; 0) ? m_pIconImage-&gt;m_handles[iconIndex] : -1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (limitPos.x &lt; drawPos.x + widthUI + nextIntervalX)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nextPos; // 描いたら limitPosの位置を超えちゃうときは描かない<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アイテムのアイコンのフレームの枠を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(drawPos.x - frameWidth, drawPos.y - frameWidth, drawPos.x + widthUI + frameWidth, drawPos.y + heightUI + frameWidth, frameColor, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawBox(drawPos.x, drawPos.y, drawPos.x + widthUI, drawPos.y + heightUI, GetColor(0, 0, 0), TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アイテムのアイコン画像を描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawRotaGraph(drawPos.x + widthUI / 2, drawPos.y + heightUI / 2, 1.0, 0.0, iconHandle, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アイテムの残りの数を表示する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string str{ (m_count == -1) ? "∞" : std::to_string(m_count) };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int fontHeight = DxLib::GetFontSize();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(drawPos.x + widthUI + 2, drawPos.y + heightUI - fontHeight, str.c_str(), GetColor(255, 255, 255));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextPos = Vector3{ drawPos.x + widthUI + nextIntervalX, drawPos.y, 0 }; // 次のアイコンのずらし位置を計算<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nextPos;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      <br>
      // ブロックのアイテムのクラス<br>
      // 壊したブロックなどを回収してステージに再配置できる<br>
      class ItemBlock : public Item<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; ItemBlock(World* world, Vector3 position, Quaternion rotation = { 0,0,0,1 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Item(world, position, rotation)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "ItemBlock";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual ~ItemBlock() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 継承overrideしてアイテムを取った時にアイテム一覧で選択できるアクションを持つかをtrueかfalseで返す<br>
      &nbsp;&nbsp;&nbsp; virtual bool hasAction() override { return true; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; m_pImage{ nullptr }; // 画像テクスチャへの共有リンク +1<br>
      &nbsp;&nbsp;&nbsp; int m_imageIndex{ -1 }; // 分割画像だったら表示させたい画像番号<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;GridCollidersComponent&gt; gridCollision; // 当たり判定用のグリッドのコンポーネント<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SphereCollider&gt; sphereCollider; // 球体コライダ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Initをoverrideしてアイテムの情報をjsonなどから受け取っておく<br>
      &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto itemBlockInfo = std::make_shared&lt;ItemBlockInfo&gt;(initParams); // アイテム情報を持っておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ItemInfo = itemBlockInfo;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pImage = Resource::MakeShared&lt;Texture&gt;(itemBlockInfo-&gt;imagePath);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_imageIndex = itemBlockInfo-&gt;imageIndex;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 球体コライダ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sphereCollider = std::make_shared&lt;SphereCollider&gt;(shared_from_this_as&lt;ItemBlock&gt;(), Vector3(0, 0, 0), itemBlockInfo-&gt;colliderRadius);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision = std::make_shared&lt;GridCollidersComponent&gt;(shared_from_this_as&lt;ItemBlock&gt;(), "ItemBlock");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision-&gt;LinkCollider(sphereCollider); // コライダをリンクする<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの弾の画像のハンドル を 事前にItemInfo から読み取ったtextureから返す(画像番号があるときはindexで返される)<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image(int&amp; id) { if (m_imageIndex &gt;= 0) id = m_imageIndex; return m_pImage; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ブロックの gid を ItemInfo から読み取って返す<br>
      &nbsp;&nbsp;&nbsp; unsigned int gid()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_ItemInfo == nullptr) return 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::static_pointer_cast&lt;ItemBlockInfo&gt;(m_ItemInfo)-&gt;gid;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理を override<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理を override<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (world() == nullptr) return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int id = 0; // 画像番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pImage = image(id); // 画像の共有リンク(indexで画像番号を受け取る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pImage == nullptr || id &lt; 0) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float radius = (sphereCollider != nullptr) ? sphereCollider-&gt;m_radius : 8; // コライダの半径(なかったら8)<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; world()-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float ExRate = radius / pImage-&gt;m_XSize; // 画像の拡大率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, ExRate, angle, *pImage, (id == -1) ? 0 : id, TRUE);<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sphereCollider != nullptr) sphereCollider-&gt;Draw();<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // [アイテムとして]フィールドに落ちているブロックと衝突したときの処理<br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollision(std::shared_ptr&lt;Collision&gt; pCollision) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Item::OnCollision(pCollision); // ベース基底の共通処理のOnCollisionを呼ぶ<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アイテムを取ったときの処理を overrideして実装<br>
      &nbsp;&nbsp;&nbsp; virtual void OnItem(std::shared_ptr&lt;Item&gt; pItem) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pItem == shared_from_this_as&lt;Item&gt;())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 自分自身からOnItemが呼ばれた場合はこちら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isDead = true; // 取られたら消える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>ItemMoney.hを新規作成</code>して、フィールド上のお金のクラスを準備しましょう。</p>
    <p class="source">#ifndef ITEM_MONEY_H_<br>
      #define ITEM_MONEY_H_<br>
      <br>
      #include "Item.h"<br>
      #include "ItemAction.h"<br>
      #include "Resource.h"<br>
      #include "DataJson.h"<br>
      #include "GridCollidersComponent.h"<br>
      #include "Factory.h"<br>
      #include "Player.h"<br>
      <br>
      // アイテムの情報のクラス 継承override して情報をjsonなどから受け取る<br>
      struct ItemMoneyInfo : public ItemInfo<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int money{ 0 }; // 取得する金額<br>
      &nbsp;&nbsp;&nbsp; float colliderRadius{ 8.0f }; // アイテムとしてのコライダの半径<br>
      &nbsp;&nbsp;&nbsp; int imageIndex{ -1 }; // 画像が分割画像だったらどの位置のIDの画像か<br>
      &nbsp;&nbsp;&nbsp; std::string imagePath{ "" }; // 画像のパス<br>
      &nbsp;&nbsp;&nbsp; inline ItemMoneyInfo(std::shared_ptr&lt;InitParams&gt; initParams = nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : ItemInfo{ initParams }<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto tmxParams = std::static_pointer_cast&lt;InitTMXProperty&gt;(initParams);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tmxParams-&gt;properties == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto tmxProperties = tmxParams-&gt;properties;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // tmxのjsonの追加プロパティからデータを読み取る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto itr = tmxProperties-&gt;find("itemTag");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::String &amp;&amp; "json の itemTag のタイプが Stringでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itemTag = itr-&gt;second.stringValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("imagePath");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::String &amp;&amp; "json の imagePath のタイプが Stringでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imagePath = itr-&gt;second.stringValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("imageIndex");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Int &amp;&amp; "json の imageIndex のタイプが Intでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imageIndex = itr-&gt;second.intValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("colliderRadius");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Float &amp;&amp; "json の colliderRadius のタイプが Floatでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; colliderRadius = itr-&gt;second.floatValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itr = tmxProperties-&gt;find("money");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (itr != end(*tmxProperties))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(itr-&gt;second == TMXProperty::Type::Int &amp;&amp; "json の colliderRadius のタイプが Intでない！jsonのプロパティを見直してください");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; money = itr-&gt;second.intValue;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; virtual ~ItemMoneyInfo() {}<br>
      };<br>
      <br>
      <br>
      class ItemMoneyAction : public ItemAction<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; inline ItemMoneyAction(ItemListComponent* pItemList, std::shared_ptr&lt;GameObject&gt; pOwner)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : ItemAction(pItemList, pOwner)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;baseTag = "ItemMoneyAction";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual ~ItemMoneyAction() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ItemMoneyInfo&gt; m_moneyInfo; // アイテムの情報<br>
      <br>
      &nbsp;&nbsp;&nbsp; inline virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_moneyInfo = std::static_pointer_cast&lt;ItemMoneyInfo&gt;(initParams);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_moneyInfo-&gt;money != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Update(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void Draw(GameObject* obj = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      <br>
      // お金のアイテムのクラス<br>
      class ItemMoney : public Item<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; ItemMoney(World* world, Vector3 position, Quaternion rotation = { 0,0,0,1 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Item(world, position, rotation)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "ItemMoney";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual ~ItemMoney() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 継承overrideしてアイテムを取った時にアイテム一覧で選択できるアクションを持つかをtrueかfalseで返す<br>
      &nbsp;&nbsp;&nbsp; virtual bool hasAction() override { return false; }<br>
      &nbsp;&nbsp;&nbsp; int m_money{ 0 };<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; m_pImage{ nullptr }; // 画像テクスチャへの共有リンク +1<br>
      &nbsp;&nbsp;&nbsp; int m_imageIndex{ -1 }; // 分割画像だったら表示させたい画像番号<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;GridCollidersComponent&gt; gridCollision; // 当たり判定用のグリッドのコンポーネント<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SphereCollider&gt; sphereCollider; // 球体コライダ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Initをoverrideしてアイテムの情報をjsonなどから受け取っておく<br>
      &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto itemMoneyInfo = std::make_shared&lt;ItemMoneyInfo&gt;(initParams); // アイテム情報を持っておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ItemInfo = itemMoneyInfo;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pImage = Resource::MakeShared&lt;Texture&gt;(itemMoneyInfo-&gt;imagePath);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_money = itemMoneyInfo-&gt;money; // お金の額の情報を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 球体コライダ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sphereCollider = std::make_shared&lt;SphereCollider&gt;(shared_from_this_as&lt;ItemMoney&gt;(), Vector3(0, 0, 0), itemMoneyInfo-&gt;colliderRadius);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision = std::make_shared&lt;GridCollidersComponent&gt;(shared_from_this_as&lt;ItemMoney&gt;(), "ItemMoney");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision-&gt;LinkCollider(sphereCollider); // コライダをリンクする<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの弾の画像のハンドル を 事前にItemInfo から読み取ったtextureから返す(画像番号があるときはindexで返される)<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image(int&amp; index) { if (m_imageIndex &gt;= 0) index = m_imageIndex; return m_pImage; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理を override<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理を override<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (world() == nullptr) return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; world()-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int index = 0; // 画像番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pImage = image(index); // 画像の共有リンク(indexで画像番号を受け取る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float radius = (sphereCollider != nullptr) ? sphereCollider-&gt;m_radius : 8; // コライダの半径(なかったら8)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float ExRate = radius / pImage-&gt;m_XSize; // 画像の拡大率<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, ExRate, angle, *pImage, (index == -1) ? 0 : index, TRUE);<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sphereCollider != nullptr) sphereCollider-&gt;Draw();<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollision(std::shared_ptr&lt;Collision&gt; pCollision) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Item::OnCollision(pCollision); // ベース基底の共通処理のOnCollisionを呼ぶ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto otherCollider = pCollision-&gt;contacts[0].otherCollider.lock();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (otherCollider == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto other = otherCollider-&gt;owner();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; other-&gt;OnMoney(m_money); // お金をゲットした時の処理を呼ぶ<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // アイテムを取ったときの処理を overrideして実装<br>
      &nbsp;&nbsp;&nbsp; virtual void OnItem(std::shared_ptr&lt;Item&gt; pItem) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pItem == shared_from_this_as&lt;Item&gt;())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 自分自身からOnItemが呼ばれた場合はこちら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isDead = true; // 取られたら消える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <p><code>Bullet.hを新規作成</code>して、エネルギー弾などの撃つ弾のクラスを準備しましょう。</p>
    <p class="source">#ifndef PLAYERBULLET_H_<br>
      #define PLAYERBULLET_H_<br>
      <br>
      #include &lt;cmath&gt;<br>
      <br>
      #include "DxLib.h"<br>
      #include "Screen.h"<br>
      #include "MyDraw.h"<br>
      <br>
      #include "GameObject.h"<br>
      <br>
      #include "Collider.h"<br>
      #include "GridCollidersComponent.h"<br>
      #include "ItemBullet.h"<br>
      <br>
      class World; // 前方宣言<br>
      <br>
      // 弾クラス<br>
      class Bullet : public GameObject<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // プレイヤ弾と敵の当たり判定を空間分割Gridで高速化<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;GridCollidersComponent&gt; gridCollision;<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;SphereCollider&gt; sphereCollider;<br>
      &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (initParams == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto params = std::static_pointer_cast&lt;ItemBulletInfo&gt;(initParams); // アイテム情報を受け取る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; collisionParams = params-&gt;collisionParams; // 物理衝突パラメータを受け取る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pImage = Resource::MakeShared&lt;Texture&gt;(params-&gt;imagePath);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sphereCollider = std::make_shared&lt;SphereCollider&gt;(shared_from_this_as&lt;Bullet&gt;(), Vector3(0, 0, 0), params-&gt;bulletRadius);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision = std::make_shared&lt;GridCollidersComponent&gt;(shared_from_this_as&lt;Bullet&gt;(), "Bullet");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision-&gt;LinkCollider(sphereCollider); // コライダをリンクする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_shooter = params-&gt;shooter; // 弾の撃ち手の弱共有リンクを得ておく<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pShooter = m_shooter.lock();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pShooter != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // 撃ち手のタグに応じて弾のタイプをPlayerBulletとEnemyBulletに切り分ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pShooter-&gt;baseTag == "Player")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "PlayerBullet";<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (pShooter-&gt;baseTag == "Enemy")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "EnemyBullet";<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Speed = params-&gt;bulletSpeed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_Damage = params-&gt;bulletDamage;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vx = (float)std::cos(params-&gt;shooterAngleY * MyMath::Deg2Rad) * Speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vz = (float)std::sin(params-&gt;shooterAngleY * MyMath::Deg2Rad) * Speed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; int deadCounter = 60 * 5; // 5秒後にisDead<br>
      &nbsp;&nbsp;&nbsp; float Speed{ 10.0 }; // 移動速度<br>
      &nbsp;&nbsp;&nbsp; float m_Damage{ 0 }; // 弾が当たった時に与えるダメージ<br>
      &nbsp;&nbsp;&nbsp; float Damage() override { return m_Damage; }<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;GameObject&gt; m_shooter; // 弾の撃ち手への弱共有ポインタ<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 弾の撃ち手への共有ポインタ(撃ち手がすでに死んでいた場合は nullptr)<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;GameObject&gt; Shooter() { auto pShooter = m_shooter.lock(); return pShooter; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; m_pImage; // 画像のパス<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コンストラクタ<br>
      &nbsp;&nbsp;&nbsp; Bullet(World* world, Vector3 position, Quaternion rotation)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : GameObject(world, position, rotation)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;baseTag = "Bullet";<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //this-&gt;pushPower = 15.0f;<br>
      #if 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double angle = rotation.getPitch();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto a = angle / MyMath::Deg2Rad)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfDx("%f\n", (float)a);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vx = (float)std::cos(angle) * Speed;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vz = (float)std::sin(angle) * Speed;<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~Bullet()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; void Update()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += vx;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z += vz;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deadCounter--;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (deadCounter &lt; 0) isDead = true; // 一定の秒数がたったら消す<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (gridCollision != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision-&gt;Update(); // 所属するマス目セルを更新する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; void Draw()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (world() == nullptr) return;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; world()-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //DrawRotaGraphF(x, y, 1, 0, Image::playerBullet, TRUE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //MyDraw::DrawRotaGraphF3D(Plane::Z, x, -y, z, 1, 0, Image::playerBullet, TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *m_pImage, 0, TRUE);<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sphereCollider != nullptr) sphereCollider-&gt;Draw();<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollision(std::shared_ptr&lt;Collision&gt; pCollision) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isDead) return; // すでにisDeadだったらreturn<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto otherCollider = pCollision-&gt;contacts[0].otherCollider.lock();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (otherCollider == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto other = otherCollider-&gt;owner();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (other-&gt;isDead) return; // other側がisDeadだったら処理をスルー<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (typeTag == "PlayerBullet" &amp;&amp; other-&gt;baseTag != "Enemy") return; // Enemyタイプ以外はスルー<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (typeTag == "EnemyBullet" &amp;&amp; other-&gt;baseTag != "Player") return; // Playerタイプ以外はスルー<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (other-&gt;typeTag == "Zako1")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //名前タグでぶつかった相手方を判別できる<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_Damage != 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; other-&gt;OnDamage(shared_from_this_as&lt;Bullet&gt;());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //isDead = true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      };<br>
      <br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <br>
    <p><code>Factory.cppを変更</code>して、Item系やBulletなどの初期化コンストラクタ発動して生成できるようにしましょう。</p>
    <p class="source">#include "Factory.h"<br>
      <br>
      #include &lt;unordered_map&gt; //★ #文字列 マクロで&lt;クラス名→コンストラクタ&gt;をビルドする瞬間に 辞書に登録<br>
      <br>
      // new や std::make_shared1 や Createで初期生成するには<br>
      // #includeしてコンストラクタを呼び出せる必要が出てくる<br>
      #include "Enemy.h"<br>
      #include "Zako0.h"<br>
      //#include "Zako1.h"<br>
      //#include "Zako2.h"<br>
      //#include "Zako3.h"<br>
      //#include "Boss.h"<br>
      <br>
      <em>#include "Item.h"</em><br>
      <em>#include "ItemBlock.h"</em><br>
      <em>#include "ItemBullet.h"</em><br>
      <em>#include "ItemMoney.h"</em><br>
      <br>
      <em>#include "Bullet.h"</em><br>
      <br>
      #include "World.h"<br>
      <br>
      //【上級1】★以下サイトを参考に【文字列"Zako1"とかからクラスを初期化するテクニック】<br>
      // https://stackoverflow.com/questions/5447675/how-to-convert-a-string-to-a-class-name/5447776<br>
      // <br>
      // 以下のようにクラスの型タイプを書かずに初期化できるので★if else文をいちいちコピーして増やさずに済む<br>
      // 例. いちいち書く例<br>
      // if (gid == 0)&nbsp;&nbsp;&nbsp;&nbsp; return Factory::make_shared&lt;Zako0&gt;(x + 32, y + 32);<br>
      // else if(gid == 1) return Factory::make_shared&lt;Zako1&gt;(x + 32, y + 32);<br>
      //&nbsp; .......(敵の種類が増えるたびにいちいちif elseコピペで書かないと..)<br>
      // ↓<br>
      // ↓★"Zako1"の文字列で初期化できれば1行で書けるようになる余地が出てくる！(CSVのクラス名の文字から初期化も目指せる)<br>
      // ↓<br>
      // 例. 初期化に&lt;Zako1&gt;を使わずに済むようになる "Zako1"で書ける<br>
      // auto enemy = g_ClassFactory.Construct("Zako1", x + 32, y + 32);//←"Zako1"で初期化 &lt;Zako1&gt;だとコードに書くしかない<br>
      <br>
      <br>
      // クラス名 classTypeName 例. Zako0 のコンストラクタを s_umConstructors 辞書に登録するための↓#文字取得マクロ<br>
      #define REGISTER_CONSTRUCTOR(classTypeName) RegisterConstructor&lt;classTypeName&gt;( #classTypeName )<br>
      <br>
      // Factoryクラスの「依存性の逆転」を引き起こすには.hでは★#includeしたくない https://blog.ecbeing.tech/entry/2021/01/20/114000<br>
      // だが、テンプレート関数は普通.hに実装までする必要があるが、それを回避する方法もある https://qiita.com/i153/items/38f9688a9c80b2cb7da7<br>
      // .cppでtemplate関数の実体を.hと分けて定義するには「★最小限下記の定義をオブジェクトごとにする必要」がある<br>
      template std::shared_ptr&lt;Object&gt; Factory::ConstructByClassName&lt;Object&gt;(const std::string&amp;, std::shared_ptr&lt;InitParams&gt;, World*, Vector3, Quaternion);<br>
      template std::shared_ptr&lt;Enemy&gt; Factory::ConstructByClassName&lt;Enemy&gt;(const std::string&amp;, std::shared_ptr&lt;InitParams&gt;, World*, Vector3, Quaternion);<br>
      <em>template std::shared_ptr&lt;Item&gt; Factory::ConstructByClassName&lt;Item&gt;(const std::string&amp;, std::shared_ptr&lt;InitParams&gt;, World*, Vector3, Quaternion);<br>
        template std::shared_ptr&lt;Bullet&gt; Factory::ConstructByClassName&lt;Bullet&gt;(const std::string&amp;, std::shared_ptr&lt;InitParams&gt;, World*, Vector3, Quaternion);</em><br>
      <br>
      <br>
      namespace // 無名名前空間(他ファイルから参照できない変数や関数を宣言)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; bool isConstructorRegistered{ false }; // 初回だけクラスのコンストラクタ登録を1回だけするためのフラグ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 初回だけ Zako0 などのクラスのコンストラクタを辞書に登録を1回だけする<br>
      &nbsp;&nbsp;&nbsp; inline void InitConstructors()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!isConstructorRegistered) // 初回だけクラスのコンストラクタ登録を1回だけする<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; //クラス登録されていないなら初回登録して "文字列"→コンストラクタ を呼び出せるようにしておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; REGISTER_CONSTRUCTOR(Zako0); // Zako0のコンストラクタを辞書に登録しておく<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //REGISTER_CONSTRUCTOR(Zako1);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //REGISTER_CONSTRUCTOR(Zako2);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //REGISTER_CONSTRUCTOR(Zako3);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //REGISTER_CONSTRUCTOR(Boss);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>REGISTER_CONSTRUCTOR(ItemBullet);</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>REGISTER_CONSTRUCTOR(ItemBlock);</em><br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>REGISTER_CONSTRUCTOR(ItemMoney);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <em>REGISTER_CONSTRUCTOR(Bullet);</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; isConstructorRegistered = true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      void Factory::Init(const std::string&amp; class_name)//int id)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // 初回だけ Zako0 などのクラスのコンストラクタを辞書に登録を1回だけする<br>
      &nbsp;&nbsp;&nbsp; InitConstructors();<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 辞書に class_name が登録されているかチェック<br>
      &nbsp;&nbsp;&nbsp; assert(g_Constructors.count(class_name) != 0 &amp;&amp; "まだ登録してない クラス名 が Factory.cpp にありました。");<br>
      }<br>
      <br>
      // class_name に応じて敵などのオブジェクトを生成してreturnで返す<br>
      template &lt;typename TypeT&gt; //[templateを.hと.cppに分けて書くのが難しい] https://qiita.com/i153/items/38f9688a9c80b2cb7da7<br>
      std::shared_ptr&lt;TypeT&gt; Factory::ConstructByClassName(const std::string&amp; class_name, std::shared_ptr&lt;InitParams&gt; initParams, World* world, Vector3 position, Quaternion rotation)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // class_nameに応じて敵などのオブジェクトを生成してreturnで返す<br>
      &nbsp;&nbsp;&nbsp; // ★Zako1*でもBoss*でもOK、ベース基底のObject型であいまいな状態で受け取る<br>
      &nbsp;&nbsp;&nbsp; auto pObject = Construct(class_name, initParams, world, position, rotation);<br>
      &nbsp;&nbsp;&nbsp; return std::dynamic_pointer_cast&lt;TypeT&gt;(pObject); // タイプをキャストでTypeTで指定した型に変換して返す<br>
      }<br>
    </p>
    <br>
    <br>
    <p><code>Player.hを変更</code>して、所持しているアイテムを更新し描画する処理を追加しましょう。</p>
    <p class="source">#ifndef PLAYER_H_<br>
      #define PLAYER_H_<br>
      <br>
      #include "DxLib.h"<br>
      #include "Input.h"<br>
      #include "Resource.h"<br>
      #include "GameObject.h"<br>
      <em>#include "ItemAction.h" // 複数アイテムを所持しItemActionを継承して使うためのコンポーネント</em><br>
      #include "PhysicsComponent.h"<br>
      #include "MapHitBoxComponent.h"<br>
      #include "GridCollidersComponent.h"<br>
      #include "Collider.h"<br>
      <br>
      class World; // 前方宣言<br>
      class Camera; // 前方宣言<br>
      <br>
      class Player : public GameObject<br>
      {<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; // コンストラクタはprotected:にしてあるので、Create関数経由で初期生成してください<br>
      &nbsp;&nbsp;&nbsp; Player(World* world, Pad pad, Vector3 position, Quaternion rotation = { 0,0,0,1 }, Vector3 velocity = { 0,0,0 }, Vector3 force = { 0,0,0 })<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pad{ pad }, GameObject(world, position, rotation, velocity, force)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;typeTag = "Player"; // タグは個別の"プレイヤ1"などに使い、タイプはtypeTagで判別する形にしてタイプのジャンルを区別<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;baseTag = "Player";<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;pushPower = 5.0f; // コライダで衝突したときに押し返す力<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      public:<br>
      &nbsp;&nbsp;&nbsp; // 仮想デストラクタ<br>
      &nbsp;&nbsp;&nbsp; virtual ~Player() {}<br>
      <br>
      &nbsp;&nbsp;&nbsp; Pad pad; // 操作するコントローラー番号<br>
      &nbsp;&nbsp;&nbsp; hash32 worldTag{ "" }; // 現在いるワールドのタグ<br>
      &nbsp;&nbsp;&nbsp; <em>int money{ 0 }; // ゲームのお金</em><br>
      &nbsp;&nbsp;&nbsp; float MoveSpeedMax = 6; // 移動速度Max値<br>
      &nbsp;&nbsp;&nbsp; float MoveSpeed = 0;//移動速度<br>
      <br>
      &nbsp;&nbsp;&nbsp; float moveAngle = 0; // X軸→方向から何度か<br>
      &nbsp;&nbsp;&nbsp; float deltaAngle = 0; // プレイヤの動く角度の変化率、ハンドルを切ったらだんだんもとに戻る<br>
      &nbsp;&nbsp;&nbsp; int animCount = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Texture&gt; image; // プレイヤの板ポリゴンで描くタイル分割画像への共有リンク<br>
      <br>
      &nbsp;&nbsp;&nbsp; Camera* camera{ nullptr }; // プレイヤを追随するカメラ<br>
      &nbsp;&nbsp;&nbsp; void SetCamera(Camera* pCamera) { camera = pCamera; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // overrideして物理落下コンポーネントからの重力値を返す<br>
      &nbsp;&nbsp;&nbsp; virtual float gravity() override { auto pGravityPhysics = gravityPhysics.lock(); return (pGravityPhysics != nullptr) ? pGravityPhysics-&gt;gravity() : 0.0f; }<br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;JumpComponent&gt; jumpPhysics; // ジャンプの物理処理コンポーネント<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;GravityComponent&gt; gravityPhysics; // 落下の重力の物理処理コンポーネント<br>
      &nbsp;&nbsp;&nbsp; // マップ地形に対するヒットボックスの当たり判定と押し戻しをするコンポーネント<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;MapHitBoxComponent&gt; mapHitBox;<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;GridCollidersComponent&gt; gridCollision; // グリッドマス目分割コンポーネント<br>
      &nbsp;&nbsp;&nbsp; std::weak_ptr&lt;SphereCollider&gt; sphereCollider; // 球コライダのコンポーネント<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>std::weak_ptr&lt;ItemListComponent&gt; itemList; // アイテムの所持リスト</em><br>
      public:<br>
      &nbsp;&nbsp;&nbsp; virtual void Init(std::shared_ptr&lt;InitParams&gt; initParams = nullptr) override<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyJumpSpeed{ 13, 14, 15, 4 }; // ジャンプ開始の初期速度<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyForceJump{ 0.5f, 0.4f, 0.3f, 0.1f }; // ジャンプ上昇にかかる力の初期値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyGravity{ 0.8f,0.8f,0.8f,0.8f }; // 重力の設定値<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;float&gt; vyDownSpeedMax{ 16, 16, 16, 8 }; // 降下スピードのリミット<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // AddComponent内部でshared_from_this()を必ず渡してセットで初期化して、オーナーがリンク切れのコンポーネントができないように気をつける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jumpPhysics = AddComponent&lt;JumpComponent&gt;(vyJumpSpeed, vyForceJump);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gravityPhysics = AddComponent&lt;GravityComponent&gt;(vyGravity, vyDownSpeedMax);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 半径16(直径32)の球体コライダ<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sphereCollider = AddComponent&lt;SphereCollider&gt;(Vector3(0, 0, 0), 16);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision = AddComponent&lt;GridCollidersComponent&gt;("Player"); //とりあえずわかりやすいように"Player"というタグをつけておく(別に何でもいい)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridCollision.lock()-&gt;LinkCollider(sphereCollider); // コライダをリンクする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float mapHitBoxSize = sphereCollider.lock()-&gt;m_radius * 2.0f; // 球体コライダの直径に合わす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 boxSize{ mapHitBoxSize,mapHitBoxSize,mapHitBoxSize };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 offsetLeftBottomBack{ 3, 0, 3 }; // ボックスの端を内側にどれだけ削るか(キャラの画像に合わせて小さくできる)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector3 offsetRightTopForward{ 3, 8, 3 }; // ボックスの端を内側にどれだけ削るか(頭を8削る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mapHitBox = AddComponent&lt;MapHitBoxComponent&gt;(boxSize, offsetLeftBottomBack, offsetRightTopForward);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>itemList = AddComponent&lt;ItemListComponent&gt;();</em><br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理<br>
      &nbsp;&nbsp;&nbsp; virtual void HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 弾を撃ったりブロックの配置などアイテムのインプット操作を受け取る<br>
        &nbsp;&nbsp;&nbsp; void HandleItemInput();</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 更新処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Update() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 描画処理<br>
      &nbsp;&nbsp;&nbsp; virtual void Draw() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// UIの描画処理はDrawとは別にすることで、一番最後にスクリーンに上書きで描ける<br>
        &nbsp;&nbsp;&nbsp; virtual void DrawUI();</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // ジャンプ開始した直後に呼ばれる関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnStartJump() override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // コライダの衝突した際に呼ばれるコールバック関数<br>
      &nbsp;&nbsp;&nbsp; virtual void OnCollision(std::shared_ptr&lt;Collision&gt; pCollision) override;<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// アイテムを取得した時に呼ばれる処理を override して実装<br>
        &nbsp;&nbsp;&nbsp; virtual void OnItem(std::shared_ptr&lt;Item&gt; pItem) override;<br>
        <br>
        &nbsp;&nbsp;&nbsp; // お金を取得した時に呼ばれる処理を override して実装<br>
        &nbsp;&nbsp;&nbsp; virtual void OnMoney(int getMoney) override;</em><br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>World.hを変更</code>して、BulletやItemなどのリストを追加しましょう。</p>
    <p class="source">#ifndef WORLD_H_<br>
      #define WORLD_H_<br>
      <br>
      #include &lt;list&gt;<br>
      #include &lt;memory&gt;<br>
      #include &lt;unordered_map&gt;<br>
      #include &lt;functional&gt; // std::functionのラムダ式 で 関数を Draw関数の引数にして、カメラすべてに対して描画処理を発動させる <br>
      <br>
      #include "MyHash.h" // ワールドのタグをhash32型で管理する<br>
      <br>
      <br>
      // [前方宣言] 宣言だけして、#includeはしてないので、ポインタだけはこのファイル内でつかえる<br>
      // #includeはしてないので、hpなどの変数には#include "～.h"しないとアクセスできないので循環インクルード防止のため.cppでインクルードしてください<br>
      class GameScene;<br>
      class Player;<br>
      <em>class Bullet;<br>
        class Item;</em><br>
      class Enemy;<br>
      class Camera;<br>
      class Grid;<br>
      class Map;<br>
      <br>
      // プレイヤや敵や弾などの共有ポインタを管理し、EraseRemoveIfで消して参照カウンタが0になったらそれらを消滅させるクラス(C#のガベージコレクタの代わり)<br>
      class World<br>
      {<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; inline World(GameScene* pScene, const std::string&amp; worldTag = "") : m_pScene{ pScene }, tag{ worldTag } {}<br>
      &nbsp;&nbsp;&nbsp; inline ~World() {}<br>
      protected: // public:にすると他で外部で後からタグやシーンを書き換えられると辞書での管理などの前提がおかしくなるのでprotected:する<br>
      &nbsp;&nbsp;&nbsp; hash32 tag{ "" }; // ワールド名のタグ<br>
      &nbsp;&nbsp;&nbsp; GameScene* m_pScene{ nullptr }; // ワールドを所有するシーン<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; hash32 Tag() const { return tag; }<br>
      &nbsp;&nbsp;&nbsp; GameScene* scene() { return m_pScene; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; //std::unordered_map&lt;hash32, std::shared_ptr&lt;Player&gt;&gt; players; // プレイヤのタグ辞書<br>
      &nbsp;&nbsp;&nbsp; // ワールドを所有するシーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp; void AddPlayer(const std::string&amp; playerTag, std::shared_ptr&lt;Player&gt; pPlayer);<br>
      &nbsp;&nbsp;&nbsp; // ワールドにいるプレイヤを得る<br>
      &nbsp;&nbsp;&nbsp; std::vector&lt;std::weak_ptr&lt;Player&gt;&gt; GetPlayers();<br>
      <br>
      &nbsp;&nbsp;&nbsp; bool LoadMap(const std::string&amp; mapFilePath); // ワールドのマップをロード<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Map&gt; map{ nullptr }; // マップ(共有ポインタ) マップのメモリ解放は World と運命をともにして消える<br>
      <br>
      protected:<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Grid&gt; m_pGrid{ nullptr }; // 当たり判定を高速にするためグリッドで空間分割<br>
      public:<br>
      &nbsp;&nbsp;&nbsp; Grid* grid() { return m_pGrid.get(); } // グリッドを返す<br>
      &nbsp;&nbsp;&nbsp; Grid* makeGrid(int cellWidth = 128, int cellHeight = 128, int cellDepth = 128); // グリッドを生成する<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;Player&gt;&gt; players; // プレイヤのタグ辞書<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>std::list&lt;std::shared_ptr&lt;Bullet&gt;&gt; bullets; // 弾のリスト<br>
        &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;Item&gt;&gt; items; // アイテムのリスト</em><br>
      &nbsp;&nbsp;&nbsp; std::list&lt;std::shared_ptr&lt;Enemy&gt;&gt; enemies; // 敵のリスト<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 削除処理を共通テンプレート関数にする<br>
      &nbsp;&nbsp;&nbsp; // [共通テンプレート関数]https://programming-place.net/ppp/contents/cpp/language/009.html#function_template<br>
      &nbsp;&nbsp;&nbsp; template &lt;typename TypeT, class T_if&gt;<br>
      &nbsp;&nbsp;&nbsp; void EraseRemoveIf(std::list&lt;TypeT&gt;&amp; v, T_if if_condition)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 特定のタイプT↑&nbsp; ↑配列v&nbsp;&nbsp; ↑条件式if_condition<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; v.erase(<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; std::remove_if(v.begin(), v.end(), if_condition),<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; v.end() //&nbsp; ↓remove_ifの位置<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; );//例.[生][生][死][死][死]← v.end()の位置<br>
      &nbsp;&nbsp;&nbsp; };<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_map&lt;hash32, std::shared_ptr&lt;Camera&gt;&gt; cameras; // このワールドに存在するカメラの辞書&lt;カメラにつけたタグ, カメラの共有ポインタ&gt;<br>
      &nbsp;&nbsp;&nbsp; // 指定されたタグのカメラへの共有ポインタを得る　カメラ辞書に存在しないタグでアクセスしたときにunordered_mapの特性で勝手に意図しないカメラができるのを防ぐ関数<br>
      &nbsp;&nbsp;&nbsp; std::shared_ptr&lt;Camera&gt; camera(const std::string&amp; cameraTag) { auto itr = cameras.find(cameraTag); return (itr != end(cameras)) ? itr-&gt;second : nullptr; }<br>
      &nbsp;&nbsp;&nbsp; // このワールドに存在するカメラすべてに対して drawFuncで描きたい処理を渡して 全カメラのスクリーンに対して描画処理を走らせる<br>
      &nbsp;&nbsp;&nbsp; void Draw(std::function&lt;void()&gt; drawFunc) noexcept;<br>
      &nbsp;&nbsp;&nbsp; // カメラにタグをつけてワールドに追加 カメラにもワールドへのポインタリンクを張る<br>
      &nbsp;&nbsp;&nbsp; inline bool AddCamera(const std::string&amp; cameraTag, std::shared_ptr&lt;Camera&gt; pCamera);<br>
      &nbsp;&nbsp;&nbsp; // 指定したタグのカメラをこのワールドから削除する カメラ側の worldへのリンクのポインタも nullptr にする<br>
      &nbsp;&nbsp;&nbsp; inline bool EraseCamera(const std::string&amp; cameraTag);<br>
      &nbsp;&nbsp;&nbsp; // カメラを nowWorld から nextWorld に移動させる<br>
      &nbsp;&nbsp;&nbsp; static bool MoveCamera(const std::string&amp; cameraTag, World* nowWorld, World* nextWorld);<br>
      <br>
      };<br>
      <br>
      #endif<br>
    </p>
    <br>
    <br>
    <p><code>Player.cppを変更</code>して、マップをスクロールして敵を出現させましょう。</p>
    <p class="source">#include "Player.h"<br>
      <br>
      #include &lt;cmath&gt; // 浮動小数点の余り%演算子がC++にないのでfmodを使うため<br>
      #include "MyMath.h"<br>
      <br>
      #include "MyDraw.h"<br>
      <br>
      #include "Camera.h"<br>
      #include "World.h"<br>
      #include "GridSteps.h"<br>
      <br>
      #include &lt;vector&gt;<br>
      <br>
      void Player::HandleInput()<br>
      {<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_LEFT) <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_A)) )<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = - MoveSpeed; // 左<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle += 1; //ハンドルを左に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_RIGHT)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_D)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vx = MoveSpeed; // 右<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaAngle -= 1; //ハンドルを右に回す<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (Input::GetButton(pad, PAD_INPUT_UP)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_W)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = - MoveSpeed; // 上<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed += 0.6f; //アクセルを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &gt; MoveSpeedMax)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = MoveSpeedMax;//Maxスピードで止める<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; else if (Input::GetButton(pad, PAD_INPUT_DOWN)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButton(Pad::Keyboard, KEY_INPUT_S)))<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //vy = MoveSpeed; // 下<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed -= 0.6f; //ブレーキを踏む<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MoveSpeed &lt; -0.9f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveSpeed = -0.9f;//ちょっとだけバックできるように<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (pad == Pad::Key || pad == Pad::One) // コントローラ1またはキーボード操作のプレイヤのときだけ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGUP)) // キーボードのPageUp ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = 2.0f; // テスト用に空中の上方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButton(Pad::Keyboard, KEY_INPUT_PGDN)) // キーボードのPageDown ボタンを押したときは<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vy = -2.0f; // テスト用に空中の下方向に移動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      }<br>
      <br>
      // ジャンプ開始した直後に呼ばれる関数<br>
      void Player::OnStartJump()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; this-&gt;isGround = false; // ジャンプ中はisGroundフラグがfalse<br>
      }<br>
      <br>
      <br>
      // 更新処理<br>
      void Player::Update()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; vxForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp; vyForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp; vzForce *= 0.9f; // かかっている力の減衰率<br>
      &nbsp;&nbsp;&nbsp; deltaAngle *= 0.5F; // 車のハンドルの方向をだんだんニュートラルに戻す<br>
      &nbsp;&nbsp;&nbsp; MoveSpeed *= 0.9F; // 移動速度も減速する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 入力を受けての処理 <br>
      &nbsp;&nbsp;&nbsp; HandleInput();<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 弾を撃ったりブロックの配置などアイテムのインプット操作を受け取る<br>
        &nbsp;&nbsp;&nbsp; HandleItemInput();</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pJumpPhysics = jumpPhysics.lock();<br>
      &nbsp;&nbsp;&nbsp; if (pJumpPhysics != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isGround)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pad, PAD_INPUT_A) // Zキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを押した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;JumpStart(); // ジャンプのスタート処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (vy &gt; 0 &amp;&amp; Input::GetButtonUp(pad, PAD_INPUT_A) // Zキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonUp(Pad::Keyboard, KEY_INPUT_Q))) // プレイヤ2がQキーを離した瞬間<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;JumpCancel(); // ジャンプのキャンセル処理を発動<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pJumpPhysics-&gt;Update(); // ジャンプのコンポーネントを更新する<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; auto pGravityPhysics = gravityPhysics.lock();<br>
      &nbsp;&nbsp;&nbsp; if (pGravityPhysics != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGravityPhysics-&gt;Update(); // 重力落下のコンポーネントを更新する<br>
      <br>
      &nbsp;&nbsp;&nbsp; moveAngle += deltaAngle; // ハンドルを回したぶんプレイヤの進行方向を変える<br>
      &nbsp;&nbsp;&nbsp; if (moveAngle &lt; -180) moveAngle = 360 + moveAngle; // -180以下の角度にならないようにマイナスになったら+180度にループさせる<br>
      &nbsp;&nbsp;&nbsp; else if (moveAngle &gt; +180) moveAngle = -360 + moveAngle; // +180以下の角度にならないようにマイナスになったら-180度にループさせる<br>
      <br>
      &nbsp;&nbsp;&nbsp; rotation.SetRotation(VGet(0, (180 - moveAngle) * MyMath::Deg2Rad, 0)); // 前向きの3Dモデルなら180度回転させて奥方向の向きに設定<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ↓進行方向角度をX方向とZ方向の速度に変える<br>
      &nbsp;&nbsp;&nbsp; vx = (float)std::cos((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      &nbsp;&nbsp;&nbsp; vz = (float)std::sin((moveAngle + 90) * MyMath::Deg2Rad) * MoveSpeed;<br>
      <br>
      &nbsp;&nbsp;&nbsp; float vyForceJump = (pJumpPhysics != nullptr) ? pJumpPhysics-&gt;vyForce() : 0.0f;<br>
      &nbsp;&nbsp;&nbsp; float vyForceGravity = (pGravityPhysics != nullptr) ? pGravityPhysics-&gt;vyForce() : 0.0f;<br>
      <br>
      &nbsp;&nbsp;&nbsp; vx += vxForce; // 力をかけて速度に加算する<br>
      &nbsp;&nbsp;&nbsp; vy += vyForce + vyForceJump + vyForceGravity; // 勢い(力・フォースを加算<br>
      &nbsp;&nbsp;&nbsp; vz += vzForce; // 力をかけて速度に加算する<br>
      <br>
      &nbsp;&nbsp;&nbsp; // 実際に位置を動かす<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pMapHitBox = mapHitBox.lock();<br>
      &nbsp;&nbsp;&nbsp; float cellHalf = (map() != nullptr) ? (float)map()-&gt;CellSize() / 2.0f : 16.0f; // マップのセルのサイズの半分<br>
      &nbsp;&nbsp;&nbsp; // 速すぎて当たり判定がすり抜けないように細切れのステップのグリッドで移動させつつ当たり判定する<br>
      &nbsp;&nbsp;&nbsp; Vector3 gridStepSize = (pMapHitBox == nullptr) ? Vector3{ cellHalf, cellHalf, cellHalf } : pMapHitBox-&gt;m_BoxSize / 2;<br>
      &nbsp;&nbsp;&nbsp; GridSteps vSteps{ velocity, gridStepSize }; // 細切れのステップの数値を計算<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp; if (vSteps.div &gt;= 1000) // 分割が1000を超える場合は物理式かどこかで∞=inf や 計算不可能数=nanが発生してそう<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // vx,vy,vzに原因がありそうなのでデバッグ表示<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isfinite(vx)) printfDx(("vx:∞かnan x:" + std::to_string(x) + "\n").c_str());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isfinite(vy)) printfDx(("vy:∞かnan y:" + std::to_string(y) + "\n").c_str());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isfinite(vz)) printfDx(("vz:∞かnan z:" + std::to_string(z) + "\n").c_str());<br>
      &nbsp;&nbsp;&nbsp; }<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; bool isCollisionX{ false }, isCollisionY{ false }, isCollisionZ{ false }, isCollisionCollider{ false };<br>
      &nbsp;&nbsp;&nbsp; for (int i = 1, iSize = vSteps.div + 1; i &lt;= iSize; ++i)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; vStep = (i &lt; iSize) ? vSteps.step : vSteps.mod;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // まず横に移動する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMapHitBox == nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += vx;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionX == false) // まだ前のステップでX方向の衝突がないなら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += vStep.x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionX = pMapHitBox-&gt;hitCheckX((TileBit)TileType::Wall);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次に縦に動かす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMapHitBox == nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += vy;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionY == false) // まだ前のステップでY方向の衝突がないなら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += vStep.y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionY = pMapHitBox-&gt;hitCheckY((TileBit)TileType::Wall | (TileBit)TileType::Floor);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 次にZ奥行き方向に動かす<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMapHitBox == nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z += vz;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (isCollisionZ == false) // まだ前のステップでZ方向の衝突がないなら<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z += vStep.z;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionZ = pMapHitBox-&gt;hitCheckZ((TileBit)TileType::Wall);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pGridCollision = gridCollision.lock())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridCollision-&gt;Update(); // 所属するマス目セルを更新する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; collider : *pGridCollision-&gt;colliders())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isCollisionCollider |= collider.lock()-&gt;IsCollision();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 衝突があったら、速すぎてすり抜けちゃう前に今のステップでbreakで抜ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isCollisionCollider)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; // ぶつかっているのにさらに次のステップの速度も足すとすり抜けちゃう<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; map()-&gt;Scroll3D(position, Vector3(vx, vy, vz)); // マップ（敵）データをスクロール<br>
      <br>
      &nbsp;&nbsp;&nbsp; // カメラのプレイヤ追尾<br>
      &nbsp;&nbsp;&nbsp; float camDistance = 150; // プレイヤからカメラまでのY平面上の距離<br>
      &nbsp;&nbsp;&nbsp; float camHeight = 100; // プレイヤからカメラまでのY方向上の高さ<br>
      &nbsp;&nbsp;&nbsp; // moveAngleは2D画像のX方向右を0度とするから、-90度回すと画像を正面に捉える位置にカメラを置ける<br>
      &nbsp;&nbsp;&nbsp; float camAngleX = (float)std::cos((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; float camAngleZ = (float)std::sin((moveAngle - 90) * MyMath::Deg2Rad) * camDistance;<br>
      &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // カメラの位置をプレイヤの進行方向と真逆に設定<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;SetPosition(position + Vector3(camAngleX, camHeight, camAngleZ));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;LookAt(position); //カメラはプレイヤの方を見る<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      <em>// 弾を撃ったりブロックの配置などアイテムのインプット操作を受け取る<br>
        void Player::HandleItemInput()<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (auto pItemList = itemList.lock())<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pItemList-&gt;Update(); // アイテムのリストをUpdateすると弾を撃つボタンを押したら弾が出るようになる<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Input::GetButtonDown(pad, PAD_INPUT_B)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (pad == Pad::Two &amp;&amp; Input::GetButtonDown(Pad::Keyboard, KEY_INPUT_R)))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pItemList-&gt;SelectNext();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; }<br>
        }<br>
        <br>
        // アイテムを取得した時に呼ばれる処理を override して実装<br>
        void Player::OnItem(std::shared_ptr&lt;Item&gt; pItem)<br>
        {<br>
        #if 0<br>
        &nbsp;&nbsp;&nbsp; if (pItem-&gt;typeTag == "ItemBlock") // アイテムブロックの場合はOnItemBlockに引き渡す<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnItemBlock(std::static_pointer_cast&lt;ItemBlock&gt;(pItem));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //itemList-&gt;Add&lt;&gt;<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp;&nbsp;&nbsp; //else if (pItem-&gt;typeTag == "ItemBullet")<br>
        #endif<br>
        <br>
        &nbsp;&nbsp;&nbsp; if (pItem-&gt;hasAction())<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itemList.lock()-&gt;Add(pItem);<br>
        &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; OnItemPlayerBullet()<br>
        <br>
        }<br>
        <br>
        <br>
        // お金を取得した時に呼ばれる処理を override して実装<br>
        void Player::OnMoney(int getMoney)<br>
        {<br>
        &nbsp;&nbsp;&nbsp; money += getMoney; // getMoneyがマイナスのときはお金は減ることもある<br>
        &nbsp;&nbsp;&nbsp; //if (money &lt; 0) money = 0; // 借金できない場合はコメントはずす<br>
        }<br>
        <br>
        // UIの描画処理はDrawとは別にすることで、一番最後にスクリーンに上書きで描ける<br>
        void Player::DrawUI()<br>
        {<br>
        &nbsp;&nbsp;&nbsp; if (camera != nullptr)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string strMoney{ std::to_string(money) + "円" };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DxLib::DrawString(0, 0, strMoney.c_str(), GetColor(255, 255, 255));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pItemList = itemList.lock())<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pItemList-&gt;Draw();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
        &nbsp;&nbsp;&nbsp; }<br>
        }</em><br>
      <br>
      void Player::OnCollision(std::shared_ptr&lt;Collision&gt; pCollision)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (isDead) return; // すでにisDeadなら return<br>
      &nbsp;&nbsp;&nbsp; auto otherCollider = pCollision-&gt;contacts[0].otherCollider.lock(); // コライダの弱共有ポインタをロック<br>
      &nbsp;&nbsp;&nbsp; if (otherCollider == nullptr) return; // すでにコライダが消去済だった<br>
      &nbsp;&nbsp;&nbsp; auto other = otherCollider-&gt;owner();<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (other-&gt;isDead) return; // other側がisDeadだったら処理をスルー<br>
      <br>
      &nbsp;&nbsp;&nbsp; if (other-&gt;baseTag == "Enemy" || other-&gt;baseTag == "Player")<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[離散要素法:DEM] https://qiita.com/konbraphat51/items/157e5803c514c60264d2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float k = 1.0f; // バネ係数(めり込みに対するバネ反発の掛け率)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float e = 0.1f; // はね返り係数(直前と比べどれくらいの速さで離れるか0.5だと半分の速さではね返る)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float log_e = std::log(e); // はね返り係数の自然対数log<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constexpr float pi_2 = DX_PI_F * DX_PI_F; // πの2乗<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float eta = -2.0f * log_e * std::sqrt(k * mass / (log_e * log_e + pi_2)); // 粘性係数η(イータ)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto norm = pCollision-&gt;contacts[0].normal; // 衝突の法線 * other-&gt;pushPower; // pushPowerの力でotherに押し返される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto v_norm = dot(other-&gt;velocity - velocity, norm) * norm; // [相対速度v] 法線norm方向のv = (v1 - v0)・norm [ドット積]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto sep = pCollision-&gt;contacts[0].separation; // 衝突点どうしの距離(めりこみ距離)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto F = -k * sep * norm - eta * v_norm; // F (法線方向の力) = -k × sep - η × v (相対速度:自分から見た相手otherの速度)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; force += F / mass; // 衝突法線方向の力を加える<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      // 描画処理<br>
      void Player::Draw()<br>
      {<br>
      &nbsp;&nbsp;&nbsp; int animIndex = animCount / 20; // キャラのパラパラアニメの画像番号(最大3)<br>
      &nbsp;&nbsp;&nbsp; float abs_vx = (vx &gt; 0) ? vx : -vx; // x方向絶対値<br>
      &nbsp;&nbsp;&nbsp; float abs_vz = (vz &gt; 0) ? vz : -vz; // y方向絶対値<br>
      &nbsp;&nbsp;&nbsp; if (abs_vx &gt; 1.00f || abs_vz &gt; 1.00f)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animCount += 6; // キャラが地面のXとZ方向に少しでもスピードがあったらアニメを走らせる<br>
      &nbsp;&nbsp;&nbsp; if (animCount &gt;= 60) animCount = 0; // アニメ時間を0へループ<br>
      <br>
      &nbsp;&nbsp;&nbsp; // ワールドに存在するすべてのカメラに関連づいたスクリーンに対して描画する<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; keyValue : world()-&gt;cameras) // プレイヤのいるワールドにあるすべてのカメラぶんループ<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; camera = keyValue.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; camera-&gt;Draw([&amp;]()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 常にカメラ方向を向くビルボード回転の角度を得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR_D angle = MyDraw::GetAngle(DxLib::GetCameraBillboardMatrixD());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; angle.x = 0; angle.z = 0; // Y軸周りのビルボード回転だけ有効にする X軸,Z軸まわりの回転は 0 にする<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int imgIndex = 9; // キャラチップ画像の起点番号<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ビルボードの角度 と キャラの向いている向き の 差 によって、別のプレイヤのカメラから見たキャラチップの向きの画像を切り替える<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -180 ～ +180 : angle.y&nbsp; moveAngle : -180 ～ +180 ↓<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float difAngleY = angle.y * 180.0f / DX_PI_F + moveAngle;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imgIndex = (difAngleY &lt; -135 || 135 &lt; difAngleY) ? 0 // カメラ向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &lt; -45) ? 6 // 右 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : (difAngleY &gt; 45) ? 3&nbsp; // 左 向きの画像<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 9; // 奥向きの画像<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyDraw::DrawDivRotaGraphF3D(MyDraw::Plane::Z, x, y, z, 1.0f, angle, *image, imgIndex + animIndex, TRUE);<br>
      <br>
      #ifdef _DEBUG // デバッグのときだけ_DEBUGが定義され描かれる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pSphereCollider = sphereCollider.lock()) pSphereCollider-&gt;Draw(); // コライダを描く<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (auto pMapHitBox = mapHitBox.lock()) pMapHitBox-&gt;Draw(); // ヒットボックスを描く<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
    </p>
    <br>
    <br>
    <p><code>GameScene.cppを変更</code>して、アイテムとUIのアイコンを更新して、描く処理を追加しましょう。<br>
    </p>
    <p class="source">#include "GameScene.h"<br>
      <br>
      #include "Player.h"<br>
      #include "Enemy.h"<br>
      <em>#include "Bullet.h"<br>
        #include "Item.h"<br>
        #include "ItemBlock.h"<br>
        #include "ItemBullet.h"</em><br>
      #include "Map.h"<br>
      <br>
      GameSceneSetting GameScene::settings{ "Map/GameSceneSetting.csv" }; // ゲームシーンの設定情報<br>
      <br>
      // 指定したゲームシーンのタグに関連づいたファイル名に対応したワールドを初期化する<br>
      bool GameScene::LoadWorlds(const std::string&amp; gameSceneTag)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (settings.info.count(gameSceneTag) == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto&amp; info = settings[gameSceneTag];<br>
      &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; tag_mapPath : info)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateWorld(tag_mapPath.second.tag); // ワールドをタグをつけて生成<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ワールドのマップをロード<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worlds[tag_mapPath.second.tag]-&gt;LoadMap(tag_mapPath.second.mapFilePath);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; return true;<br>
      }<br>
      <br>
      void GameScene::ChangeWorld(const std::string&amp; worldTag, std::shared_ptr&lt;Player&gt; pPlayer)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; if (pPlayer == nullptr) return;<br>
      &nbsp;&nbsp;&nbsp; if (worlds.count(worldTag) == 0) return; // 存在しないタグだった<br>
      <br>
      &nbsp;&nbsp;&nbsp; pPlayer-&gt;world(worlds[worldTag].get()); // ワールドへのリンクをすげ替える<br>
      }<br>
      <br>
      <br>
      void GameScene::Initialize()<br>
      {// Init処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Ｚバッファを有効にする [Zの深度]<br>
      &nbsp;&nbsp;&nbsp; //[参考]https://docs.google.com/presentation/d/1Z23t1yAS7uzPDVakgW_M02p20qt9DeTs4ku4IiMDLco/edit?usp=sharing<br>
      &nbsp;&nbsp;&nbsp; //[参考] https://dxlib.xsrv.jp/function/dxfunc_3d_draw.html#R14N12<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp; // Ｚバッファへの書き込みを有効にする<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetWriteZBuffer3D(TRUE);<br>
      &nbsp;&nbsp;&nbsp; // 光の明暗計算を無効に<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetUseLighting(FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // SetDrawScreen に引数として渡せる( 描画対象として使用できる )グラフィックハンドルを作成するかどうかを設定する<br>
      &nbsp;&nbsp;&nbsp; // ( TRUE:描画可能グラフィックハンドルを作成する&nbsp; FLASE:通常のグラフィックハンドルを作成する( デフォルト ) )<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(TRUE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // サブのスクリーンを2つ生成 画面の全体の縦方向サイズの Height / 2 にして、上下分割で配置できるようにする<br>
      &nbsp;&nbsp;&nbsp; screenHandle0 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      &nbsp;&nbsp;&nbsp; screenHandle1 = DxLib::MakeScreen(Screen::Width, Screen::Height / 2, FALSE);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーンを作成したらデフォルト設定に戻しておかないと<br>
      &nbsp;&nbsp;&nbsp; DxLib::SetDrawValidGraphCreateFlag(FALSE);<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath1, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;(playerImgPath2, 3, 4, 32, 32)-&gt;Load(); // メソッドチェーン -&gt; でMakeShared読込後にLoadもする<br>
      <br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;("Image/zako0.png")-&gt;Load(); // 敵画像を読込<br>
      &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;("Image/skullman.png", 3, 4, 32, 32)-&gt;LoadDivGraph(); // 敵画像を読込<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>Resource::MakeShared&lt;Texture&gt;("Image/yen1.png")-&gt;Load(); // お金の画像を読込<br>
        &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;("Image/yen10.png")-&gt;Load(); // お金の画像を読込<br>
        &nbsp;&nbsp;&nbsp; Resource::MakeShared&lt;Texture&gt;("Image/bullet.png")-&gt;Load(); // 弾の画像を読込</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; // プレイヤの生成<br>
      &nbsp;&nbsp;&nbsp; if (pWorld != nullptr)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pWorld-&gt;AddCamera("カメラ1", Camera::defaultCamera); // カメラ1というタグをデフォルトカメラにつけてワールドにデフォルトカメラを配置<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ1", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera1 = pWorld-&gt;camera("カメラ1"); // カメラ1 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera1-&gt;SetScreenHandle(screenHandle0); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer1 = Object::Create&lt;Player&gt;(nullptr, pWorld, Pad::Key, Vector3(90 + 256, 32, 95 + 256));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ1", pPlayer1); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath1]);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;camera = pCamera1.get(); // カメラをプレイヤにリンクする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer1-&gt;mass = 100.0f; // 体重を100にして衝突されてもびくともしないようにする<br>
      <br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddCamera("カメラ2", std::make_shared&lt;Camera&gt;(pWorld, Vector3{ 0,0,0 }));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pCamera2 = pWorld-&gt;camera("カメラ2"); // プレイヤ2 というタグのついたカメラへの共有ポインタを得る<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCamera2-&gt;SetScreenHandle(screenHandle1); // カメラから見える3Dを描く スクリーンのハンドル を関連付ける<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pPlayer2 = Object::Create&lt;Player&gt;(nullptr, pWorld, Pad::Two, Vector3(190, 32, 195));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pWorld-&gt;AddPlayer("プレイヤ2", pPlayer2); // シーンにプレイヤを追加する<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;image = std::dynamic_pointer_cast&lt;Texture&gt;(Resource::files[playerImgPath2]);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;camera = pCamera2.get(); // カメラをプレイヤにリンクする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pPlayer2-&gt;mass = 1.0f; // 体重を1にして普通にふっとぶようにする<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      };<br>
      <br>
      <br>
      void GameScene::Update()<br>
      {// 更新処理<br>
      <br>
      &nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle0); // 一旦キャンバスをきれいにまっさらに<br>
      &nbsp;&nbsp;&nbsp; Screen::ClearDrawScreen(screenHandle1); // 一旦キャンバスをきれいにまっさらに<br>
      <br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; player : players)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player.second-&gt;Update(); // プレイヤの更新【忘れるとプレイヤが動かない】<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 弾の更新処理<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; world : worlds)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; b : world.second-&gt;bullets)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b-&gt;Update();</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // 敵の更新処理<br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; world : worlds)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; e : world.second-&gt;enemies)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e-&gt;Update();<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// アイテムの更新処理<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; world : worlds)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; item : world.second-&gt;items)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item-&gt;Update();</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // グリッドを更新して隣接するグリッドに含まれる敵や弾の当たり判定を行う<br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; world : worlds)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (world.second-&gt;grid() != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; cell : world.second-&gt;grid()-&gt;cellData)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto pGridObject = cell.second;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (pGridObject != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; // while文で数珠つなぎのm_pNextを次々とたどって最後にたどり着くと次がなくてnullptrになる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridObject-&gt;checkCell();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pGridObject = pGridObject-&gt;m_pNext; // リンクリスト構造を次々とたどる<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// 敵のリストから死んでるものを除去する<br>
        &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; world : worlds)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; world.second-&gt;EraseRemoveIf(world.second-&gt;enemies,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;Enemy&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
        <br>
        &nbsp;&nbsp;&nbsp; // 自機弾の削除処理<br>
        &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; world : worlds)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; world.second-&gt;EraseRemoveIf(world.second-&gt;bullets,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;Bullet&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除<br>
        <br>
        &nbsp;&nbsp;&nbsp; // アイテムのリストから死んでるものを除去する<br>
        &nbsp;&nbsp;&nbsp; for (auto&amp;&amp; world : worlds)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; world.second-&gt;EraseRemoveIf(world.second-&gt;items,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](std::shared_ptr&lt;Item&gt;&amp; ptr) { return ptr-&gt;isDead; });//isDead==trueの条件のものを削除</em><br>
      }<br>
      <br>
      void GameScene::Draw()<br>
      {// 描画処理<br>
      &nbsp;&nbsp;&nbsp; auto pWorld = world("ステージ1"); // ワールドへのリンクを得る<br>
      <br>
      &nbsp;&nbsp;&nbsp; std::unordered_set&lt;World*&gt; drawEndSet; // すでに描いたWorldをポインタのsetでかぶらないように判定する<br>
      <br>
      &nbsp;&nbsp;&nbsp; for (const auto&amp; player : players)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player.second-&gt;Draw(); // プレイヤの描画【忘れるとプレイヤ表示されない】<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto world = player.second-&gt;world(); // プレイヤのいるワールド<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (drawEndSet.count(world) &gt; 0) continue; // すでに描いたWorldは描かずスキップする<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawEndSet.emplace(world); // 描いたWorldのポインタ住所をsetに登録する<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; world-&gt;map-&gt;DrawTerrain(); // マップの描画<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 敵の描画<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; enemy : world-&gt;enemies)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enemy-&gt;Draw();<br>
      #ifdef _DEBUG<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //enemy-&gt;DrawHitBox(); // 当たり判定の描画<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// 弾の描画処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; bullet : world-&gt;bullets)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bullet-&gt;Draw();<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // アイテムの描画処理<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; item : world-&gt;items)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item-&gt;Draw();</em><br>
      <br>
      #ifdef _DEBUG&nbsp; // デバッグのときだけ_DEBUGが定義され描画される<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (world-&gt;grid() != nullptr)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; cell : world-&gt;grid()-&gt;cellData)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cell.second-&gt;Draw(); // グリッドの描画<br>
      #endif<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; <em>// UIの描画処理はDrawとは別にすることで、他のマップなどに塗りつぶされずに一番上のレイヤでスクリーンに上書きで描ける<br>
        &nbsp;&nbsp;&nbsp; for (const auto&amp; player : players)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player.second-&gt;DrawUI();</em><br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーン0の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, 0, screenHandle0, FALSE);<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, 0, Screen::Width, Screen::Height / 2, GetColor(255, 0, 0));<br>
      <br>
      &nbsp;&nbsp;&nbsp; // スクリーン1の内容を画面に描く<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawGraph(0, Screen::Height / 2, screenHandle1, FALSE);<br>
      &nbsp;&nbsp;&nbsp; DxLib::DrawLineBox(0, Screen::Height / 2, Screen::Width, Screen::Height, GetColor(0, 255, 0));<br>
      <br>
      }<br>
    </p>
    <br>
    いかがでしょう？アイテムを取ったら、画面左上にアイテムのアイコンが表示され、<br>
    プレイヤ1は<b>Bボタン(キーボードのX)で次のアイテムを選択</b>でき、<b>Cボタン(キーボードのC)で弾発射やブロック配置</b>ができ<br>
    プレイヤ2は<b>Bボタン(キーボードのR)で次のアイテムを選択</b>でき、<b>Cボタン(キーボードのT)で弾発射やブロック配置</b>ができたでしょうか？<br>
    次のアイテムの選択には「次、前のリンクリスト構造」が使われています。<br>
    <b>リンクリスト構造ぐらいは便利で使い勝手があるデータの構造なので、自分で気軽に自作できるようになっておきたい</b>ですね。<br>
    <br>
    <br>
    <br>
  </body>
</html>
